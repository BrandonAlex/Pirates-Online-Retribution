1436948122
2 3
10 libp3putil 4 xqRv 12 panda3d.core 
878
891 5 clear 0 4 1771 56 PointerToBase< ReferenceCountedVector< ushort > >::clear 0 1 13 0
75
inline void PointerToBase< ReferenceCountedVector< ushort > >::clear(void);

892 6 output 0 4 1771 57 PointerToBase< ReferenceCountedVector< ushort > >::output 0 1 14 0
83
void PointerToBase< ReferenceCountedVector< ushort > >::output(ostream &out) const;

893 19 ~PointerToArrayBase 0 4 1770 49 PointerToArrayBase< ushort >::~PointerToArrayBase 0 0 0
63
inline PointerToArrayBase< ushort >::~PointerToArrayBase(void);

894 19 ConstPointerToArray 0 4 1769 50 ConstPointerToArray< ushort >::ConstPointerToArray 0 3 1 2 3 0
284
inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy);
inline ConstPointerToArray< ushort >::ConstPointerToArray(ConstPointerToArray< ushort > const &copy);
ConstPointerToArray< ushort >::ConstPointerToArray(PyObject *self, PyObject *source);

895 4 size 0 4 1769 35 ConstPointerToArray< ushort >::size 0 1 4 0
62
inline size_t ConstPointerToArray< ushort >::size(void) const;

896 11 get_element 0 4 1769 42 ConstPointerToArray< ushort >::get_element 0 1 5 0
80
inline ushort const &ConstPointerToArray< ushort >::get_element(size_t n) const;

897 11 __getitem__ 0 4 1769 42 ConstPointerToArray< ushort >::__getitem__ 0 1 6 0
73
ushort const &ConstPointerToArray< ushort >::__getitem__(size_t n) const;

898 8 get_data 0 4 1769 39 ConstPointerToArray< ushort >::get_data 0 1 7 0
66
inline string ConstPointerToArray< ushort >::get_data(void) const;

899 11 get_subdata 0 4 1769 42 ConstPointerToArray< ushort >::get_subdata 0 1 8 0
87
inline string ConstPointerToArray< ushort >::get_subdata(size_t n, size_t count) const;

900 13 get_ref_count 0 4 1769 44 ConstPointerToArray< ushort >::get_ref_count 0 1 9 0
68
inline int ConstPointerToArray< ushort >::get_ref_count(void) const;

901 18 get_node_ref_count 0 4 1769 49 ConstPointerToArray< ushort >::get_node_ref_count 0 1 10 0
73
inline int ConstPointerToArray< ushort >::get_node_ref_count(void) const;

902 13 __getbuffer__ 0 4 1769 44 ConstPointerToArray< ushort >::__getbuffer__ 0 1 11 0
99
int ConstPointerToArray< ushort >::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

903 17 __releasebuffer__ 0 4 1769 48 ConstPointerToArray< ushort >::__releasebuffer__ 0 1 12 0
93
void ConstPointerToArray< ushort >::__releasebuffer__(PyObject *self, Py_buffer *view) const;

904 20 ~ConstPointerToArray 0 4 1769 51 ConstPointerToArray< ushort >::~ConstPointerToArray 0 0 0
58
ConstPointerToArray< ushort >::~ConstPointerToArray(void);

905 14 PointerToArray 0 4 1773 40 PointerToArray< ushort >::PointerToArray 0 3 15 16 17 0
277
inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle = (_get_type_handle((ushort const *)(0))));
inline PointerToArray< ushort >::PointerToArray(PointerToArray< ushort > const &copy);
PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source);

906 11 empty_array 0 4 1773 37 PointerToArray< ushort >::empty_array 0 1 18 0
153
static inline PointerToArray< ushort > PointerToArray< ushort >::empty_array(size_t n, TypeHandle type_handle = (_get_type_handle((ushort const *)(0))));

907 4 size 0 4 1773 30 PointerToArray< ushort >::size 0 1 19 0
57
inline size_t PointerToArray< ushort >::size(void) const;

908 9 push_back 0 4 1773 35 PointerToArray< ushort >::push_back 0 1 20 0
65
inline void PointerToArray< ushort >::push_back(ushort const &x);

909 8 pop_back 0 4 1773 34 PointerToArray< ushort >::pop_back 0 1 21 0
53
inline void PointerToArray< ushort >::pop_back(void);

910 11 get_element 0 4 1773 37 PointerToArray< ushort >::get_element 0 1 22 0
75
inline ushort const &PointerToArray< ushort >::get_element(size_t n) const;

911 11 set_element 0 4 1773 37 PointerToArray< ushort >::set_element 0 1 23 0
81
inline void PointerToArray< ushort >::set_element(size_t n, ushort const &value);

912 11 __getitem__ 0 4 1773 37 PointerToArray< ushort >::__getitem__ 0 1 24 0
68
ushort const &PointerToArray< ushort >::__getitem__(size_t n) const;

913 11 __setitem__ 0 4 1773 37 PointerToArray< ushort >::__setitem__ 0 1 25 0
74
void PointerToArray< ushort >::__setitem__(size_t n, ushort const &value);

914 8 get_data 0 4 1773 34 PointerToArray< ushort >::get_data 0 1 26 0
61
inline string PointerToArray< ushort >::get_data(void) const;

915 8 set_data 0 4 1773 34 PointerToArray< ushort >::set_data 0 1 27 0
67
inline void PointerToArray< ushort >::set_data(string const &data);

916 11 get_subdata 0 4 1773 37 PointerToArray< ushort >::get_subdata 0 1 28 0
82
inline string PointerToArray< ushort >::get_subdata(size_t n, size_t count) const;

917 11 set_subdata 0 4 1773 37 PointerToArray< ushort >::set_subdata 0 1 29 0
94
inline void PointerToArray< ushort >::set_subdata(size_t n, size_t count, string const &data);

918 13 get_ref_count 0 4 1773 39 PointerToArray< ushort >::get_ref_count 0 1 30 0
63
inline int PointerToArray< ushort >::get_ref_count(void) const;

919 18 get_node_ref_count 0 4 1773 44 PointerToArray< ushort >::get_node_ref_count 0 1 31 0
68
inline int PointerToArray< ushort >::get_node_ref_count(void) const;

920 13 __getbuffer__ 0 4 1773 39 PointerToArray< ushort >::__getbuffer__ 0 1 32 0
88
int PointerToArray< ushort >::__getbuffer__(PyObject *self, Py_buffer *view, int flags);

921 17 __releasebuffer__ 0 4 1773 43 PointerToArray< ushort >::__releasebuffer__ 0 1 33 0
88
void PointerToArray< ushort >::__releasebuffer__(PyObject *self, Py_buffer *view) const;

922 15 ~PointerToArray 0 4 1773 41 PointerToArray< ushort >::~PointerToArray 0 0 0
48
PointerToArray< ushort >::~PointerToArray(void);

923 14 ~AnimInterface 0 6 1775 29 AnimInterface::~AnimInterface 0 0 233
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
44
virtual AnimInterface::~AnimInterface(void);

924 4 play 0 4 1775 19 AnimInterface::play 0 2 34 35 1032
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::play
//       Access: Published
//  Description: Runs the entire animation from beginning to end and
//               stops.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::play
//       Access: Published
//  Description: Runs the animation from the frame "from" to and
//               including the frame "to", at which point the
//               animation is stopped.  Both "from" and "to" frame
//               numbers may be outside the range (0,
//               get_num_frames()) and the animation will follow the
//               range correctly, reporting numbers modulo
//               get_num_frames().  For instance, play(0,
//               get_num_frames() * 2) will play the animation twice
//               and then stop.
////////////////////////////////////////////////////////////////////
95
inline void AnimInterface::play(void);
inline void AnimInterface::play(double from, double to);

925 4 loop 0 4 1775 19 AnimInterface::loop 0 2 36 37 898
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::loop
//       Access: Published
//  Description: Starts the entire animation looping.  If restart is
//               true, the animation is restarted from the beginning;
//               otherwise, it continues from the current frame.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::loop
//       Access: Published
//  Description: Loops the animation from the frame "from" to and
//               including the frame "to", indefinitely.  If restart
//               is true, the animation is restarted from the
//               beginning; otherwise, it continues from the current
//               frame.
////////////////////////////////////////////////////////////////////
117
inline void AnimInterface::loop(bool restart);
inline void AnimInterface::loop(bool restart, double from, double to);

926 8 pingpong 0 4 1775 23 AnimInterface::pingpong 0 2 38 39 886
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pingpong
//       Access: Published
//  Description: Starts the entire animation bouncing back and forth
//               between its first frame and last frame.  If restart
//               is true, the animation is restarted from the
//               beginning; otherwise, it continues from the current
//               frame.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pingpong
//       Access: Published
//  Description: Loops the animation from the frame "from" to and
//               including the frame "to", and then back in the
//               opposite direction, indefinitely.
////////////////////////////////////////////////////////////////////
125
inline void AnimInterface::pingpong(bool restart);
inline void AnimInterface::pingpong(bool restart, double from, double to);

927 4 stop 0 4 1775 19 AnimInterface::stop 0 1 40 369
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::stop
//       Access: Published
//  Description: Stops a currently playing or looping animation right
//               where it is.  The animation remains posed at the
//               current frame.
////////////////////////////////////////////////////////////////////
38
inline void AnimInterface::stop(void);

928 4 pose 0 4 1775 19 AnimInterface::pose 0 1 41 297
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pose
//       Access: Published
//  Description: Sets the animation to the indicated frame and holds
//               it there.
////////////////////////////////////////////////////////////////////
46
inline void AnimInterface::pose(double frame);

929 13 set_play_rate 0 4 1775 28 AnimInterface::set_play_rate 0 1 42 519
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::set_play_rate
//       Access: Published
//  Description: Changes the rate at which the animation plays.  1.0
//               is the normal speed, 2.0 is twice normal speed, and
//               0.5 is half normal speed.  0.0 is legal to pause the
//               animation, and a negative value will play the
//               animation backwards.
////////////////////////////////////////////////////////////////////
59
inline void AnimInterface::set_play_rate(double play_rate);

930 13 get_play_rate 0 4 1775 28 AnimInterface::get_play_rate 0 1 43 313
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_play_rate
//       Access: Published
//  Description: Returns the rate at which the animation plays.  See
//               set_play_rate().
////////////////////////////////////////////////////////////////////
55
inline double AnimInterface::get_play_rate(void) const;

931 14 get_frame_rate 0 4 1775 29 AnimInterface::get_frame_rate 0 1 44 514
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frame_rate
//       Access: Published
//  Description: Returns the native frame rate of the animation.  This
//               is the number of frames per second that will elapse
//               when the play_rate is set to 1.0.  It is a fixed
//               property of the animation and may not be adjusted by
//               the user.
////////////////////////////////////////////////////////////////////
56
inline double AnimInterface::get_frame_rate(void) const;

932 14 get_num_frames 0 6 1775 29 AnimInterface::get_num_frames 0 1 45 581
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_num_frames
//       Access: Published, Virtual
//  Description: Returns the number of frames in the animation.  This
//               is a property of the animation and may not be
//               directly adjusted by the user (although it may change
//               without warning with certain kinds of animations,
//               since this is a virtual method that may be
//               overridden).
////////////////////////////////////////////////////////////////////
54
virtual int AnimInterface::get_num_frames(void) const;

933 9 get_frame 0 4 1775 24 AnimInterface::get_frame 0 1 46 359
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frame
//       Access: Published
//  Description: Returns the current integer frame number.
//               This number will be in the range 0 <= f <
//               get_num_frames().
////////////////////////////////////////////////////////////////////
48
inline int AnimInterface::get_frame(void) const;

934 14 get_next_frame 0 4 1775 29 AnimInterface::get_next_frame 0 1 47 638
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_next_frame
//       Access: Published
//  Description: Returns the current integer frame number + 1,
//               constrained to the range 0 <= f < get_num_frames().
//
//               If the play mode is PM_play, this will clamp to the
//               same value as get_frame() at the end of the
//               animation.  If the play mode is any other value, this
//               will wrap around to frame 0 at the end of the
//               animation.
////////////////////////////////////////////////////////////////////
53
inline int AnimInterface::get_next_frame(void) const;

935 8 get_frac 0 4 1775 23 AnimInterface::get_frac 0 1 48 598
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frac
//       Access: Published
//  Description: Returns the fractional part of the current frame.
//               Normally, this is in the range 0.0 <= f < 1.0, but in
//               the one special case of an animation playing to its
//               end frame and stopping, it might exactly equal 1.0.
//
//               It will always be true that get_full_frame() +
//               get_frac() == get_full_fframe().
////////////////////////////////////////////////////////////////////
50
inline double AnimInterface::get_frac(void) const;

936 14 get_full_frame 0 4 1775 29 AnimInterface::get_full_frame 0 1 49 693
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_full_frame
//       Access: Published
//  Description: Returns the current integer frame number.
//
//               Unlike the value returned by get_frame(), this frame
//               number may extend beyond the range of
//               get_num_frames() if the frame range passed to play(),
//               loop(), etc. did.
//
//               Unlike the value returned by get_full_fframe(), this
//               return value will never exceed the value passed to
//               to_frame in the play() method.
////////////////////////////////////////////////////////////////////
53
inline int AnimInterface::get_full_frame(void) const;

937 15 get_full_fframe 0 4 1775 30 AnimInterface::get_full_fframe 0 1 50 841
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_full_fframe
//       Access: Published
//  Description: Returns the current floating-point frame number.
//
//               Unlike the value returned by get_frame(), this frame
//               number may extend beyond the range of
//               get_num_frames() if the frame range passed to play(),
//               loop(), etc. did.
//
//               Unlike the value returned by get_full_frame(), this
//               return value may equal (to_frame + 1.0), when the
//               animation has played to its natural end.  However, in
//               this case the return value of get_full_frame() will
//               be to_frame, not (to_frame + 1).
////////////////////////////////////////////////////////////////////
57
inline double AnimInterface::get_full_fframe(void) const;

938 10 is_playing 0 4 1775 25 AnimInterface::is_playing 0 1 51 466
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::is_playing
//       Access: Published
//  Description: Returns true if the animation is currently playing,
//               false if it is stopped (e.g. because stop() or pose()
//               was called, or because it reached the end of the
//               animation after play() was called).
////////////////////////////////////////////////////////////////////
50
inline bool AnimInterface::is_playing(void) const;

939 6 output 0 6 1775 21 AnimInterface::output 0 1 52 230
////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
55
virtual void AnimInterface::output(ostream &out) const;

940 14 get_class_type 0 4 1775 29 AnimInterface::get_class_type 0 1 53 0
54
static TypeHandle AnimInterface::get_class_type(void);

941 9 UpdateSeq 0 4 1777 20 UpdateSeq::UpdateSeq 0 2 54 55 502
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Default Constructor
//       Access: Published
//  Description: Creates an UpdateSeq in the 'initial' state.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
86
inline UpdateSeq::UpdateSeq(void);
inline UpdateSeq::UpdateSeq(UpdateSeq const &copy);

942 7 initial 0 4 1777 18 UpdateSeq::initial 0 1 56 290
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::initial (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'initial' state.
////////////////////////////////////////////////////////////////////
49
static inline UpdateSeq UpdateSeq::initial(void);

943 3 old 0 4 1777 14 UpdateSeq::old 0 1 57 282
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::old (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'old' state.
////////////////////////////////////////////////////////////////////
45
static inline UpdateSeq UpdateSeq::old(void);

944 5 fresh 0 4 1777 16 UpdateSeq::fresh 0 1 58 286
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::fresh (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'fresh' state.
////////////////////////////////////////////////////////////////////
47
static inline UpdateSeq UpdateSeq::fresh(void);

945 10 operator = 0 4 1777 21 UpdateSeq::operator = 0 1 59 234
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Copy Assignment operator
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
63
inline UpdateSeq &UpdateSeq::operator =(UpdateSeq const &copy);

946 5 clear 0 4 1777 16 UpdateSeq::clear 0 1 60 260
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::clear
//       Access: Published
//  Description: Resets the UpdateSeq to the 'initial' state.
////////////////////////////////////////////////////////////////////
35
inline void UpdateSeq::clear(void);

947 10 is_initial 0 4 1777 21 UpdateSeq::is_initial 0 1 61 294
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_initial
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'initial'
//               state.
////////////////////////////////////////////////////////////////////
46
inline bool UpdateSeq::is_initial(void) const;

948 6 is_old 0 4 1777 17 UpdateSeq::is_old 0 1 62 269
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_old
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'old' state.
////////////////////////////////////////////////////////////////////
42
inline bool UpdateSeq::is_old(void) const;

949 8 is_fresh 0 4 1777 19 UpdateSeq::is_fresh 0 1 63 290
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_fresh
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'fresh'
//               state.
////////////////////////////////////////////////////////////////////
44
inline bool UpdateSeq::is_fresh(void) const;

950 10 is_special 0 4 1777 21 UpdateSeq::is_special 0 1 64 328
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_special
//       Access: Published
//  Description: Returns true if the UpdateSeq is in any special
//               states, i.e. 'initial', 'old', or 'fresh'.
////////////////////////////////////////////////////////////////////
46
inline bool UpdateSeq::is_special(void) const;

951 11 operator == 0 4 1777 22 UpdateSeq::operator == 0 1 65 0
65
inline bool UpdateSeq::operator ==(UpdateSeq const &other) const;

952 11 operator != 0 4 1777 22 UpdateSeq::operator != 0 1 66 0
65
inline bool UpdateSeq::operator !=(UpdateSeq const &other) const;

953 10 operator < 0 4 1777 21 UpdateSeq::operator < 0 1 67 0
64
inline bool UpdateSeq::operator <(UpdateSeq const &other) const;

954 11 operator <= 0 4 1777 22 UpdateSeq::operator <= 0 1 68 0
65
inline bool UpdateSeq::operator <=(UpdateSeq const &other) const;

955 10 operator > 0 4 1777 21 UpdateSeq::operator > 0 1 69 0
64
inline bool UpdateSeq::operator >(UpdateSeq const &other) const;

956 11 operator >= 0 4 1777 22 UpdateSeq::operator >= 0 1 70 0
65
inline bool UpdateSeq::operator >=(UpdateSeq const &other) const;

957 11 operator ++ 0 68 1777 22 UpdateSeq::operator ++ 0 1 71 0
46
inline UpdateSeq UpdateSeq::operator ++(void);

958 11 operator ++ 0 4 1777 22 UpdateSeq::operator ++ 0 1 72 0
46
inline UpdateSeq UpdateSeq::operator ++(int );

959 7 get_seq 0 4 1777 18 UpdateSeq::get_seq 0 1 73 328
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::get_seq
//       Access: Published
//  Description: Returns the internal integer value associated with
//               the UpdateSeq.  Useful for debugging only.
////////////////////////////////////////////////////////////////////
60
inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const;

960 6 output 0 4 1777 17 UpdateSeq::output 0 1 74 216
////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
50
inline void UpdateSeq::output(ostream &out) const;

961 10 ~UpdateSeq 0 4 1777 21 UpdateSeq::~UpdateSeq 0 0 0
28
UpdateSeq::~UpdateSeq(void);

962 17 mark_bam_modified 0 4 1778 32 TypedWritable::mark_bam_modified 0 1 75 653
////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::mark_bam_modified
//       Access: Public
//  Description: Increments the bam_modified counter, so that this
//               object will be invalidated and retransmitted on any
//               open bam streams.  This should normally not need to
//               be called by user code; it should be called
//               internally when the object has been changed in a way
//               that legitimately requires its retransmission to any
//               connected clients.
////////////////////////////////////////////////////////////////////
51
inline void TypedWritable::mark_bam_modified(void);

963 16 get_bam_modified 0 4 1778 31 TypedWritable::get_bam_modified 0 1 76 388
////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::get_bam_modified
//       Access: Public
//  Description: Returns the current bam_modified counter.  This
//               counter is normally incremented automatically
//               whenever the object is modified.
////////////////////////////////////////////////////////////////////
61
inline UpdateSeq TypedWritable::get_bam_modified(void) const;

964 10 __reduce__ 0 4 1778 25 TypedWritable::__reduce__ 0 1 77 0
58
PyObject *TypedWritable::__reduce__(PyObject *self) const;

965 18 __reduce_persist__ 0 4 1778 33 TypedWritable::__reduce_persist__ 0 1 78 0
85
PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const;

966 20 encode_to_bam_stream 0 4 1778 35 TypedWritable::encode_to_bam_stream 0 2 79 80 1528
////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::encode_to_bam_stream
//       Access: Published
//  Description: Converts the TypedWritable object into a single
//               stream of data using a BamWriter, and returns that
//               data as a string string.  Returns empty string on
//               failure.
//
//               This is a convenience method particularly useful for
//               cases when you are only serializing a single object.
//               If you have many objects to process, it is more
//               efficient to use the same BamWriter to serialize all
//               of them together.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::encode_to_bam_stream
//       Access: Published
//  Description: Converts the TypedWritable object into a single
//               stream of data using a BamWriter, and stores that
//               data in the indicated string.  Returns true on
//               success, false on failure.
//
//               This is a convenience method particularly useful for
//               cases when you are only serializing a single object.
//               If you have many objects to process, it is more
//               efficient to use the same BamWriter to serialize all
//               of them together.
////////////////////////////////////////////////////////////////////
147
inline string TypedWritable::encode_to_bam_stream(void) const;
bool TypedWritable::encode_to_bam_stream(string &data, BamWriter *writer = 0) const;

967 26 decode_raw_from_bam_stream 0 4 1778 41 TypedWritable::decode_raw_from_bam_stream 0 0 1476
////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::decode_raw_from_bam_stream
//       Access: Published, Static
//  Description: Reads the string created by a previous call to
//               encode_to_bam_stream(), and extracts the single
//               object on that string.  Returns true on success,
//               false on on error.
//
//               This variant sets the TypedWritable and
//               ReferenceCount pointers separately; both are pointers
//               to the same object.  The reference count is not
//               incremented; it is the caller's responsibility to
//               manage the reference count.
//
//               Note that this method cannot be used to retrieve
//               objects that do not inherit from ReferenceCount,
//               because these objects cannot persist beyond the
//               lifetime of the BamReader that reads them.  To
//               retrieve these objects from a bam stream, you must
//               construct a BamReader directly.
//
//               If you happen to know that the particular object in
//               question inherits from TypedWritableReferenceCount or
//               PandaNode, consider calling the variant of
//               decode_from_bam_stream() defined for those methods,
//               which presents a simpler interface.
////////////////////////////////////////////////////////////////////
144
static bool TypedWritable::decode_raw_from_bam_stream(TypedWritable *&ptr, ReferenceCount *&ref_ptr, string const &data, BamReader *reader = 0);

968 14 get_class_type 0 4 1778 29 TypedWritable::get_class_type 0 1 81 0
54
static TypeHandle TypedWritable::get_class_type(void);

969 23 upcast_to_TypedWritable 0 12 1780 52 TypedWritableReferenceCount::upcast_to_TypedWritable 0 1 84 56
upcast from TypedWritableReferenceCount to TypedWritable
74
TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void);

970 39 downcast_to_TypedWritableReferenceCount 0 12 1778 54 TypedWritable::downcast_to_TypedWritableReferenceCount 0 1 85 58
downcast from TypedWritable to TypedWritableReferenceCount
90
TypedWritableReferenceCount *TypedWritable::downcast_to_TypedWritableReferenceCount(void);

971 24 upcast_to_ReferenceCount 0 12 1780 53 TypedWritableReferenceCount::upcast_to_ReferenceCount 0 1 86 57
upcast from TypedWritableReferenceCount to ReferenceCount
76
ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void);

972 39 downcast_to_TypedWritableReferenceCount 0 12 1781 55 ReferenceCount::downcast_to_TypedWritableReferenceCount 0 1 87 59
downcast from ReferenceCount to TypedWritableReferenceCount
91
TypedWritableReferenceCount *ReferenceCount::downcast_to_TypedWritableReferenceCount(void);

973 22 decode_from_bam_stream 0 4 1780 51 TypedWritableReferenceCount::decode_from_bam_stream 0 1 82 872
////////////////////////////////////////////////////////////////////
//     Function: TypedWritableReferenceCount::decode_from_bam_stream
//       Access: Published, Static
//  Description: Reads the string created by a previous call to
//               encode_to_bam_stream(), and extracts and returns the
//               single object on that string.  Returns NULL on error.
//
//               This method is intended to replace
//               decode_raw_from_bam_stream() when you know the stream
//               in question returns an object of type
//               TypedWritableReferenceCount, allowing for easier
//               reference count management.  Note that the caller is
//               still responsible for maintaining the reference count
//               on the return value.
////////////////////////////////////////////////////////////////////
143
static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(string const &data, BamReader *reader = 0);

974 14 get_class_type 0 4 1780 43 TypedWritableReferenceCount::get_class_type 0 1 83 0
68
static TypeHandle TypedWritableReferenceCount::get_class_type(void);

975 28 ~TypedWritableReferenceCount 0 4 1780 57 TypedWritableReferenceCount::~TypedWritableReferenceCount 0 0 0
64
TypedWritableReferenceCount::~TypedWritableReferenceCount(void);

976 37 upcast_to_TypedWritableReferenceCount 0 12 1782 53 BamCacheRecord::upcast_to_TypedWritableReferenceCount 0 1 107 57
upcast from BamCacheRecord to TypedWritableReferenceCount
89
TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void);

977 26 downcast_to_BamCacheRecord 0 12 1780 55 TypedWritableReferenceCount::downcast_to_BamCacheRecord 0 1 108 59
downcast from TypedWritableReferenceCount to BamCacheRecord
78
BamCacheRecord *TypedWritableReferenceCount::downcast_to_BamCacheRecord(void);

978 24 upcast_to_LinkedListNode 0 12 1782 40 BamCacheRecord::upcast_to_LinkedListNode 0 0 44
upcast from BamCacheRecord to LinkedListNode
63
LinkedListNode *BamCacheRecord::upcast_to_LinkedListNode(void);

979 26 downcast_to_BamCacheRecord 0 12 1783 42 LinkedListNode::downcast_to_BamCacheRecord 0 0 46
downcast from LinkedListNode to BamCacheRecord
65
BamCacheRecord *LinkedListNode::downcast_to_BamCacheRecord(void);

980 15 ~BamCacheRecord 0 6 1782 31 BamCacheRecord::~BamCacheRecord 0 0 235
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::Destructor
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
46
virtual BamCacheRecord::~BamCacheRecord(void);

981 9 make_copy 0 4 1782 25 BamCacheRecord::make_copy 0 1 88 438
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::make_copy
//       Access: Published
//  Description: Returns a duplicate of the BamCacheRecord.  The
//               duplicate will not have a data pointer set, even
//               though one may have been assigned to the original via
//               set_data().
////////////////////////////////////////////////////////////////////
73
inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const;

982 11 operator == 0 4 1782 27 BamCacheRecord::operator == 0 1 89 0
75
inline bool BamCacheRecord::operator ==(BamCacheRecord const &other) const;

983 19 get_source_pathname 0 4 1782 35 BamCacheRecord::get_source_pathname 0 1 90 523
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_source_pathname
//       Access: Published
//  Description: Returns the full pathname to the source file that
//               originally generated this cache request.  In some
//               cases, for instance in the case of a of a multipage
//               texture like "cube_#.png", this may not not a true
//               filename on disk.
////////////////////////////////////////////////////////////////////
71
inline Filename const &BamCacheRecord::get_source_pathname(void) const;

984 18 get_cache_filename 0 4 1782 34 BamCacheRecord::get_cache_filename 0 1 91 516
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_cache_filename
//       Access: Published
//  Description: Returns the name of the cache file as hashed from the
//               source_pathname.  This will be relative to the root
//               of the cache directory, and it will not include any
//               suffixes that may be appended to resolve hash
//               conflicts.
////////////////////////////////////////////////////////////////////
70
inline Filename const &BamCacheRecord::get_cache_filename(void) const;

985 20 get_source_timestamp 0 4 1782 36 BamCacheRecord::get_source_timestamp 0 1 92 473
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_source_timestamp
//       Access: Published
//  Description: Returns the file timestamp of the original source
//               file that generated this cache record, if available.
//               In some cases the original file timestamp is not
//               available, and this will return 0.
////////////////////////////////////////////////////////////////////
63
inline time_t BamCacheRecord::get_source_timestamp(void) const;

986 17 get_recorded_time 0 4 1782 33 BamCacheRecord::get_recorded_time 0 1 93 323
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_recorded_time
//       Access: Published
//  Description: Returns the time at which this particular record was
//               recorded or updated.
////////////////////////////////////////////////////////////////////
60
inline time_t BamCacheRecord::get_recorded_time(void) const;

987 23 get_num_dependent_files 0 4 1782 39 BamCacheRecord::get_num_dependent_files 0 1 94 320
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_num_dependent_files
//       Access: Published
//  Description: Returns the number of source files that contribute to
//               the cache.
////////////////////////////////////////////////////////////////////
63
inline int BamCacheRecord::get_num_dependent_files(void) const;

988 22 get_dependent_pathname 0 4 1782 38 BamCacheRecord::get_dependent_pathname 0 1 95 335
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_dependent_pathname
//       Access: Published
//  Description: Returns the full pathname of the nth source files
//               that contributes to the cache.
////////////////////////////////////////////////////////////////////
75
inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const;

989 20 dependents_unchanged 0 4 1782 36 BamCacheRecord::dependents_unchanged 0 1 96 380
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::dependents_unchanged
//       Access: Published
//  Description: Returns true if all of the dependent files are still
//               the same as when the cache was recorded, false
//               otherwise.
////////////////////////////////////////////////////////////////////
54
bool BamCacheRecord::dependents_unchanged(void) const;

990 21 clear_dependent_files 0 4 1782 37 BamCacheRecord::clear_dependent_files 0 1 97 323
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::clear_dependent_files
//       Access: Published
//  Description: Empties the list of files that contribute to the data
//               in this record.
////////////////////////////////////////////////////////////////////
49
void BamCacheRecord::clear_dependent_files(void);

991 18 add_dependent_file 0 4 1782 34 BamCacheRecord::add_dependent_file 0 1 98 509
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::add_dependent_file
//       Access: Published
//  Description: Adds the indicated file to the list of files that
//               will be loaded to generate the data in this record.
//               This should be called once for the primary source
//               file, and again for each secondary source file, if
//               any.
////////////////////////////////////////////////////////////////////
66
void BamCacheRecord::add_dependent_file(Filename const &pathname);

992 8 has_data 0 4 1782 24 BamCacheRecord::has_data 0 1 99 373
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::has_data
//       Access: Published
//  Description: Returns true if this cache record has an in-memory
//               data object associated--that is, the object stored in
//               the cache.
////////////////////////////////////////////////////////////////////
49
inline bool BamCacheRecord::has_data(void) const;

993 10 clear_data 0 4 1782 26 BamCacheRecord::clear_data 0 1 100 394
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::clear_data
//       Access: Published
//  Description: Removes the in-memory data object associated with
//               this record, if any.  This does not affect the
//               on-disk representation of the record.
////////////////////////////////////////////////////////////////////
45
inline void BamCacheRecord::clear_data(void);

994 8 get_data 0 4 1782 24 BamCacheRecord::get_data 0 1 101 383
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_data
//       Access: Published
//  Description: Returns a pointer to the data stored in the
//               record, or NULL if there is no data.  The pointer is
//               not removed from the record.
////////////////////////////////////////////////////////////////////
59
inline TypedWritable *BamCacheRecord::get_data(void) const;

995 12 extract_data 0 4 1782 28 BamCacheRecord::extract_data 0 0 737
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::extract_data
//       Access: Published
//  Description: Fills ptr and ref_ptr with the two different-typed
//               pointers to the same object, the data stored within
//               this record.  This transfers ownership of the data
//               pointer; the caller will be responsible for managing
//               the reference counts on this object subsequently.
//
//               Returns true if the record contained any data (and
//               the pointers have been filled), false if it didn't
//               (and the pointers are NULL).
////////////////////////////////////////////////////////////////////
88
inline bool BamCacheRecord::extract_data(TypedWritable *&ptr, ReferenceCount *&ref_ptr);

996 8 set_data 0 4 1782 24 BamCacheRecord::set_data 0 2 102 103 1279
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::set_data
//       Access: Published
//  Description: Stores a new data object on the record.  You should
//               pass the same pointer twice, to both parameters; this
//               allows the C++ typecasting to automatically convert
//               the pointer into both a TypedWritable and a
//               ReferenceCount pointer, so that the BamCacheRecord
//               object can reliably manage the reference counts.
//
//               You may pass 0 or NULL as the second parameter.  If
//               you do this, the BamCacheRecord will not manage the
//               object's reference count; it will be up to you to
//               ensure the object is not deleted during the lifetime
//               of the BamCacheRecord object.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::set_data
//       Access: Published
//  Description: This variant on set_data() is provided just to allow
//               Python code to pass a 0 as the second parameter.
////////////////////////////////////////////////////////////////////
151
inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr);
inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy);

997 6 output 0 4 1782 22 BamCacheRecord::output 0 1 104 222
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
48
void BamCacheRecord::output(ostream &out) const;

998 5 write 0 4 1782 21 BamCacheRecord::write 0 1 105 221
////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
69
void BamCacheRecord::write(ostream &out, int indent_level = 0) const;

999 14 get_class_type 0 4 1782 30 BamCacheRecord::get_class_type 0 1 106 0
55
static TypeHandle BamCacheRecord::get_class_type(void);

1000 8 BamCache 0 4 1784 18 BamCache::BamCache 0 1 109 220
////////////////////////////////////////////////////////////////////
//     Function: BamCache::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
25
BamCache::BamCache(void);

1001 9 ~BamCache 0 4 1784 19 BamCache::~BamCache 0 0 219
////////////////////////////////////////////////////////////////////
//     Function: BamCache::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
26
BamCache::~BamCache(void);

1002 10 set_active 0 4 1784 20 BamCache::set_active 0 1 110 646
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_active
//       Access: Published
//  Description: Changes the state of the active flag.  "active" means
//               that the cache should be consulted automatically on
//               loads, "not active" means that objects should be
//               loaded directly without consulting the cache.
//
//               This represents the global flag.  Also see the
//               individual cache_models, cache_textures,
//               cache_compressed_textures flags.
////////////////////////////////////////////////////////////////////
44
inline void BamCache::set_active(bool flag);

1003 10 get_active 0 4 1784 20 BamCache::get_active 0 1 111 695
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_active
//       Access: Published
//  Description: Returns true if the BamCache is currently active,
//               false if it is not.  "active" means that the cache
//               should be consulted automatically on loads, "not
//               active" means that objects should be loaded directly
//               without consulting the cache.
//
//               This represents the global flag.  Also see the
//               individual cache_models, cache_textures,
//               cache_compressed_textures flags.
////////////////////////////////////////////////////////////////////
45
inline bool BamCache::get_active(void) const;

1004 16 set_cache_models 0 4 1784 26 BamCache::set_cache_models 0 1 112 346
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_models
//       Access: Published
//  Description: Indicates whether model files (e.g. egg files and bam
//               files) will be stored in the cache, as bam files.
////////////////////////////////////////////////////////////////////
50
inline void BamCache::set_cache_models(bool flag);

1005 16 get_cache_models 0 4 1784 26 BamCache::get_cache_models 0 1 113 414
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_models
//       Access: Published
//  Description: Returns whether model files (e.g. egg files and bam
//               files) will be stored in the cache, as bam files.
//
//               This also returns false if get_active() is false.
////////////////////////////////////////////////////////////////////
51
inline bool BamCache::get_cache_models(void) const;

1006 18 set_cache_textures 0 4 1784 28 BamCache::set_cache_textures 0 1 114 332
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_textures
//       Access: Published
//  Description: Indicates whether texture files will be stored in the
//               cache, as uncompressed txo files.
////////////////////////////////////////////////////////////////////
52
inline void BamCache::set_cache_textures(bool flag);

1007 18 get_cache_textures 0 4 1784 28 BamCache::get_cache_textures 0 1 115 418
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_textures
//       Access: Published
//  Description: Returns whether texture files (e.g. egg files and bam
//               files) will be stored in the cache, as txo files.
//
//               This also returns false if get_active() is false.
////////////////////////////////////////////////////////////////////
53
inline bool BamCache::get_cache_textures(void) const;

1008 29 set_cache_compressed_textures 0 4 1784 39 BamCache::set_cache_compressed_textures 0 1 116 1143
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_compressed_textures
//       Access: Published
//  Description: Indicates whether compressed texture files will be
//               stored in the cache, as compressed txo files.  The
//               compressed data may either be generated in-CPU, via
//               the squish library, or it may be extracted from the
//               GSG after the texture has been loaded.
//
//               This may be set in conjunction with
//               set_cache_textures(), or independently of it.  If
//               set_cache_textures() is true and this is false, all
//               textures will be cached in their uncompressed form.
//               If set_cache_textures() is false and this is true,
//               only compressed textures will be cached, and they
//               will be cached in their compressed form.  If both are
//               true, all textures will be cached, in their
//               uncompressed or compressed form appropriately.
////////////////////////////////////////////////////////////////////
63
inline void BamCache::set_cache_compressed_textures(bool flag);

1009 29 get_cache_compressed_textures 0 4 1784 39 BamCache::get_cache_compressed_textures 0 1 117 475
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_compressed_textures
//       Access: Published
//  Description: Returns whether compressed texture files will be
//               stored in the cache, as compressed txo files.  See
//               set_cache_compressed_textures().
//
//               This also returns false if get_active() is false.
////////////////////////////////////////////////////////////////////
64
inline bool BamCache::get_cache_compressed_textures(void) const;

1010 8 set_root 0 4 1784 18 BamCache::set_root 0 1 118 665
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_root
//       Access: Published
//  Description: Changes the current root pathname of the cache.  This
//               specifies where the cache files are stored on disk.
//               This should name a directory that is on a disk local
//               to the machine (not on a network-mounted disk), for
//               instance, /tmp/panda-cache or /c/panda-cache.
//
//               If the directory does not already exist, it will be
//               created as a result of this call.
////////////////////////////////////////////////////////////////////
46
void BamCache::set_root(Filename const &root);

1011 8 get_root 0 4 1784 18 BamCache::get_root 0 1 119 299
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_root
//       Access: Published
//  Description: Returns the current root pathname of the cache.  See
//               set_root().
////////////////////////////////////////////////////////////////////
47
inline Filename BamCache::get_root(void) const;

1012 14 set_flush_time 0 4 1784 24 BamCache::set_flush_time 0 1 120 316
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_flush_time
//       Access: Published
//  Description: Specifies the time in seconds between automatic
//               flushes of the cache index.
////////////////////////////////////////////////////////////////////
53
inline void BamCache::set_flush_time(int flush_time);

1013 14 get_flush_time 0 4 1784 24 BamCache::get_flush_time 0 1 121 314
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_flush_time
//       Access: Published
//  Description: Returns the time in seconds between automatic
//               flushes of the cache index.
////////////////////////////////////////////////////////////////////
48
inline int BamCache::get_flush_time(void) const;

1014 20 set_cache_max_kbytes 0 4 1784 30 BamCache::set_cache_max_kbytes 0 1 122 767
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_max_kbytes
//       Access: Published
//  Description: Specifies the maximum size, in kilobytes, which the
//               cache is allowed to grow to.  If a newly cached file
//               would exceed this size, an older file is removed from
//               the cache.
//
//               Note that in the case of multiple different processes
//               simultaneously operating on the same cache directory,
//               the actual cache size may slightly exceed this value
//               from time to time due to latency in checking between
//               the processes.
////////////////////////////////////////////////////////////////////
59
inline void BamCache::set_cache_max_kbytes(int max_kbytes);

1015 20 get_cache_max_kbytes 0 4 1784 30 BamCache::get_cache_max_kbytes 0 1 123 371
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_max_kbytes
//       Access: Published
//  Description: Returns the maximum size, in kilobytes, which the
//               cache is allowed to grow to.  See
//               set_cache_max_kbytes().
////////////////////////////////////////////////////////////////////
54
inline int BamCache::get_cache_max_kbytes(void) const;

1016 13 set_read_only 0 4 1784 23 BamCache::set_read_only 0 1 124 523
////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_read_only
//       Access: Published
//  Description: Can be used to put the cache in read-only mode,
//               or take it out of read-only mode.  Note that if you
//               put it into read-write mode, and it discovers that
//               it does not have write access, it will put itself
//               right back into read-only mode.
////////////////////////////////////////////////////////////////////
45
inline void BamCache::set_read_only(bool ro);

1017 13 get_read_only 0 4 1784 23 BamCache::get_read_only 0 1 125 503
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_read_only
//       Access: Published
//  Description: Returns true if the cache is in read-only mode.
//               Normally, the cache starts in read-write mode.  It
//               can put itself into read-only mode automatically if
//               it discovers that it does not have write access to
//               the cache.
////////////////////////////////////////////////////////////////////
48
inline bool BamCache::get_read_only(void) const;

1018 6 lookup 0 4 1784 16 BamCache::lookup 0 1 126 1209
////////////////////////////////////////////////////////////////////
//     Function: BamCache::lookup
//       Access: Published
//  Description: Looks up a file in the cache.
//
//               If the file is cacheable, then regardless of whether
//               the file is found in the cache or not, this returns a
//               BamCacheRecord.  On the other hand, if the file
//               cannot be cached, returns NULL.
//
//               If record->has_data() returns true, then the file was
//               found in the cache, and you may call
//               record->extract_data() to get the object.  If
//               record->has_data() returns false, then the file was
//               not found in the cache or the cache was stale; and
//               you should reload the source file (calling
//               record->add_dependent_file() for each file loaded,
//               including the original source file), and then call
//               record->set_data() to record the resulting loaded
//               object; and finally, you should call store() to write
//               the cached record to disk.
////////////////////////////////////////////////////////////////////
109
PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, string const &cache_extension);

1019 5 store 0 4 1784 15 BamCache::store 0 1 127 478
////////////////////////////////////////////////////////////////////
//     Function: BamCache::store
//       Access: Published
//  Description: Flushes a cache entry to disk.  You must have
//               retrieved the cache record via a prior call to
//               lookup(), and then stored the data via
//               record->set_data().  Returns true on success, false
//               on failure.
////////////////////////////////////////////////////////////////////
45
bool BamCache::store(BamCacheRecord *record);

1020 20 consider_flush_index 0 4 1784 30 BamCache::consider_flush_index 0 1 128 325
////////////////////////////////////////////////////////////////////
//     Function: BamCache::consider_flush_index
//       Access: Published
//  Description: Flushes the index if enough time has elapsed since
//               the index was last flushed.
////////////////////////////////////////////////////////////////////
42
void BamCache::consider_flush_index(void);

1021 11 flush_index 0 4 1784 21 BamCache::flush_index 0 1 129 258
////////////////////////////////////////////////////////////////////
//     Function: BamCache::flush_index
//       Access: Published
//  Description: Ensures the index is written to disk.
////////////////////////////////////////////////////////////////////
33
void BamCache::flush_index(void);

1022 10 list_index 0 4 1784 20 BamCache::list_index 0 1 130 272
////////////////////////////////////////////////////////////////////
//     Function: BamCache::list_index
//       Access: Published
//  Description: Writes the contents of the index to standard output.
////////////////////////////////////////////////////////////////////
68
void BamCache::list_index(ostream &out, int indent_level = 0) const;

1023 14 get_global_ptr 0 4 1784 24 BamCache::get_global_ptr 0 1 131 376
////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_global_ptr
//       Access: Published, Static
//  Description: Returns a pointer to the global BamCache object,
//               which is used automatically by the ModelPool and
//               TexturePool.
////////////////////////////////////////////////////////////////////
55
static inline BamCache *BamCache::get_global_ptr(void);

1024 9 ~BamEnums 0 4 1785 19 BamEnums::~BamEnums 0 0 0
26
BamEnums::~BamEnums(void);

1025 13 LoaderOptions 0 4 1789 28 LoaderOptions::LoaderOptions 0 3 132 133 134 684
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
238
LoaderOptions::LoaderOptions(int flags = (::LoaderOptions::LF_search | ::LoaderOptions::LF_report_errors));
inline LoaderOptions::LoaderOptions(int flags, int texture_flags);
inline LoaderOptions::LoaderOptions(LoaderOptions const &copy);

1026 10 operator = 0 4 1789 25 LoaderOptions::operator = 0 1 135 0
65
inline void LoaderOptions::operator =(LoaderOptions const &copy);

1027 9 set_flags 0 4 1789 24 LoaderOptions::set_flags 0 1 136 223
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_flags
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
48
inline void LoaderOptions::set_flags(int flags);

1028 9 get_flags 0 4 1789 24 LoaderOptions::get_flags 0 1 137 223
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_flags
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
48
inline int LoaderOptions::get_flags(void) const;

1029 17 set_texture_flags 0 4 1789 32 LoaderOptions::set_texture_flags 0 1 138 231
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_texture_flags
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
56
inline void LoaderOptions::set_texture_flags(int flags);

1030 17 get_texture_flags 0 4 1789 32 LoaderOptions::get_texture_flags 0 1 139 231
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_texture_flags
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
56
inline int LoaderOptions::get_texture_flags(void) const;

1031 21 set_texture_num_views 0 4 1789 36 LoaderOptions::set_texture_num_views 0 1 140 767
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_texture_num_views
//       Access: Published
//  Description: Specifies the expected number of views to load for
//               the texture.  This is ignored unless TF_multiview is
//               included in texture_flags.  This must be specified
//               when loading a 3-d multiview texture, in which case
//               it is used to differentiate z levels from separate
//               views; it may be zero in the case of 2-d textures or
//               cube maps, in which case the number of views can be
//               inferred from the number of images found on disk.
////////////////////////////////////////////////////////////////////
64
inline void LoaderOptions::set_texture_num_views(int num_views);

1032 21 get_texture_num_views 0 4 1789 36 LoaderOptions::get_texture_num_views 0 1 141 264
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_texture_num_views
//       Access: Published
//  Description: See set_texture_num_views().
////////////////////////////////////////////////////////////////////
60
inline int LoaderOptions::get_texture_num_views(void) const;

1033 22 set_auto_texture_scale 0 4 1789 37 LoaderOptions::set_auto_texture_scale 0 1 142 480
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_auto_texture_scale
//       Access: Published
//  Description: Set this flag to ATS_none, ATS_up, ATS_down, or
//               ATS_pad to control how a texture is scaled from
//               disk when it is subsequently loaded.  Set it to
//               ATS_unspecified to restore the default behavior.
////////////////////////////////////////////////////////////////////
74
inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale);

1034 22 get_auto_texture_scale 0 4 1789 37 LoaderOptions::get_auto_texture_scale 0 1 143 266
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_auto_texture_scale
//       Access: Published
//  Description: See set_auto_texture_scale().
////////////////////////////////////////////////////////////////////
74
inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const;

1035 6 output 0 4 1789 21 LoaderOptions::output 0 1 144 221
////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
47
void LoaderOptions::output(ostream &out) const;

1036 14 ~LoaderOptions 0 4 1789 29 LoaderOptions::~LoaderOptions 0 0 0
36
LoaderOptions::~LoaderOptions(void);

1037 9 BamReader 0 4 1792 20 BamReader::BamReader 0 1 145 261
// The primary interface for a caller.

////////////////////////////////////////////////////////////////////
//     Function: BamReader::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
52
BamReader::BamReader(DatagramGenerator *source = 0);

1038 10 ~BamReader 0 4 1792 21 BamReader::~BamReader 0 0 220
////////////////////////////////////////////////////////////////////
//     Function: BamReader::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
28
BamReader::~BamReader(void);

1039 10 set_source 0 4 1792 21 BamReader::set_source 0 1 146 383
////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_source
//       Access: Published
//  Description: Changes the source of future datagrams for this
//               BamReader.  This also implicitly calls init() if it
//               has not already been called.
////////////////////////////////////////////////////////////////////
54
void BamReader::set_source(DatagramGenerator *source);

1040 10 get_source 0 4 1792 21 BamReader::get_source 0 1 147 324
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_source
//       Access: Published
//  Description: Returns the current source of the BamReader as set by
//               set_source() or the constructor.
////////////////////////////////////////////////////////////////////
54
inline DatagramGenerator *BamReader::get_source(void);

1041 4 init 0 4 1792 15 BamReader::init 0 1 148 474
////////////////////////////////////////////////////////////////////
//     Function: BamReader::init
//       Access: Published
//  Description: Initializes the BamReader prior to reading any
//               objects from its source.  This includes reading the
//               Bam header.
//
//               This returns true if the BamReader successfully
//               initialized, false otherwise.
////////////////////////////////////////////////////////////////////
27
bool BamReader::init(void);

1042 12 set_aux_data 0 4 1792 23 BamReader::set_aux_data 0 1 149 1496
////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_aux_data
//       Access: Published
//  Description: Associates an arbitrary block of data with the
//               indicated object (or NULL), and the indicated name.
//
//               This is intended to provide a place for temporary
//               storage for objects reading themselves from the bam
//               file.  To use it, inherit from BamReader::AuxData and
//               store whatever data you like there.  Then associate
//               your AuxData with the object as it is being read with
//               set_aux_data().  You may later set the aux data to
//               NULL to remove it; or it will automatically be
//               removed (and deleted) after finalize() is called for
//               the object in question.
//
//               If the TypedWritable pointer is NULL, the the aux
//               data is stored globally for the BamReader in general.
//               This pointer is available to any bam objects, and
//               will not be automatically removed until the BamReader
//               itself destructs.
//
//               In either case, the name is just an arbitrary
//               user-defined key.  If there is already a data pointer
//               stored for the obj/name pair, that data pointer will
//               be replaced (and deleted).
////////////////////////////////////////////////////////////////////
95
void BamReader::set_aux_data(TypedWritable *obj, string const &name, BamReader::AuxData *data);

1043 12 get_aux_data 0 4 1792 23 BamReader::get_aux_data 0 1 150 413
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_aux_data
//       Access: Published
//  Description: Returns the pointer previously associated with the
//               bam reader by a previous call to set_aux_data(), or
//               NULL if data with the indicated key has not been set.
////////////////////////////////////////////////////////////////////
90
BamReader::AuxData *BamReader::get_aux_data(TypedWritable *obj, string const &name) const;

1044 12 get_filename 0 4 1792 23 BamReader::get_filename 0 1 151 457
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_filename
//       Access: Published
//  Description: If a BAM is a file, then the BamReader should
//               contain the name of the file.  This enables the
//               reader to interpret pathnames in the BAM as relative
//               to the directory containing the BAM.
////////////////////////////////////////////////////////////////////
59
inline Filename const &BamReader::get_filename(void) const;

1045 18 get_loader_options 0 4 1792 29 BamReader::get_loader_options 0 1 152 330
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_loader_options
//       Access: Published
//  Description: Returns the LoaderOptions passed to the loader when
//               the model was requested, if any.
////////////////////////////////////////////////////////////////////
70
inline LoaderOptions const &BamReader::get_loader_options(void) const;

1046 18 set_loader_options 0 4 1792 29 BamReader::set_loader_options 0 1 153 276
////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_loader_options
//       Access: Published
//  Description: Specifies the LoaderOptions for this BamReader.
////////////////////////////////////////////////////////////////////
72
inline void BamReader::set_loader_options(LoaderOptions const &options);

1047 11 read_object 0 4 1792 22 BamReader::read_object 0 1 154 2207
////////////////////////////////////////////////////////////////////
//     Function: BamReader::read_object
//       Access: Published
//  Description: Reads a single object from the Bam file.  If the
//               object type is known, a new object of the appropriate
//               type is created and returned; otherwise, NULL is
//               returned.  NULL is also returned when the end of the
//               file is reached.  is_eof() may be called to
//               differentiate between these two cases.
//
//               This may be called repeatedly to extract out all the
//               objects in the Bam file, but typically (especially
//               for scene graph files, indicated with the .bam
//               extension), only one object is retrieved directly
//               from the Bam file: the root of the scene graph.  The
//               remaining objects will all be retrieved recursively
//               by the first object.
//
//               Note that the object returned may not yet be
//               complete.  In particular, some of its pointers may
//               not be filled in; you must call resolve() to fill in
//               all the available pointers before you can safely use
//               any objects returned by read_object().
//
//               This flavor of read_object() requires the caller to
//               know what type of object it has received in order to
//               properly manage the reference counts.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BamReader::read_object
//       Access: Published
//  Description: Reads a single object from the Bam file.  
//
//               This flavor of read_object() returns both a
//               TypedWritable and a ReferenceCount pointer to the
//               same object, so the reference count may be tracked
//               reliably, without having to know precisely what type
//               of object we have.  It returns true on success, or
//               false on failure.
////////////////////////////////////////////////////////////////////
120
TypedWritable *BamReader::read_object(void);
bool BamReader::read_object(TypedWritable *&ptr, ReferenceCount *&ref_ptr);

1048 6 is_eof 0 4 1792 17 BamReader::is_eof 0 1 155 375
////////////////////////////////////////////////////////////////////
//     Function: BamReader::is_eof
//       Access: Published
//  Description: Returns true if the reader has reached end-of-file,
//               false otherwise.  This call is only valid after a
//               call to read_object().
////////////////////////////////////////////////////////////////////
42
inline bool BamReader::is_eof(void) const;

1049 7 resolve 0 4 1792 18 BamReader::resolve 0 1 156 935
////////////////////////////////////////////////////////////////////
//     Function: BamReader::resolve
//       Access: Published
//  Description: This may be called at any time during processing of
//               the Bam file to resolve all the known pointers so
//               far.  It is usually called at the end of the
//               processing, after all objects have been read, which
//               is generally the best time to call it.
//
//               This must be called at least once after reading a
//               particular object via get_object() in order to
//               validate that object.
//
//               The return value is true if all objects have been
//               resolved, or false if some objects are still
//               outstanding (in which case you will need to call
//               resolve() again later).
////////////////////////////////////////////////////////////////////
30
bool BamReader::resolve(void);

1050 14 change_pointer 0 4 1792 25 BamReader::change_pointer 0 1 157 724
////////////////////////////////////////////////////////////////////
//     Function: BamReader::change_pointer
//       Access: Published
//  Description: Indicates that an object recently read from the bam
//               stream should be replaced with a new object.  Any
//               future occurrences of the original object in the
//               stream will henceforth return the new object instead.
//
//               The return value is true if the replacement was
//               successfully made, or false if the object was not
//               read from the stream (or if change_pointer had
//               already been called on it).
////////////////////////////////////////////////////////////////////
100
bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer);

1051 18 get_file_major_ver 0 4 1792 29 BamReader::get_file_major_ver 0 1 158 316
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_major_ver
//       Access: Published
//  Description: Returns the major version number of the Bam file
//               currently being read.
////////////////////////////////////////////////////////////////////
53
inline int BamReader::get_file_major_ver(void) const;

1052 18 get_file_minor_ver 0 4 1792 29 BamReader::get_file_minor_ver 0 1 159 316
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_minor_ver
//       Access: Published
//  Description: Returns the minor version number of the Bam file
//               currently being read.
////////////////////////////////////////////////////////////////////
53
inline int BamReader::get_file_minor_ver(void) const;

1053 15 get_file_endian 0 4 1792 26 BamReader::get_file_endian 0 1 160 528
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_endian
//       Access: Published
//  Description: Returns the endian preference indicated by the Bam
//               file currently being read.  This does not imply that
//               every number is stored using the indicated
//               convention, but individual objects may choose to
//               respect this flag when recording data.
////////////////////////////////////////////////////////////////////
66
inline BamEnums::BamEndian BamReader::get_file_endian(void) const;

1054 24 get_file_stdfloat_double 0 4 1792 35 BamReader::get_file_stdfloat_double 0 1 161 489
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_stdfloat_double
//       Access: Published
//  Description: Returns true if the file stores all "standard"
//               floats as 64-bit doubles, or false if they are 32-bit
//               floats.  This is determined by the compilation flags
//               of the version of Panda that generated this file.
////////////////////////////////////////////////////////////////////
60
inline bool BamReader::get_file_stdfloat_double(void) const;

1055 21 get_current_major_ver 0 4 1792 32 BamReader::get_current_major_ver 0 1 162 440
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_current_major_ver
//       Access: Published
//  Description: Returns the major version number of Bam files
//               supported by the current code base.  This must match
//               get_file_major_ver() in order to successfully read a
//               file.
////////////////////////////////////////////////////////////////////
56
inline int BamReader::get_current_major_ver(void) const;

1056 21 get_current_minor_ver 0 4 1792 32 BamReader::get_current_minor_ver 0 1 163 450
////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_current_minor_ver
//       Access: Published
//  Description: Returns the minor version number of Bam files
//               supported by the current code base.  This must match
//               or exceed get_file_minor_ver() in order to
//               successfully read a file.
////////////////////////////////////////////////////////////////////
56
inline int BamReader::get_current_minor_ver(void) const;

1057 9 BamWriter 0 4 1793 20 BamWriter::BamWriter 0 1 164 221
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
47
BamWriter::BamWriter(DatagramSink *target = 0);

1058 10 ~BamWriter 0 4 1793 21 BamWriter::~BamWriter 0 0 220
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
28
BamWriter::~BamWriter(void);

1059 10 set_target 0 4 1793 21 BamWriter::set_target 0 1 165 394
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::set_target
//       Access: Published
//  Description: Changes the destination of future datagrams written
//               by the BamWriter.  This also implicitly calls init()
//               if it has not already been called.
////////////////////////////////////////////////////////////////////
49
void BamWriter::set_target(DatagramSink *target);

1060 10 get_target 0 4 1793 21 BamWriter::get_target 0 1 166 324
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_target
//       Access: Published
//  Description: Returns the current target of the BamWriter as set by
//               set_target() or the constructor.
////////////////////////////////////////////////////////////////////
49
inline DatagramSink *BamWriter::get_target(void);

1061 4 init 0 4 1793 15 BamWriter::init 0 1 167 483
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::init
//       Access: Published
//  Description: Initializes the BamWriter prior to writing any
//               objects to its output stream.  This includes writing
//               out the Bam header.
//
//               This returns true if the BamWriter successfully
//               initialized, false otherwise.
////////////////////////////////////////////////////////////////////
27
bool BamWriter::init(void);

1062 12 get_filename 0 4 1793 23 BamWriter::get_filename 0 1 168 455
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_filename
//       Access: Published
//  Description: If a BAM is a file, then the BamWriter should
//               contain the name of the file.  This enables the
//               writer to convert pathnames in the BAM to relative
//               to the directory containing the BAM.
////////////////////////////////////////////////////////////////////
59
inline Filename const &BamWriter::get_filename(void) const;

1063 12 write_object 0 4 1793 23 BamWriter::write_object 0 1 169 1153
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::write_object
//       Access: Published
//  Description: Writes a single object to the Bam file, so that the
//               BamReader::read_object() can later correctly restore
//               the object and all its pointers.
//
//               This implicitly also writes any additional objects
//               this object references (if they haven't already been
//               written), so that pointers may be fully resolved.
//
//               This may be called repeatedly to write a sequence of
//               objects to the Bam file, but typically (especially
//               for scene graph files, indicated with the .bam
//               extension), only one object is written directly from
//               the Bam file: the root of the scene graph.  The
//               remaining objects will all be written recursively by
//               the first object.
//
//               Returns true if the object is successfully written,
//               false otherwise.
////////////////////////////////////////////////////////////////////
55
bool BamWriter::write_object(TypedWritable const *obj);

1064 10 has_object 0 4 1793 21 BamWriter::has_object 0 1 170 408
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::has_object
//       Access: Published
//  Description: Returns true if the object has previously been
//               written (or at least requested to be written) to the
//               bam file, or false if we've never heard of it before.
////////////////////////////////////////////////////////////////////
59
bool BamWriter::has_object(TypedWritable const *obj) const;

1065 5 flush 0 4 1793 16 BamWriter::flush 0 1 171 307
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::flush
//       Access: Published
//  Description: Ensures that all data written thus far is manifested
//               on the output stream.
////////////////////////////////////////////////////////////////////
28
void BamWriter::flush(void);

1066 15 get_file_endian 0 4 1793 26 BamWriter::get_file_endian 0 1 172 531
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_endian
//       Access: Published
//  Description: Returns the endian preference indicated by the Bam
//               file currently being written.  This does not imply
//               that every number is stored using the indicated
//               convention, but individual objects may choose to
//               respect this flag when recording data.
////////////////////////////////////////////////////////////////////
66
inline BamEnums::BamEndian BamWriter::get_file_endian(void) const;

1067 24 get_file_stdfloat_double 0 4 1793 35 BamWriter::get_file_stdfloat_double 0 1 173 531
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_stdfloat_double
//       Access: Published
//  Description: Returns true if the file will store all "standard"
//               floats as 64-bit doubles, or false if they are 32-bit
//               floats.  This isn't runtime settable; it's based on
//               the compilation flags of the version of Panda that
//               generated this file.
////////////////////////////////////////////////////////////////////
60
inline bool BamWriter::get_file_stdfloat_double(void) const;

1068 21 get_file_texture_mode 0 4 1793 32 BamWriter::get_file_texture_mode 0 1 174 462
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_texture_mode
//       Access: Published
//  Description: Returns the BamTextureMode preference indicated by
//               the Bam file currently being written.  Texture
//               objects written to this Bam file will be encoded
//               according to the specified mode.
////////////////////////////////////////////////////////////////////
77
inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const;

1069 21 set_file_texture_mode 0 4 1793 32 BamWriter::set_file_texture_mode 0 1 175 453
////////////////////////////////////////////////////////////////////
//     Function: BamWriter::set_file_texture_mode
//       Access: Published
//  Description: Changes the BamTextureMode preference for
//               the Bam file currently being written.  Texture
//               objects written to this Bam file will be encoded
//               according to the specified mode.
////////////////////////////////////////////////////////////////////
89
inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode);

1070 7 BitMask 0 4 1794 33 BitMask< PN_uint16, 16 >::BitMask 0 3 176 177 178 0
191
inline BitMask< PN_uint16, 16 >::BitMask(void);
inline BitMask< PN_uint16, 16 >::BitMask(PN_uint16 init_value);
inline BitMask< PN_uint16, 16 >::BitMask(BitMask< PN_uint16, 16 > const &copy);

1071 10 operator = 0 4 1794 36 BitMask< PN_uint16, 16 >::operator = 0 1 179 0
108
inline BitMask< PN_uint16, 16 > &BitMask< PN_uint16, 16 >::operator =(BitMask< PN_uint16, 16 > const &copy);

1072 6 all_on 0 4 1794 32 BitMask< PN_uint16, 16 >::all_on 0 1 180 0
78
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::all_on(void);

1073 7 all_off 0 4 1794 33 BitMask< PN_uint16, 16 >::all_off 0 1 181 0
79
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::all_off(void);

1074 8 lower_on 0 4 1794 34 BitMask< PN_uint16, 16 >::lower_on 0 1 182 0
87
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::lower_on(int on_bits);

1075 3 bit 0 4 1794 29 BitMask< PN_uint16, 16 >::bit 0 1 183 0
80
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::bit(int index);

1076 5 range 0 4 1794 31 BitMask< PN_uint16, 16 >::range 0 1 184 0
94
static inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::range(int low_bit, int size);

1077 8 ~BitMask 0 4 1794 34 BitMask< PN_uint16, 16 >::~BitMask 0 0 0
48
inline BitMask< PN_uint16, 16 >::~BitMask(void);

1078 16 has_max_num_bits 0 4 1794 42 BitMask< PN_uint16, 16 >::has_max_num_bits 0 1 185 0
61
static bool BitMask< PN_uint16, 16 >::has_max_num_bits(void);

1079 16 get_max_num_bits 0 4 1794 42 BitMask< PN_uint16, 16 >::get_max_num_bits 0 1 186 0
60
static int BitMask< PN_uint16, 16 >::get_max_num_bits(void);

1080 12 get_num_bits 0 4 1794 38 BitMask< PN_uint16, 16 >::get_num_bits 0 1 187 0
56
static int BitMask< PN_uint16, 16 >::get_num_bits(void);

1081 7 get_bit 0 4 1794 33 BitMask< PN_uint16, 16 >::get_bit 0 1 188 0
63
inline bool BitMask< PN_uint16, 16 >::get_bit(int index) const;

1082 7 set_bit 0 4 1794 33 BitMask< PN_uint16, 16 >::set_bit 0 1 189 0
57
inline void BitMask< PN_uint16, 16 >::set_bit(int index);

1083 9 clear_bit 0 4 1794 35 BitMask< PN_uint16, 16 >::clear_bit 0 1 190 0
59
inline void BitMask< PN_uint16, 16 >::clear_bit(int index);

1084 10 set_bit_to 0 4 1794 36 BitMask< PN_uint16, 16 >::set_bit_to 0 1 191 0
72
inline void BitMask< PN_uint16, 16 >::set_bit_to(int index, bool value);

1085 7 is_zero 0 4 1794 33 BitMask< PN_uint16, 16 >::is_zero 0 1 192 0
58
inline bool BitMask< PN_uint16, 16 >::is_zero(void) const;

1086 9 is_all_on 0 4 1794 35 BitMask< PN_uint16, 16 >::is_all_on 0 1 193 0
60
inline bool BitMask< PN_uint16, 16 >::is_all_on(void) const;

1087 7 extract 0 4 1794 33 BitMask< PN_uint16, 16 >::extract 0 1 194 0
80
inline PN_uint16 BitMask< PN_uint16, 16 >::extract(int low_bit, int size) const;

1088 5 store 0 4 1794 31 BitMask< PN_uint16, 16 >::store 0 1 195 0
84
inline void BitMask< PN_uint16, 16 >::store(PN_uint16 value, int low_bit, int size);

1089 10 has_any_of 0 4 1794 36 BitMask< PN_uint16, 16 >::has_any_of 0 1 196 0
78
inline bool BitMask< PN_uint16, 16 >::has_any_of(int low_bit, int size) const;

1090 10 has_all_of 0 4 1794 36 BitMask< PN_uint16, 16 >::has_all_of 0 1 197 0
78
inline bool BitMask< PN_uint16, 16 >::has_all_of(int low_bit, int size) const;

1091 9 set_range 0 4 1794 35 BitMask< PN_uint16, 16 >::set_range 0 1 198 0
71
inline void BitMask< PN_uint16, 16 >::set_range(int low_bit, int size);

1092 11 clear_range 0 4 1794 37 BitMask< PN_uint16, 16 >::clear_range 0 1 199 0
73
inline void BitMask< PN_uint16, 16 >::clear_range(int low_bit, int size);

1093 12 set_range_to 0 4 1794 38 BitMask< PN_uint16, 16 >::set_range_to 0 1 200 0
86
inline void BitMask< PN_uint16, 16 >::set_range_to(bool value, int low_bit, int size);

1094 8 get_word 0 4 1794 34 BitMask< PN_uint16, 16 >::get_word 0 1 201 0
64
inline PN_uint16 BitMask< PN_uint16, 16 >::get_word(void) const;

1095 8 set_word 0 4 1794 34 BitMask< PN_uint16, 16 >::set_word 0 1 202 0
64
inline void BitMask< PN_uint16, 16 >::set_word(PN_uint16 value);

1096 15 get_num_on_bits 0 4 1794 41 BitMask< PN_uint16, 16 >::get_num_on_bits 0 1 203 0
65
inline int BitMask< PN_uint16, 16 >::get_num_on_bits(void) const;

1097 16 get_num_off_bits 0 4 1794 42 BitMask< PN_uint16, 16 >::get_num_off_bits 0 1 204 0
66
inline int BitMask< PN_uint16, 16 >::get_num_off_bits(void) const;

1098 17 get_lowest_on_bit 0 4 1794 43 BitMask< PN_uint16, 16 >::get_lowest_on_bit 0 1 205 0
67
inline int BitMask< PN_uint16, 16 >::get_lowest_on_bit(void) const;

1099 18 get_lowest_off_bit 0 4 1794 44 BitMask< PN_uint16, 16 >::get_lowest_off_bit 0 1 206 0
68
inline int BitMask< PN_uint16, 16 >::get_lowest_off_bit(void) const;

1100 18 get_highest_on_bit 0 4 1794 44 BitMask< PN_uint16, 16 >::get_highest_on_bit 0 1 207 0
68
inline int BitMask< PN_uint16, 16 >::get_highest_on_bit(void) const;

1101 19 get_highest_off_bit 0 4 1794 45 BitMask< PN_uint16, 16 >::get_highest_off_bit 0 1 208 0
69
inline int BitMask< PN_uint16, 16 >::get_highest_off_bit(void) const;

1102 29 get_next_higher_different_bit 0 4 1794 55 BitMask< PN_uint16, 16 >::get_next_higher_different_bit 0 1 209 0
86
inline int BitMask< PN_uint16, 16 >::get_next_higher_different_bit(int low_bit) const;

1103 15 invert_in_place 0 4 1794 41 BitMask< PN_uint16, 16 >::invert_in_place 0 1 210 0
60
inline void BitMask< PN_uint16, 16 >::invert_in_place(void);

1104 18 has_bits_in_common 0 4 1794 44 BitMask< PN_uint16, 16 >::has_bits_in_common 0 1 211 0
102
inline bool BitMask< PN_uint16, 16 >::has_bits_in_common(BitMask< PN_uint16, 16 > const &other) const;

1105 5 clear 0 4 1794 31 BitMask< PN_uint16, 16 >::clear 0 1 212 0
50
inline void BitMask< PN_uint16, 16 >::clear(void);

1106 6 output 0 4 1794 32 BitMask< PN_uint16, 16 >::output 0 1 213 0
58
void BitMask< PN_uint16, 16 >::output(ostream &out) const;

1107 13 output_binary 0 4 1794 39 BitMask< PN_uint16, 16 >::output_binary 0 1 214 0
87
void BitMask< PN_uint16, 16 >::output_binary(ostream &out, int spaces_every = 4) const;

1108 10 output_hex 0 4 1794 36 BitMask< PN_uint16, 16 >::output_hex 0 1 215 0
84
void BitMask< PN_uint16, 16 >::output_hex(ostream &out, int spaces_every = 4) const;

1109 5 write 0 4 1794 31 BitMask< PN_uint16, 16 >::write 0 1 216 0
79
void BitMask< PN_uint16, 16 >::write(ostream &out, int indent_level = 0) const;

1110 11 operator == 0 4 1794 37 BitMask< PN_uint16, 16 >::operator == 0 1 217 0
95
inline bool BitMask< PN_uint16, 16 >::operator ==(BitMask< PN_uint16, 16 > const &other) const;

1111 11 operator != 0 4 1794 37 BitMask< PN_uint16, 16 >::operator != 0 1 218 0
95
inline bool BitMask< PN_uint16, 16 >::operator !=(BitMask< PN_uint16, 16 > const &other) const;

1112 10 operator < 0 4 1794 36 BitMask< PN_uint16, 16 >::operator < 0 1 219 0
94
inline bool BitMask< PN_uint16, 16 >::operator <(BitMask< PN_uint16, 16 > const &other) const;

1113 10 compare_to 0 4 1794 36 BitMask< PN_uint16, 16 >::compare_to 0 1 220 0
93
inline int BitMask< PN_uint16, 16 >::compare_to(BitMask< PN_uint16, 16 > const &other) const;

1114 10 operator & 0 4 1794 36 BitMask< PN_uint16, 16 >::operator & 0 1 221 0
114
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator &(BitMask< PN_uint16, 16 > const &other) const;

1115 10 operator | 0 4 1794 36 BitMask< PN_uint16, 16 >::operator | 0 1 222 0
114
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator |(BitMask< PN_uint16, 16 > const &other) const;

1116 10 operator ^ 0 4 1794 36 BitMask< PN_uint16, 16 >::operator ^ 0 1 223 0
114
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator ^(BitMask< PN_uint16, 16 > const &other) const;

1117 10 operator ~ 0 68 1794 36 BitMask< PN_uint16, 16 >::operator ~ 0 1 224 0
81
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator ~(void) const;

1118 11 operator << 0 4 1794 37 BitMask< PN_uint16, 16 >::operator << 0 1 225 0
87
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator <<(int shift) const;

1119 11 operator >> 0 4 1794 37 BitMask< PN_uint16, 16 >::operator >> 0 1 226 0
87
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::operator >>(int shift) const;

1120 11 operator &= 0 4 1794 37 BitMask< PN_uint16, 16 >::operator &= 0 1 227 0
89
inline void BitMask< PN_uint16, 16 >::operator &=(BitMask< PN_uint16, 16 > const &other);

1121 11 operator |= 0 4 1794 37 BitMask< PN_uint16, 16 >::operator |= 0 1 228 0
89
inline void BitMask< PN_uint16, 16 >::operator |=(BitMask< PN_uint16, 16 > const &other);

1122 11 operator ^= 0 4 1794 37 BitMask< PN_uint16, 16 >::operator ^= 0 1 229 0
89
inline void BitMask< PN_uint16, 16 >::operator ^=(BitMask< PN_uint16, 16 > const &other);

1123 12 operator <<= 0 4 1794 38 BitMask< PN_uint16, 16 >::operator <<= 0 1 230 0
62
inline void BitMask< PN_uint16, 16 >::operator <<=(int shift);

1124 12 operator >>= 0 4 1794 38 BitMask< PN_uint16, 16 >::operator >>= 0 1 231 0
62
inline void BitMask< PN_uint16, 16 >::operator >>=(int shift);

1125 19 flood_down_in_place 0 4 1794 45 BitMask< PN_uint16, 16 >::flood_down_in_place 0 1 232 0
64
inline void BitMask< PN_uint16, 16 >::flood_down_in_place(void);

1126 17 flood_up_in_place 0 4 1794 43 BitMask< PN_uint16, 16 >::flood_up_in_place 0 1 233 0
62
inline void BitMask< PN_uint16, 16 >::flood_up_in_place(void);

1127 15 flood_bits_down 0 4 1794 41 BitMask< PN_uint16, 16 >::flood_bits_down 0 1 234 0
86
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::flood_bits_down(void) const;

1128 13 flood_bits_up 0 4 1794 39 BitMask< PN_uint16, 16 >::flood_bits_up 0 1 235 0
84
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::flood_bits_up(void) const;

1129 21 keep_next_highest_bit 0 4 1794 47 BitMask< PN_uint16, 16 >::keep_next_highest_bit 0 3 236 237 238 0
316
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_highest_bit(void) const;
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_highest_bit(int index) const;
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_highest_bit(BitMask< PN_uint16, 16 > const &other) const;

1130 20 keep_next_lowest_bit 0 4 1794 46 BitMask< PN_uint16, 16 >::keep_next_lowest_bit 0 3 239 240 241 0
313
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_lowest_bit(void) const;
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_lowest_bit(int index) const;
inline BitMask< PN_uint16, 16 > BitMask< PN_uint16, 16 >::keep_next_lowest_bit(BitMask< PN_uint16, 16 > const &other) const;

1131 7 get_key 0 4 1794 33 BitMask< PN_uint16, 16 >::get_key 0 1 242 0
57
inline int BitMask< PN_uint16, 16 >::get_key(void) const;

1132 11 __nonzero__ 0 4 1794 37 BitMask< PN_uint16, 16 >::__nonzero__ 0 1 243 0
62
inline bool BitMask< PN_uint16, 16 >::__nonzero__(void) const;

1133 14 get_class_type 0 4 1794 40 BitMask< PN_uint16, 16 >::get_class_type 0 1 244 0
65
static TypeHandle BitMask< PN_uint16, 16 >::get_class_type(void);

1134 7 BitMask 0 4 1796 33 BitMask< PN_uint32, 32 >::BitMask 0 3 245 246 247 0
191
inline BitMask< PN_uint32, 32 >::BitMask(void);
inline BitMask< PN_uint32, 32 >::BitMask(PN_uint32 init_value);
inline BitMask< PN_uint32, 32 >::BitMask(BitMask< PN_uint32, 32 > const &copy);

1135 10 operator = 0 4 1796 36 BitMask< PN_uint32, 32 >::operator = 0 1 248 0
108
inline BitMask< PN_uint32, 32 > &BitMask< PN_uint32, 32 >::operator =(BitMask< PN_uint32, 32 > const &copy);

1136 6 all_on 0 4 1796 32 BitMask< PN_uint32, 32 >::all_on 0 1 249 0
78
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::all_on(void);

1137 7 all_off 0 4 1796 33 BitMask< PN_uint32, 32 >::all_off 0 1 250 0
79
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::all_off(void);

1138 8 lower_on 0 4 1796 34 BitMask< PN_uint32, 32 >::lower_on 0 1 251 0
87
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::lower_on(int on_bits);

1139 3 bit 0 4 1796 29 BitMask< PN_uint32, 32 >::bit 0 1 252 0
80
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::bit(int index);

1140 5 range 0 4 1796 31 BitMask< PN_uint32, 32 >::range 0 1 253 0
94
static inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::range(int low_bit, int size);

1141 8 ~BitMask 0 4 1796 34 BitMask< PN_uint32, 32 >::~BitMask 0 0 0
48
inline BitMask< PN_uint32, 32 >::~BitMask(void);

1142 16 has_max_num_bits 0 4 1796 42 BitMask< PN_uint32, 32 >::has_max_num_bits 0 1 254 0
61
static bool BitMask< PN_uint32, 32 >::has_max_num_bits(void);

1143 16 get_max_num_bits 0 4 1796 42 BitMask< PN_uint32, 32 >::get_max_num_bits 0 1 255 0
60
static int BitMask< PN_uint32, 32 >::get_max_num_bits(void);

1144 12 get_num_bits 0 4 1796 38 BitMask< PN_uint32, 32 >::get_num_bits 0 1 256 0
56
static int BitMask< PN_uint32, 32 >::get_num_bits(void);

1145 7 get_bit 0 4 1796 33 BitMask< PN_uint32, 32 >::get_bit 0 1 257 0
63
inline bool BitMask< PN_uint32, 32 >::get_bit(int index) const;

1146 7 set_bit 0 4 1796 33 BitMask< PN_uint32, 32 >::set_bit 0 1 258 0
57
inline void BitMask< PN_uint32, 32 >::set_bit(int index);

1147 9 clear_bit 0 4 1796 35 BitMask< PN_uint32, 32 >::clear_bit 0 1 259 0
59
inline void BitMask< PN_uint32, 32 >::clear_bit(int index);

1148 10 set_bit_to 0 4 1796 36 BitMask< PN_uint32, 32 >::set_bit_to 0 1 260 0
72
inline void BitMask< PN_uint32, 32 >::set_bit_to(int index, bool value);

1149 7 is_zero 0 4 1796 33 BitMask< PN_uint32, 32 >::is_zero 0 1 261 0
58
inline bool BitMask< PN_uint32, 32 >::is_zero(void) const;

1150 9 is_all_on 0 4 1796 35 BitMask< PN_uint32, 32 >::is_all_on 0 1 262 0
60
inline bool BitMask< PN_uint32, 32 >::is_all_on(void) const;

1151 7 extract 0 4 1796 33 BitMask< PN_uint32, 32 >::extract 0 1 263 0
80
inline PN_uint32 BitMask< PN_uint32, 32 >::extract(int low_bit, int size) const;

1152 5 store 0 4 1796 31 BitMask< PN_uint32, 32 >::store 0 1 264 0
84
inline void BitMask< PN_uint32, 32 >::store(PN_uint32 value, int low_bit, int size);

1153 10 has_any_of 0 4 1796 36 BitMask< PN_uint32, 32 >::has_any_of 0 1 265 0
78
inline bool BitMask< PN_uint32, 32 >::has_any_of(int low_bit, int size) const;

1154 10 has_all_of 0 4 1796 36 BitMask< PN_uint32, 32 >::has_all_of 0 1 266 0
78
inline bool BitMask< PN_uint32, 32 >::has_all_of(int low_bit, int size) const;

1155 9 set_range 0 4 1796 35 BitMask< PN_uint32, 32 >::set_range 0 1 267 0
71
inline void BitMask< PN_uint32, 32 >::set_range(int low_bit, int size);

1156 11 clear_range 0 4 1796 37 BitMask< PN_uint32, 32 >::clear_range 0 1 268 0
73
inline void BitMask< PN_uint32, 32 >::clear_range(int low_bit, int size);

1157 12 set_range_to 0 4 1796 38 BitMask< PN_uint32, 32 >::set_range_to 0 1 269 0
86
inline void BitMask< PN_uint32, 32 >::set_range_to(bool value, int low_bit, int size);

1158 8 get_word 0 4 1796 34 BitMask< PN_uint32, 32 >::get_word 0 1 270 0
64
inline PN_uint32 BitMask< PN_uint32, 32 >::get_word(void) const;

1159 8 set_word 0 4 1796 34 BitMask< PN_uint32, 32 >::set_word 0 1 271 0
64
inline void BitMask< PN_uint32, 32 >::set_word(PN_uint32 value);

1160 15 get_num_on_bits 0 4 1796 41 BitMask< PN_uint32, 32 >::get_num_on_bits 0 1 272 0
65
inline int BitMask< PN_uint32, 32 >::get_num_on_bits(void) const;

1161 16 get_num_off_bits 0 4 1796 42 BitMask< PN_uint32, 32 >::get_num_off_bits 0 1 273 0
66
inline int BitMask< PN_uint32, 32 >::get_num_off_bits(void) const;

1162 17 get_lowest_on_bit 0 4 1796 43 BitMask< PN_uint32, 32 >::get_lowest_on_bit 0 1 274 0
67
inline int BitMask< PN_uint32, 32 >::get_lowest_on_bit(void) const;

1163 18 get_lowest_off_bit 0 4 1796 44 BitMask< PN_uint32, 32 >::get_lowest_off_bit 0 1 275 0
68
inline int BitMask< PN_uint32, 32 >::get_lowest_off_bit(void) const;

1164 18 get_highest_on_bit 0 4 1796 44 BitMask< PN_uint32, 32 >::get_highest_on_bit 0 1 276 0
68
inline int BitMask< PN_uint32, 32 >::get_highest_on_bit(void) const;

1165 19 get_highest_off_bit 0 4 1796 45 BitMask< PN_uint32, 32 >::get_highest_off_bit 0 1 277 0
69
inline int BitMask< PN_uint32, 32 >::get_highest_off_bit(void) const;

1166 29 get_next_higher_different_bit 0 4 1796 55 BitMask< PN_uint32, 32 >::get_next_higher_different_bit 0 1 278 0
86
inline int BitMask< PN_uint32, 32 >::get_next_higher_different_bit(int low_bit) const;

1167 15 invert_in_place 0 4 1796 41 BitMask< PN_uint32, 32 >::invert_in_place 0 1 279 0
60
inline void BitMask< PN_uint32, 32 >::invert_in_place(void);

1168 18 has_bits_in_common 0 4 1796 44 BitMask< PN_uint32, 32 >::has_bits_in_common 0 1 280 0
102
inline bool BitMask< PN_uint32, 32 >::has_bits_in_common(BitMask< PN_uint32, 32 > const &other) const;

1169 5 clear 0 4 1796 31 BitMask< PN_uint32, 32 >::clear 0 1 281 0
50
inline void BitMask< PN_uint32, 32 >::clear(void);

1170 6 output 0 4 1796 32 BitMask< PN_uint32, 32 >::output 0 1 282 0
58
void BitMask< PN_uint32, 32 >::output(ostream &out) const;

1171 13 output_binary 0 4 1796 39 BitMask< PN_uint32, 32 >::output_binary 0 1 283 0
87
void BitMask< PN_uint32, 32 >::output_binary(ostream &out, int spaces_every = 4) const;

1172 10 output_hex 0 4 1796 36 BitMask< PN_uint32, 32 >::output_hex 0 1 284 0
84
void BitMask< PN_uint32, 32 >::output_hex(ostream &out, int spaces_every = 4) const;

1173 5 write 0 4 1796 31 BitMask< PN_uint32, 32 >::write 0 1 285 0
79
void BitMask< PN_uint32, 32 >::write(ostream &out, int indent_level = 0) const;

1174 11 operator == 0 4 1796 37 BitMask< PN_uint32, 32 >::operator == 0 1 286 0
95
inline bool BitMask< PN_uint32, 32 >::operator ==(BitMask< PN_uint32, 32 > const &other) const;

1175 11 operator != 0 4 1796 37 BitMask< PN_uint32, 32 >::operator != 0 1 287 0
95
inline bool BitMask< PN_uint32, 32 >::operator !=(BitMask< PN_uint32, 32 > const &other) const;

1176 10 operator < 0 4 1796 36 BitMask< PN_uint32, 32 >::operator < 0 1 288 0
94
inline bool BitMask< PN_uint32, 32 >::operator <(BitMask< PN_uint32, 32 > const &other) const;

1177 10 compare_to 0 4 1796 36 BitMask< PN_uint32, 32 >::compare_to 0 1 289 0
93
inline int BitMask< PN_uint32, 32 >::compare_to(BitMask< PN_uint32, 32 > const &other) const;

1178 10 operator & 0 4 1796 36 BitMask< PN_uint32, 32 >::operator & 0 1 290 0
114
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator &(BitMask< PN_uint32, 32 > const &other) const;

1179 10 operator | 0 4 1796 36 BitMask< PN_uint32, 32 >::operator | 0 1 291 0
114
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator |(BitMask< PN_uint32, 32 > const &other) const;

1180 10 operator ^ 0 4 1796 36 BitMask< PN_uint32, 32 >::operator ^ 0 1 292 0
114
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator ^(BitMask< PN_uint32, 32 > const &other) const;

1181 10 operator ~ 0 68 1796 36 BitMask< PN_uint32, 32 >::operator ~ 0 1 293 0
81
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator ~(void) const;

1182 11 operator << 0 4 1796 37 BitMask< PN_uint32, 32 >::operator << 0 1 294 0
87
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator <<(int shift) const;

1183 11 operator >> 0 4 1796 37 BitMask< PN_uint32, 32 >::operator >> 0 1 295 0
87
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::operator >>(int shift) const;

1184 11 operator &= 0 4 1796 37 BitMask< PN_uint32, 32 >::operator &= 0 1 296 0
89
inline void BitMask< PN_uint32, 32 >::operator &=(BitMask< PN_uint32, 32 > const &other);

1185 11 operator |= 0 4 1796 37 BitMask< PN_uint32, 32 >::operator |= 0 1 297 0
89
inline void BitMask< PN_uint32, 32 >::operator |=(BitMask< PN_uint32, 32 > const &other);

1186 11 operator ^= 0 4 1796 37 BitMask< PN_uint32, 32 >::operator ^= 0 1 298 0
89
inline void BitMask< PN_uint32, 32 >::operator ^=(BitMask< PN_uint32, 32 > const &other);

1187 12 operator <<= 0 4 1796 38 BitMask< PN_uint32, 32 >::operator <<= 0 1 299 0
62
inline void BitMask< PN_uint32, 32 >::operator <<=(int shift);

1188 12 operator >>= 0 4 1796 38 BitMask< PN_uint32, 32 >::operator >>= 0 1 300 0
62
inline void BitMask< PN_uint32, 32 >::operator >>=(int shift);

1189 19 flood_down_in_place 0 4 1796 45 BitMask< PN_uint32, 32 >::flood_down_in_place 0 1 301 0
64
inline void BitMask< PN_uint32, 32 >::flood_down_in_place(void);

1190 17 flood_up_in_place 0 4 1796 43 BitMask< PN_uint32, 32 >::flood_up_in_place 0 1 302 0
62
inline void BitMask< PN_uint32, 32 >::flood_up_in_place(void);

1191 15 flood_bits_down 0 4 1796 41 BitMask< PN_uint32, 32 >::flood_bits_down 0 1 303 0
86
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::flood_bits_down(void) const;

1192 13 flood_bits_up 0 4 1796 39 BitMask< PN_uint32, 32 >::flood_bits_up 0 1 304 0
84
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::flood_bits_up(void) const;

1193 21 keep_next_highest_bit 0 4 1796 47 BitMask< PN_uint32, 32 >::keep_next_highest_bit 0 3 305 306 307 0
316
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_highest_bit(void) const;
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_highest_bit(int index) const;
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_highest_bit(BitMask< PN_uint32, 32 > const &other) const;

1194 20 keep_next_lowest_bit 0 4 1796 46 BitMask< PN_uint32, 32 >::keep_next_lowest_bit 0 3 308 309 310 0
313
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_lowest_bit(void) const;
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_lowest_bit(int index) const;
inline BitMask< PN_uint32, 32 > BitMask< PN_uint32, 32 >::keep_next_lowest_bit(BitMask< PN_uint32, 32 > const &other) const;

1195 7 get_key 0 4 1796 33 BitMask< PN_uint32, 32 >::get_key 0 1 311 0
57
inline int BitMask< PN_uint32, 32 >::get_key(void) const;

1196 11 __nonzero__ 0 4 1796 37 BitMask< PN_uint32, 32 >::__nonzero__ 0 1 312 0
62
inline bool BitMask< PN_uint32, 32 >::__nonzero__(void) const;

1197 14 get_class_type 0 4 1796 40 BitMask< PN_uint32, 32 >::get_class_type 0 1 313 0
65
static TypeHandle BitMask< PN_uint32, 32 >::get_class_type(void);

1198 7 BitMask 0 4 1798 33 BitMask< PN_uint64, 64 >::BitMask 0 3 314 315 316 0
191
inline BitMask< PN_uint64, 64 >::BitMask(void);
inline BitMask< PN_uint64, 64 >::BitMask(PN_uint64 init_value);
inline BitMask< PN_uint64, 64 >::BitMask(BitMask< PN_uint64, 64 > const &copy);

1199 10 operator = 0 4 1798 36 BitMask< PN_uint64, 64 >::operator = 0 1 317 0
108
inline BitMask< PN_uint64, 64 > &BitMask< PN_uint64, 64 >::operator =(BitMask< PN_uint64, 64 > const &copy);

1200 6 all_on 0 4 1798 32 BitMask< PN_uint64, 64 >::all_on 0 1 318 0
78
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::all_on(void);

1201 7 all_off 0 4 1798 33 BitMask< PN_uint64, 64 >::all_off 0 1 319 0
79
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::all_off(void);

1202 8 lower_on 0 4 1798 34 BitMask< PN_uint64, 64 >::lower_on 0 1 320 0
87
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::lower_on(int on_bits);

1203 3 bit 0 4 1798 29 BitMask< PN_uint64, 64 >::bit 0 1 321 0
80
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::bit(int index);

1204 5 range 0 4 1798 31 BitMask< PN_uint64, 64 >::range 0 1 322 0
94
static inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::range(int low_bit, int size);

1205 8 ~BitMask 0 4 1798 34 BitMask< PN_uint64, 64 >::~BitMask 0 0 0
48
inline BitMask< PN_uint64, 64 >::~BitMask(void);

1206 16 has_max_num_bits 0 4 1798 42 BitMask< PN_uint64, 64 >::has_max_num_bits 0 1 323 0
61
static bool BitMask< PN_uint64, 64 >::has_max_num_bits(void);

1207 16 get_max_num_bits 0 4 1798 42 BitMask< PN_uint64, 64 >::get_max_num_bits 0 1 324 0
60
static int BitMask< PN_uint64, 64 >::get_max_num_bits(void);

1208 12 get_num_bits 0 4 1798 38 BitMask< PN_uint64, 64 >::get_num_bits 0 1 325 0
56
static int BitMask< PN_uint64, 64 >::get_num_bits(void);

1209 7 get_bit 0 4 1798 33 BitMask< PN_uint64, 64 >::get_bit 0 1 326 0
63
inline bool BitMask< PN_uint64, 64 >::get_bit(int index) const;

1210 7 set_bit 0 4 1798 33 BitMask< PN_uint64, 64 >::set_bit 0 1 327 0
57
inline void BitMask< PN_uint64, 64 >::set_bit(int index);

1211 9 clear_bit 0 4 1798 35 BitMask< PN_uint64, 64 >::clear_bit 0 1 328 0
59
inline void BitMask< PN_uint64, 64 >::clear_bit(int index);

1212 10 set_bit_to 0 4 1798 36 BitMask< PN_uint64, 64 >::set_bit_to 0 1 329 0
72
inline void BitMask< PN_uint64, 64 >::set_bit_to(int index, bool value);

1213 7 is_zero 0 4 1798 33 BitMask< PN_uint64, 64 >::is_zero 0 1 330 0
58
inline bool BitMask< PN_uint64, 64 >::is_zero(void) const;

1214 9 is_all_on 0 4 1798 35 BitMask< PN_uint64, 64 >::is_all_on 0 1 331 0
60
inline bool BitMask< PN_uint64, 64 >::is_all_on(void) const;

1215 7 extract 0 4 1798 33 BitMask< PN_uint64, 64 >::extract 0 1 332 0
80
inline PN_uint64 BitMask< PN_uint64, 64 >::extract(int low_bit, int size) const;

1216 5 store 0 4 1798 31 BitMask< PN_uint64, 64 >::store 0 1 333 0
84
inline void BitMask< PN_uint64, 64 >::store(PN_uint64 value, int low_bit, int size);

1217 10 has_any_of 0 4 1798 36 BitMask< PN_uint64, 64 >::has_any_of 0 1 334 0
78
inline bool BitMask< PN_uint64, 64 >::has_any_of(int low_bit, int size) const;

1218 10 has_all_of 0 4 1798 36 BitMask< PN_uint64, 64 >::has_all_of 0 1 335 0
78
inline bool BitMask< PN_uint64, 64 >::has_all_of(int low_bit, int size) const;

1219 9 set_range 0 4 1798 35 BitMask< PN_uint64, 64 >::set_range 0 1 336 0
71
inline void BitMask< PN_uint64, 64 >::set_range(int low_bit, int size);

1220 11 clear_range 0 4 1798 37 BitMask< PN_uint64, 64 >::clear_range 0 1 337 0
73
inline void BitMask< PN_uint64, 64 >::clear_range(int low_bit, int size);

1221 12 set_range_to 0 4 1798 38 BitMask< PN_uint64, 64 >::set_range_to 0 1 338 0
86
inline void BitMask< PN_uint64, 64 >::set_range_to(bool value, int low_bit, int size);

1222 8 get_word 0 4 1798 34 BitMask< PN_uint64, 64 >::get_word 0 1 339 0
64
inline PN_uint64 BitMask< PN_uint64, 64 >::get_word(void) const;

1223 8 set_word 0 4 1798 34 BitMask< PN_uint64, 64 >::set_word 0 1 340 0
64
inline void BitMask< PN_uint64, 64 >::set_word(PN_uint64 value);

1224 15 get_num_on_bits 0 4 1798 41 BitMask< PN_uint64, 64 >::get_num_on_bits 0 1 341 0
65
inline int BitMask< PN_uint64, 64 >::get_num_on_bits(void) const;

1225 16 get_num_off_bits 0 4 1798 42 BitMask< PN_uint64, 64 >::get_num_off_bits 0 1 342 0
66
inline int BitMask< PN_uint64, 64 >::get_num_off_bits(void) const;

1226 17 get_lowest_on_bit 0 4 1798 43 BitMask< PN_uint64, 64 >::get_lowest_on_bit 0 1 343 0
67
inline int BitMask< PN_uint64, 64 >::get_lowest_on_bit(void) const;

1227 18 get_lowest_off_bit 0 4 1798 44 BitMask< PN_uint64, 64 >::get_lowest_off_bit 0 1 344 0
68
inline int BitMask< PN_uint64, 64 >::get_lowest_off_bit(void) const;

1228 18 get_highest_on_bit 0 4 1798 44 BitMask< PN_uint64, 64 >::get_highest_on_bit 0 1 345 0
68
inline int BitMask< PN_uint64, 64 >::get_highest_on_bit(void) const;

1229 19 get_highest_off_bit 0 4 1798 45 BitMask< PN_uint64, 64 >::get_highest_off_bit 0 1 346 0
69
inline int BitMask< PN_uint64, 64 >::get_highest_off_bit(void) const;

1230 29 get_next_higher_different_bit 0 4 1798 55 BitMask< PN_uint64, 64 >::get_next_higher_different_bit 0 1 347 0
86
inline int BitMask< PN_uint64, 64 >::get_next_higher_different_bit(int low_bit) const;

1231 15 invert_in_place 0 4 1798 41 BitMask< PN_uint64, 64 >::invert_in_place 0 1 348 0
60
inline void BitMask< PN_uint64, 64 >::invert_in_place(void);

1232 18 has_bits_in_common 0 4 1798 44 BitMask< PN_uint64, 64 >::has_bits_in_common 0 1 349 0
102
inline bool BitMask< PN_uint64, 64 >::has_bits_in_common(BitMask< PN_uint64, 64 > const &other) const;

1233 5 clear 0 4 1798 31 BitMask< PN_uint64, 64 >::clear 0 1 350 0
50
inline void BitMask< PN_uint64, 64 >::clear(void);

1234 6 output 0 4 1798 32 BitMask< PN_uint64, 64 >::output 0 1 351 0
58
void BitMask< PN_uint64, 64 >::output(ostream &out) const;

1235 13 output_binary 0 4 1798 39 BitMask< PN_uint64, 64 >::output_binary 0 1 352 0
87
void BitMask< PN_uint64, 64 >::output_binary(ostream &out, int spaces_every = 4) const;

1236 10 output_hex 0 4 1798 36 BitMask< PN_uint64, 64 >::output_hex 0 1 353 0
84
void BitMask< PN_uint64, 64 >::output_hex(ostream &out, int spaces_every = 4) const;

1237 5 write 0 4 1798 31 BitMask< PN_uint64, 64 >::write 0 1 354 0
79
void BitMask< PN_uint64, 64 >::write(ostream &out, int indent_level = 0) const;

1238 11 operator == 0 4 1798 37 BitMask< PN_uint64, 64 >::operator == 0 1 355 0
95
inline bool BitMask< PN_uint64, 64 >::operator ==(BitMask< PN_uint64, 64 > const &other) const;

1239 11 operator != 0 4 1798 37 BitMask< PN_uint64, 64 >::operator != 0 1 356 0
95
inline bool BitMask< PN_uint64, 64 >::operator !=(BitMask< PN_uint64, 64 > const &other) const;

1240 10 operator < 0 4 1798 36 BitMask< PN_uint64, 64 >::operator < 0 1 357 0
94
inline bool BitMask< PN_uint64, 64 >::operator <(BitMask< PN_uint64, 64 > const &other) const;

1241 10 compare_to 0 4 1798 36 BitMask< PN_uint64, 64 >::compare_to 0 1 358 0
93
inline int BitMask< PN_uint64, 64 >::compare_to(BitMask< PN_uint64, 64 > const &other) const;

1242 10 operator & 0 4 1798 36 BitMask< PN_uint64, 64 >::operator & 0 1 359 0
114
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator &(BitMask< PN_uint64, 64 > const &other) const;

1243 10 operator | 0 4 1798 36 BitMask< PN_uint64, 64 >::operator | 0 1 360 0
114
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator |(BitMask< PN_uint64, 64 > const &other) const;

1244 10 operator ^ 0 4 1798 36 BitMask< PN_uint64, 64 >::operator ^ 0 1 361 0
114
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator ^(BitMask< PN_uint64, 64 > const &other) const;

1245 10 operator ~ 0 68 1798 36 BitMask< PN_uint64, 64 >::operator ~ 0 1 362 0
81
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator ~(void) const;

1246 11 operator << 0 4 1798 37 BitMask< PN_uint64, 64 >::operator << 0 1 363 0
87
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator <<(int shift) const;

1247 11 operator >> 0 4 1798 37 BitMask< PN_uint64, 64 >::operator >> 0 1 364 0
87
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::operator >>(int shift) const;

1248 11 operator &= 0 4 1798 37 BitMask< PN_uint64, 64 >::operator &= 0 1 365 0
89
inline void BitMask< PN_uint64, 64 >::operator &=(BitMask< PN_uint64, 64 > const &other);

1249 11 operator |= 0 4 1798 37 BitMask< PN_uint64, 64 >::operator |= 0 1 366 0
89
inline void BitMask< PN_uint64, 64 >::operator |=(BitMask< PN_uint64, 64 > const &other);

1250 11 operator ^= 0 4 1798 37 BitMask< PN_uint64, 64 >::operator ^= 0 1 367 0
89
inline void BitMask< PN_uint64, 64 >::operator ^=(BitMask< PN_uint64, 64 > const &other);

1251 12 operator <<= 0 4 1798 38 BitMask< PN_uint64, 64 >::operator <<= 0 1 368 0
62
inline void BitMask< PN_uint64, 64 >::operator <<=(int shift);

1252 12 operator >>= 0 4 1798 38 BitMask< PN_uint64, 64 >::operator >>= 0 1 369 0
62
inline void BitMask< PN_uint64, 64 >::operator >>=(int shift);

1253 19 flood_down_in_place 0 4 1798 45 BitMask< PN_uint64, 64 >::flood_down_in_place 0 1 370 0
64
inline void BitMask< PN_uint64, 64 >::flood_down_in_place(void);

1254 17 flood_up_in_place 0 4 1798 43 BitMask< PN_uint64, 64 >::flood_up_in_place 0 1 371 0
62
inline void BitMask< PN_uint64, 64 >::flood_up_in_place(void);

1255 15 flood_bits_down 0 4 1798 41 BitMask< PN_uint64, 64 >::flood_bits_down 0 1 372 0
86
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::flood_bits_down(void) const;

1256 13 flood_bits_up 0 4 1798 39 BitMask< PN_uint64, 64 >::flood_bits_up 0 1 373 0
84
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::flood_bits_up(void) const;

1257 21 keep_next_highest_bit 0 4 1798 47 BitMask< PN_uint64, 64 >::keep_next_highest_bit 0 3 374 375 376 0
316
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_highest_bit(void) const;
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_highest_bit(int index) const;
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_highest_bit(BitMask< PN_uint64, 64 > const &other) const;

1258 20 keep_next_lowest_bit 0 4 1798 46 BitMask< PN_uint64, 64 >::keep_next_lowest_bit 0 3 377 378 379 0
313
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_lowest_bit(void) const;
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_lowest_bit(int index) const;
inline BitMask< PN_uint64, 64 > BitMask< PN_uint64, 64 >::keep_next_lowest_bit(BitMask< PN_uint64, 64 > const &other) const;

1259 7 get_key 0 4 1798 33 BitMask< PN_uint64, 64 >::get_key 0 1 380 0
57
inline int BitMask< PN_uint64, 64 >::get_key(void) const;

1260 11 __nonzero__ 0 4 1798 37 BitMask< PN_uint64, 64 >::__nonzero__ 0 1 381 0
62
inline bool BitMask< PN_uint64, 64 >::__nonzero__(void) const;

1261 14 get_class_type 0 4 1798 40 BitMask< PN_uint64, 64 >::get_class_type 0 1 382 0
65
static TypeHandle BitMask< PN_uint64, 64 >::get_class_type(void);

1262 8 BitArray 0 4 1801 18 BitArray::BitArray 0 4 383 384 385 386 910
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BitArray::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor (from SparseArray)
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
184
inline BitArray::BitArray(void);
inline BitArray::BitArray(BitArray::WordType init_value);
inline BitArray::BitArray(BitArray const &copy);
BitArray::BitArray(SparseArray const &from);

1263 10 operator = 0 4 1801 20 BitArray::operator = 0 1 387 233
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Copy Assignment Operator
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
60
inline BitArray &BitArray::operator =(BitArray const &copy);

1264 6 all_on 0 4 1801 16 BitArray::all_on 0 1 388 317
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray with an infinite array of bits,
//               all on.
////////////////////////////////////////////////////////////////////
46
static inline BitArray BitArray::all_on(void);

1265 7 all_off 0 4 1801 17 BitArray::all_off 0 1 389 284
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose bits are all off.
////////////////////////////////////////////////////////////////////
47
static inline BitArray BitArray::all_off(void);

1266 8 lower_on 0 4 1801 18 BitArray::lower_on 0 1 390 295
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named lower_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose lower on_bits bits are on.
////////////////////////////////////////////////////////////////////
55
static inline BitArray BitArray::lower_on(int on_bits);

1267 3 bit 0 4 1801 13 BitArray::bit 0 1 391 289
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named bit constructor
//       Access: Published, Static
//  Description: Returns a BitArray with only the indicated bit on.
////////////////////////////////////////////////////////////////////
48
static inline BitArray BitArray::bit(int index);

1268 5 range 0 4 1801 15 BitArray::range 0 1 392 323
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named range constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose size bits, beginning at
//               low_bit, are on.
////////////////////////////////////////////////////////////////////
62
static inline BitArray BitArray::range(int low_bit, int size);

1269 9 ~BitArray 0 4 1801 19 BitArray::~BitArray 0 0 219
////////////////////////////////////////////////////////////////////
//     Function: BitArray::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
33
inline BitArray::~BitArray(void);

1270 16 has_max_num_bits 0 4 1801 26 BitArray::has_max_num_bits 0 1 393 714
////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_max_num_bits
//       Access: Published, Static
//  Description: Returns true if there is a maximum number of bits
//               that may be stored in this structure, false
//               otherwise.  If this returns true, the number may be
//               queried in get_max_num_bits().
//
//               This method always returns false.  The BitArray has
//               no maximum number of bits.  This method is defined so
//               generic programming algorithms can use BitMask or
//               BitArray interchangeably.
////////////////////////////////////////////////////////////////////
45
static bool BitArray::has_max_num_bits(void);

1271 16 get_max_num_bits 0 4 1801 26 BitArray::get_max_num_bits 0 1 394 749
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_max_num_bits
//       Access: Published, Static
//  Description: If get_max_num_bits() returned true, this method may
//               be called to return the maximum number of bits that
//               may be stored in this structure.  It is an error to
//               call this if get_max_num_bits() return false.
//
//               It is always an error to call this method.  The
//               BitArray has no maximum number of bits.  This method
//               is defined so generic programming algorithms can use
//               BitMask or BitArray interchangeably.
////////////////////////////////////////////////////////////////////
44
static int BitArray::get_max_num_bits(void);

1272 21 get_num_bits_per_word 0 4 1801 31 BitArray::get_num_bits_per_word 0 1 395 476
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_bits_per_word
//       Access: Published, Static
//  Description: Returns the number of bits stored per word
//               internally.  This is of interest only in that it
//               limits the maximum number of bits that may be queried
//               or set at once by extract() and store().
////////////////////////////////////////////////////////////////////
49
static int BitArray::get_num_bits_per_word(void);

1273 12 get_num_bits 0 4 1801 22 BitArray::get_num_bits 0 1 396 604
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_bits
//       Access: Published
//  Description: Returns the current number of possibly different bits
//               in this array.  There are actually an infinite number
//               of bits, but every bit higher than this bit will have
//               the same value, either 0 or 1 (see
//               get_highest_bits()).
//
//               This number may grow and/or shrink automatically as
//               needed.
////////////////////////////////////////////////////////////////////
46
inline int BitArray::get_num_bits(void) const;

1274 7 get_bit 0 4 1801 17 BitArray::get_bit 0 1 397 442
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_bit
//       Access: Published
//  Description: Returns true if the nth bit is set, false if it is
//               cleared.  It is valid for n to increase beyond
//               get_num_bits(), but the return value get_num_bits()
//               will always be the same.
////////////////////////////////////////////////////////////////////
47
inline bool BitArray::get_bit(int index) const;

1275 7 set_bit 0 4 1801 17 BitArray::set_bit 0 1 398 317
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_bit
//       Access: Published
//  Description: Sets the nth bit on.  If n >= get_num_bits(), this
//               automatically extends the array.
////////////////////////////////////////////////////////////////////
41
inline void BitArray::set_bit(int index);

1276 9 clear_bit 0 4 1801 19 BitArray::clear_bit 0 1 399 320
////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear_bit
//       Access: Published
//  Description: Sets the nth bit off.  If n >= get_num_bits(), this
//               automatically extends the array.
////////////////////////////////////////////////////////////////////
43
inline void BitArray::clear_bit(int index);

1277 10 set_bit_to 0 4 1801 20 BitArray::set_bit_to 0 1 400 310
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_bit_to
//       Access: Published
//  Description: Sets the nth bit either on or off, according to the
//               indicated bool value.
////////////////////////////////////////////////////////////////////
56
inline void BitArray::set_bit_to(int index, bool value);

1278 16 get_highest_bits 0 4 1801 26 BitArray::get_highest_bits 0 1 401 364
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_bits
//       Access: Published
//  Description: Returns true if the infinite set of bits beyond
//               get_num_bits() are all on, or false of they are all
//               off.
////////////////////////////////////////////////////////////////////
51
inline bool BitArray::get_highest_bits(void) const;

1279 7 is_zero 0 4 1801 17 BitArray::is_zero 0 1 402 294
////////////////////////////////////////////////////////////////////
//     Function: BitArray::is_zero
//       Access: Published
//  Description: Returns true if the entire bitmask is zero, false
//               otherwise.
////////////////////////////////////////////////////////////////////
35
bool BitArray::is_zero(void) const;

1280 9 is_all_on 0 4 1801 19 BitArray::is_all_on 0 1 403 295
////////////////////////////////////////////////////////////////////
//     Function: BitArray::is_all_on
//       Access: Published
//  Description: Returns true if the entire bitmask is one, false
//               otherwise.
////////////////////////////////////////////////////////////////////
37
bool BitArray::is_all_on(void) const;

1281 7 extract 0 4 1801 17 BitArray::extract 0 1 404 438
////////////////////////////////////////////////////////////////////
//     Function: BitArray::extract
//       Access: Published
//  Description: Returns a word that represents only the indicated
//               range of bits within this BitArray, shifted to the
//               least-significant position.  size must be <=
//               get_num_bits_per_word().
////////////////////////////////////////////////////////////////////
73
inline BitArray::WordType BitArray::extract(int low_bit, int size) const;

1282 5 store 0 4 1801 15 BitArray::store 0 1 405 310
////////////////////////////////////////////////////////////////////
//     Function: BitArray::store
//       Access: Published
//  Description: Stores the indicated word into the indicated range of
//               bits with this BitArray.
////////////////////////////////////////////////////////////////////
77
inline void BitArray::store(BitArray::WordType value, int low_bit, int size);

1283 10 has_any_of 0 4 1801 20 BitArray::has_any_of 0 1 406 308
////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_any_of
//       Access: Published
//  Description: Returns true if any bit in the indicated range is
//               set, false otherwise.
////////////////////////////////////////////////////////////////////
55
bool BitArray::has_any_of(int low_bit, int size) const;

1284 10 has_all_of 0 4 1801 20 BitArray::has_all_of 0 1 407 310
////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_all_of
//       Access: Published
//  Description: Returns true if all bits in the indicated range are
//               set, false otherwise.
////////////////////////////////////////////////////////////////////
55
bool BitArray::has_all_of(int low_bit, int size) const;

1285 9 set_range 0 4 1801 19 BitArray::set_range 0 1 408 255
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_range
//       Access: Published
//  Description: Sets the indicated range of bits on.
////////////////////////////////////////////////////////////////////
48
void BitArray::set_range(int low_bit, int size);

1286 11 clear_range 0 4 1801 21 BitArray::clear_range 0 1 409 258
////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear_range
//       Access: Published
//  Description: Sets the indicated range of bits off.
////////////////////////////////////////////////////////////////////
50
void BitArray::clear_range(int low_bit, int size);

1287 12 set_range_to 0 4 1801 22 BitArray::set_range_to 0 1 410 275
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_range_to
//       Access: Published
//  Description: Sets the indicated range of bits to either on or off.
////////////////////////////////////////////////////////////////////
70
inline void BitArray::set_range_to(bool value, int low_bit, int size);

1288 15 get_num_on_bits 0 4 1801 25 BitArray::get_num_on_bits 0 1 411 372
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_on_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 1 in the
//               array.  Returns -1 if there are an infinite number of
//               1 bits.
////////////////////////////////////////////////////////////////////
42
int BitArray::get_num_on_bits(void) const;

1289 16 get_num_off_bits 0 4 1801 26 BitArray::get_num_off_bits 0 1 412 373
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_off_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 0 in the
//               array.  Returns -1 if there are an infinite number of
//               0 bits.
////////////////////////////////////////////////////////////////////
43
int BitArray::get_num_off_bits(void) const;

1290 17 get_lowest_on_bit 0 4 1801 27 BitArray::get_lowest_on_bit 0 1 413 330
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_lowest_on_bit
//       Access: Published
//  Description: Returns the index of the lowest 1 bit in the array.
//               Returns -1 if there are no 1 bits.
////////////////////////////////////////////////////////////////////
44
int BitArray::get_lowest_on_bit(void) const;

1291 18 get_lowest_off_bit 0 4 1801 28 BitArray::get_lowest_off_bit 0 1 414 331
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_lowest_off_bit
//       Access: Published
//  Description: Returns the index of the lowest 0 bit in the array.
//               Returns -1 if there are no 0 bits.
////////////////////////////////////////////////////////////////////
45
int BitArray::get_lowest_off_bit(void) const;

1292 18 get_highest_on_bit 0 4 1801 28 BitArray::get_highest_on_bit 0 1 415 390
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_on_bit
//       Access: Published
//  Description: Returns the index of the highest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
45
int BitArray::get_highest_on_bit(void) const;

1293 19 get_highest_off_bit 0 4 1801 29 BitArray::get_highest_off_bit 0 1 416 391
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_off_bit
//       Access: Published
//  Description: Returns the index of the highest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
46
int BitArray::get_highest_off_bit(void) const;

1294 29 get_next_higher_different_bit 0 4 1801 39 BitArray::get_next_higher_different_bit 0 1 417 591
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_next_higher_different_bit
//       Access: Published
//  Description: Returns the index of the next bit in the array, above
//               low_bit, whose value is different that the value of
//               low_bit.  Returns low_bit again if all bits higher
//               than low_bit have the same value.
//
//               This can be used to quickly iterate through all of
//               the bits in the array.
////////////////////////////////////////////////////////////////////
63
int BitArray::get_next_higher_different_bit(int low_bit) const;

1295 13 get_num_words 0 4 1801 23 BitArray::get_num_words 0 1 418 304
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_words
//       Access: Published
//  Description: Returns the number of possibly-unique words stored in
//               the array.
////////////////////////////////////////////////////////////////////
47
inline int BitArray::get_num_words(void) const;

1296 8 get_word 0 4 1801 18 BitArray::get_word 0 1 419 410
////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_word
//       Access: Published
//  Description: Returns the nth word in the array.  It is valid for n
//               to be greater than get_num_words(), but the return
//               value beyond get_num_words() will always be the same.
////////////////////////////////////////////////////////////////////
58
inline BitArray::MaskType BitArray::get_word(int n) const;

1297 8 set_word 0 4 1801 18 BitArray::set_word 0 1 420 351
////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_word
//       Access: Published
//  Description: Replaces the nth word in the array.  If n >=
//               get_num_words(), this automatically extends the
//               array.
////////////////////////////////////////////////////////////////////
64
inline void BitArray::set_word(int n, BitArray::WordType value);

1298 15 invert_in_place 0 4 1801 25 BitArray::invert_in_place 0 1 421 318
////////////////////////////////////////////////////////////////////
//     Function: BitArray::invert_in_place
//       Access: Published
//  Description: Inverts all the bits in the BitArray.  This is
//               equivalent to array = ~array.
////////////////////////////////////////////////////////////////////
37
void BitArray::invert_in_place(void);

1299 18 has_bits_in_common 0 4 1801 28 BitArray::has_bits_in_common 0 1 422 440
////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_bits_in_common
//       Access: Published
//  Description: Returns true if this BitArray has any "one" bits in
//               common with the other one, false otherwise.
//
//               This is equivalent to (array & other) != 0, but may
//               be faster.
////////////////////////////////////////////////////////////////////
63
bool BitArray::has_bits_in_common(BitArray const &other) const;

1300 5 clear 0 4 1801 15 BitArray::clear 0 1 423 253
////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear
//       Access: Published
//  Description: Sets all the bits in the BitArray off.
////////////////////////////////////////////////////////////////////
34
inline void BitArray::clear(void);

1301 6 output 0 4 1801 16 BitArray::output 0 1 424 443
////////////////////////////////////////////////////////////////////
//     Function: BitArray::output
//       Access: Published
//  Description: Writes the BitArray out as a hex number.  For a
//               BitArray, this is always the same as output_hex();
//               it's too confusing for the output format to change
//               back and forth at runtime.
////////////////////////////////////////////////////////////////////
42
void BitArray::output(ostream &out) const;

1302 13 output_binary 0 4 1801 23 BitArray::output_binary 0 1 425 312
////////////////////////////////////////////////////////////////////
//     Function: BitArray::output_binary
//       Access: Published
//  Description: Writes the BitArray out as a binary number, with
//               spaces every four bits.
////////////////////////////////////////////////////////////////////
71
void BitArray::output_binary(ostream &out, int spaces_every = 4) const;

1303 10 output_hex 0 4 1801 20 BitArray::output_hex 0 1 426 316
////////////////////////////////////////////////////////////////////
//     Function: BitArray::output_hex
//       Access: Published
//  Description: Writes the BitArray out as a hexadecimal number, with
//               spaces every four digits.
////////////////////////////////////////////////////////////////////
68
void BitArray::output_hex(ostream &out, int spaces_every = 4) const;

1304 5 write 0 4 1801 15 BitArray::write 0 1 427 317
////////////////////////////////////////////////////////////////////
//     Function: BitArray::write
//       Access: Published
//  Description: Writes the BitArray out as a binary or a hex number,
//               according to the number of bits.
////////////////////////////////////////////////////////////////////
63
void BitArray::write(ostream &out, int indent_level = 0) const;

1305 11 operator == 0 4 1801 21 BitArray::operator == 0 1 428 0
63
inline bool BitArray::operator ==(BitArray const &other) const;

1306 11 operator != 0 4 1801 21 BitArray::operator != 0 1 429 0
63
inline bool BitArray::operator !=(BitArray const &other) const;

1307 10 operator < 0 4 1801 20 BitArray::operator < 0 1 430 0
62
inline bool BitArray::operator <(BitArray const &other) const;

1308 10 compare_to 0 4 1801 20 BitArray::compare_to 0 1 431 487
////////////////////////////////////////////////////////////////////
//     Function: BitArray::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this BitArray sorts
//               before the indicated other BitArray, greater than zero
//               if it sorts after, or 0 if they are equivalent.  This
//               is based on the same ordering defined by operator <.
////////////////////////////////////////////////////////////////////
54
int BitArray::compare_to(BitArray const &other) const;

1309 10 operator & 0 4 1801 20 BitArray::operator & 0 1 432 0
66
inline BitArray BitArray::operator &(BitArray const &other) const;

1310 10 operator | 0 4 1801 20 BitArray::operator | 0 1 433 0
66
inline BitArray BitArray::operator |(BitArray const &other) const;

1311 10 operator ^ 0 4 1801 20 BitArray::operator ^ 0 1 434 0
66
inline BitArray BitArray::operator ^(BitArray const &other) const;

1312 10 operator ~ 0 68 1801 20 BitArray::operator ~ 0 1 435 0
49
inline BitArray BitArray::operator ~(void) const;

1313 11 operator << 0 4 1801 21 BitArray::operator << 0 1 436 0
55
inline BitArray BitArray::operator <<(int shift) const;

1314 11 operator >> 0 4 1801 21 BitArray::operator >> 0 1 437 0
55
inline BitArray BitArray::operator >>(int shift) const;

1315 11 operator &= 0 4 1801 21 BitArray::operator &= 0 1 438 0
50
void BitArray::operator &=(BitArray const &other);

1316 11 operator |= 0 4 1801 21 BitArray::operator |= 0 1 439 0
50
void BitArray::operator |=(BitArray const &other);

1317 11 operator ^= 0 4 1801 21 BitArray::operator ^= 0 1 440 0
50
void BitArray::operator ^=(BitArray const &other);

1318 12 operator <<= 0 4 1801 22 BitArray::operator <<= 0 1 441 0
39
void BitArray::operator <<=(int shift);

1319 12 operator >>= 0 4 1801 22 BitArray::operator >>= 0 1 442 0
39
void BitArray::operator >>=(int shift);

1320 14 get_class_type 0 4 1801 24 BitArray::get_class_type 0 1 443 0
49
static TypeHandle BitArray::get_class_type(void);

1321 12 ButtonHandle 0 4 1803 26 ButtonHandle::ButtonHandle 0 4 444 445 446 447 1817
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: The default constructor must do nothing, because we
//               can't guarantee ordering of static initializers.  If
//               the constructor tried to initialize its value, it
//               might happen after the value had already been set
//               previously by another static initializer!
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: Constructs a ButtonHandle with the corresponding
//               index number, which may have been returned by an
//               earlier call to ButtonHandle::get_index().
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: Constructs a ButtonHandle with the corresponding
//               name, which is looked up in the ButtonRegistry.
//               This exists for the purpose of being able to
//               automatically coerce a string into a ButtonHandle;
//               for most purposes, you should use either the static
//               KeyboardButton/MouseButton getters or
//               ButtonRegistry::register_button().
////////////////////////////////////////////////////////////////////
195
inline ButtonHandle::ButtonHandle(void);
inline ButtonHandle::ButtonHandle(int index);
inline ButtonHandle::ButtonHandle(ButtonHandle const &copy);
ButtonHandle::ButtonHandle(string const &name);

1322 11 operator == 0 4 1803 25 ButtonHandle::operator == 0 1 448 0
71
inline bool ButtonHandle::operator ==(ButtonHandle const &other) const;

1323 11 operator != 0 4 1803 25 ButtonHandle::operator != 0 1 449 0
71
inline bool ButtonHandle::operator !=(ButtonHandle const &other) const;

1324 10 operator < 0 4 1803 24 ButtonHandle::operator < 0 1 450 0
70
inline bool ButtonHandle::operator <(ButtonHandle const &other) const;

1325 11 operator <= 0 4 1803 25 ButtonHandle::operator <= 0 1 451 0
71
inline bool ButtonHandle::operator <=(ButtonHandle const &other) const;

1326 10 operator > 0 4 1803 24 ButtonHandle::operator > 0 1 452 0
70
inline bool ButtonHandle::operator >(ButtonHandle const &other) const;

1327 11 operator >= 0 4 1803 25 ButtonHandle::operator >= 0 1 453 0
71
inline bool ButtonHandle::operator >=(ButtonHandle const &other) const;

1328 10 compare_to 0 4 1803 24 ButtonHandle::compare_to 0 1 454 467
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::compare_to
//       Access: Published
//  Description: Sorts ButtonHandles arbitrarily (according to <, >,
//               etc.).  Returns a number less than 0 if this type
//               sorts before the other one, greater than zero if it
//               sorts after, 0 if they are equivalent.
////////////////////////////////////////////////////////////////////
69
inline int ButtonHandle::compare_to(ButtonHandle const &other) const;

1329 8 get_hash 0 4 1803 22 ButtonHandle::get_hash 0 1 455 265
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_hash
//       Access: Published
//  Description: Returns a hash code suitable for phash_map.
////////////////////////////////////////////////////////////////////
49
inline size_t ButtonHandle::get_hash(void) const;

1330 8 get_name 0 4 1803 22 ButtonHandle::get_name 0 1 456 250
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_name
//       Access: Public
//  Description: Returns the name of the button.
////////////////////////////////////////////////////////////////////
42
string ButtonHandle::get_name(void) const;

1331 20 has_ascii_equivalent 0 4 1803 34 ButtonHandle::has_ascii_equivalent 0 1 457 375
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::has_ascii_equivalent
//       Access: Published
//  Description: Returns true if the button was created with an ASCII
//               equivalent code (e.g. for a standard keyboard
//               button).
////////////////////////////////////////////////////////////////////
59
inline bool ButtonHandle::has_ascii_equivalent(void) const;

1332 20 get_ascii_equivalent 0 4 1803 34 ButtonHandle::get_ascii_equivalent 0 1 458 346
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_ascii_equivalent
//       Access: Published
//  Description: Returns the character code associated with the
//               button, or '\0' if no ASCII code was associated.
////////////////////////////////////////////////////////////////////
59
inline char ButtonHandle::get_ascii_equivalent(void) const;

1333 9 get_alias 0 4 1803 23 ButtonHandle::get_alias 0 1 459 692
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_alias
//       Access: Published
//  Description: Returns the alias (alternate name) associated with
//               the button, if any, or ButtonHandle::none() if the
//               button has no alias.
//
//               Each button is allowed to have one alias, and
//               multiple different buttons can refer to the same
//               alias.  The alias should be the more general name for
//               the button, for instance, shift is an alias for
//               lshift, but not vice-versa.
////////////////////////////////////////////////////////////////////
49
ButtonHandle ButtonHandle::get_alias(void) const;

1334 7 matches 0 4 1803 21 ButtonHandle::matches 0 1 460 532
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::matches
//       Access: Published
//  Description: Returns true if this ButtonHandle is the same as the
//               other one, or if the other one is an alias for this
//               one.  (Does not return true if this button is an
//               alias for the other one, however.)
//
//               This is a more general comparison than operator ==.
////////////////////////////////////////////////////////////////////
67
inline bool ButtonHandle::matches(ButtonHandle const &other) const;

1335 9 get_index 0 4 1803 23 ButtonHandle::get_index 0 1 461 664
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_index
//       Access: Published
//  Description: Returns the integer index associated with this
//               ButtonHandle. Each different ButtonHandle will have a
//               different index.  However, you probably shouldn't be
//               using this method; you should just treat the
//               ButtonHandles as opaque classes.  This is provided
//               for the convenience of non-C++ scripting languages to
//               build a hashtable of ButtonHandles.
////////////////////////////////////////////////////////////////////
47
inline int ButtonHandle::get_index(void) const;

1336 6 output 0 4 1803 20 ButtonHandle::output 0 1 462 219
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
53
inline void ButtonHandle::output(ostream &out) const;

1337 4 none 0 4 1803 18 ButtonHandle::none 0 1 463 321
////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::none
//       Access: Published, Static
//  Description: Returns a special zero-valued ButtonHandle that is
//               used to indicate no button.
////////////////////////////////////////////////////////////////////
52
static inline ButtonHandle ButtonHandle::none(void);

1338 22 operator typecast bool 0 132 1803 36 ButtonHandle::operator typecast bool 0 1 465 0
61
inline bool ButtonHandle::operator typecast bool(void) const;

1339 14 get_class_type 0 4 1803 28 ButtonHandle::get_class_type 0 1 464 0
53
static TypeHandle ButtonHandle::get_class_type(void);

1340 13 ~ButtonHandle 0 4 1803 27 ButtonHandle::~ButtonHandle 0 0 0
34
ButtonHandle::~ButtonHandle(void);

1341 10 get_button 0 4 1804 26 ButtonRegistry::get_button 0 1 466 396
////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::get_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated name.  If there is no such ButtonHandle,
//               registers a new one and returns it.
////////////////////////////////////////////////////////////////////
60
ButtonHandle ButtonRegistry::get_button(string const &name);

1342 11 find_button 0 4 1804 27 ButtonRegistry::find_button 0 1 467 391
////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::find_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated name.  If there is no such ButtonHandle,
//               returns ButtonHandle::none().
////////////////////////////////////////////////////////////////////
61
ButtonHandle ButtonRegistry::find_button(string const &name);

1343 17 find_ascii_button 0 4 1804 33 ButtonRegistry::find_ascii_button 0 1 468 419
////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::find_ascii_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated ASCII equivalent character.  If there is no
//               such ButtonHandle, returns ButtonHandle::none().
////////////////////////////////////////////////////////////////////
76
ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const;

1344 5 write 0 4 1804 21 ButtonRegistry::write 0 1 469 220
////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::write
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
47
void ButtonRegistry::write(ostream &out) const;

1345 3 ptr 0 4 1804 19 ButtonRegistry::ptr 0 1 470 367
// ptr() returns the pointer to the global ButtonRegistry object.

////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::ptr
//       Access: Published, Static
//  Description: Returns the pointer to the global ButtonRegistry
//               object.
////////////////////////////////////////////////////////////////////
56
static inline ButtonRegistry *ButtonRegistry::ptr(void);

1346 15 ~ButtonRegistry 0 4 1804 31 ButtonRegistry::~ButtonRegistry 0 0 0
38
ButtonRegistry::~ButtonRegistry(void);

1347 15 get_num_buttons 0 4 1805 26 ButtonMap::get_num_buttons 0 1 471 308
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_num_buttons
//       Access: Published
//  Description: Returns the number of buttons that this button
//               mapping specifies.
////////////////////////////////////////////////////////////////////
50
inline int ButtonMap::get_num_buttons(void) const;

1348 14 get_raw_button 0 4 1805 25 ButtonMap::get_raw_button 0 1 472 307
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_raw_button
//       Access: Published
//  Description: Returns the underlying raw button associated with
//               the nth button.
////////////////////////////////////////////////////////////////////
59
inline ButtonHandle ButtonMap::get_raw_button(int i) const;

1349 17 get_mapped_button 0 4 1805 28 ButtonMap::get_mapped_button 0 3 473 474 475 1158
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the nth mapped button, meaning the button
//               that the nth raw button is mapped to.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the button that the given button is mapped
//               to, or ButtonHandle::none() if this map does not
//               specify a mapped button for the given raw button.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the button that the given button is mapped
//               to, or ButtonHandle::none() if this map does not
//               specify a mapped button for the given raw button.
////////////////////////////////////////////////////////////////////
216
inline ButtonHandle ButtonMap::get_mapped_button(int i) const;
inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const;
inline ButtonHandle ButtonMap::get_mapped_button(string const &raw_name) const;

1350 23 get_mapped_button_label 0 4 1805 34 ButtonMap::get_mapped_button_label 0 3 476 477 478 1713
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button_label
//       Access: Published
//  Description: Returns the label associated with the nth mapped
//               button, meaning the button that the nth raw
//               button is mapped to.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtoMap::get_mapped_button_label
//       Access: Published
//  Description: If the button map specifies a special name for the
//               button (eg. if the operating system or keyboard
//               device has a localized name describing the key),
//               returns it, or the empty string otherwise.
//
//               Note that this is not the same as
//               get_mapped_button().get_name(), which returns the
//               name of the Panda event associated with the button.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ButtoMap::get_mapped_button_label
//       Access: Published
//  Description: If the button map specifies a special name for the
//               button (eg. if the operating system or keyboard
//               device has a localized name describing the key),
//               returns it, or the empty string otherwise.
//
//               Note that this is not the same as
//               get_mapped_button().get_name(), which returns the
//               name of the Panda event associated with the button.
////////////////////////////////////////////////////////////////////
237
inline string const &ButtonMap::get_mapped_button_label(int i) const;
inline string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const;
inline string const &ButtonMap::get_mapped_button_label(string const &raw_name) const;

1351 6 output 0 4 1805 17 ButtonMap::output 0 1 479 217
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
43
void ButtonMap::output(ostream &out) const;

1352 5 write 0 4 1805 16 ButtonMap::write 0 1 480 216
////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
64
void ButtonMap::write(ostream &out, int indent_level = 0) const;

1353 14 get_class_type 0 4 1805 25 ButtonMap::get_class_type 0 1 481 0
50
static TypeHandle ButtonMap::get_class_type(void);

1354 10 ~ButtonMap 0 4 1805 21 ButtonMap::~ButtonMap 0 0 0
28
ButtonMap::~ButtonMap(void);

1355 6 output 0 6 1807 22 CallbackObject::output 0 1 482 230
////////////////////////////////////////////////////////////////////
//     Function: CallbackObject::output
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
56
virtual void CallbackObject::output(ostream &out) const;

1356 4 make 0 4 1807 20 CallbackObject::make 0 1 483 0
76
static PointerTo< CallbackObject > CallbackObject::make(PyObject *function);

1357 14 get_class_type 0 4 1807 30 CallbackObject::get_class_type 0 1 484 0
55
static TypeHandle CallbackObject::get_class_type(void);

1358 15 ~CallbackObject 0 4 1807 31 CallbackObject::~CallbackObject 0 0 0
38
CallbackObject::~CallbackObject(void);

1359 19 get_cache_ref_count 0 4 1808 54 CachedTypedWritableReferenceCount::get_cache_ref_count 0 1 485 290
////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::get_cache_ref_count
//       Access: Published
//  Description: Returns the current reference count.
////////////////////////////////////////////////////////////////////
78
inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const;

1360 9 cache_ref 0 4 1808 44 CachedTypedWritableReferenceCount::cache_ref 0 1 486 355
////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::cache_ref
//       Access: Published
//  Description: Explicitly increments the cache reference count and
//               the normal reference count simultaneously.
////////////////////////////////////////////////////////////////////
69
inline void CachedTypedWritableReferenceCount::cache_ref(void) const;

1361 11 cache_unref 0 4 1808 46 CachedTypedWritableReferenceCount::cache_unref 0 1 487 479
////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::cache_unref
//       Access: Published
//  Description: Explicitly decrements the cache reference count and
//               the normal reference count simultaneously.
//
//               The return value is true if the new reference count
//               is nonzero, false if it is zero.
////////////////////////////////////////////////////////////////////
71
inline bool CachedTypedWritableReferenceCount::cache_unref(void) const;

1362 24 test_ref_count_integrity 0 4 1808 59 CachedTypedWritableReferenceCount::test_ref_count_integrity 0 1 488 359
////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::test_ref_count_integrity
//       Access: Published
//  Description: Does some easy checks to make sure that the reference
//               count isn't completely bogus.
////////////////////////////////////////////////////////////////////
84
inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const;

1363 14 get_class_type 0 4 1808 49 CachedTypedWritableReferenceCount::get_class_type 0 1 489 0
74
static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void);

1364 6 output 0 6 1809 20 CallbackData::output 0 1 490 228
////////////////////////////////////////////////////////////////////
//     Function: CallbackData::output
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
54
virtual void CallbackData::output(ostream &out) const;

1365 6 upcall 0 6 1809 20 CallbackData::upcall 0 1 491 408
////////////////////////////////////////////////////////////////////
//     Function: CallbackData::upcall
//       Access: Published, Virtual
//  Description: You should make this call during the callback if you
//               want to continue the normal function that would have
//               been done in the absence of a callback.
////////////////////////////////////////////////////////////////////
40
virtual void CallbackData::upcall(void);

1366 14 get_class_type 0 4 1809 28 CallbackData::get_class_type 0 1 492 0
53
static TypeHandle CallbackData::get_class_type(void);

1367 13 ~CallbackData 0 4 1809 27 CallbackData::~CallbackData 0 0 0
34
CallbackData::~CallbackData(void);

1368 20 PythonCallbackObject 0 4 1810 42 PythonCallbackObject::PythonCallbackObject 0 1 493 0
86
PythonCallbackObject::PythonCallbackObject(PyObject *function = (& ::_Py_NoneStruct));

1369 12 operator new 0 4 1810 34 PythonCallbackObject::operator new 0 1 494 0
134
inline void *PythonCallbackObject::operator new(size_t size);
inline void *PythonCallbackObject::operator new(size_t size, void *ptr);

1370 15 operator delete 0 4 1810 37 PythonCallbackObject::operator delete 0 0 0
128
inline void PythonCallbackObject::operator delete(void *ptr);
inline void PythonCallbackObject::operator delete(void *, void *);

1371 12 validate_ptr 0 4 1810 34 PythonCallbackObject::validate_ptr 0 0 0
71
static inline bool PythonCallbackObject::validate_ptr(void const *ptr);

1372 12 set_function 0 4 1810 34 PythonCallbackObject::set_function 0 1 495 0
60
void PythonCallbackObject::set_function(PyObject *function);

1373 12 get_function 0 4 1810 34 PythonCallbackObject::get_function 0 1 496 0
51
PyObject *PythonCallbackObject::get_function(void);

1374 14 get_class_type 0 4 1810 36 PythonCallbackObject::get_class_type 0 1 497 0
61
static TypeHandle PythonCallbackObject::get_class_type(void);

1375 7 TimeVal 0 4 1811 16 TimeVal::TimeVal 0 1 498 218
////////////////////////////////////////////////////////////////////
//     Function: TimeVal::contructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
30
inline TimeVal::TimeVal(void);

1376 7 get_sec 0 4 1811 16 TimeVal::get_sec 0 1 499 215
////////////////////////////////////////////////////////////////////
//     Function: TimeVal::get_sec
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
42
inline ulong TimeVal::get_sec(void) const;

1377 8 get_usec 0 4 1811 17 TimeVal::get_usec 0 1 500 216
////////////////////////////////////////////////////////////////////
//     Function: TimeVal::get_usec
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
43
inline ulong TimeVal::get_usec(void) const;

1378 6 get_tv 0 20 1811 15 TimeVal::get_tv 0 1 502 32
getter for ulong TimeVal::tv[2];
35
ulong *TimeVal::get_tv(void) const;

1379 6 set_tv 0 36 1811 15 TimeVal::set_tv 0 1 501 32
setter for ulong TimeVal::tv[2];
37
void TimeVal::set_tv(ulong value[2]);

1380 8 ~TimeVal 0 4 1811 17 TimeVal::~TimeVal 0 0 0
24
TimeVal::~TimeVal(void);

1381 11 ClockObject 0 4 1815 24 ClockObject::ClockObject 0 2 503 504 454
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ClockObject::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
82
ClockObject::ClockObject(void);
ClockObject::ClockObject(ClockObject const &copy);

1382 8 set_mode 0 4 1815 21 ClockObject::set_mode 0 1 505 2596
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_mode
//       Access: Published
//  Description: Changes the mode of the clock.  Normally, the clock
//               is in mode M_normal. In this mode, each call to
//               tick() will set the value returned by
//               get_frame_time() to the current real time; thus, the
//               clock simply reports time advancing.
//
//               Other possible modes:
//
//               M_non_real_time - the clock ignores real time
//               completely; at each call to tick(), it pretends that
//               exactly dt seconds have elapsed since the last call
//               to tick().  You may set the value of dt with
//               set_dt() or set_frame_rate().
//
//               M_limited - the clock will run as fast as it can, as
//               in M_normal, but will not run faster than the rate
//               specified by set_frame_rate().  If the application
//               would run faster than this rate, the clock will slow
//               down the application.
//
//               M_integer - the clock will run as fast as it can, but
//               the rate will be constrained to be an integer
//               multiple or divisor of the rate specified by
//               set_frame_rate().  The clock will slow down the
//               application a bit to guarantee this.
//
//               M_integer_limited - a combination of M_limited and
//               M_integer; the clock will not run faster than
//               set_frame_rate(), and if it runs slower, it will run
//               at a integer divisor of that rate.
//
//               M_forced - the clock forces the application to run at
//               the rate specified by set_frame_rate().  If the
//               application would run faster than this rate, the
//               clock will slow down the application; if the
//               application would run slower than this rate, the
//               clock slows down time so that the application
//               believes it is running at the given rate.
//
//               M_degrade - the clock runs at real time, but the
//               application is slowed down by a set factor of its
//               frame rate, specified by set_degrade_factor().
//
//               M_slave - the clock does not advance, but relies on
//               the user to call set_frame_time() and/or
//               set_frame_count() each frame.
////////////////////////////////////////////////////////////////////
51
void ClockObject::set_mode(ClockObject::Mode mode);

1383 8 get_mode 0 4 1815 21 ClockObject::get_mode 0 1 506 293
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_mode
//       Access: Published
//  Description: Returns the current mode of the clock.  See
//               set_mode().
////////////////////////////////////////////////////////////////////
59
inline ClockObject::Mode ClockObject::get_mode(void) const;

1384 14 get_frame_time 0 4 1815 27 ClockObject::get_frame_time 0 1 507 656
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_frame_time
//       Access: Published
//  Description: Returns the time in seconds as of the last time
//               tick() was called (typically, this will be as of the
//               start of the current frame).
//
//               This is generally the kind of time you want to ask
//               for in most rendering and animation contexts, since
//               it's important that all of the animation for a given
//               frame remains in sync with each other.
////////////////////////////////////////////////////////////////////
97
inline double ClockObject::get_frame_time(Thread *current_thread = (get_current_thread())) const;

1385 13 get_real_time 0 4 1815 26 ClockObject::get_real_time 0 1 508 769
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_real_time
//       Access: Published
//  Description: Returns the actual number of seconds elapsed since
//               the ClockObject was created, or since it was last
//               reset.  This is useful for doing real timing
//               measurements, e.g. for performance statistics.
//
//               This returns the most precise timer we have for short
//               time intervals, but it may tend to drift over the
//               long haul.  If more accurate timekeeping is needed
//               over a long period of time, use get_long_time()
//               instead.
////////////////////////////////////////////////////////////////////
53
inline double ClockObject::get_real_time(void) const;

1386 13 get_long_time 0 4 1815 26 ClockObject::get_long_time 0 1 509 773
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_long_time
//       Access: Published
//  Description: Returns the actual number of seconds elapsed since
//               the ClockObject was created, or since it was last
//               reset.
//
//               This is similar to get_real_time(), except that it
//               uses the most accurate counter we have over a long
//               period of time, and so it is less likely to drift.
//               However, it may not be very precise for measuring
//               short intervals.  On Windows, for instace, this is
//               only accurate to within about 55 milliseconds.
////////////////////////////////////////////////////////////////////
53
inline double ClockObject::get_long_time(void) const;

1387 5 reset 0 4 1815 18 ClockObject::reset 0 1 510 299
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::reset
//       Access: Published
//  Description: Simultaneously resets both the time and the frame
//               count to zero.
////////////////////////////////////////////////////////////////////
37
inline void ClockObject::reset(void);

1388 13 set_real_time 0 4 1815 26 ClockObject::set_real_time 0 1 511 607
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_real_time
//       Access: Published
//  Description: Resets the clock to the indicated time.  This
//               changes only the real time of the clock as reported
//               by get_real_time(), but does not immediately change
//               the time reported by get_frame_time()--that will
//               change after the next call to tick().  Also see
//               reset(), set_frame_time(), and set_frame_count().
////////////////////////////////////////////////////////////////////
45
void ClockObject::set_real_time(double time);

1389 14 set_frame_time 0 4 1815 27 ClockObject::set_frame_time 0 1 512 477
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_time
//       Access: Published
//  Description: Changes the time as reported for the current frame to
//               the indicated time.  Normally, the way to adjust the
//               frame time is via tick(); this function is provided
//               only for occasional special adjustments.
////////////////////////////////////////////////////////////////////
95
void ClockObject::set_frame_time(double time, Thread *current_thread = (get_current_thread()));

1390 15 set_frame_count 0 4 1815 28 ClockObject::set_frame_count 0 1 513 380
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_count
//       Access: Published
//  Description: Resets the number of frames counted to the indicated
//               number.  Also see reset(), set_real_time(), and
//               set_frame_time().
////////////////////////////////////////////////////////////////////
100
void ClockObject::set_frame_count(int frame_count, Thread *current_thread = (get_current_thread()));

1391 15 get_frame_count 0 4 1815 28 ClockObject::get_frame_count 0 1 514 457
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_frame_count
//       Access: Published
//  Description: Returns the number of times tick() has been called
//               since the ClockObject was created, or since it was
//               last reset.  This is generally the number of frames
//               that have been rendered.
////////////////////////////////////////////////////////////////////
95
inline int ClockObject::get_frame_count(Thread *current_thread = (get_current_thread())) const;

1392 18 get_net_frame_rate 0 4 1815 31 ClockObject::get_net_frame_rate 0 1 515 523
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_net_frame_rate
//       Access: Published
//  Description: Returns the average frame rate since the last reset.
//               This is simply the total number of frames divided by
//               the total elapsed time.  This reports the virtual
//               frame rate if the clock is in (or has been in)
//               M_non_real_time mode.
////////////////////////////////////////////////////////////////////
101
inline double ClockObject::get_net_frame_rate(Thread *current_thread = (get_current_thread())) const;

1393 6 get_dt 0 4 1815 19 ClockObject::get_dt 0 1 516 369
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_dt
//       Access: Published
//  Description: Returns the elapsed time for the previous frame: the
//               number of seconds elapsed between the last two calls
//               to tick().
////////////////////////////////////////////////////////////////////
89
inline double ClockObject::get_dt(Thread *current_thread = (get_current_thread())) const;

1394 6 set_dt 0 4 1815 19 ClockObject::set_dt 0 1 517 575
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_dt
//       Access: Published
//  Description: In non-real-time mode, sets the number of seconds
//               that should appear to elapse between frames.  In
//               forced mode or limited mode, sets our target dt.  In
//               normal mode, this has no effect.  
//
//               Also see set_frame_rate(), which is a different way
//               to specify the same quantity.
////////////////////////////////////////////////////////////////////
36
void ClockObject::set_dt(double dt);

1395 14 set_frame_rate 0 4 1815 27 ClockObject::set_frame_rate 0 1 518 583
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_rate
//       Access: Published
//  Description: In non-real-time mode, sets the number of frames per
//               second that we should appear to be running.  In forced
//               mode or limited mode, sets our target frame rate.  In
//               normal mode, this has no effect.
//
//               Also see set_dt(), which is a different way to
//               specify the same quantity.
////////////////////////////////////////////////////////////////////
52
void ClockObject::set_frame_rate(double frame_rate);

1396 10 get_max_dt 0 4 1815 23 ClockObject::get_max_dt 0 1 519 333
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_max_dt
//       Access: Published
//  Description: Returns the current maximum allowable time elapsed
//               between any two frames.  See set_max_dt().
////////////////////////////////////////////////////////////////////
50
inline double ClockObject::get_max_dt(void) const;

1397 10 set_max_dt 0 4 1815 23 ClockObject::set_max_dt 0 1 520 872
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_max_dt
//       Access: Published
//  Description: Sets a limit on the value returned by get_dt().  If
//               this value is less than zero, no limit is imposed;
//               otherwise, this is the maximum value that will ever
//               be returned by get_dt(), regardless of how much time
//               has actually elapsed between frames.
//
//               This limit is only imposed in real-time mode; in
//               non-real-time mode, the dt is fixed anyway and max_dt
//               is ignored.
//
//               This is generally used to guarantee reasonable
//               behavior even in the presence of a very slow or
//               chuggy frame rame.
////////////////////////////////////////////////////////////////////
51
inline void ClockObject::set_max_dt(double max_dt);

1398 18 get_degrade_factor 0 4 1815 31 ClockObject::get_degrade_factor 0 1 521 544
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_degrade_factor
//       Access: Published
//  Description: In degrade mode, returns the ratio by which the
//               performance is degraded.  A value of 2.0 causes the
//               clock to be slowed down by a factor of two (reducing
//               performance to 1/2 what would be otherwise).
//
//               This has no effect if mode is not M_degrade.
////////////////////////////////////////////////////////////////////
58
inline double ClockObject::get_degrade_factor(void) const;

1399 18 set_degrade_factor 0 4 1815 31 ClockObject::set_degrade_factor 0 1 522 541
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_degrade_factor
//       Access: Published
//  Description: In degrade mode, sets the ratio by which the
//               performance is degraded.  A value of 2.0 causes the
//               clock to be slowed down by a factor of two (reducing
//               performance to 1/2 what would be otherwise).
//
//               This has no effect if mode is not M_degrade.
////////////////////////////////////////////////////////////////////
67
inline void ClockObject::set_degrade_factor(double degrade_factor);

1400 31 set_average_frame_rate_interval 0 4 1815 44 ClockObject::set_average_frame_rate_interval 0 1 523 729
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_average_frame_rate_interval
//       Access: Published
//  Description: Specifies the interval of time (in seconds) over
//               which get_average_frame_rate() averages the number of
//               frames per second to compute the frame rate.
//               Changing this does not necessarily immediately change
//               the result of get_average_frame_rate(), until this
//               interval of time has elapsed again.
//
//               Setting this to zero disables the computation of
//               get_average_frame_rate().
////////////////////////////////////////////////////////////////////
70
inline void ClockObject::set_average_frame_rate_interval(double time);

1401 31 get_average_frame_rate_interval 0 4 1815 44 ClockObject::get_average_frame_rate_interval 0 1 524 423
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_average_frame_rate_interval
//       Access: Published
//  Description: Returns the interval of time (in seconds) over
//               which get_average_frame_rate() averages the number of frames
//               per second to compute the frame rate.
////////////////////////////////////////////////////////////////////
71
inline double ClockObject::get_average_frame_rate_interval(void) const;

1402 22 get_average_frame_rate 0 4 1815 35 ClockObject::get_average_frame_rate 0 1 525 500
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_average_frame_rate
//       Access: Published
//  Description: Returns the average frame rate in number of frames
//               per second over the last
//               get_average_frame_rate_interval() seconds.  This
//               measures the virtual frame rate if the clock is in
//               M_non_real_time mode.
////////////////////////////////////////////////////////////////////
98
double ClockObject::get_average_frame_rate(Thread *current_thread = (get_current_thread())) const;

1403 22 get_max_frame_duration 0 4 1815 35 ClockObject::get_max_frame_duration 0 1 526 343
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_max_frame_duration
//       Access: Published
//  Description: Returns the maximum frame duration over the last
//               get_average_frame_rate_interval() seconds.
////////////////////////////////////////////////////////////////////
98
double ClockObject::get_max_frame_duration(Thread *current_thread = (get_current_thread())) const;

1404 25 calc_frame_rate_deviation 0 4 1815 38 ClockObject::calc_frame_rate_deviation 0 1 527 915
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::calc_frame_time_deviation
//       Access: Published
//  Description: Returns the standard deviation of the frame times of
//               the frames rendered over the past
//               get_average_frame_rate_interval() seconds.  This
//               number gives an estimate of the chugginess of the
//               frame rate; if it is large, there is a large
//               variation in the frame rate; if is small, all of the
//               frames are consistent in length.
//
//               A large value might also represent just a recent
//               change in frame rate, for instance, because the
//               camera has just rotated from looking at a simple
//               scene to looking at a more complex scene.
////////////////////////////////////////////////////////////////////
101
double ClockObject::calc_frame_rate_deviation(Thread *current_thread = (get_current_thread())) const;

1405 4 tick 0 4 1815 17 ClockObject::tick 0 1 528 566
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::tick
//       Access: Published
//  Description: Instructs the clock that a new frame has just begun.
//               In normal, real-time mode, get_frame_time() will
//               henceforth report the time as of this instant as the
//               current start-of-frame time.  In non-real-time mode,
//               get_frame_time() will be incremented by the value of
//               dt.
////////////////////////////////////////////////////////////////////
72
void ClockObject::tick(Thread *current_thread = (get_current_thread()));

1406 15 sync_frame_time 0 4 1815 28 ClockObject::sync_frame_time 0 1 529 756
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::sync_frame_time
//       Access: Published
//  Description: Resets the frame time to the current real time.  This
//               is similar to tick(), except that it does not advance
//               the frame counter and does not affect dt.  This is
//               intended to be used in the middle of a particularly
//               long frame to compensate for the time that has
//               already elapsed.
//
//               In non-real-time mode, this function has no effect
//               (because in this mode all frames take the same length
//               of time).
////////////////////////////////////////////////////////////////////
83
void ClockObject::sync_frame_time(Thread *current_thread = (get_current_thread()));

1407 12 check_errors 0 4 1815 25 ClockObject::check_errors 0 1 530 609
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::check_errors
//       Access: Published
//  Description: Returns true if a clock error was detected since the
//               last time check_errors() was called.  A clock error
//               means that something happened, an OS or BIOS bug, for
//               instance, that makes the current value of the clock
//               somewhat suspect, and an application may wish to
//               resynchronize with any external clocks.
////////////////////////////////////////////////////////////////////
62
inline bool ClockObject::check_errors(Thread *current_thread);

1408 16 get_global_clock 0 4 1815 29 ClockObject::get_global_clock 0 1 531 408
////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_global_clock
//       Access: Published
//  Description: Returns a pointer to the global ClockObject.  This is
//               the ClockObject that most code should use for
//               handling scene graph rendering and animation.
////////////////////////////////////////////////////////////////////
63
static inline ClockObject *ClockObject::get_global_clock(void);

1409 14 get_class_type 0 4 1815 27 ClockObject::get_class_type 0 1 532 0
52
static TypeHandle ClockObject::get_class_type(void);

1410 24 parse_color_space_string 0 1 0 24 parse_color_space_string 0 1 881 0
55
ColorSpace parse_color_space_string(string const &str);

1411 18 format_color_space 0 1 0 18 format_color_space 0 1 882 0
41
string format_color_space(ColorSpace cs);

1412 14 get_model_path 0 1 0 14 get_model_path 0 1 883 0
47
ConfigVariableSearchPath &get_model_path(void);

1413 15 get_plugin_path 0 1 0 15 get_plugin_path 0 1 884 0
48
ConfigVariableSearchPath &get_plugin_path(void);

1414 9 cache_ref 0 4 1819 28 CopyOnWriteObject::cache_ref 0 1 533 279
////////////////////////////////////////////////////////////////////
//     Function: CopyOnWriteObject::cache_ref
//       Access: Published
//  Description: See CachedTypedWritableReferenceCount::cache_ref().
////////////////////////////////////////////////////////////////////
53
inline void CopyOnWriteObject::cache_ref(void) const;

1415 14 get_class_type 0 4 1819 33 CopyOnWriteObject::get_class_type 0 1 534 0
58
static TypeHandle CopyOnWriteObject::get_class_type(void);

1416 18 ~CopyOnWriteObject 0 4 1819 37 CopyOnWriteObject::~CopyOnWriteObject 0 0 0
44
CopyOnWriteObject::~CopyOnWriteObject(void);

1417 17 DatagramInputFile 0 4 1820 36 DatagramInputFile::DatagramInputFile 0 1 535 229
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
50
inline DatagramInputFile::DatagramInputFile(void);

1418 4 open 0 4 1820 23 DatagramInputFile::open 0 3 536 537 538 1158
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Opens the indicated filename for reading.  Returns
//               true on success, false on failure.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Opens the indicated filename for reading.  Returns
//               true on success, false on failure.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Starts reading from the indicated stream.  Returns
//               true on success, false on failure.  The
//               DatagramInputFile does not take ownership of the
//               stream; you are responsible for closing or deleting
//               it when you are done.
////////////////////////////////////////////////////////////////////
201
bool DatagramInputFile::open(FileReference const *file);
inline bool DatagramInputFile::open(Filename const &filename);
bool DatagramInputFile::open(istream &in, Filename const &filename = Filename());

1419 10 get_stream 0 4 1820 29 DatagramInputFile::get_stream 0 1 539 279
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::get_stream
//       Access: Published
//  Description: Returns the istream represented by the input file.
////////////////////////////////////////////////////////////////////
52
inline istream &DatagramInputFile::get_stream(void);

1420 5 close 0 4 1820 24 DatagramInputFile::close 0 1 540 325
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::close
//       Access: Published
//  Description: Closes the file.  This is also implicitly done when
//               the DatagramInputFile destructs.
////////////////////////////////////////////////////////////////////
36
void DatagramInputFile::close(void);

1421 11 read_header 0 4 1820 30 DatagramInputFile::read_header 0 1 541 535
////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::read_header
//       Access: Published
//  Description: Reads a sequence of bytes from the beginning of the
//               datagram file.  This may be called any number of
//               times after the file has been opened and before the
//               first datagram is read.  It may not be called once
//               the first datagram has been read.
////////////////////////////////////////////////////////////////////
70
bool DatagramInputFile::read_header(string &header, size_t num_bytes);

1422 13 DoubleBitMask 0 4 1822 45 DoubleBitMask< BitMaskNative >::DoubleBitMask 0 2 542 543 0
157
inline DoubleBitMask< BitMaskNative >::DoubleBitMask(void);
inline DoubleBitMask< BitMaskNative >::DoubleBitMask(DoubleBitMask< BitMaskNative > const &copy);

1423 10 operator = 0 4 1822 42 DoubleBitMask< BitMaskNative >::operator = 0 1 544 0
126
inline DoubleBitMask< BitMaskNative > &DoubleBitMask< BitMaskNative >::operator =(DoubleBitMask< BitMaskNative > const &copy);

1424 6 all_on 0 4 1822 38 DoubleBitMask< BitMaskNative >::all_on 0 1 545 0
90
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_on(void);

1425 7 all_off 0 4 1822 39 DoubleBitMask< BitMaskNative >::all_off 0 1 546 0
91
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_off(void);

1426 8 lower_on 0 4 1822 40 DoubleBitMask< BitMaskNative >::lower_on 0 1 547 0
99
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::lower_on(int on_bits);

1427 3 bit 0 4 1822 35 DoubleBitMask< BitMaskNative >::bit 0 1 548 0
92
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::bit(int index);

1428 5 range 0 4 1822 37 DoubleBitMask< BitMaskNative >::range 0 1 549 0
106
static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::range(int low_bit, int size);

1429 14 ~DoubleBitMask 0 4 1822 46 DoubleBitMask< BitMaskNative >::~DoubleBitMask 0 0 0
60
inline DoubleBitMask< BitMaskNative >::~DoubleBitMask(void);

1430 16 has_max_num_bits 0 4 1822 48 DoubleBitMask< BitMaskNative >::has_max_num_bits 0 1 550 0
67
static bool DoubleBitMask< BitMaskNative >::has_max_num_bits(void);

1431 16 get_max_num_bits 0 4 1822 48 DoubleBitMask< BitMaskNative >::get_max_num_bits 0 1 551 0
66
static int DoubleBitMask< BitMaskNative >::get_max_num_bits(void);

1432 12 get_num_bits 0 4 1822 44 DoubleBitMask< BitMaskNative >::get_num_bits 0 1 552 0
62
static int DoubleBitMask< BitMaskNative >::get_num_bits(void);

1433 7 get_bit 0 4 1822 39 DoubleBitMask< BitMaskNative >::get_bit 0 1 553 0
69
inline bool DoubleBitMask< BitMaskNative >::get_bit(int index) const;

1434 7 set_bit 0 4 1822 39 DoubleBitMask< BitMaskNative >::set_bit 0 1 554 0
63
inline void DoubleBitMask< BitMaskNative >::set_bit(int index);

1435 9 clear_bit 0 4 1822 41 DoubleBitMask< BitMaskNative >::clear_bit 0 1 555 0
65
inline void DoubleBitMask< BitMaskNative >::clear_bit(int index);

1436 10 set_bit_to 0 4 1822 42 DoubleBitMask< BitMaskNative >::set_bit_to 0 1 556 0
78
inline void DoubleBitMask< BitMaskNative >::set_bit_to(int index, bool value);

1437 7 is_zero 0 4 1822 39 DoubleBitMask< BitMaskNative >::is_zero 0 1 557 0
64
inline bool DoubleBitMask< BitMaskNative >::is_zero(void) const;

1438 9 is_all_on 0 4 1822 41 DoubleBitMask< BitMaskNative >::is_all_on 0 1 558 0
66
inline bool DoubleBitMask< BitMaskNative >::is_all_on(void) const;

1439 7 extract 0 4 1822 39 DoubleBitMask< BitMaskNative >::extract 0 1 559 0
86
inline PN_uint32 DoubleBitMask< BitMaskNative >::extract(int low_bit, int size) const;

1440 5 store 0 4 1822 37 DoubleBitMask< BitMaskNative >::store 0 1 560 0
90
inline void DoubleBitMask< BitMaskNative >::store(PN_uint32 value, int low_bit, int size);

1441 10 has_any_of 0 4 1822 42 DoubleBitMask< BitMaskNative >::has_any_of 0 1 561 0
84
inline bool DoubleBitMask< BitMaskNative >::has_any_of(int low_bit, int size) const;

1442 10 has_all_of 0 4 1822 42 DoubleBitMask< BitMaskNative >::has_all_of 0 1 562 0
84
inline bool DoubleBitMask< BitMaskNative >::has_all_of(int low_bit, int size) const;

1443 9 set_range 0 4 1822 41 DoubleBitMask< BitMaskNative >::set_range 0 1 563 0
77
inline void DoubleBitMask< BitMaskNative >::set_range(int low_bit, int size);

1444 11 clear_range 0 4 1822 43 DoubleBitMask< BitMaskNative >::clear_range 0 1 564 0
79
inline void DoubleBitMask< BitMaskNative >::clear_range(int low_bit, int size);

1445 12 set_range_to 0 4 1822 44 DoubleBitMask< BitMaskNative >::set_range_to 0 1 565 0
92
inline void DoubleBitMask< BitMaskNative >::set_range_to(bool value, int low_bit, int size);

1446 15 get_num_on_bits 0 4 1822 47 DoubleBitMask< BitMaskNative >::get_num_on_bits 0 1 566 0
71
inline int DoubleBitMask< BitMaskNative >::get_num_on_bits(void) const;

1447 16 get_num_off_bits 0 4 1822 48 DoubleBitMask< BitMaskNative >::get_num_off_bits 0 1 567 0
72
inline int DoubleBitMask< BitMaskNative >::get_num_off_bits(void) const;

1448 17 get_lowest_on_bit 0 4 1822 49 DoubleBitMask< BitMaskNative >::get_lowest_on_bit 0 1 568 0
73
inline int DoubleBitMask< BitMaskNative >::get_lowest_on_bit(void) const;

1449 18 get_lowest_off_bit 0 4 1822 50 DoubleBitMask< BitMaskNative >::get_lowest_off_bit 0 1 569 0
74
inline int DoubleBitMask< BitMaskNative >::get_lowest_off_bit(void) const;

1450 18 get_highest_on_bit 0 4 1822 50 DoubleBitMask< BitMaskNative >::get_highest_on_bit 0 1 570 0
74
inline int DoubleBitMask< BitMaskNative >::get_highest_on_bit(void) const;

1451 19 get_highest_off_bit 0 4 1822 51 DoubleBitMask< BitMaskNative >::get_highest_off_bit 0 1 571 0
75
inline int DoubleBitMask< BitMaskNative >::get_highest_off_bit(void) const;

1452 29 get_next_higher_different_bit 0 4 1822 61 DoubleBitMask< BitMaskNative >::get_next_higher_different_bit 0 1 572 0
92
inline int DoubleBitMask< BitMaskNative >::get_next_higher_different_bit(int low_bit) const;

1453 15 invert_in_place 0 4 1822 47 DoubleBitMask< BitMaskNative >::invert_in_place 0 1 573 0
66
inline void DoubleBitMask< BitMaskNative >::invert_in_place(void);

1454 18 has_bits_in_common 0 4 1822 50 DoubleBitMask< BitMaskNative >::has_bits_in_common 0 1 574 0
114
inline bool DoubleBitMask< BitMaskNative >::has_bits_in_common(DoubleBitMask< BitMaskNative > const &other) const;

1455 5 clear 0 4 1822 37 DoubleBitMask< BitMaskNative >::clear 0 1 575 0
56
inline void DoubleBitMask< BitMaskNative >::clear(void);

1456 6 output 0 4 1822 38 DoubleBitMask< BitMaskNative >::output 0 1 576 0
64
void DoubleBitMask< BitMaskNative >::output(ostream &out) const;

1457 13 output_binary 0 4 1822 45 DoubleBitMask< BitMaskNative >::output_binary 0 1 577 0
93
void DoubleBitMask< BitMaskNative >::output_binary(ostream &out, int spaces_every = 4) const;

1458 10 output_hex 0 4 1822 42 DoubleBitMask< BitMaskNative >::output_hex 0 1 578 0
90
void DoubleBitMask< BitMaskNative >::output_hex(ostream &out, int spaces_every = 4) const;

1459 5 write 0 4 1822 37 DoubleBitMask< BitMaskNative >::write 0 1 579 0
85
void DoubleBitMask< BitMaskNative >::write(ostream &out, int indent_level = 0) const;

1460 11 operator == 0 4 1822 43 DoubleBitMask< BitMaskNative >::operator == 0 1 580 0
107
inline bool DoubleBitMask< BitMaskNative >::operator ==(DoubleBitMask< BitMaskNative > const &other) const;

1461 11 operator != 0 4 1822 43 DoubleBitMask< BitMaskNative >::operator != 0 1 581 0
107
inline bool DoubleBitMask< BitMaskNative >::operator !=(DoubleBitMask< BitMaskNative > const &other) const;

1462 10 operator < 0 4 1822 42 DoubleBitMask< BitMaskNative >::operator < 0 1 582 0
106
inline bool DoubleBitMask< BitMaskNative >::operator <(DoubleBitMask< BitMaskNative > const &other) const;

1463 10 compare_to 0 4 1822 42 DoubleBitMask< BitMaskNative >::compare_to 0 1 583 0
105
inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const;

1464 10 operator & 0 4 1822 42 DoubleBitMask< BitMaskNative >::operator & 0 1 584 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator &(DoubleBitMask< BitMaskNative > const &other) const;

1465 10 operator | 0 4 1822 42 DoubleBitMask< BitMaskNative >::operator | 0 1 585 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator |(DoubleBitMask< BitMaskNative > const &other) const;

1466 10 operator ^ 0 4 1822 42 DoubleBitMask< BitMaskNative >::operator ^ 0 1 586 0
132
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ^(DoubleBitMask< BitMaskNative > const &other) const;

1467 10 operator ~ 0 68 1822 42 DoubleBitMask< BitMaskNative >::operator ~ 0 1 587 0
93
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ~(void) const;

1468 11 operator << 0 4 1822 43 DoubleBitMask< BitMaskNative >::operator << 0 1 588 0
99
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator <<(int shift) const;

1469 11 operator >> 0 4 1822 43 DoubleBitMask< BitMaskNative >::operator >> 0 1 589 0
99
inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator >>(int shift) const;

1470 11 operator &= 0 4 1822 43 DoubleBitMask< BitMaskNative >::operator &= 0 1 590 0
101
inline void DoubleBitMask< BitMaskNative >::operator &=(DoubleBitMask< BitMaskNative > const &other);

1471 11 operator |= 0 4 1822 43 DoubleBitMask< BitMaskNative >::operator |= 0 1 591 0
101
inline void DoubleBitMask< BitMaskNative >::operator |=(DoubleBitMask< BitMaskNative > const &other);

1472 11 operator ^= 0 4 1822 43 DoubleBitMask< BitMaskNative >::operator ^= 0 1 592 0
101
inline void DoubleBitMask< BitMaskNative >::operator ^=(DoubleBitMask< BitMaskNative > const &other);

1473 12 operator <<= 0 4 1822 44 DoubleBitMask< BitMaskNative >::operator <<= 0 1 593 0
68
inline void DoubleBitMask< BitMaskNative >::operator <<=(int shift);

1474 12 operator >>= 0 4 1822 44 DoubleBitMask< BitMaskNative >::operator >>= 0 1 594 0
68
inline void DoubleBitMask< BitMaskNative >::operator >>=(int shift);

1475 14 get_class_type 0 4 1822 46 DoubleBitMask< BitMaskNative >::get_class_type 0 1 595 0
71
static TypeHandle DoubleBitMask< BitMaskNative >::get_class_type(void);

1476 13 DoubleBitMask 0 4 1824 51 DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask 0 2 596 597 0
175
inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(void);
inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(DoubleBitMask< DoubleBitMaskNative > const &copy);

1477 10 operator = 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::operator = 0 1 598 0
144
inline DoubleBitMask< DoubleBitMaskNative > &DoubleBitMask< DoubleBitMaskNative >::operator =(DoubleBitMask< DoubleBitMaskNative > const &copy);

1478 6 all_on 0 4 1824 44 DoubleBitMask< DoubleBitMaskNative >::all_on 0 1 599 0
102
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_on(void);

1479 7 all_off 0 4 1824 45 DoubleBitMask< DoubleBitMaskNative >::all_off 0 1 600 0
103
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_off(void);

1480 8 lower_on 0 4 1824 46 DoubleBitMask< DoubleBitMaskNative >::lower_on 0 1 601 0
111
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::lower_on(int on_bits);

1481 3 bit 0 4 1824 41 DoubleBitMask< DoubleBitMaskNative >::bit 0 1 602 0
104
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::bit(int index);

1482 5 range 0 4 1824 43 DoubleBitMask< DoubleBitMaskNative >::range 0 1 603 0
118
static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::range(int low_bit, int size);

1483 14 ~DoubleBitMask 0 4 1824 52 DoubleBitMask< DoubleBitMaskNative >::~DoubleBitMask 0 0 0
66
inline DoubleBitMask< DoubleBitMaskNative >::~DoubleBitMask(void);

1484 16 has_max_num_bits 0 4 1824 54 DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits 0 1 604 0
73
static bool DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits(void);

1485 16 get_max_num_bits 0 4 1824 54 DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits 0 1 605 0
72
static int DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits(void);

1486 12 get_num_bits 0 4 1824 50 DoubleBitMask< DoubleBitMaskNative >::get_num_bits 0 1 606 0
68
static int DoubleBitMask< DoubleBitMaskNative >::get_num_bits(void);

1487 7 get_bit 0 4 1824 45 DoubleBitMask< DoubleBitMaskNative >::get_bit 0 1 607 0
75
inline bool DoubleBitMask< DoubleBitMaskNative >::get_bit(int index) const;

1488 7 set_bit 0 4 1824 45 DoubleBitMask< DoubleBitMaskNative >::set_bit 0 1 608 0
69
inline void DoubleBitMask< DoubleBitMaskNative >::set_bit(int index);

1489 9 clear_bit 0 4 1824 47 DoubleBitMask< DoubleBitMaskNative >::clear_bit 0 1 609 0
71
inline void DoubleBitMask< DoubleBitMaskNative >::clear_bit(int index);

1490 10 set_bit_to 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::set_bit_to 0 1 610 0
84
inline void DoubleBitMask< DoubleBitMaskNative >::set_bit_to(int index, bool value);

1491 7 is_zero 0 4 1824 45 DoubleBitMask< DoubleBitMaskNative >::is_zero 0 1 611 0
70
inline bool DoubleBitMask< DoubleBitMaskNative >::is_zero(void) const;

1492 9 is_all_on 0 4 1824 47 DoubleBitMask< DoubleBitMaskNative >::is_all_on 0 1 612 0
72
inline bool DoubleBitMask< DoubleBitMaskNative >::is_all_on(void) const;

1493 7 extract 0 4 1824 45 DoubleBitMask< DoubleBitMaskNative >::extract 0 1 613 0
92
inline PN_uint32 DoubleBitMask< DoubleBitMaskNative >::extract(int low_bit, int size) const;

1494 5 store 0 4 1824 43 DoubleBitMask< DoubleBitMaskNative >::store 0 1 614 0
96
inline void DoubleBitMask< DoubleBitMaskNative >::store(PN_uint32 value, int low_bit, int size);

1495 10 has_any_of 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::has_any_of 0 1 615 0
90
inline bool DoubleBitMask< DoubleBitMaskNative >::has_any_of(int low_bit, int size) const;

1496 10 has_all_of 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::has_all_of 0 1 616 0
90
inline bool DoubleBitMask< DoubleBitMaskNative >::has_all_of(int low_bit, int size) const;

1497 9 set_range 0 4 1824 47 DoubleBitMask< DoubleBitMaskNative >::set_range 0 1 617 0
83
inline void DoubleBitMask< DoubleBitMaskNative >::set_range(int low_bit, int size);

1498 11 clear_range 0 4 1824 49 DoubleBitMask< DoubleBitMaskNative >::clear_range 0 1 618 0
85
inline void DoubleBitMask< DoubleBitMaskNative >::clear_range(int low_bit, int size);

1499 12 set_range_to 0 4 1824 50 DoubleBitMask< DoubleBitMaskNative >::set_range_to 0 1 619 0
98
inline void DoubleBitMask< DoubleBitMaskNative >::set_range_to(bool value, int low_bit, int size);

1500 15 get_num_on_bits 0 4 1824 53 DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits 0 1 620 0
77
inline int DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits(void) const;

1501 16 get_num_off_bits 0 4 1824 54 DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits 0 1 621 0
78
inline int DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits(void) const;

1502 17 get_lowest_on_bit 0 4 1824 55 DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit 0 1 622 0
79
inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit(void) const;

1503 18 get_lowest_off_bit 0 4 1824 56 DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit 0 1 623 0
80
inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit(void) const;

1504 18 get_highest_on_bit 0 4 1824 56 DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit 0 1 624 0
80
inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit(void) const;

1505 19 get_highest_off_bit 0 4 1824 57 DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit 0 1 625 0
81
inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit(void) const;

1506 29 get_next_higher_different_bit 0 4 1824 67 DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit 0 1 626 0
98
inline int DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit(int low_bit) const;

1507 15 invert_in_place 0 4 1824 53 DoubleBitMask< DoubleBitMaskNative >::invert_in_place 0 1 627 0
72
inline void DoubleBitMask< DoubleBitMaskNative >::invert_in_place(void);

1508 18 has_bits_in_common 0 4 1824 56 DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common 0 1 628 0
126
inline bool DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1509 5 clear 0 4 1824 43 DoubleBitMask< DoubleBitMaskNative >::clear 0 1 629 0
62
inline void DoubleBitMask< DoubleBitMaskNative >::clear(void);

1510 6 output 0 4 1824 44 DoubleBitMask< DoubleBitMaskNative >::output 0 1 630 0
70
void DoubleBitMask< DoubleBitMaskNative >::output(ostream &out) const;

1511 13 output_binary 0 4 1824 51 DoubleBitMask< DoubleBitMaskNative >::output_binary 0 1 631 0
99
void DoubleBitMask< DoubleBitMaskNative >::output_binary(ostream &out, int spaces_every = 4) const;

1512 10 output_hex 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::output_hex 0 1 632 0
96
void DoubleBitMask< DoubleBitMaskNative >::output_hex(ostream &out, int spaces_every = 4) const;

1513 5 write 0 4 1824 43 DoubleBitMask< DoubleBitMaskNative >::write 0 1 633 0
91
void DoubleBitMask< DoubleBitMaskNative >::write(ostream &out, int indent_level = 0) const;

1514 11 operator == 0 4 1824 49 DoubleBitMask< DoubleBitMaskNative >::operator == 0 1 634 0
119
inline bool DoubleBitMask< DoubleBitMaskNative >::operator ==(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1515 11 operator != 0 4 1824 49 DoubleBitMask< DoubleBitMaskNative >::operator != 0 1 635 0
119
inline bool DoubleBitMask< DoubleBitMaskNative >::operator !=(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1516 10 operator < 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::operator < 0 1 636 0
118
inline bool DoubleBitMask< DoubleBitMaskNative >::operator <(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1517 10 compare_to 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::compare_to 0 1 637 0
117
inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1518 10 operator & 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::operator & 0 1 638 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator &(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1519 10 operator | 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::operator | 0 1 639 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator |(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1520 10 operator ^ 0 4 1824 48 DoubleBitMask< DoubleBitMaskNative >::operator ^ 0 1 640 0
150
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ^(DoubleBitMask< DoubleBitMaskNative > const &other) const;

1521 10 operator ~ 0 68 1824 48 DoubleBitMask< DoubleBitMaskNative >::operator ~ 0 1 641 0
105
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ~(void) const;

1522 11 operator << 0 4 1824 49 DoubleBitMask< DoubleBitMaskNative >::operator << 0 1 642 0
111
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator <<(int shift) const;

1523 11 operator >> 0 4 1824 49 DoubleBitMask< DoubleBitMaskNative >::operator >> 0 1 643 0
111
inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator >>(int shift) const;

1524 11 operator &= 0 4 1824 49 DoubleBitMask< DoubleBitMaskNative >::operator &= 0 1 644 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator &=(DoubleBitMask< DoubleBitMaskNative > const &other);

1525 11 operator |= 0 4 1824 49 DoubleBitMask< DoubleBitMaskNative >::operator |= 0 1 645 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator |=(DoubleBitMask< DoubleBitMaskNative > const &other);

1526 11 operator ^= 0 4 1824 49 DoubleBitMask< DoubleBitMaskNative >::operator ^= 0 1 646 0
113
inline void DoubleBitMask< DoubleBitMaskNative >::operator ^=(DoubleBitMask< DoubleBitMaskNative > const &other);

1527 12 operator <<= 0 4 1824 50 DoubleBitMask< DoubleBitMaskNative >::operator <<= 0 1 647 0
74
inline void DoubleBitMask< DoubleBitMaskNative >::operator <<=(int shift);

1528 12 operator >>= 0 4 1824 50 DoubleBitMask< DoubleBitMaskNative >::operator >>= 0 1 648 0
74
inline void DoubleBitMask< DoubleBitMaskNative >::operator >>=(int shift);

1529 14 get_class_type 0 4 1824 52 DoubleBitMask< DoubleBitMaskNative >::get_class_type 0 1 649 0
77
static TypeHandle DoubleBitMask< DoubleBitMaskNative >::get_class_type(void);

1530 9 ascii_key 0 4 1827 25 KeyboardButton::ascii_key 0 1 650 394
////////////////////////////////////////////////////////////////////
//     Function: KeyboardButton::ascii_key
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               particular ASCII character, if there is one, or
//               ButtonHandle::none() if there is not.
////////////////////////////////////////////////////////////////////
69
static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent);

1531 5 space 0 4 1827 21 KeyboardButton::space 0 1 651 0
48
static ButtonHandle KeyboardButton::space(void);

1532 9 backspace 0 4 1827 25 KeyboardButton::backspace 0 1 652 0
52
static ButtonHandle KeyboardButton::backspace(void);

1533 3 tab 0 4 1827 19 KeyboardButton::tab 0 1 653 0
46
static ButtonHandle KeyboardButton::tab(void);

1534 5 enter 0 4 1827 21 KeyboardButton::enter 0 1 654 0
48
static ButtonHandle KeyboardButton::enter(void);

1535 6 escape 0 4 1827 22 KeyboardButton::escape 0 1 655 0
49
static ButtonHandle KeyboardButton::escape(void);

1536 2 f1 0 4 1827 18 KeyboardButton::f1 0 1 656 0
45
static ButtonHandle KeyboardButton::f1(void);

1537 2 f2 0 4 1827 18 KeyboardButton::f2 0 1 657 0
45
static ButtonHandle KeyboardButton::f2(void);

1538 2 f3 0 4 1827 18 KeyboardButton::f3 0 1 658 0
45
static ButtonHandle KeyboardButton::f3(void);

1539 2 f4 0 4 1827 18 KeyboardButton::f4 0 1 659 0
45
static ButtonHandle KeyboardButton::f4(void);

1540 2 f5 0 4 1827 18 KeyboardButton::f5 0 1 660 0
45
static ButtonHandle KeyboardButton::f5(void);

1541 2 f6 0 4 1827 18 KeyboardButton::f6 0 1 661 0
45
static ButtonHandle KeyboardButton::f6(void);

1542 2 f7 0 4 1827 18 KeyboardButton::f7 0 1 662 0
45
static ButtonHandle KeyboardButton::f7(void);

1543 2 f8 0 4 1827 18 KeyboardButton::f8 0 1 663 0
45
static ButtonHandle KeyboardButton::f8(void);

1544 2 f9 0 4 1827 18 KeyboardButton::f9 0 1 664 0
45
static ButtonHandle KeyboardButton::f9(void);

1545 3 f10 0 4 1827 19 KeyboardButton::f10 0 1 665 0
46
static ButtonHandle KeyboardButton::f10(void);

1546 3 f11 0 4 1827 19 KeyboardButton::f11 0 1 666 0
46
static ButtonHandle KeyboardButton::f11(void);

1547 3 f12 0 4 1827 19 KeyboardButton::f12 0 1 667 0
46
static ButtonHandle KeyboardButton::f12(void);

1548 3 f13 0 4 1827 19 KeyboardButton::f13 0 1 668 59
// PC keyboards don't have these four buttons, but Macs do.
46
static ButtonHandle KeyboardButton::f13(void);

1549 3 f14 0 4 1827 19 KeyboardButton::f14 0 1 669 0
46
static ButtonHandle KeyboardButton::f14(void);

1550 3 f15 0 4 1827 19 KeyboardButton::f15 0 1 670 0
46
static ButtonHandle KeyboardButton::f15(void);

1551 3 f16 0 4 1827 19 KeyboardButton::f16 0 1 671 0
46
static ButtonHandle KeyboardButton::f16(void);

1552 4 left 0 4 1827 20 KeyboardButton::left 0 1 672 0
47
static ButtonHandle KeyboardButton::left(void);

1553 5 right 0 4 1827 21 KeyboardButton::right 0 1 673 0
48
static ButtonHandle KeyboardButton::right(void);

1554 2 up 0 4 1827 18 KeyboardButton::up 0 1 674 0
45
static ButtonHandle KeyboardButton::up(void);

1555 4 down 0 4 1827 20 KeyboardButton::down 0 1 675 0
47
static ButtonHandle KeyboardButton::down(void);

1556 7 page_up 0 4 1827 23 KeyboardButton::page_up 0 1 676 0
50
static ButtonHandle KeyboardButton::page_up(void);

1557 9 page_down 0 4 1827 25 KeyboardButton::page_down 0 1 677 0
52
static ButtonHandle KeyboardButton::page_down(void);

1558 4 home 0 4 1827 20 KeyboardButton::home 0 1 678 0
47
static ButtonHandle KeyboardButton::home(void);

1559 3 end 0 4 1827 19 KeyboardButton::end 0 1 679 0
46
static ButtonHandle KeyboardButton::end(void);

1560 6 insert 0 4 1827 22 KeyboardButton::insert 0 1 680 0
49
static ButtonHandle KeyboardButton::insert(void);

1561 3 del 0 4 1827 19 KeyboardButton::del 0 1 681 27
// delete is a C++ keyword.
46
static ButtonHandle KeyboardButton::del(void);

1562 4 help 0 4 1827 20 KeyboardButton::help 0 1 682 27
// delete is a C++ keyword.
47
static ButtonHandle KeyboardButton::help(void);

1563 4 menu 0 4 1827 20 KeyboardButton::menu 0 1 683 0
47
static ButtonHandle KeyboardButton::menu(void);

1564 5 shift 0 4 1827 21 KeyboardButton::shift 0 1 684 0
48
static ButtonHandle KeyboardButton::shift(void);

1565 7 control 0 4 1827 23 KeyboardButton::control 0 1 685 0
50
static ButtonHandle KeyboardButton::control(void);

1566 3 alt 0 4 1827 19 KeyboardButton::alt 0 1 686 0
46
static ButtonHandle KeyboardButton::alt(void);

1567 4 meta 0 4 1827 20 KeyboardButton::meta 0 1 687 0
47
static ButtonHandle KeyboardButton::meta(void);

1568 9 caps_lock 0 4 1827 25 KeyboardButton::caps_lock 0 1 688 0
52
static ButtonHandle KeyboardButton::caps_lock(void);

1569 10 shift_lock 0 4 1827 26 KeyboardButton::shift_lock 0 1 689 0
53
static ButtonHandle KeyboardButton::shift_lock(void);

1570 8 num_lock 0 4 1827 24 KeyboardButton::num_lock 0 1 690 0
51
static ButtonHandle KeyboardButton::num_lock(void);

1571 11 scroll_lock 0 4 1827 27 KeyboardButton::scroll_lock 0 1 691 0
54
static ButtonHandle KeyboardButton::scroll_lock(void);

1572 12 print_screen 0 4 1827 28 KeyboardButton::print_screen 0 1 692 0
55
static ButtonHandle KeyboardButton::print_screen(void);

1573 5 pause 0 4 1827 21 KeyboardButton::pause 0 1 693 0
48
static ButtonHandle KeyboardButton::pause(void);

1574 6 lshift 0 4 1827 22 KeyboardButton::lshift 0 1 694 0
49
static ButtonHandle KeyboardButton::lshift(void);

1575 6 rshift 0 4 1827 22 KeyboardButton::rshift 0 1 695 0
49
static ButtonHandle KeyboardButton::rshift(void);

1576 8 lcontrol 0 4 1827 24 KeyboardButton::lcontrol 0 1 696 0
51
static ButtonHandle KeyboardButton::lcontrol(void);

1577 8 rcontrol 0 4 1827 24 KeyboardButton::rcontrol 0 1 697 0
51
static ButtonHandle KeyboardButton::rcontrol(void);

1578 4 lalt 0 4 1827 20 KeyboardButton::lalt 0 1 698 0
47
static ButtonHandle KeyboardButton::lalt(void);

1579 4 ralt 0 4 1827 20 KeyboardButton::ralt 0 1 699 0
47
static ButtonHandle KeyboardButton::ralt(void);

1580 5 lmeta 0 4 1827 21 KeyboardButton::lmeta 0 1 700 0
48
static ButtonHandle KeyboardButton::lmeta(void);

1581 5 rmeta 0 4 1827 21 KeyboardButton::rmeta 0 1 701 0
48
static ButtonHandle KeyboardButton::rmeta(void);

1582 15 ~KeyboardButton 0 4 1827 31 KeyboardButton::~KeyboardButton 0 0 0
38
KeyboardButton::~KeyboardButton(void);

1583 13 load_prc_file 0 1 0 13 load_prc_file 0 1 885 1916
////////////////////////////////////////////////////////////////////
//     Function: load_prc_file
//  Description: A convenience function for loading explicit prc files
//               from a disk file or from within a multifile (via the
//               virtual file system).  Save the return value and pass
//               it to unload_prc_file() if you ever want to unload
//               this file later.
//
//               The filename is first searched along the default prc
//               search path, and then also along the model path, for
//               convenience.
//
//               This function is defined in putil instead of in dtool
//               with the read of the prc stuff, so that it can take
//               advantage of the virtual file system (which is
//               defined in express), and the model path (which is in
//               putil).
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: load_prc_file
//  Description: A convenience function for loading explicit prc files
//               from a disk file or from within a multifile (via the
//               virtual file system).  Save the return value and pass
//               it to unload_prc_file() if you ever want to unload
//               this file later.
//
//               The filename is first searched along the default prc
//               search path, and then also along the model path, for
//               convenience.
//
//               This function is defined in putil instead of in dtool
//               with the read of the prc stuff, so that it can take
//               advantage of the virtual file system (which is
//               defined in express), and the model path (which is in
//               putil).
////////////////////////////////////////////////////////////////////
52
ConfigPage *load_prc_file(Filename const &filename);

1584 18 load_prc_file_data 0 1 0 18 load_prc_file_data 0 1 886 1362
////////////////////////////////////////////////////////////////////
//     Function: load_prc_file_data
//  Description: Another convenience function to load a prc file from
//               an explicit string, which represents the contents of
//               the prc file.
//
//               The first parameter is an arbitrary name to assign to
//               this in-memory prc file.  Supply a filename if the
//               data was read from a file, or use any other name that
//               is meaningful to you.  The name is only used when the
//               set of loaded prc files is listed.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: load_prc_file_data
//  Description: Another convenience function to load a prc file from
//               an explicit string, which represents the contents of
//               the prc file.
//
//               The first parameter is an arbitrary name to assign to
//               this in-memory prc file.  Supply a filename if the
//               data was read from a file, or use any other name that
//               is meaningful to you.  The name is only used when the
//               set of loaded prc files is listed.
////////////////////////////////////////////////////////////////////
71
ConfigPage *load_prc_file_data(string const &name, string const &data);

1585 15 unload_prc_file 0 1 0 15 unload_prc_file 0 1 887 0
39
bool unload_prc_file(ConfigPage *page);

1586 18 hash_prc_variables 0 1 0 18 hash_prc_variables 0 1 888 0
39
void hash_prc_variables(HashVal &hash);

1587 15 ModifierButtons 0 4 1828 32 ModifierButtons::ModifierButtons 0 2 702 703 461
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
102
ModifierButtons::ModifierButtons(void);
ModifierButtons::ModifierButtons(ModifierButtons const &copy);

1588 16 ~ModifierButtons 0 4 1828 33 ModifierButtons::~ModifierButtons 0 0 226
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
40
ModifierButtons::~ModifierButtons(void);

1589 10 operator = 0 4 1828 27 ModifierButtons::operator = 0 1 704 0
69
inline void ModifierButtons::operator =(ModifierButtons const &copy);

1590 11 operator == 0 4 1828 28 ModifierButtons::operator == 0 1 705 0
77
inline bool ModifierButtons::operator ==(ModifierButtons const &other) const;

1591 11 operator != 0 4 1828 28 ModifierButtons::operator != 0 1 706 0
77
inline bool ModifierButtons::operator !=(ModifierButtons const &other) const;

1592 10 operator < 0 4 1828 27 ModifierButtons::operator < 0 1 707 0
76
inline bool ModifierButtons::operator <(ModifierButtons const &other) const;

1593 10 operator & 0 4 1828 27 ModifierButtons::operator & 0 1 708 0
87
inline ModifierButtons ModifierButtons::operator &(ModifierButtons const &other) const;

1594 10 operator | 0 4 1828 27 ModifierButtons::operator | 0 1 709 0
87
inline ModifierButtons ModifierButtons::operator |(ModifierButtons const &other) const;

1595 11 operator &= 0 4 1828 28 ModifierButtons::operator &= 0 1 710 0
64
void ModifierButtons::operator &=(ModifierButtons const &other);

1596 11 operator |= 0 4 1828 28 ModifierButtons::operator |= 0 1 711 0
64
void ModifierButtons::operator |=(ModifierButtons const &other);

1597 15 set_button_list 0 4 1828 32 ModifierButtons::set_button_list 0 1 712 698
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::set_button_list
//       Access: Published
//  Description: Sets the list of buttons to watch to be the same as
//               that of the other ModifierButtons object.  This makes
//               the lists pointer equivalent (until one or the other
//               is later modified).
//
//               This will preserve the state of any button that was
//               on the original list and is also on the new lists.
//               Any other buttons will get reset to the default state
//               of "up".
////////////////////////////////////////////////////////////////////
68
void ModifierButtons::set_button_list(ModifierButtons const &other);

1598 7 matches 0 4 1828 24 ModifierButtons::matches 0 1 713 504
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::matches
//       Access: Published
//  Description: Returns true if the set of buttons indicated as down
//               by this ModifierButtons object is the same set of
//               buttons indicated as down by the other
//               ModifierButtons object.  The buttons indicated as up
//               are not relevant.
////////////////////////////////////////////////////////////////////
66
bool ModifierButtons::matches(ModifierButtons const &other) const;

1599 10 add_button 0 4 1828 27 ModifierButtons::add_button 0 1 714 523
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::add_button
//       Access: Published
//  Description: Adds the indicated button to the set of buttons that
//               will be monitored for upness and downness.  Returns
//               true if the button was added, false if it was already
//               being monitored or if too many buttons are currently
//               being monitored.
////////////////////////////////////////////////////////////////////
54
bool ModifierButtons::add_button(ButtonHandle button);

1600 10 has_button 0 4 1828 27 ModifierButtons::has_button 0 1 715 339
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::has_button
//       Access: Published
//  Description: Returns true if the indicated button is in the set of
//               buttons being monitored, false otherwise.
////////////////////////////////////////////////////////////////////
60
bool ModifierButtons::has_button(ButtonHandle button) const;

1601 13 remove_button 0 4 1828 30 ModifierButtons::remove_button 0 1 716 623
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::remove_button
//       Access: Published
//  Description: Removes the indicated button from the set of buttons
//               being monitored.  Returns true if the button was
//               removed, false if it was not being monitored in the
//               first place.
//
//               Unlike the other methods, you cannot remove a button
//               by removing its alias; you have to remove exactly the
//               button itself.
////////////////////////////////////////////////////////////////////
57
bool ModifierButtons::remove_button(ButtonHandle button);

1602 15 get_num_buttons 0 4 1828 32 ModifierButtons::get_num_buttons 0 1 717 394
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_num_buttons
//       Access: Published
//  Description: Returns the number of buttons that the
//               ModifierButtons object is monitoring (e.g. the number
//               of buttons passed to add_button()).
////////////////////////////////////////////////////////////////////
56
inline int ModifierButtons::get_num_buttons(void) const;

1603 10 get_button 0 4 1828 27 ModifierButtons::get_button 0 1 718 446
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_button
//       Access: Published
//  Description: Returns the nth button that the ModifierButtons
//               object is monitoring (the nth button passed to
//               add_button()).  This must be in the range 0 <= index
//               < get_num_buttons().
////////////////////////////////////////////////////////////////////
65
inline ButtonHandle ModifierButtons::get_button(int index) const;

1604 11 button_down 0 4 1828 28 ModifierButtons::button_down 0 1 719 597
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::button_down
//       Access: Published
//  Description: Records that a particular button has been pressed.
//               If the given button is one of the buttons that is
//               currently being monitored, this will update the
//               internal state appropriately; otherwise, it will do
//               nothing.  Returns true if the button is one that was
//               monitored, or false otherwise.
////////////////////////////////////////////////////////////////////
55
bool ModifierButtons::button_down(ButtonHandle button);

1605 9 button_up 0 4 1828 26 ModifierButtons::button_up 0 1 720 596
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::button_up
//       Access: Published
//  Description: Records that a particular button has been released.
//               If the given button is one of the buttons that is
//               currently being monitored, this will update the
//               internal state appropriately; otherwise, it will do
//               nothing.  Returns true if the button is one that was
//               monitored, or false otherwise.
////////////////////////////////////////////////////////////////////
53
bool ModifierButtons::button_up(ButtonHandle button);

1606 14 all_buttons_up 0 4 1828 31 ModifierButtons::all_buttons_up 0 1 721 303
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::all_buttons_up
//       Access: Published
//  Description: Marks all monitored buttons as being in the "up"
//               state.
////////////////////////////////////////////////////////////////////
50
inline void ModifierButtons::all_buttons_up(void);

1607 7 is_down 0 4 1828 24 ModifierButtons::is_down 0 2 722 723 735
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_down
//       Access: Published
//  Description: Returns true if the indicated button is known to be
//               down, or false if it is known to be up.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_down
//       Access: Published
//  Description: Returns true if the indicated button is known to be
//               down, or false if it is known to be up or if it is
//               not in the set of buttons being tracked.
////////////////////////////////////////////////////////////////////
112
bool ModifierButtons::is_down(ButtonHandle button) const;
inline bool ModifierButtons::is_down(int index) const;

1608 11 is_any_down 0 4 1828 28 ModifierButtons::is_any_down 0 1 724 340
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_any_down
//       Access: Published
//  Description: Returns true if any of the tracked button are known
//               to be down, or false if all of them are up.
////////////////////////////////////////////////////////////////////
53
inline bool ModifierButtons::is_any_down(void) const;

1609 10 get_prefix 0 4 1828 27 ModifierButtons::get_prefix 0 1 725 397
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_prefix
//       Access: Published
//  Description: Returns a string which can be used to prefix any
//               button name or event name with the unique set of
//               modifier buttons currently being held.
////////////////////////////////////////////////////////////////////
47
string ModifierButtons::get_prefix(void) const;

1610 6 output 0 4 1828 23 ModifierButtons::output 0 1 726 298
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::output
//       Access: Published
//  Description: Writes a one-line summary of the buttons known to be
//               down.
////////////////////////////////////////////////////////////////////
49
void ModifierButtons::output(ostream &out) const;

1611 5 write 0 4 1828 22 ModifierButtons::write 0 1 727 365
////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::write
//       Access: Published
//  Description: Writes a multi-line summary including all of the
//               buttons being monitored and which ones are known to
//               be down.
////////////////////////////////////////////////////////////////////
48
void ModifierButtons::write(ostream &out) const;

1612 6 button 0 4 1829 19 MouseButton::button 0 1 728 424
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::button
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               particular numbered mouse button (zero-based), if
//               there is one, or ButtonHandle::none() if there is
//               not.
////////////////////////////////////////////////////////////////////
59
static ButtonHandle MouseButton::button(int button_number);

1613 3 one 0 4 1829 16 MouseButton::one 0 1 729 302
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::one
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               first mouse button.
////////////////////////////////////////////////////////////////////
43
static ButtonHandle MouseButton::one(void);

1614 3 two 0 4 1829 16 MouseButton::two 0 1 730 303
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::two
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               second mouse button.
////////////////////////////////////////////////////////////////////
43
static ButtonHandle MouseButton::two(void);

1615 5 three 0 4 1829 18 MouseButton::three 0 1 731 304
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::three
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               third mouse button.
////////////////////////////////////////////////////////////////////
45
static ButtonHandle MouseButton::three(void);

1616 4 four 0 4 1829 17 MouseButton::four 0 1 732 304
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::four
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               fourth mouse button.
////////////////////////////////////////////////////////////////////
44
static ButtonHandle MouseButton::four(void);

1617 4 five 0 4 1829 17 MouseButton::five 0 1 733 303
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::five
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               fifth mouse button.
////////////////////////////////////////////////////////////////////
44
static ButtonHandle MouseButton::five(void);

1618 8 wheel_up 0 4 1829 21 MouseButton::wheel_up 0 1 734 327
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_up
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               wheel is rolled one notch upwards.
////////////////////////////////////////////////////////////////////
48
static ButtonHandle MouseButton::wheel_up(void);

1619 10 wheel_down 0 4 1829 23 MouseButton::wheel_down 0 1 735 331
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_down
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               wheel is rolled one notch downwards.
////////////////////////////////////////////////////////////////////
50
static ButtonHandle MouseButton::wheel_down(void);

1620 10 wheel_left 0 4 1829 23 MouseButton::wheel_left 0 1 736 396
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_left
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               is scrolled to the left. Usually, you'll only
//               find the horizontal scroll on laptops.
////////////////////////////////////////////////////////////////////
50
static ButtonHandle MouseButton::wheel_left(void);

1621 11 wheel_right 0 4 1829 24 MouseButton::wheel_right 0 1 737 398
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_right
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               is scrolled to the right. Usually, you'll only
//               find the horizontal scroll on laptops.
////////////////////////////////////////////////////////////////////
51
static ButtonHandle MouseButton::wheel_right(void);

1622 15 is_mouse_button 0 4 1829 28 MouseButton::is_mouse_button 0 1 738 353
////////////////////////////////////////////////////////////////////
//     Function: MouseButton::is_mouse_button
//       Access: Public, Static
//  Description: Returns true if the indicated ButtonHandle is a mouse
//               button, false if it is some other kind of button.
////////////////////////////////////////////////////////////////////
62
static bool MouseButton::is_mouse_button(ButtonHandle button);

1623 12 ~MouseButton 0 4 1829 25 MouseButton::~MouseButton 0 0 0
32
MouseButton::~MouseButton(void);

1624 9 MouseData 0 4 1830 20 MouseData::MouseData 0 2 739 740 449
////////////////////////////////////////////////////////////////////
//     Function: MouseData::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: MouseData::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
86
inline MouseData::MouseData(void);
inline MouseData::MouseData(MouseData const &copy);

1625 10 operator = 0 4 1830 21 MouseData::operator = 0 1 741 0
57
inline void MouseData::operator =(MouseData const &copy);

1626 5 get_x 0 4 1830 16 MouseData::get_x 0 1 742 215
////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_x
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
43
inline double MouseData::get_x(void) const;

1627 5 get_y 0 4 1830 16 MouseData::get_y 0 1 743 215
////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_y
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
43
inline double MouseData::get_y(void) const;

1628 13 get_in_window 0 4 1830 24 MouseData::get_in_window 0 1 744 223
////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_in_window
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
49
inline bool MouseData::get_in_window(void) const;

1629 6 output 0 4 1830 17 MouseData::output 0 1 745 216
////////////////////////////////////////////////////////////////////
//     Function: MouseData::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
43
void MouseData::output(ostream &out) const;

1630 10 ~MouseData 0 4 1830 21 MouseData::~MouseData 0 0 0
28
MouseData::~MouseData(void);

1631 18 get_node_ref_count 0 4 1831 44 NodeCachedReferenceCount::get_node_ref_count 0 1 746 280
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::get_node_ref_count
//       Access: Published
//  Description: Returns the current reference count.
////////////////////////////////////////////////////////////////////
68
inline int NodeCachedReferenceCount::get_node_ref_count(void) const;

1632 8 node_ref 0 4 1831 34 NodeCachedReferenceCount::node_ref 0 1 747 662
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::node_ref
//       Access: Published
//  Description: Explicitly increments the reference count.
//
//               This function is const, even though it changes the
//               object, because generally fiddling with an object's
//               reference count isn't considered part of fiddling
//               with the object.  An object might be const in other
//               ways, but we still need to accurately count the
//               number of references to it.
////////////////////////////////////////////////////////////////////
59
inline void NodeCachedReferenceCount::node_ref(void) const;

1633 10 node_unref 0 4 1831 36 NodeCachedReferenceCount::node_unref 0 1 748 468
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::node_unref
//       Access: Published
//  Description: Explicitly decrements the node reference count and
//               the normal reference count simultaneously.
//
//               The return value is true if the new reference count
//               is nonzero, false if it is zero.
////////////////////////////////////////////////////////////////////
61
inline bool NodeCachedReferenceCount::node_unref(void) const;

1634 24 test_ref_count_integrity 0 4 1831 50 NodeCachedReferenceCount::test_ref_count_integrity 0 1 749 350
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::test_ref_count_integrity
//       Access: Published
//  Description: Does some easy checks to make sure that the reference
//               count isn't completely bogus.
////////////////////////////////////////////////////////////////////
75
inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const;

1635 19 get_referenced_bits 0 4 1831 45 NodeCachedReferenceCount::get_referenced_bits 0 1 750 600
////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::get_referenced_bits
//       Access: Published
//  Description: Returns the union of the values defined in the
//               Referenced enum that represents the various things
//               that appear to be holding a pointer to this object.
//
//               If R_node is included, at least one node is holding a
//               pointer; if R_cache is included, at least one cache
//               element is.
////////////////////////////////////////////////////////////////////
69
inline int NodeCachedReferenceCount::get_referenced_bits(void) const;

1636 14 get_class_type 0 4 1831 40 NodeCachedReferenceCount::get_class_type 0 1 751 0
65
static TypeHandle NodeCachedReferenceCount::get_class_type(void);

1637 11 SparseArray 0 4 1833 24 SparseArray::SparseArray 0 3 752 753 754 694
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Constructor (from BitArray)
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
144
inline SparseArray::SparseArray(void);
inline SparseArray::SparseArray(SparseArray const &copy);
SparseArray::SparseArray(BitArray const &from);

1638 10 operator = 0 4 1833 23 SparseArray::operator = 0 1 755 236
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Copy Assignment Operator
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
69
inline SparseArray &SparseArray::operator =(SparseArray const &copy);

1639 6 all_on 0 4 1833 19 SparseArray::all_on 0 1 756 323
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray with an infinite array of bits,
//               all on.
////////////////////////////////////////////////////////////////////
52
static inline SparseArray SparseArray::all_on(void);

1640 7 all_off 0 4 1833 20 SparseArray::all_off 0 1 757 290
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose bits are all off.
////////////////////////////////////////////////////////////////////
53
static inline SparseArray SparseArray::all_off(void);

1641 8 lower_on 0 4 1833 21 SparseArray::lower_on 0 1 758 301
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named lower_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose lower on_bits bits are on.
////////////////////////////////////////////////////////////////////
61
static inline SparseArray SparseArray::lower_on(int on_bits);

1642 3 bit 0 4 1833 16 SparseArray::bit 0 1 759 295
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named bit constructor
//       Access: Published, Static
//  Description: Returns a SparseArray with only the indicated bit on.
////////////////////////////////////////////////////////////////////
54
static inline SparseArray SparseArray::bit(int index);

1643 5 range 0 4 1833 18 SparseArray::range 0 1 760 329
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named range constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose size bits, beginning at
//               low_bit, are on.
////////////////////////////////////////////////////////////////////
68
static inline SparseArray SparseArray::range(int low_bit, int size);

1644 12 ~SparseArray 0 4 1833 25 SparseArray::~SparseArray 0 0 222
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
39
inline SparseArray::~SparseArray(void);

1645 16 has_max_num_bits 0 4 1833 29 SparseArray::has_max_num_bits 0 1 761 723
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_max_num_bits
//       Access: Published, Static
//  Description: Returns true if there is a maximum number of bits
//               that may be stored in this structure, false
//               otherwise.  If this returns true, the number may be
//               queried in get_max_num_bits().
//
//               This method always returns false.  The SparseArray has
//               no maximum number of bits.  This method is defined so
//               generic programming algorithms can use BitMask or
//               SparseArray interchangeably.
////////////////////////////////////////////////////////////////////
55
static inline bool SparseArray::has_max_num_bits(void);

1646 16 get_max_num_bits 0 4 1833 29 SparseArray::get_max_num_bits 0 1 762 758
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_max_num_bits
//       Access: Published, Static
//  Description: If get_max_num_bits() returned true, this method may
//               be called to return the maximum number of bits that
//               may be stored in this structure.  It is an error to
//               call this if get_max_num_bits() return false.
//
//               It is always an error to call this method.  The
//               SparseArray has no maximum number of bits.  This method
//               is defined so generic programming algorithms can use
//               BitMask or SparseArray interchangeably.
////////////////////////////////////////////////////////////////////
54
static inline int SparseArray::get_max_num_bits(void);

1647 12 get_num_bits 0 4 1833 25 SparseArray::get_num_bits 0 1 763 607
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_bits
//       Access: Published
//  Description: Returns the current number of possibly different bits
//               in this array.  There are actually an infinite number
//               of bits, but every bit higher than this bit will have
//               the same value, either 0 or 1 (see
//               get_highest_bits()).
//
//               This number may grow and/or shrink automatically as
//               needed.
////////////////////////////////////////////////////////////////////
49
inline int SparseArray::get_num_bits(void) const;

1648 7 get_bit 0 4 1833 20 SparseArray::get_bit 0 1 764 445
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_bit
//       Access: Published
//  Description: Returns true if the nth bit is set, false if it is
//               cleared.  It is valid for n to increase beyond
//               get_num_bits(), but the return value get_num_bits()
//               will always be the same.
////////////////////////////////////////////////////////////////////
50
inline bool SparseArray::get_bit(int index) const;

1649 7 set_bit 0 4 1833 20 SparseArray::set_bit 0 1 765 320
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_bit
//       Access: Published
//  Description: Sets the nth bit on.  If n >= get_num_bits(), this
//               automatically extends the array.
////////////////////////////////////////////////////////////////////
44
inline void SparseArray::set_bit(int index);

1650 9 clear_bit 0 4 1833 22 SparseArray::clear_bit 0 1 766 323
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear_bit
//       Access: Published
//  Description: Sets the nth bit off.  If n >= get_num_bits(), this
//               automatically extends the array.
////////////////////////////////////////////////////////////////////
46
inline void SparseArray::clear_bit(int index);

1651 10 set_bit_to 0 4 1833 23 SparseArray::set_bit_to 0 1 767 313
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_bit_to
//       Access: Published
//  Description: Sets the nth bit either on or off, according to the
//               indicated bool value.
////////////////////////////////////////////////////////////////////
59
inline void SparseArray::set_bit_to(int index, bool value);

1652 16 get_highest_bits 0 4 1833 29 SparseArray::get_highest_bits 0 1 768 367
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_bits
//       Access: Published
//  Description: Returns true if the infinite set of bits beyond
//               get_num_bits() are all on, or false of they are all
//               off.
////////////////////////////////////////////////////////////////////
54
inline bool SparseArray::get_highest_bits(void) const;

1653 7 is_zero 0 4 1833 20 SparseArray::is_zero 0 1 769 297
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_zero
//       Access: Published
//  Description: Returns true if the entire bitmask is zero, false
//               otherwise.
////////////////////////////////////////////////////////////////////
45
inline bool SparseArray::is_zero(void) const;

1654 9 is_all_on 0 4 1833 22 SparseArray::is_all_on 0 1 770 298
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_all_on
//       Access: Published
//  Description: Returns true if the entire bitmask is one, false
//               otherwise.
////////////////////////////////////////////////////////////////////
47
inline bool SparseArray::is_all_on(void) const;

1655 10 has_any_of 0 4 1833 23 SparseArray::has_any_of 0 1 771 311
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_any_of
//       Access: Published
//  Description: Returns true if any bit in the indicated range is
//               set, false otherwise.
////////////////////////////////////////////////////////////////////
65
inline bool SparseArray::has_any_of(int low_bit, int size) const;

1656 10 has_all_of 0 4 1833 23 SparseArray::has_all_of 0 1 772 313
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_all_of
//       Access: Published
//  Description: Returns true if all bits in the indicated range are
//               set, false otherwise.
////////////////////////////////////////////////////////////////////
65
inline bool SparseArray::has_all_of(int low_bit, int size) const;

1657 9 set_range 0 4 1833 22 SparseArray::set_range 0 1 773 258
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_range
//       Access: Published
//  Description: Sets the indicated range of bits on.
////////////////////////////////////////////////////////////////////
58
inline void SparseArray::set_range(int low_bit, int size);

1658 11 clear_range 0 4 1833 24 SparseArray::clear_range 0 1 774 261
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear_range
//       Access: Published
//  Description: Sets the indicated range of bits off.
////////////////////////////////////////////////////////////////////
60
inline void SparseArray::clear_range(int low_bit, int size);

1659 12 set_range_to 0 4 1833 25 SparseArray::set_range_to 0 1 775 278
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_range_to
//       Access: Published
//  Description: Sets the indicated range of bits to either on or off.
////////////////////////////////////////////////////////////////////
73
inline void SparseArray::set_range_to(bool value, int low_bit, int size);

1660 15 get_num_on_bits 0 4 1833 28 SparseArray::get_num_on_bits 0 1 776 375
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_on_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 1 in the
//               array.  Returns -1 if there are an infinite number of
//               1 bits.
////////////////////////////////////////////////////////////////////
45
int SparseArray::get_num_on_bits(void) const;

1661 16 get_num_off_bits 0 4 1833 29 SparseArray::get_num_off_bits 0 1 777 376
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_off_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 0 in the
//               array.  Returns -1 if there are an infinite number of
//               0 bits.
////////////////////////////////////////////////////////////////////
46
int SparseArray::get_num_off_bits(void) const;

1662 17 get_lowest_on_bit 0 4 1833 30 SparseArray::get_lowest_on_bit 0 1 778 395
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_lowest_on_bit
//       Access: Published
//  Description: Returns the index of the lowest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there are an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
47
int SparseArray::get_lowest_on_bit(void) const;

1663 18 get_lowest_off_bit 0 4 1833 31 SparseArray::get_lowest_off_bit 0 1 779 396
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_lowest_off_bit
//       Access: Published
//  Description: Returns the index of the lowest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there are an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
48
int SparseArray::get_lowest_off_bit(void) const;

1664 18 get_highest_on_bit 0 4 1833 31 SparseArray::get_highest_on_bit 0 1 780 393
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_on_bit
//       Access: Published
//  Description: Returns the index of the highest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
48
int SparseArray::get_highest_on_bit(void) const;

1665 19 get_highest_off_bit 0 4 1833 32 SparseArray::get_highest_off_bit 0 1 781 394
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_off_bit
//       Access: Published
//  Description: Returns the index of the highest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there an
//               infinite number of 1 bits.
////////////////////////////////////////////////////////////////////
49
int SparseArray::get_highest_off_bit(void) const;

1666 29 get_next_higher_different_bit 0 4 1833 42 SparseArray::get_next_higher_different_bit 0 1 782 594
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_next_higher_different_bit
//       Access: Published
//  Description: Returns the index of the next bit in the array, above
//               low_bit, whose value is different that the value of
//               low_bit.  Returns low_bit again if all bits higher
//               than low_bit have the same value.
//
//               This can be used to quickly iterate through all of
//               the bits in the array.
////////////////////////////////////////////////////////////////////
66
int SparseArray::get_next_higher_different_bit(int low_bit) const;

1667 15 invert_in_place 0 4 1833 28 SparseArray::invert_in_place 0 1 783 324
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::invert_in_place
//       Access: Published
//  Description: Inverts all the bits in the SparseArray.  This is
//               equivalent to array = ~array.
////////////////////////////////////////////////////////////////////
47
inline void SparseArray::invert_in_place(void);

1668 18 has_bits_in_common 0 4 1833 31 SparseArray::has_bits_in_common 0 1 784 446
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_bits_in_common
//       Access: Published
//  Description: Returns true if this SparseArray has any "one" bits in
//               common with the other one, false otherwise.
//
//               This is equivalent to (array & other) != 0, but may
//               be faster.
////////////////////////////////////////////////////////////////////
69
bool SparseArray::has_bits_in_common(SparseArray const &other) const;

1669 5 clear 0 4 1833 18 SparseArray::clear 0 1 785 259
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear
//       Access: Published
//  Description: Sets all the bits in the SparseArray off.
////////////////////////////////////////////////////////////////////
37
inline void SparseArray::clear(void);

1670 6 output 0 4 1833 19 SparseArray::output 0 1 786 219
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
45
void SparseArray::output(ostream &out) const;

1671 11 operator == 0 4 1833 24 SparseArray::operator == 0 1 787 0
69
inline bool SparseArray::operator ==(SparseArray const &other) const;

1672 11 operator != 0 4 1833 24 SparseArray::operator != 0 1 788 0
69
inline bool SparseArray::operator !=(SparseArray const &other) const;

1673 10 operator < 0 4 1833 23 SparseArray::operator < 0 1 789 0
68
inline bool SparseArray::operator <(SparseArray const &other) const;

1674 10 compare_to 0 4 1833 23 SparseArray::compare_to 0 1 790 513
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this SparseArray
//               sorts before the indicated other SparseArray, greater
//               than zero if it sorts after, or 0 if they are
//               equivalent.  This is based on the same ordering
//               defined by operator <.
////////////////////////////////////////////////////////////////////
60
int SparseArray::compare_to(SparseArray const &other) const;

1675 10 operator & 0 4 1833 23 SparseArray::operator & 0 1 791 0
75
inline SparseArray SparseArray::operator &(SparseArray const &other) const;

1676 10 operator | 0 4 1833 23 SparseArray::operator | 0 1 792 0
75
inline SparseArray SparseArray::operator |(SparseArray const &other) const;

1677 10 operator ^ 0 4 1833 23 SparseArray::operator ^ 0 1 793 0
75
inline SparseArray SparseArray::operator ^(SparseArray const &other) const;

1678 10 operator ~ 0 68 1833 23 SparseArray::operator ~ 0 1 794 0
55
inline SparseArray SparseArray::operator ~(void) const;

1679 11 operator << 0 4 1833 24 SparseArray::operator << 0 1 795 0
61
inline SparseArray SparseArray::operator <<(int shift) const;

1680 11 operator >> 0 4 1833 24 SparseArray::operator >> 0 1 796 0
61
inline SparseArray SparseArray::operator >>(int shift) const;

1681 11 operator &= 0 4 1833 24 SparseArray::operator &= 0 1 797 0
56
void SparseArray::operator &=(SparseArray const &other);

1682 11 operator |= 0 4 1833 24 SparseArray::operator |= 0 1 798 0
56
void SparseArray::operator |=(SparseArray const &other);

1683 11 operator ^= 0 4 1833 24 SparseArray::operator ^= 0 1 799 0
56
void SparseArray::operator ^=(SparseArray const &other);

1684 12 operator <<= 0 4 1833 25 SparseArray::operator <<= 0 1 800 0
49
inline void SparseArray::operator <<=(int shift);

1685 12 operator >>= 0 4 1833 25 SparseArray::operator >>= 0 1 801 0
49
inline void SparseArray::operator >>=(int shift);

1686 10 is_inverse 0 4 1833 23 SparseArray::is_inverse 0 1 802 614
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_inverse
//       Access: Published
//  Description: If this is true, the SparseArray is actually defined
//               as a list of subranges of integers that are *not* in
//               the set.  If this is false (the default), then the
//               subranges define the integers that *are* in the set.
//               This affects the interpretation of the values
//               returned by iterating through get_num_subranges().
////////////////////////////////////////////////////////////////////
48
inline bool SparseArray::is_inverse(void) const;

1687 17 get_num_subranges 0 4 1833 30 SparseArray::get_num_subranges 0 1 803 515
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_subranges
//       Access: Published
//  Description: Returns the number of separate subranges stored in
//               the SparseArray.  You can use this limit to iterate
//               through the subranges, calling get_subrange_begin()
//               and get_subrange_end() for each one.
//
//               Also see is_inverse().
////////////////////////////////////////////////////////////////////
54
inline int SparseArray::get_num_subranges(void) const;

1688 18 get_subrange_begin 0 4 1833 31 SparseArray::get_subrange_begin 0 1 804 345
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_subrange_begin
//       Access: Published
//  Description: Returns the first numeric element in the nth
//               subrange.
//
//               Also see is_inverse().
////////////////////////////////////////////////////////////////////
56
inline int SparseArray::get_subrange_begin(int n) const;

1689 16 get_subrange_end 0 4 1833 29 SparseArray::get_subrange_end 0 1 805 353
////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_subrange_end
//       Access: Published
//  Description: Returns the last numeric element, plus one, in the
//               nth subrange.
//
//               Also see is_inverse().
////////////////////////////////////////////////////////////////////
54
inline int SparseArray::get_subrange_end(int n) const;

1690 14 get_class_type 0 4 1833 27 SparseArray::get_class_type 0 1 806 0
52
static TypeHandle SparseArray::get_class_type(void);

1691 14 get_value_type 0 6 1834 30 ParamValueBase::get_value_type 0 1 807 280
////////////////////////////////////////////////////////////////////
//     Function: ParamValueBase::get_value_type
//       Access: Published, Virtual
//  Description: Returns the type of the underlying value.
////////////////////////////////////////////////////////////////////
69
virtual inline TypeHandle ParamValueBase::get_value_type(void) const;

1692 6 output 0 6 1834 22 ParamValueBase::output 0 1 808 0
60
virtual void ParamValueBase::output(ostream &out) const = 0;

1693 14 get_class_type 0 4 1834 30 ParamValueBase::get_class_type 0 1 809 0
55
static TypeHandle ParamValueBase::get_class_type(void);

1694 18 ParamTypedRefCount 0 4 1835 38 ParamTypedRefCount::ParamTypedRefCount 0 1 810 230
////////////////////////////////////////////////////////////////////
//     Function: ParamTypedRefCount::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
80
inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value);

1695 9 get_value 0 4 1835 29 ParamTypedRefCount::get_value 0 1 811 273
////////////////////////////////////////////////////////////////////
//     Function: ParamTypedRefCount::get_value
//       Access: Published
//  Description: Retrieves the value stored in the parameter.
////////////////////////////////////////////////////////////////////
70
inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const;

1696 14 get_class_type 0 4 1835 34 ParamTypedRefCount::get_class_type 0 1 812 0
59
static TypeHandle ParamTypedRefCount::get_class_type(void);

1697 10 ParamValue 0 4 1836 32 ParamValue< string >::ParamValue 0 1 813 0
61
inline ParamValue< string >::ParamValue(string const &value);

1698 9 set_value 0 4 1836 31 ParamValue< string >::set_value 0 1 814 0
65
inline void ParamValue< string >::set_value(string const &value);

1699 9 get_value 0 4 1836 31 ParamValue< string >::get_value 0 1 815 0
65
inline string const &ParamValue< string >::get_value(void) const;

1700 14 get_class_type 0 4 1836 36 ParamValue< string >::get_class_type 0 1 816 0
61
static TypeHandle ParamValue< string >::get_class_type(void);

1701 10 ParamValue 0 4 1838 33 ParamValue< wstring >::ParamValue 0 1 817 0
63
inline ParamValue< wstring >::ParamValue(wstring const &value);

1702 9 set_value 0 4 1838 32 ParamValue< wstring >::set_value 0 1 818 0
67
inline void ParamValue< wstring >::set_value(wstring const &value);

1703 9 get_value 0 4 1838 32 ParamValue< wstring >::get_value 0 1 819 0
67
inline wstring const &ParamValue< wstring >::get_value(void) const;

1704 14 get_class_type 0 4 1838 37 ParamValue< wstring >::get_class_type 0 1 820 0
62
static TypeHandle ParamValue< wstring >::get_class_type(void);

1705 10 ParamValue 0 4 1840 36 ParamValue< LVecBase2d >::ParamValue 0 1 821 0
69
inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value);

1706 9 set_value 0 4 1840 35 ParamValue< LVecBase2d >::set_value 0 1 822 0
73
inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value);

1707 9 get_value 0 4 1840 35 ParamValue< LVecBase2d >::get_value 0 1 823 0
73
inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const;

1708 14 get_class_type 0 4 1840 40 ParamValue< LVecBase2d >::get_class_type 0 1 824 0
65
static TypeHandle ParamValue< LVecBase2d >::get_class_type(void);

1709 10 ParamValue 0 4 1842 36 ParamValue< LVecBase2f >::ParamValue 0 1 825 0
69
inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value);

1710 9 set_value 0 4 1842 35 ParamValue< LVecBase2f >::set_value 0 1 826 0
73
inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value);

1711 9 get_value 0 4 1842 35 ParamValue< LVecBase2f >::get_value 0 1 827 0
73
inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const;

1712 14 get_class_type 0 4 1842 40 ParamValue< LVecBase2f >::get_class_type 0 1 828 0
65
static TypeHandle ParamValue< LVecBase2f >::get_class_type(void);

1713 10 ParamValue 0 4 1844 36 ParamValue< LVecBase2i >::ParamValue 0 1 829 0
69
inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value);

1714 9 set_value 0 4 1844 35 ParamValue< LVecBase2i >::set_value 0 1 830 0
73
inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value);

1715 9 get_value 0 4 1844 35 ParamValue< LVecBase2i >::get_value 0 1 831 0
73
inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const;

1716 14 get_class_type 0 4 1844 40 ParamValue< LVecBase2i >::get_class_type 0 1 832 0
65
static TypeHandle ParamValue< LVecBase2i >::get_class_type(void);

1717 10 ParamValue 0 4 1846 36 ParamValue< LVecBase3d >::ParamValue 0 1 833 0
69
inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value);

1718 9 set_value 0 4 1846 35 ParamValue< LVecBase3d >::set_value 0 1 834 0
73
inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value);

1719 9 get_value 0 4 1846 35 ParamValue< LVecBase3d >::get_value 0 1 835 0
73
inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const;

1720 14 get_class_type 0 4 1846 40 ParamValue< LVecBase3d >::get_class_type 0 1 836 0
65
static TypeHandle ParamValue< LVecBase3d >::get_class_type(void);

1721 10 ParamValue 0 4 1848 36 ParamValue< LVecBase3f >::ParamValue 0 1 837 0
69
inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value);

1722 9 set_value 0 4 1848 35 ParamValue< LVecBase3f >::set_value 0 1 838 0
73
inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value);

1723 9 get_value 0 4 1848 35 ParamValue< LVecBase3f >::get_value 0 1 839 0
73
inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const;

1724 14 get_class_type 0 4 1848 40 ParamValue< LVecBase3f >::get_class_type 0 1 840 0
65
static TypeHandle ParamValue< LVecBase3f >::get_class_type(void);

1725 10 ParamValue 0 4 1850 36 ParamValue< LVecBase3i >::ParamValue 0 1 841 0
69
inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value);

1726 9 set_value 0 4 1850 35 ParamValue< LVecBase3i >::set_value 0 1 842 0
73
inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value);

1727 9 get_value 0 4 1850 35 ParamValue< LVecBase3i >::get_value 0 1 843 0
73
inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const;

1728 14 get_class_type 0 4 1850 40 ParamValue< LVecBase3i >::get_class_type 0 1 844 0
65
static TypeHandle ParamValue< LVecBase3i >::get_class_type(void);

1729 10 ParamValue 0 4 1852 36 ParamValue< LVecBase4d >::ParamValue 0 1 845 0
69
inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value);

1730 9 set_value 0 4 1852 35 ParamValue< LVecBase4d >::set_value 0 1 846 0
73
inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value);

1731 9 get_value 0 4 1852 35 ParamValue< LVecBase4d >::get_value 0 1 847 0
73
inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const;

1732 14 get_class_type 0 4 1852 40 ParamValue< LVecBase4d >::get_class_type 0 1 848 0
65
static TypeHandle ParamValue< LVecBase4d >::get_class_type(void);

1733 10 ParamValue 0 4 1854 36 ParamValue< LVecBase4f >::ParamValue 0 1 849 0
69
inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value);

1734 9 set_value 0 4 1854 35 ParamValue< LVecBase4f >::set_value 0 1 850 0
73
inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value);

1735 9 get_value 0 4 1854 35 ParamValue< LVecBase4f >::get_value 0 1 851 0
73
inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const;

1736 14 get_class_type 0 4 1854 40 ParamValue< LVecBase4f >::get_class_type 0 1 852 0
65
static TypeHandle ParamValue< LVecBase4f >::get_class_type(void);

1737 10 ParamValue 0 4 1856 36 ParamValue< LVecBase4i >::ParamValue 0 1 853 0
69
inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value);

1738 9 set_value 0 4 1856 35 ParamValue< LVecBase4i >::set_value 0 1 854 0
73
inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value);

1739 9 get_value 0 4 1856 35 ParamValue< LVecBase4i >::get_value 0 1 855 0
73
inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const;

1740 14 get_class_type 0 4 1856 40 ParamValue< LVecBase4i >::get_class_type 0 1 856 0
65
static TypeHandle ParamValue< LVecBase4i >::get_class_type(void);

1741 10 ParamValue 0 4 1858 35 ParamValue< LMatrix3d >::ParamValue 0 1 857 0
67
inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value);

1742 9 set_value 0 4 1858 34 ParamValue< LMatrix3d >::set_value 0 1 858 0
71
inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value);

1743 9 get_value 0 4 1858 34 ParamValue< LMatrix3d >::get_value 0 1 859 0
71
inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const;

1744 14 get_class_type 0 4 1858 39 ParamValue< LMatrix3d >::get_class_type 0 1 860 0
64
static TypeHandle ParamValue< LMatrix3d >::get_class_type(void);

1745 10 ParamValue 0 4 1860 35 ParamValue< LMatrix3f >::ParamValue 0 1 861 0
67
inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value);

1746 9 set_value 0 4 1860 34 ParamValue< LMatrix3f >::set_value 0 1 862 0
71
inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value);

1747 9 get_value 0 4 1860 34 ParamValue< LMatrix3f >::get_value 0 1 863 0
71
inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const;

1748 14 get_class_type 0 4 1860 39 ParamValue< LMatrix3f >::get_class_type 0 1 864 0
64
static TypeHandle ParamValue< LMatrix3f >::get_class_type(void);

1749 10 ParamValue 0 4 1862 35 ParamValue< LMatrix4d >::ParamValue 0 1 865 0
67
inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value);

1750 9 set_value 0 4 1862 34 ParamValue< LMatrix4d >::set_value 0 1 866 0
71
inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value);

1751 9 get_value 0 4 1862 34 ParamValue< LMatrix4d >::get_value 0 1 867 0
71
inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const;

1752 14 get_class_type 0 4 1862 39 ParamValue< LMatrix4d >::get_class_type 0 1 868 0
64
static TypeHandle ParamValue< LMatrix4d >::get_class_type(void);

1753 10 ParamValue 0 4 1864 35 ParamValue< LMatrix4f >::ParamValue 0 1 869 0
67
inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value);

1754 9 set_value 0 4 1864 34 ParamValue< LMatrix4f >::set_value 0 1 870 0
71
inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value);

1755 9 get_value 0 4 1864 34 ParamValue< LMatrix4f >::get_value 0 1 871 0
71
inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const;

1756 14 get_class_type 0 4 1864 39 ParamValue< LMatrix4f >::get_class_type 0 1 872 0
64
static TypeHandle ParamValue< LMatrix4f >::get_class_type(void);

1757 14 get_class_type 0 4 1871 36 WritableConfigurable::get_class_type 0 1 873 0
61
static TypeHandle WritableConfigurable::get_class_type(void);

1758 21 ~WritableConfigurable 0 4 1871 43 WritableConfigurable::~WritableConfigurable 0 0 0
50
WritableConfigurable::~WritableConfigurable(void);

1759 17 UniqueIdAllocator 0 4 1872 36 UniqueIdAllocator::UniqueIdAllocator 0 1 874 275
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::Constructor
//       Access: Published
//  Description: Create a free id pool in the range [min:max].
////////////////////////////////////////////////////////////////////
76
UniqueIdAllocator::UniqueIdAllocator(PN_uint32 min = 0, PN_uint32 max = 20);

1760 18 ~UniqueIdAllocator 0 4 1872 37 UniqueIdAllocator::~UniqueIdAllocator 0 0 229
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
44
UniqueIdAllocator::~UniqueIdAllocator(void);

1761 8 allocate 0 4 1872 27 UniqueIdAllocator::allocate 0 1 875 381
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::allocate
//       Access: Published
//  Description: Returns an id between _min and _max (that were passed
//               to the constructor).
//               IndexEnd is returned if no ids are available.
////////////////////////////////////////////////////////////////////
44
PN_uint32 UniqueIdAllocator::allocate(void);

1762 18 initial_reserve_id 0 4 1872 37 UniqueIdAllocator::initial_reserve_id 0 1 876 893
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::initial_reserve_id
//       Access: Published
//  Description: This may be called to mark a particular id as having
//               already been allocated (for instance, by a prior
//               pass).  The specified id is removed from the
//               available pool.
//
//               Because of the limitations of this algorithm, this is
//               most efficient when it is called before the first
//               call to allocate(), and when all the calls to
//               initial_reserve_id() are made in descending order by
//               id.  However, this is a performance warning only; if
//               performance is not an issue, any id may be reserved
//               at any time.
////////////////////////////////////////////////////////////////////
57
void UniqueIdAllocator::initial_reserve_id(PN_uint32 id);

1763 4 free 0 4 1872 23 UniqueIdAllocator::free 0 1 877 338
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::free
//       Access: Published
//  Description: Free an allocated index (index must be between _min
//               and _max that were passed to the constructor).
////////////////////////////////////////////////////////////////////
46
void UniqueIdAllocator::free(PN_uint32 index);

1764 13 fraction_used 0 4 1872 32 UniqueIdAllocator::fraction_used 0 1 878 350
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::fraction_used
//       Access: Published
//  Description: return the decimal fraction of the pool that is used.
//               The range is 0 to 1.0 (e.g. 75% would be 0.75).
////////////////////////////////////////////////////////////////////
57
PN_stdfloat UniqueIdAllocator::fraction_used(void) const;

1765 6 output 0 4 1872 25 UniqueIdAllocator::output 0 1 879 256
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::output
//       Access: Published
//  Description: ...intended for debugging only.
////////////////////////////////////////////////////////////////////
51
void UniqueIdAllocator::output(ostream &out) const;

1766 5 write 0 4 1872 24 UniqueIdAllocator::write 0 1 880 255
////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::write
//       Access: Published
//  Description: ...intended for debugging only.
////////////////////////////////////////////////////////////////////
50
void UniqueIdAllocator::write(ostream &out) const;

1767 39 py_decode_TypedWritable_from_bam_stream 0 1 0 39 py_decode_TypedWritable_from_bam_stream 0 1 889 0
92
PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, string const &data);

1768 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 0 47 py_decode_TypedWritable_from_bam_stream_persist 0 1 890 0
121
PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, string const &data);

890
1 0 0 7 8 1876 904 0 0 1 4 copy 1 1874  
2 0 0 7 8 1876 904 0 0 1 4 copy 1 1877  
3 0 0 7 8 1876 904 0 0 1 6 source 1 1879  
4 0 0 6 9 1882 0 0 0 1 4 this 3 1874  
5 0 0 6 10 1883 0 0 0 2 4 this 3 1874  1 n 1 1882  
6 0 0 6 11 1883 0 0 0 2 4 this 3 1874  1 n 1 1882  
7 0 0 6 12 1885 0 0 0 1 4 this 3 1874  
8 0 0 6 13 1885 0 0 0 3 4 this 3 1874  1 n 1 1882  5 count 1 1882  
9 0 0 6 14 1886 0 0 0 1 4 this 3 1874  
10 0 0 6 15 1886 0 0 0 1 4 this 3 1874  
11 0 0 6 16 1886 0 0 0 3 4 this 3 1874  4 view 1 1887  5 flags 1 1886  
12 0 0 4 17 1889 0 0 0 2 4 this 3 1874  4 view 1 1887  
13 0 0 4 5 1889 0 0 0 1 4 this 3 1890  
14 0 0 4 6 1889 0 0 0 2 4 this 3 1891  3 out 1 1893  
15 0 0 7 20 1895 922 0 0 1 4 copy 1 1877  
16 0 0 7 20 1895 922 0 0 1 6 source 1 1879  
17 0 0 7 20 1895 922 0 0 1 11 type_handle 1 1896  
18 0 0 7 21 1895 922 0 0 2 1 n 1 1882  11 type_handle 1 1896  
19 0 0 6 22 1882 0 0 0 1 4 this 3 1877  
20 0 0 4 23 1889 0 0 0 2 4 this 3 1895  1 x 1 1883  
21 0 0 4 24 1889 0 0 0 1 4 this 3 1895  
22 0 0 6 25 1883 0 0 0 2 4 this 3 1877  1 n 1 1882  
23 0 0 4 26 1889 0 0 0 3 4 this 3 1895  1 n 1 1882  5 value 1 1883  
24 0 0 6 27 1883 0 0 0 2 4 this 3 1877  1 n 1 1882  
25 0 0 4 28 1889 0 0 0 3 4 this 3 1895  1 n 1 1882  5 value 1 1883  
26 0 0 6 29 1885 0 0 0 1 4 this 3 1877  
27 0 0 4 30 1889 0 0 0 2 4 this 3 1895  4 data 1 1885  
28 0 0 6 31 1885 0 0 0 3 4 this 3 1877  1 n 1 1882  5 count 1 1882  
29 0 0 4 32 1889 0 0 0 4 4 this 3 1895  1 n 1 1882  5 count 1 1882  4 data 1 1885  
30 0 0 6 33 1886 0 0 0 1 4 this 3 1877  
31 0 0 6 34 1886 0 0 0 1 4 this 3 1877  
32 0 0 6 35 1886 0 0 0 3 4 this 3 1895  4 view 1 1887  5 flags 1 1886  
33 0 0 4 36 1889 0 0 0 2 4 this 3 1877  4 view 1 1887  
34 0 0 4 41 1889 0 0 294 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::play
//       Access: Published
//  Description: Runs the entire animation from beginning to end and
//               stops.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1898  
35 0 0 4 41 1889 0 0 736 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::play
//       Access: Published
//  Description: Runs the animation from the frame "from" to and
//               including the frame "to", at which point the
//               animation is stopped.  Both "from" and "to" frame
//               numbers may be outside the range (0,
//               get_num_frames()) and the animation will follow the
//               range correctly, reporting numbers modulo
//               get_num_frames().  For instance, play(0,
//               get_num_frames() * 2) will play the animation twice
//               and then stop.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1898  4 from 1 1899  2 to 1 1899  
36 0 0 4 42 1889 0 0 405 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::loop
//       Access: Published
//  Description: Starts the entire animation looping.  If restart is
//               true, the animation is restarted from the beginning;
//               otherwise, it continues from the current frame.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1898  7 restart 1 1900  
37 0 0 4 42 1889 0 0 491 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::loop
//       Access: Published
//  Description: Loops the animation from the frame "from" to and
//               including the frame "to", indefinitely.  If restart
//               is true, the animation is restarted from the
//               beginning; otherwise, it continues from the current
//               frame.
//////////////////////////////////////////////////////////////////// 4 4 this 3 1898  7 restart 1 1900  4 from 1 1899  2 to 1 1899  
38 0 0 4 43 1889 0 0 498 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pingpong
//       Access: Published
//  Description: Starts the entire animation bouncing back and forth
//               between its first frame and last frame.  If restart
//               is true, the animation is restarted from the
//               beginning; otherwise, it continues from the current
//               frame.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1898  7 restart 1 1900  
39 0 0 4 43 1889 0 0 386 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pingpong
//       Access: Published
//  Description: Loops the animation from the frame "from" to and
//               including the frame "to", and then back in the
//               opposite direction, indefinitely.
//////////////////////////////////////////////////////////////////// 4 4 this 3 1898  7 restart 1 1900  4 from 1 1899  2 to 1 1899  
40 0 0 4 44 1889 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::stop
//       Access: Published
//  Description: Stops a currently playing or looping animation right
//               where it is.  The animation remains posed at the
//               current frame.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1898  
41 0 0 4 45 1889 0 0 297 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::pose
//       Access: Published
//  Description: Sets the animation to the indicated frame and holds
//               it there.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1898  5 frame 1 1899  
42 0 0 4 46 1889 0 0 519 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::set_play_rate
//       Access: Published
//  Description: Changes the rate at which the animation plays.  1.0
//               is the normal speed, 2.0 is twice normal speed, and
//               0.5 is half normal speed.  0.0 is legal to pause the
//               animation, and a negative value will play the
//               animation backwards.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1898  9 play_rate 1 1899  
43 0 0 6 47 1899 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_play_rate
//       Access: Published
//  Description: Returns the rate at which the animation plays.  See
//               set_play_rate().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1901  
44 0 0 6 48 1899 0 0 514 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frame_rate
//       Access: Published
//  Description: Returns the native frame rate of the animation.  This
//               is the number of frames per second that will elapse
//               when the play_rate is set to 1.0.  It is a fixed
//               property of the animation and may not be adjusted by
//               the user.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1901  
45 0 0 6 49 1886 0 0 581 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_num_frames
//       Access: Published, Virtual
//  Description: Returns the number of frames in the animation.  This
//               is a property of the animation and may not be
//               directly adjusted by the user (although it may change
//               without warning with certain kinds of animations,
//               since this is a virtual method that may be
//               overridden).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1901  
46 0 0 6 50 1886 0 0 359 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frame
//       Access: Published
//  Description: Returns the current integer frame number.
//               This number will be in the range 0 <= f <
//               get_num_frames().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1901  
47 0 0 6 51 1886 0 0 638 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_next_frame
//       Access: Published
//  Description: Returns the current integer frame number + 1,
//               constrained to the range 0 <= f < get_num_frames().
//
//               If the play mode is PM_play, this will clamp to the
//               same value as get_frame() at the end of the
//               animation.  If the play mode is any other value, this
//               will wrap around to frame 0 at the end of the
//               animation.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1901  
48 0 0 6 52 1899 0 0 598 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_frac
//       Access: Published
//  Description: Returns the fractional part of the current frame.
//               Normally, this is in the range 0.0 <= f < 1.0, but in
//               the one special case of an animation playing to its
//               end frame and stopping, it might exactly equal 1.0.
//
//               It will always be true that get_full_frame() +
//               get_frac() == get_full_fframe().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1901  
49 0 0 6 53 1886 0 0 693 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_full_frame
//       Access: Published
//  Description: Returns the current integer frame number.
//
//               Unlike the value returned by get_frame(), this frame
//               number may extend beyond the range of
//               get_num_frames() if the frame range passed to play(),
//               loop(), etc. did.
//
//               Unlike the value returned by get_full_fframe(), this
//               return value will never exceed the value passed to
//               to_frame in the play() method.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1901  
50 0 0 6 54 1899 0 0 841 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::get_full_fframe
//       Access: Published
//  Description: Returns the current floating-point frame number.
//
//               Unlike the value returned by get_frame(), this frame
//               number may extend beyond the range of
//               get_num_frames() if the frame range passed to play(),
//               loop(), etc. did.
//
//               Unlike the value returned by get_full_frame(), this
//               return value may equal (to_frame + 1.0), when the
//               animation has played to its natural end.  However, in
//               this case the return value of get_full_frame() will
//               be to_frame, not (to_frame + 1).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1901  
51 0 0 6 55 1900 0 0 466 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::is_playing
//       Access: Published
//  Description: Returns true if the animation is currently playing,
//               false if it is stopped (e.g. because stop() or pose()
//               was called, or because it reached the end of the
//               animation after play() was called).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1901  
52 0 0 4 56 1889 0 0 230 ////////////////////////////////////////////////////////////////////
//     Function: AnimInterface::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1901  3 out 1 1893  
53 0 0 7 57 1896 0 0 0 0 
54 0 0 7 60 1903 961 0 274 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Default Constructor
//       Access: Published
//  Description: Creates an UpdateSeq in the 'initial' state.
//////////////////////////////////////////////////////////////////// 0 
55 0 0 7 60 1903 961 0 226 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1904  
56 0 0 7 61 1903 961 0 290 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::initial (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'initial' state.
//////////////////////////////////////////////////////////////////// 0 
57 0 0 7 62 1903 961 0 282 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::old (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'old' state.
//////////////////////////////////////////////////////////////////// 0 
58 0 0 7 63 1903 961 0 286 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::fresh (named constructor)
//       Access: Published, Static
//  Description: Returns an UpdateSeq in the 'fresh' state.
//////////////////////////////////////////////////////////////////// 0 
59 0 0 6 64 1903 0 0 234 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::Copy Assignment operator
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1903  4 copy 1 1904  
60 0 0 4 65 1889 0 0 260 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::clear
//       Access: Published
//  Description: Resets the UpdateSeq to the 'initial' state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1903  
61 0 0 6 66 1900 0 0 294 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_initial
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'initial'
//               state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1904  
62 0 0 6 67 1900 0 0 269 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_old
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'old' state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1904  
63 0 0 6 68 1900 0 0 290 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_fresh
//       Access: Published
//  Description: Returns true if the UpdateSeq is in the 'fresh'
//               state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1904  
64 0 0 6 69 1900 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::is_special
//       Access: Published
//  Description: Returns true if the UpdateSeq is in any special
//               states, i.e. 'initial', 'old', or 'fresh'.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1904  
65 0 0 6 70 1900 0 0 0 2 4 this 3 1904  5 other 1 1904  
66 0 0 6 71 1900 0 0 0 2 4 this 3 1904  5 other 1 1904  
67 0 0 6 72 1900 0 0 0 2 4 this 3 1904  5 other 1 1904  
68 0 0 6 73 1900 0 0 0 2 4 this 3 1904  5 other 1 1904  
69 0 0 6 74 1900 0 0 0 2 4 this 3 1904  5 other 1 1904  
70 0 0 6 75 1900 0 0 0 2 4 this 3 1904  5 other 1 1904  
71 0 0 7 76 1903 961 0 0 1 4 this 3 1903  
72 0 0 7 77 1903 961 0 0 2 4 this 3 1903  6 param0 0 1886  
73 0 0 6 78 1906 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::get_seq
//       Access: Published
//  Description: Returns the internal integer value associated with
//               the UpdateSeq.  Useful for debugging only.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1904  
74 0 0 4 79 1889 0 0 216 ////////////////////////////////////////////////////////////////////
//     Function: UpdateSeq::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1904  3 out 1 1893  
75 0 0 4 83 1889 0 0 653 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::mark_bam_modified
//       Access: Public
//  Description: Increments the bam_modified counter, so that this
//               object will be invalidated and retransmitted on any
//               open bam streams.  This should normally not need to
//               be called by user code; it should be called
//               internally when the object has been changed in a way
//               that legitimately requires its retransmission to any
//               connected clients.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1909  
76 0 0 7 84 1903 961 0 388 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::get_bam_modified
//       Access: Public
//  Description: Returns the current bam_modified counter.  This
//               counter is normally incremented automatically
//               whenever the object is modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1910  
77 0 0 6 85 1879 0 0 0 1 4 this 3 1910  
78 0 0 6 86 1879 0 0 0 2 4 this 3 1910  7 pickler 1 1879  
79 0 0 6 87 1885 0 0 756 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::encode_to_bam_stream
//       Access: Published
//  Description: Converts the TypedWritable object into a single
//               stream of data using a BamWriter, and returns that
//               data as a string string.  Returns empty string on
//               failure.
//
//               This is a convenience method particularly useful for
//               cases when you are only serializing a single object.
//               If you have many objects to process, it is more
//               efficient to use the same BamWriter to serialize all
//               of them together.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1910  
80 0 0 6 87 1900 0 0 770 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritable::encode_to_bam_stream
//       Access: Published
//  Description: Converts the TypedWritable object into a single
//               stream of data using a BamWriter, and stores that
//               data in the indicated string.  Returns true on
//               success, false on failure.
//
//               This is a convenience method particularly useful for
//               cases when you are only serializing a single object.
//               If you have many objects to process, it is more
//               efficient to use the same BamWriter to serialize all
//               of them together.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1910  4 data 1 1912  6 writer 1 1914  
81 0 0 7 89 1896 0 0 0 0 
82 0 0 7 96 1916 975 0 872 ////////////////////////////////////////////////////////////////////
//     Function: TypedWritableReferenceCount::decode_from_bam_stream
//       Access: Published, Static
//  Description: Reads the string created by a previous call to
//               encode_to_bam_stream(), and extracts and returns the
//               single object on that string.  Returns NULL on error.
//
//               This method is intended to replace
//               decode_raw_from_bam_stream() when you know the stream
//               in question returns an object of type
//               TypedWritableReferenceCount, allowing for easier
//               reference count management.  Note that the caller is
//               still responsible for maintaining the reference count
//               on the return value.
//////////////////////////////////////////////////////////////////// 2 4 data 1 1885  6 reader 1 1915  
83 0 0 7 97 1896 0 0 0 0 
84 0 0 6 91 1909 0 0 0 1 4 this 3 1916  
85 0 0 7 92 1916 975 0 0 1 4 this 3 1909  
86 0 0 7 94 1917 0 0 0 1 4 this 3 1916  
87 0 0 7 95 1916 975 0 0 1 4 this 3 1917  
88 0 0 7 106 1920 980 0 438 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::make_copy
//       Access: Published
//  Description: Returns a duplicate of the BamCacheRecord.  The
//               duplicate will not have a data pointer set, even
//               though one may have been assigned to the original via
//               set_data().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1918  
89 0 0 6 107 1900 0 0 0 2 4 this 3 1918  5 other 1 1918  
90 0 0 6 108 1921 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_source_pathname
//       Access: Published
//  Description: Returns the full pathname to the source file that
//               originally generated this cache request.  In some
//               cases, for instance in the case of a of a multipage
//               texture like "cube_#.png", this may not not a true
//               filename on disk.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1918  
91 0 0 6 109 1921 0 0 516 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_cache_filename
//       Access: Published
//  Description: Returns the name of the cache file as hashed from the
//               source_pathname.  This will be relative to the root
//               of the cache directory, and it will not include any
//               suffixes that may be appended to resolve hash
//               conflicts.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1918  
92 0 0 6 110 1924 0 0 473 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_source_timestamp
//       Access: Published
//  Description: Returns the file timestamp of the original source
//               file that generated this cache record, if available.
//               In some cases the original file timestamp is not
//               available, and this will return 0.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1918  
93 0 0 6 111 1924 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_recorded_time
//       Access: Published
//  Description: Returns the time at which this particular record was
//               recorded or updated.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1918  
94 0 0 6 112 1886 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_num_dependent_files
//       Access: Published
//  Description: Returns the number of source files that contribute to
//               the cache.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1918  
95 0 0 6 113 1921 0 0 335 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_dependent_pathname
//       Access: Published
//  Description: Returns the full pathname of the nth source files
//               that contributes to the cache.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1918  1 n 1 1886  
96 0 0 6 114 1900 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::dependents_unchanged
//       Access: Published
//  Description: Returns true if all of the dependent files are still
//               the same as when the cache was recorded, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1918  
97 0 0 4 115 1889 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::clear_dependent_files
//       Access: Published
//  Description: Empties the list of files that contribute to the data
//               in this record.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1920  
98 0 0 4 116 1889 0 0 509 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::add_dependent_file
//       Access: Published
//  Description: Adds the indicated file to the list of files that
//               will be loaded to generate the data in this record.
//               This should be called once for the primary source
//               file, and again for each secondary source file, if
//               any.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1920  8 pathname 1 1921  
99 0 0 6 117 1900 0 0 373 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::has_data
//       Access: Published
//  Description: Returns true if this cache record has an in-memory
//               data object associated--that is, the object stored in
//               the cache.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1918  
100 0 0 4 118 1889 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::clear_data
//       Access: Published
//  Description: Removes the in-memory data object associated with
//               this record, if any.  This does not affect the
//               on-disk representation of the record.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1920  
101 0 0 6 119 1909 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::get_data
//       Access: Published
//  Description: Returns a pointer to the data stored in the
//               record, or NULL if there is no data.  The pointer is
//               not removed from the record.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1918  
102 0 0 4 121 1889 0 0 935 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::set_data
//       Access: Published
//  Description: Stores a new data object on the record.  You should
//               pass the same pointer twice, to both parameters; this
//               allows the C++ typecasting to automatically convert
//               the pointer into both a TypedWritable and a
//               ReferenceCount pointer, so that the BamCacheRecord
//               object can reliably manage the reference counts.
//
//               You may pass 0 or NULL as the second parameter.  If
//               you do this, the BamCacheRecord will not manage the
//               object's reference count; it will be up to you to
//               ensure the object is not deleted during the lifetime
//               of the BamCacheRecord object.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1920  3 ptr 1 1909  7 ref_ptr 1 1917  
103 0 0 4 121 1889 0 0 342 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::set_data
//       Access: Published
//  Description: This variant on set_data() is provided just to allow
//               Python code to pass a 0 as the second parameter.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1920  3 ptr 1 1909  5 dummy 1 1886  
104 0 0 4 122 1889 0 0 222 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1918  3 out 1 1893  
105 0 0 4 123 1889 0 0 221 ////////////////////////////////////////////////////////////////////
//     Function: BamCacheRecord::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 1918  3 out 1 1893  12 indent_level 1 1886  
106 0 0 7 124 1896 0 0 0 0 
107 0 0 7 100 1916 975 0 0 1 4 this 3 1920  
108 0 0 7 101 1920 980 0 0 1 4 this 3 1916  
109 0 0 7 126 1926 1001 0 220 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
110 0 0 4 128 1889 0 0 646 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_active
//       Access: Published
//  Description: Changes the state of the active flag.  "active" means
//               that the cache should be consulted automatically on
//               loads, "not active" means that objects should be
//               loaded directly without consulting the cache.
//
//               This represents the global flag.  Also see the
//               individual cache_models, cache_textures,
//               cache_compressed_textures flags.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1926  4 flag 1 1900  
111 0 0 6 129 1900 0 0 695 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_active
//       Access: Published
//  Description: Returns true if the BamCache is currently active,
//               false if it is not.  "active" means that the cache
//               should be consulted automatically on loads, "not
//               active" means that objects should be loaded directly
//               without consulting the cache.
//
//               This represents the global flag.  Also see the
//               individual cache_models, cache_textures,
//               cache_compressed_textures flags.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1927  
112 0 0 4 130 1889 0 0 346 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_models
//       Access: Published
//  Description: Indicates whether model files (e.g. egg files and bam
//               files) will be stored in the cache, as bam files.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1926  4 flag 1 1900  
113 0 0 6 131 1900 0 0 414 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_models
//       Access: Published
//  Description: Returns whether model files (e.g. egg files and bam
//               files) will be stored in the cache, as bam files.
//
//               This also returns false if get_active() is false.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1927  
114 0 0 4 132 1889 0 0 332 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_textures
//       Access: Published
//  Description: Indicates whether texture files will be stored in the
//               cache, as uncompressed txo files.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1926  4 flag 1 1900  
115 0 0 6 133 1900 0 0 418 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_textures
//       Access: Published
//  Description: Returns whether texture files (e.g. egg files and bam
//               files) will be stored in the cache, as txo files.
//
//               This also returns false if get_active() is false.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1927  
116 0 0 4 134 1889 0 0 1143 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_compressed_textures
//       Access: Published
//  Description: Indicates whether compressed texture files will be
//               stored in the cache, as compressed txo files.  The
//               compressed data may either be generated in-CPU, via
//               the squish library, or it may be extracted from the
//               GSG after the texture has been loaded.
//
//               This may be set in conjunction with
//               set_cache_textures(), or independently of it.  If
//               set_cache_textures() is true and this is false, all
//               textures will be cached in their uncompressed form.
//               If set_cache_textures() is false and this is true,
//               only compressed textures will be cached, and they
//               will be cached in their compressed form.  If both are
//               true, all textures will be cached, in their
//               uncompressed or compressed form appropriately.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1926  4 flag 1 1900  
117 0 0 6 135 1900 0 0 475 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_compressed_textures
//       Access: Published
//  Description: Returns whether compressed texture files will be
//               stored in the cache, as compressed txo files.  See
//               set_cache_compressed_textures().
//
//               This also returns false if get_active() is false.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1927  
118 0 0 4 136 1889 0 0 665 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_root
//       Access: Published
//  Description: Changes the current root pathname of the cache.  This
//               specifies where the cache files are stored on disk.
//               This should name a directory that is on a disk local
//               to the machine (not on a network-mounted disk), for
//               instance, /tmp/panda-cache or /c/panda-cache.
//
//               If the directory does not already exist, it will be
//               created as a result of this call.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1926  4 root 1 1921  
119 0 0 7 137 1929 0 0 299 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_root
//       Access: Published
//  Description: Returns the current root pathname of the cache.  See
//               set_root().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1927  
120 0 0 4 138 1889 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_flush_time
//       Access: Published
//  Description: Specifies the time in seconds between automatic
//               flushes of the cache index.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1926  10 flush_time 1 1886  
121 0 0 6 139 1886 0 0 314 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_flush_time
//       Access: Published
//  Description: Returns the time in seconds between automatic
//               flushes of the cache index.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1927  
122 0 0 4 140 1889 0 0 767 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_cache_max_kbytes
//       Access: Published
//  Description: Specifies the maximum size, in kilobytes, which the
//               cache is allowed to grow to.  If a newly cached file
//               would exceed this size, an older file is removed from
//               the cache.
//
//               Note that in the case of multiple different processes
//               simultaneously operating on the same cache directory,
//               the actual cache size may slightly exceed this value
//               from time to time due to latency in checking between
//               the processes.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1926  10 max_kbytes 1 1886  
123 0 0 6 141 1886 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_cache_max_kbytes
//       Access: Published
//  Description: Returns the maximum size, in kilobytes, which the
//               cache is allowed to grow to.  See
//               set_cache_max_kbytes().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1927  
124 0 0 4 142 1889 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::set_read_only
//       Access: Published
//  Description: Can be used to put the cache in read-only mode,
//               or take it out of read-only mode.  Note that if you
//               put it into read-write mode, and it discovers that
//               it does not have write access, it will put itself
//               right back into read-only mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1926  2 ro 1 1900  
125 0 0 6 143 1900 0 0 503 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_read_only
//       Access: Published
//  Description: Returns true if the cache is in read-only mode.
//               Normally, the cache starts in read-write mode.  It
//               can put itself into read-only mode automatically if
//               it discovers that it does not have write access to
//               the cache.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1927  
126 0 0 7 144 1920 980 0 1209 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::lookup
//       Access: Published
//  Description: Looks up a file in the cache.
//
//               If the file is cacheable, then regardless of whether
//               the file is found in the cache or not, this returns a
//               BamCacheRecord.  On the other hand, if the file
//               cannot be cached, returns NULL.
//
//               If record->has_data() returns true, then the file was
//               found in the cache, and you may call
//               record->extract_data() to get the object.  If
//               record->has_data() returns false, then the file was
//               not found in the cache or the cache was stale; and
//               you should reload the source file (calling
//               record->add_dependent_file() for each file loaded,
//               including the original source file), and then call
//               record->set_data() to record the resulting loaded
//               object; and finally, you should call store() to write
//               the cached record to disk.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1926  15 source_filename 1 1921  15 cache_extension 1 1885  
127 0 0 6 145 1900 0 0 478 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::store
//       Access: Published
//  Description: Flushes a cache entry to disk.  You must have
//               retrieved the cache record via a prior call to
//               lookup(), and then stored the data via
//               record->set_data().  Returns true on success, false
//               on failure.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1926  6 record 1 1920  
128 0 0 4 146 1889 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::consider_flush_index
//       Access: Published
//  Description: Flushes the index if enough time has elapsed since
//               the index was last flushed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1926  
129 0 0 4 147 1889 0 0 258 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::flush_index
//       Access: Published
//  Description: Ensures the index is written to disk.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1926  
130 0 0 4 148 1889 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::list_index
//       Access: Published
//  Description: Writes the contents of the index to standard output.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1927  3 out 1 1893  12 indent_level 1 1886  
131 0 0 6 149 1926 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: BamCache::get_global_ptr
//       Access: Published, Static
//  Description: Returns a pointer to the global BamCache object,
//               which is used automatically by the ModelPool and
//               TexturePool.
//////////////////////////////////////////////////////////////////// 0 
132 0 0 7 158 1932 1036 0 230 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1930  
133 0 0 7 158 1932 1036 0 225 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 5 flags 1 1886  
134 0 0 7 158 1932 1036 0 225 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 5 flags 1 1886  13 texture_flags 1 1886  
135 0 0 6 159 1932 0 0 0 2 4 this 3 1932  4 copy 1 1930  
136 0 0 4 160 1889 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_flags
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1932  5 flags 1 1886  
137 0 0 6 161 1886 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_flags
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 1930  
138 0 0 4 162 1889 0 0 231 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_texture_flags
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1932  5 flags 1 1886  
139 0 0 6 163 1886 0 0 231 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_texture_flags
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 1930  
140 0 0 4 164 1889 0 0 767 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_texture_num_views
//       Access: Published
//  Description: Specifies the expected number of views to load for
//               the texture.  This is ignored unless TF_multiview is
//               included in texture_flags.  This must be specified
//               when loading a 3-d multiview texture, in which case
//               it is used to differentiate z levels from separate
//               views; it may be zero in the case of 2-d textures or
//               cube maps, in which case the number of views can be
//               inferred from the number of images found on disk.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1932  9 num_views 1 1886  
141 0 0 6 165 1886 0 0 264 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_texture_num_views
//       Access: Published
//  Description: See set_texture_num_views().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1930  
142 0 0 4 166 1889 0 0 480 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::set_auto_texture_scale
//       Access: Published
//  Description: Set this flag to ATS_none, ATS_up, ATS_down, or
//               ATS_pad to control how a texture is scaled from
//               disk when it is subsequently loaded.  Set it to
//               ATS_unspecified to restore the default behavior.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1932  5 scale 1 1776  
143 0 0 6 167 1776 0 0 266 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::get_auto_texture_scale
//       Access: Published
//  Description: See set_auto_texture_scale().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1930  
144 0 0 4 168 1889 0 0 221 ////////////////////////////////////////////////////////////////////
//     Function: LoaderOptions::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1930  3 out 1 1893  
145 0 0 7 171 1915 1038 0 221 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 6 source 1 1933  
146 0 0 4 173 1889 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_source
//       Access: Published
//  Description: Changes the source of future datagrams for this
//               BamReader.  This also implicitly calls init() if it
//               has not already been called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1915  6 source 1 1933  
147 0 0 6 174 1933 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_source
//       Access: Published
//  Description: Returns the current source of the BamReader as set by
//               set_source() or the constructor.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1915  
148 0 0 6 175 1900 0 0 474 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::init
//       Access: Published
//  Description: Initializes the BamReader prior to reading any
//               objects from its source.  This includes reading the
//               Bam header.
//
//               This returns true if the BamReader successfully
//               initialized, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1915  
149 0 0 4 176 1889 0 0 1496 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_aux_data
//       Access: Published
//  Description: Associates an arbitrary block of data with the
//               indicated object (or NULL), and the indicated name.
//
//               This is intended to provide a place for temporary
//               storage for objects reading themselves from the bam
//               file.  To use it, inherit from BamReader::AuxData and
//               store whatever data you like there.  Then associate
//               your AuxData with the object as it is being read with
//               set_aux_data().  You may later set the aux data to
//               NULL to remove it; or it will automatically be
//               removed (and deleted) after finalize() is called for
//               the object in question.
//
//               If the TypedWritable pointer is NULL, the the aux
//               data is stored globally for the BamReader in general.
//               This pointer is available to any bam objects, and
//               will not be automatically removed until the BamReader
//               itself destructs.
//
//               In either case, the name is just an arbitrary
//               user-defined key.  If there is already a data pointer
//               stored for the obj/name pair, that data pointer will
//               be replaced (and deleted).
//////////////////////////////////////////////////////////////////// 4 4 this 3 1915  3 obj 1 1909  4 name 1 1885  4 data 1 1934  
150 0 0 7 177 1934 0 0 413 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_aux_data
//       Access: Published
//  Description: Returns the pointer previously associated with the
//               bam reader by a previous call to set_aux_data(), or
//               NULL if data with the indicated key has not been set.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1936  3 obj 1 1909  4 name 1 1885  
151 0 0 6 178 1921 0 0 457 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_filename
//       Access: Published
//  Description: If a BAM is a file, then the BamReader should
//               contain the name of the file.  This enables the
//               reader to interpret pathnames in the BAM as relative
//               to the directory containing the BAM.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1936  
152 0 0 6 179 1930 0 0 330 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_loader_options
//       Access: Published
//  Description: Returns the LoaderOptions passed to the loader when
//               the model was requested, if any.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1936  
153 0 0 4 180 1889 0 0 276 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::set_loader_options
//       Access: Published
//  Description: Specifies the LoaderOptions for this BamReader.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1915  7 options 1 1930  
154 0 0 6 181 1909 0 0 1569 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::read_object
//       Access: Published
//  Description: Reads a single object from the Bam file.  If the
//               object type is known, a new object of the appropriate
//               type is created and returned; otherwise, NULL is
//               returned.  NULL is also returned when the end of the
//               file is reached.  is_eof() may be called to
//               differentiate between these two cases.
//
//               This may be called repeatedly to extract out all the
//               objects in the Bam file, but typically (especially
//               for scene graph files, indicated with the .bam
//               extension), only one object is retrieved directly
//               from the Bam file: the root of the scene graph.  The
//               remaining objects will all be retrieved recursively
//               by the first object.
//
//               Note that the object returned may not yet be
//               complete.  In particular, some of its pointers may
//               not be filled in; you must call resolve() to fill in
//               all the available pointers before you can safely use
//               any objects returned by read_object().
//
//               This flavor of read_object() requires the caller to
//               know what type of object it has received in order to
//               properly manage the reference counts.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1915  
155 0 0 6 182 1900 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::is_eof
//       Access: Published
//  Description: Returns true if the reader has reached end-of-file,
//               false otherwise.  This call is only valid after a
//               call to read_object().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1936  
156 0 0 6 183 1900 0 0 935 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::resolve
//       Access: Published
//  Description: This may be called at any time during processing of
//               the Bam file to resolve all the known pointers so
//               far.  It is usually called at the end of the
//               processing, after all objects have been read, which
//               is generally the best time to call it.
//
//               This must be called at least once after reading a
//               particular object via get_object() in order to
//               validate that object.
//
//               The return value is true if all objects have been
//               resolved, or false if some objects are still
//               outstanding (in which case you will need to call
//               resolve() again later).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1915  
157 0 0 6 184 1900 0 0 724 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::change_pointer
//       Access: Published
//  Description: Indicates that an object recently read from the bam
//               stream should be replaced with a new object.  Any
//               future occurrences of the original object in the
//               stream will henceforth return the new object instead.
//
//               The return value is true if the replacement was
//               successfully made, or false if the object was not
//               read from the stream (or if change_pointer had
//               already been called on it).
//////////////////////////////////////////////////////////////////// 3 4 this 3 1915  12 orig_pointer 1 1910  11 new_pointer 1 1910  
158 0 0 6 185 1886 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_major_ver
//       Access: Published
//  Description: Returns the major version number of the Bam file
//               currently being read.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1936  
159 0 0 6 186 1886 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_minor_ver
//       Access: Published
//  Description: Returns the minor version number of the Bam file
//               currently being read.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1936  
160 0 0 6 187 1786 0 0 528 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_endian
//       Access: Published
//  Description: Returns the endian preference indicated by the Bam
//               file currently being read.  This does not imply that
//               every number is stored using the indicated
//               convention, but individual objects may choose to
//               respect this flag when recording data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1936  
161 0 0 6 188 1900 0 0 489 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_file_stdfloat_double
//       Access: Published
//  Description: Returns true if the file stores all "standard"
//               floats as 64-bit doubles, or false if they are 32-bit
//               floats.  This is determined by the compilation flags
//               of the version of Panda that generated this file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1936  
162 0 0 6 189 1886 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_current_major_ver
//       Access: Published
//  Description: Returns the major version number of Bam files
//               supported by the current code base.  This must match
//               get_file_major_ver() in order to successfully read a
//               file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1936  
163 0 0 6 190 1886 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: BamReader::get_current_minor_ver
//       Access: Published
//  Description: Returns the minor version number of Bam files
//               supported by the current code base.  This must match
//               or exceed get_file_minor_ver() in order to
//               successfully read a file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1936  
164 0 0 7 192 1914 1058 0 221 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 6 target 1 1938  
165 0 0 4 194 1889 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::set_target
//       Access: Published
//  Description: Changes the destination of future datagrams written
//               by the BamWriter.  This also implicitly calls init()
//               if it has not already been called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1914  6 target 1 1938  
166 0 0 6 195 1938 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_target
//       Access: Published
//  Description: Returns the current target of the BamWriter as set by
//               set_target() or the constructor.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1914  
167 0 0 6 196 1900 0 0 483 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::init
//       Access: Published
//  Description: Initializes the BamWriter prior to writing any
//               objects to its output stream.  This includes writing
//               out the Bam header.
//
//               This returns true if the BamWriter successfully
//               initialized, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1914  
168 0 0 6 197 1921 0 0 455 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_filename
//       Access: Published
//  Description: If a BAM is a file, then the BamWriter should
//               contain the name of the file.  This enables the
//               writer to convert pathnames in the BAM to relative
//               to the directory containing the BAM.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
169 0 0 6 198 1900 0 0 1153 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::write_object
//       Access: Published
//  Description: Writes a single object to the Bam file, so that the
//               BamReader::read_object() can later correctly restore
//               the object and all its pointers.
//
//               This implicitly also writes any additional objects
//               this object references (if they haven't already been
//               written), so that pointers may be fully resolved.
//
//               This may be called repeatedly to write a sequence of
//               objects to the Bam file, but typically (especially
//               for scene graph files, indicated with the .bam
//               extension), only one object is written directly from
//               the Bam file: the root of the scene graph.  The
//               remaining objects will all be written recursively by
//               the first object.
//
//               Returns true if the object is successfully written,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1914  3 obj 1 1910  
170 0 0 6 199 1900 0 0 408 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::has_object
//       Access: Published
//  Description: Returns true if the object has previously been
//               written (or at least requested to be written) to the
//               bam file, or false if we've never heard of it before.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1940  3 obj 1 1910  
171 0 0 4 200 1889 0 0 307 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::flush
//       Access: Published
//  Description: Ensures that all data written thus far is manifested
//               on the output stream.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1914  
172 0 0 6 201 1786 0 0 531 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_endian
//       Access: Published
//  Description: Returns the endian preference indicated by the Bam
//               file currently being written.  This does not imply
//               that every number is stored using the indicated
//               convention, but individual objects may choose to
//               respect this flag when recording data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
173 0 0 6 202 1900 0 0 531 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_stdfloat_double
//       Access: Published
//  Description: Returns true if the file will store all "standard"
//               floats as 64-bit doubles, or false if they are 32-bit
//               floats.  This isn't runtime settable; it's based on
//               the compilation flags of the version of Panda that
//               generated this file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
174 0 0 6 203 1788 0 0 462 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::get_file_texture_mode
//       Access: Published
//  Description: Returns the BamTextureMode preference indicated by
//               the Bam file currently being written.  Texture
//               objects written to this Bam file will be encoded
//               according to the specified mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1940  
175 0 0 4 204 1889 0 0 453 ////////////////////////////////////////////////////////////////////
//     Function: BamWriter::set_file_texture_mode
//       Access: Published
//  Description: Changes the BamTextureMode preference for
//               the Bam file currently being written.  Texture
//               objects written to this Bam file will be encoded
//               according to the specified mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1914  17 file_texture_mode 1 1788  
176 0 0 7 206 1942 1077 0 0 0 
177 0 0 7 206 1942 1077 0 0 1 4 copy 1 1943  
178 0 0 7 206 1942 1077 0 0 1 10 init_value 1 1945  
179 0 0 6 207 1942 0 0 0 2 4 this 3 1942  4 copy 1 1943  
180 0 0 7 208 1942 1077 0 0 0 
181 0 0 7 209 1942 1077 0 0 0 
182 0 0 7 210 1942 1077 0 0 1 7 on_bits 1 1886  
183 0 0 7 211 1942 1077 0 0 1 5 index 1 1886  
184 0 0 7 212 1942 1077 0 0 2 7 low_bit 1 1886  4 size 1 1886  
185 0 0 6 214 1900 0 0 0 0 
186 0 0 6 215 1886 0 0 0 0 
187 0 0 6 216 1886 0 0 0 0 
188 0 0 6 217 1900 0 0 0 2 4 this 3 1943  5 index 1 1886  
189 0 0 4 218 1889 0 0 0 2 4 this 3 1942  5 index 1 1886  
190 0 0 4 219 1889 0 0 0 2 4 this 3 1942  5 index 1 1886  
191 0 0 4 220 1889 0 0 0 3 4 this 3 1942  5 index 1 1886  5 value 1 1900  
192 0 0 6 221 1900 0 0 0 1 4 this 3 1943  
193 0 0 6 222 1900 0 0 0 1 4 this 3 1943  
194 0 0 6 223 1945 0 0 0 3 4 this 3 1943  7 low_bit 1 1886  4 size 1 1886  
195 0 0 4 224 1889 0 0 0 4 4 this 3 1942  5 value 1 1945  7 low_bit 1 1886  4 size 1 1886  
196 0 0 6 225 1900 0 0 0 3 4 this 3 1943  7 low_bit 1 1886  4 size 1 1886  
197 0 0 6 226 1900 0 0 0 3 4 this 3 1943  7 low_bit 1 1886  4 size 1 1886  
198 0 0 4 227 1889 0 0 0 3 4 this 3 1942  7 low_bit 1 1886  4 size 1 1886  
199 0 0 4 228 1889 0 0 0 3 4 this 3 1942  7 low_bit 1 1886  4 size 1 1886  
200 0 0 4 229 1889 0 0 0 4 4 this 3 1942  5 value 1 1900  7 low_bit 1 1886  4 size 1 1886  
201 0 0 6 230 1945 0 0 0 1 4 this 3 1943  
202 0 0 4 231 1889 0 0 0 2 4 this 3 1942  5 value 1 1945  
203 0 0 6 232 1886 0 0 0 1 4 this 3 1943  
204 0 0 6 233 1886 0 0 0 1 4 this 3 1943  
205 0 0 6 234 1886 0 0 0 1 4 this 3 1943  
206 0 0 6 235 1886 0 0 0 1 4 this 3 1943  
207 0 0 6 236 1886 0 0 0 1 4 this 3 1943  
208 0 0 6 237 1886 0 0 0 1 4 this 3 1943  
209 0 0 6 238 1886 0 0 0 2 4 this 3 1943  7 low_bit 1 1886  
210 0 0 4 239 1889 0 0 0 1 4 this 3 1942  
211 0 0 6 240 1900 0 0 0 2 4 this 3 1943  5 other 1 1943  
212 0 0 4 241 1889 0 0 0 1 4 this 3 1942  
213 0 0 4 242 1889 0 0 0 2 4 this 3 1943  3 out 1 1893  
214 0 0 4 243 1889 0 0 0 3 4 this 3 1943  3 out 1 1893  12 spaces_every 1 1886  
215 0 0 4 244 1889 0 0 0 3 4 this 3 1943  3 out 1 1893  12 spaces_every 1 1886  
216 0 0 4 245 1889 0 0 0 3 4 this 3 1943  3 out 1 1893  12 indent_level 1 1886  
217 0 0 6 246 1900 0 0 0 2 4 this 3 1943  5 other 1 1943  
218 0 0 6 247 1900 0 0 0 2 4 this 3 1943  5 other 1 1943  
219 0 0 6 248 1900 0 0 0 2 4 this 3 1943  5 other 1 1943  
220 0 0 6 249 1886 0 0 0 2 4 this 3 1943  5 other 1 1943  
221 0 0 7 250 1942 1077 0 0 2 4 this 3 1943  5 other 1 1943  
222 0 0 7 251 1942 1077 0 0 2 4 this 3 1943  5 other 1 1943  
223 0 0 7 252 1942 1077 0 0 2 4 this 3 1943  5 other 1 1943  
224 0 0 7 253 1942 1077 0 0 1 4 this 3 1943  
225 0 0 7 254 1942 1077 0 0 2 4 this 3 1943  5 shift 1 1886  
226 0 0 7 255 1942 1077 0 0 2 4 this 3 1943  5 shift 1 1886  
227 0 0 6 256 1942 0 0 0 2 4 this 3 1942  5 other 1 1943  
228 0 0 6 257 1942 0 0 0 2 4 this 3 1942  5 other 1 1943  
229 0 0 6 258 1942 0 0 0 2 4 this 3 1942  5 other 1 1943  
230 0 0 6 259 1942 0 0 0 2 4 this 3 1942  5 shift 1 1886  
231 0 0 6 260 1942 0 0 0 2 4 this 3 1942  5 shift 1 1886  
232 0 0 4 261 1889 0 0 0 1 4 this 3 1942  
233 0 0 4 262 1889 0 0 0 1 4 this 3 1942  
234 0 0 7 263 1942 1077 0 0 1 4 this 3 1943  
235 0 0 7 264 1942 1077 0 0 1 4 this 3 1943  
236 0 0 7 265 1942 1077 0 0 1 4 this 3 1943  
237 0 0 7 265 1942 1077 0 0 2 4 this 3 1943  5 other 1 1943  
238 0 0 7 265 1942 1077 0 0 2 4 this 3 1943  5 index 1 1886  
239 0 0 7 266 1942 1077 0 0 1 4 this 3 1943  
240 0 0 7 266 1942 1077 0 0 2 4 this 3 1943  5 other 1 1943  
241 0 0 7 266 1942 1077 0 0 2 4 this 3 1943  5 index 1 1886  
242 0 0 6 267 1886 0 0 0 1 4 this 3 1943  
243 0 0 6 268 1900 0 0 0 1 4 this 3 1943  
244 0 0 7 269 1896 0 0 0 0 
245 0 0 7 272 1946 1141 0 0 0 
246 0 0 7 272 1946 1141 0 0 1 4 copy 1 1947  
247 0 0 7 272 1946 1141 0 0 1 10 init_value 1 1949  
248 0 0 6 273 1946 0 0 0 2 4 this 3 1946  4 copy 1 1947  
249 0 0 7 274 1946 1141 0 0 0 
250 0 0 7 275 1946 1141 0 0 0 
251 0 0 7 276 1946 1141 0 0 1 7 on_bits 1 1886  
252 0 0 7 277 1946 1141 0 0 1 5 index 1 1886  
253 0 0 7 278 1946 1141 0 0 2 7 low_bit 1 1886  4 size 1 1886  
254 0 0 6 280 1900 0 0 0 0 
255 0 0 6 281 1886 0 0 0 0 
256 0 0 6 282 1886 0 0 0 0 
257 0 0 6 283 1900 0 0 0 2 4 this 3 1947  5 index 1 1886  
258 0 0 4 284 1889 0 0 0 2 4 this 3 1946  5 index 1 1886  
259 0 0 4 285 1889 0 0 0 2 4 this 3 1946  5 index 1 1886  
260 0 0 4 286 1889 0 0 0 3 4 this 3 1946  5 index 1 1886  5 value 1 1900  
261 0 0 6 287 1900 0 0 0 1 4 this 3 1947  
262 0 0 6 288 1900 0 0 0 1 4 this 3 1947  
263 0 0 6 289 1949 0 0 0 3 4 this 3 1947  7 low_bit 1 1886  4 size 1 1886  
264 0 0 4 290 1889 0 0 0 4 4 this 3 1946  5 value 1 1949  7 low_bit 1 1886  4 size 1 1886  
265 0 0 6 291 1900 0 0 0 3 4 this 3 1947  7 low_bit 1 1886  4 size 1 1886  
266 0 0 6 292 1900 0 0 0 3 4 this 3 1947  7 low_bit 1 1886  4 size 1 1886  
267 0 0 4 293 1889 0 0 0 3 4 this 3 1946  7 low_bit 1 1886  4 size 1 1886  
268 0 0 4 294 1889 0 0 0 3 4 this 3 1946  7 low_bit 1 1886  4 size 1 1886  
269 0 0 4 295 1889 0 0 0 4 4 this 3 1946  5 value 1 1900  7 low_bit 1 1886  4 size 1 1886  
270 0 0 6 296 1949 0 0 0 1 4 this 3 1947  
271 0 0 4 297 1889 0 0 0 2 4 this 3 1946  5 value 1 1949  
272 0 0 6 298 1886 0 0 0 1 4 this 3 1947  
273 0 0 6 299 1886 0 0 0 1 4 this 3 1947  
274 0 0 6 300 1886 0 0 0 1 4 this 3 1947  
275 0 0 6 301 1886 0 0 0 1 4 this 3 1947  
276 0 0 6 302 1886 0 0 0 1 4 this 3 1947  
277 0 0 6 303 1886 0 0 0 1 4 this 3 1947  
278 0 0 6 304 1886 0 0 0 2 4 this 3 1947  7 low_bit 1 1886  
279 0 0 4 305 1889 0 0 0 1 4 this 3 1946  
280 0 0 6 306 1900 0 0 0 2 4 this 3 1947  5 other 1 1947  
281 0 0 4 307 1889 0 0 0 1 4 this 3 1946  
282 0 0 4 308 1889 0 0 0 2 4 this 3 1947  3 out 1 1893  
283 0 0 4 309 1889 0 0 0 3 4 this 3 1947  3 out 1 1893  12 spaces_every 1 1886  
284 0 0 4 310 1889 0 0 0 3 4 this 3 1947  3 out 1 1893  12 spaces_every 1 1886  
285 0 0 4 311 1889 0 0 0 3 4 this 3 1947  3 out 1 1893  12 indent_level 1 1886  
286 0 0 6 312 1900 0 0 0 2 4 this 3 1947  5 other 1 1947  
287 0 0 6 313 1900 0 0 0 2 4 this 3 1947  5 other 1 1947  
288 0 0 6 314 1900 0 0 0 2 4 this 3 1947  5 other 1 1947  
289 0 0 6 315 1886 0 0 0 2 4 this 3 1947  5 other 1 1947  
290 0 0 7 316 1946 1141 0 0 2 4 this 3 1947  5 other 1 1947  
291 0 0 7 317 1946 1141 0 0 2 4 this 3 1947  5 other 1 1947  
292 0 0 7 318 1946 1141 0 0 2 4 this 3 1947  5 other 1 1947  
293 0 0 7 319 1946 1141 0 0 1 4 this 3 1947  
294 0 0 7 320 1946 1141 0 0 2 4 this 3 1947  5 shift 1 1886  
295 0 0 7 321 1946 1141 0 0 2 4 this 3 1947  5 shift 1 1886  
296 0 0 6 322 1946 0 0 0 2 4 this 3 1946  5 other 1 1947  
297 0 0 6 323 1946 0 0 0 2 4 this 3 1946  5 other 1 1947  
298 0 0 6 324 1946 0 0 0 2 4 this 3 1946  5 other 1 1947  
299 0 0 6 325 1946 0 0 0 2 4 this 3 1946  5 shift 1 1886  
300 0 0 6 326 1946 0 0 0 2 4 this 3 1946  5 shift 1 1886  
301 0 0 4 327 1889 0 0 0 1 4 this 3 1946  
302 0 0 4 328 1889 0 0 0 1 4 this 3 1946  
303 0 0 7 329 1946 1141 0 0 1 4 this 3 1947  
304 0 0 7 330 1946 1141 0 0 1 4 this 3 1947  
305 0 0 7 331 1946 1141 0 0 1 4 this 3 1947  
306 0 0 7 331 1946 1141 0 0 2 4 this 3 1947  5 other 1 1947  
307 0 0 7 331 1946 1141 0 0 2 4 this 3 1947  5 index 1 1886  
308 0 0 7 332 1946 1141 0 0 1 4 this 3 1947  
309 0 0 7 332 1946 1141 0 0 2 4 this 3 1947  5 other 1 1947  
310 0 0 7 332 1946 1141 0 0 2 4 this 3 1947  5 index 1 1886  
311 0 0 6 333 1886 0 0 0 1 4 this 3 1947  
312 0 0 6 334 1900 0 0 0 1 4 this 3 1947  
313 0 0 7 335 1896 0 0 0 0 
314 0 0 7 338 1950 1205 0 0 0 
315 0 0 7 338 1950 1205 0 0 1 4 copy 1 1951  
316 0 0 7 338 1950 1205 0 0 1 10 init_value 1 1953  
317 0 0 6 339 1950 0 0 0 2 4 this 3 1950  4 copy 1 1951  
318 0 0 7 340 1950 1205 0 0 0 
319 0 0 7 341 1950 1205 0 0 0 
320 0 0 7 342 1950 1205 0 0 1 7 on_bits 1 1886  
321 0 0 7 343 1950 1205 0 0 1 5 index 1 1886  
322 0 0 7 344 1950 1205 0 0 2 7 low_bit 1 1886  4 size 1 1886  
323 0 0 6 346 1900 0 0 0 0 
324 0 0 6 347 1886 0 0 0 0 
325 0 0 6 348 1886 0 0 0 0 
326 0 0 6 349 1900 0 0 0 2 4 this 3 1951  5 index 1 1886  
327 0 0 4 350 1889 0 0 0 2 4 this 3 1950  5 index 1 1886  
328 0 0 4 351 1889 0 0 0 2 4 this 3 1950  5 index 1 1886  
329 0 0 4 352 1889 0 0 0 3 4 this 3 1950  5 index 1 1886  5 value 1 1900  
330 0 0 6 353 1900 0 0 0 1 4 this 3 1951  
331 0 0 6 354 1900 0 0 0 1 4 this 3 1951  
332 0 0 6 355 1953 0 0 0 3 4 this 3 1951  7 low_bit 1 1886  4 size 1 1886  
333 0 0 4 356 1889 0 0 0 4 4 this 3 1950  5 value 1 1953  7 low_bit 1 1886  4 size 1 1886  
334 0 0 6 357 1900 0 0 0 3 4 this 3 1951  7 low_bit 1 1886  4 size 1 1886  
335 0 0 6 358 1900 0 0 0 3 4 this 3 1951  7 low_bit 1 1886  4 size 1 1886  
336 0 0 4 359 1889 0 0 0 3 4 this 3 1950  7 low_bit 1 1886  4 size 1 1886  
337 0 0 4 360 1889 0 0 0 3 4 this 3 1950  7 low_bit 1 1886  4 size 1 1886  
338 0 0 4 361 1889 0 0 0 4 4 this 3 1950  5 value 1 1900  7 low_bit 1 1886  4 size 1 1886  
339 0 0 6 362 1953 0 0 0 1 4 this 3 1951  
340 0 0 4 363 1889 0 0 0 2 4 this 3 1950  5 value 1 1953  
341 0 0 6 364 1886 0 0 0 1 4 this 3 1951  
342 0 0 6 365 1886 0 0 0 1 4 this 3 1951  
343 0 0 6 366 1886 0 0 0 1 4 this 3 1951  
344 0 0 6 367 1886 0 0 0 1 4 this 3 1951  
345 0 0 6 368 1886 0 0 0 1 4 this 3 1951  
346 0 0 6 369 1886 0 0 0 1 4 this 3 1951  
347 0 0 6 370 1886 0 0 0 2 4 this 3 1951  7 low_bit 1 1886  
348 0 0 4 371 1889 0 0 0 1 4 this 3 1950  
349 0 0 6 372 1900 0 0 0 2 4 this 3 1951  5 other 1 1951  
350 0 0 4 373 1889 0 0 0 1 4 this 3 1950  
351 0 0 4 374 1889 0 0 0 2 4 this 3 1951  3 out 1 1893  
352 0 0 4 375 1889 0 0 0 3 4 this 3 1951  3 out 1 1893  12 spaces_every 1 1886  
353 0 0 4 376 1889 0 0 0 3 4 this 3 1951  3 out 1 1893  12 spaces_every 1 1886  
354 0 0 4 377 1889 0 0 0 3 4 this 3 1951  3 out 1 1893  12 indent_level 1 1886  
355 0 0 6 378 1900 0 0 0 2 4 this 3 1951  5 other 1 1951  
356 0 0 6 379 1900 0 0 0 2 4 this 3 1951  5 other 1 1951  
357 0 0 6 380 1900 0 0 0 2 4 this 3 1951  5 other 1 1951  
358 0 0 6 381 1886 0 0 0 2 4 this 3 1951  5 other 1 1951  
359 0 0 7 382 1950 1205 0 0 2 4 this 3 1951  5 other 1 1951  
360 0 0 7 383 1950 1205 0 0 2 4 this 3 1951  5 other 1 1951  
361 0 0 7 384 1950 1205 0 0 2 4 this 3 1951  5 other 1 1951  
362 0 0 7 385 1950 1205 0 0 1 4 this 3 1951  
363 0 0 7 386 1950 1205 0 0 2 4 this 3 1951  5 shift 1 1886  
364 0 0 7 387 1950 1205 0 0 2 4 this 3 1951  5 shift 1 1886  
365 0 0 6 388 1950 0 0 0 2 4 this 3 1950  5 other 1 1951  
366 0 0 6 389 1950 0 0 0 2 4 this 3 1950  5 other 1 1951  
367 0 0 6 390 1950 0 0 0 2 4 this 3 1950  5 other 1 1951  
368 0 0 6 391 1950 0 0 0 2 4 this 3 1950  5 shift 1 1886  
369 0 0 6 392 1950 0 0 0 2 4 this 3 1950  5 shift 1 1886  
370 0 0 4 393 1889 0 0 0 1 4 this 3 1950  
371 0 0 4 394 1889 0 0 0 1 4 this 3 1950  
372 0 0 7 395 1950 1205 0 0 1 4 this 3 1951  
373 0 0 7 396 1950 1205 0 0 1 4 this 3 1951  
374 0 0 7 397 1950 1205 0 0 1 4 this 3 1951  
375 0 0 7 397 1950 1205 0 0 2 4 this 3 1951  5 other 1 1951  
376 0 0 7 397 1950 1205 0 0 2 4 this 3 1951  5 index 1 1886  
377 0 0 7 398 1950 1205 0 0 1 4 this 3 1951  
378 0 0 7 398 1950 1205 0 0 2 4 this 3 1951  5 other 1 1951  
379 0 0 7 398 1950 1205 0 0 2 4 this 3 1951  5 index 1 1886  
380 0 0 6 399 1886 0 0 0 1 4 this 3 1951  
381 0 0 6 400 1900 0 0 0 1 4 this 3 1951  
382 0 0 7 401 1896 0 0 0 0 
383 0 0 7 406 1955 1269 0 220 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
384 0 0 7 406 1955 1269 0 225 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1956  
385 0 0 7 406 1955 1269 0 0 1 10 init_value 1 1958  
386 0 0 7 406 1955 1269 0 239 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Constructor (from SparseArray)
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 from 1 1959  
387 0 0 6 407 1955 0 0 233 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Copy Assignment Operator
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1955  4 copy 1 1956  
388 0 0 7 408 1955 1269 0 317 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray with an infinite array of bits,
//               all on.
//////////////////////////////////////////////////////////////////// 0 
389 0 0 7 409 1955 1269 0 284 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose bits are all off.
//////////////////////////////////////////////////////////////////// 0 
390 0 0 7 410 1955 1269 0 295 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named lower_on constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose lower on_bits bits are on.
//////////////////////////////////////////////////////////////////// 1 7 on_bits 1 1886  
391 0 0 7 411 1955 1269 0 289 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named bit constructor
//       Access: Published, Static
//  Description: Returns a BitArray with only the indicated bit on.
//////////////////////////////////////////////////////////////////// 1 5 index 1 1886  
392 0 0 7 412 1955 1269 0 323 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::Named range constructor
//       Access: Published, Static
//  Description: Returns a BitArray whose size bits, beginning at
//               low_bit, are on.
//////////////////////////////////////////////////////////////////// 2 7 low_bit 1 1886  4 size 1 1886  
393 0 0 6 414 1900 0 0 714 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_max_num_bits
//       Access: Published, Static
//  Description: Returns true if there is a maximum number of bits
//               that may be stored in this structure, false
//               otherwise.  If this returns true, the number may be
//               queried in get_max_num_bits().
//
//               This method always returns false.  The BitArray has
//               no maximum number of bits.  This method is defined so
//               generic programming algorithms can use BitMask or
//               BitArray interchangeably.
//////////////////////////////////////////////////////////////////// 0 
394 0 0 6 415 1886 0 0 749 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_max_num_bits
//       Access: Published, Static
//  Description: If get_max_num_bits() returned true, this method may
//               be called to return the maximum number of bits that
//               may be stored in this structure.  It is an error to
//               call this if get_max_num_bits() return false.
//
//               It is always an error to call this method.  The
//               BitArray has no maximum number of bits.  This method
//               is defined so generic programming algorithms can use
//               BitMask or BitArray interchangeably.
//////////////////////////////////////////////////////////////////// 0 
395 0 0 6 416 1886 0 0 476 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_bits_per_word
//       Access: Published, Static
//  Description: Returns the number of bits stored per word
//               internally.  This is of interest only in that it
//               limits the maximum number of bits that may be queried
//               or set at once by extract() and store().
//////////////////////////////////////////////////////////////////// 0 
396 0 0 6 417 1886 0 0 604 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_bits
//       Access: Published
//  Description: Returns the current number of possibly different bits
//               in this array.  There are actually an infinite number
//               of bits, but every bit higher than this bit will have
//               the same value, either 0 or 1 (see
//               get_highest_bits()).
//
//               This number may grow and/or shrink automatically as
//               needed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
397 0 0 6 418 1900 0 0 442 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_bit
//       Access: Published
//  Description: Returns true if the nth bit is set, false if it is
//               cleared.  It is valid for n to increase beyond
//               get_num_bits(), but the return value get_num_bits()
//               will always be the same.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1956  5 index 1 1886  
398 0 0 4 419 1889 0 0 317 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_bit
//       Access: Published
//  Description: Sets the nth bit on.  If n >= get_num_bits(), this
//               automatically extends the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1955  5 index 1 1886  
399 0 0 4 420 1889 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear_bit
//       Access: Published
//  Description: Sets the nth bit off.  If n >= get_num_bits(), this
//               automatically extends the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1955  5 index 1 1886  
400 0 0 4 421 1889 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_bit_to
//       Access: Published
//  Description: Sets the nth bit either on or off, according to the
//               indicated bool value.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1955  5 index 1 1886  5 value 1 1900  
401 0 0 6 422 1900 0 0 364 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_bits
//       Access: Published
//  Description: Returns true if the infinite set of bits beyond
//               get_num_bits() are all on, or false of they are all
//               off.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
402 0 0 6 423 1900 0 0 294 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::is_zero
//       Access: Published
//  Description: Returns true if the entire bitmask is zero, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
403 0 0 6 424 1900 0 0 295 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::is_all_on
//       Access: Published
//  Description: Returns true if the entire bitmask is one, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
404 0 0 6 425 1958 0 0 438 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::extract
//       Access: Published
//  Description: Returns a word that represents only the indicated
//               range of bits within this BitArray, shifted to the
//               least-significant position.  size must be <=
//               get_num_bits_per_word().
//////////////////////////////////////////////////////////////////// 3 4 this 3 1956  7 low_bit 1 1886  4 size 1 1886  
405 0 0 4 426 1889 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::store
//       Access: Published
//  Description: Stores the indicated word into the indicated range of
//               bits with this BitArray.
//////////////////////////////////////////////////////////////////// 4 4 this 3 1955  5 value 1 1958  7 low_bit 1 1886  4 size 1 1886  
406 0 0 6 427 1900 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_any_of
//       Access: Published
//  Description: Returns true if any bit in the indicated range is
//               set, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1956  7 low_bit 1 1886  4 size 1 1886  
407 0 0 6 428 1900 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_all_of
//       Access: Published
//  Description: Returns true if all bits in the indicated range are
//               set, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1956  7 low_bit 1 1886  4 size 1 1886  
408 0 0 4 429 1889 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_range
//       Access: Published
//  Description: Sets the indicated range of bits on.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1955  7 low_bit 1 1886  4 size 1 1886  
409 0 0 4 430 1889 0 0 258 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear_range
//       Access: Published
//  Description: Sets the indicated range of bits off.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1955  7 low_bit 1 1886  4 size 1 1886  
410 0 0 4 431 1889 0 0 275 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_range_to
//       Access: Published
//  Description: Sets the indicated range of bits to either on or off.
//////////////////////////////////////////////////////////////////// 4 4 this 3 1955  5 value 1 1900  7 low_bit 1 1886  4 size 1 1886  
411 0 0 6 432 1886 0 0 372 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_on_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 1 in the
//               array.  Returns -1 if there are an infinite number of
//               1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
412 0 0 6 433 1886 0 0 373 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_off_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 0 in the
//               array.  Returns -1 if there are an infinite number of
//               0 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
413 0 0 6 434 1886 0 0 330 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_lowest_on_bit
//       Access: Published
//  Description: Returns the index of the lowest 1 bit in the array.
//               Returns -1 if there are no 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
414 0 0 6 435 1886 0 0 331 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_lowest_off_bit
//       Access: Published
//  Description: Returns the index of the lowest 0 bit in the array.
//               Returns -1 if there are no 0 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
415 0 0 6 436 1886 0 0 390 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_on_bit
//       Access: Published
//  Description: Returns the index of the highest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
416 0 0 6 437 1886 0 0 391 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_highest_off_bit
//       Access: Published
//  Description: Returns the index of the highest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
417 0 0 6 438 1886 0 0 591 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_next_higher_different_bit
//       Access: Published
//  Description: Returns the index of the next bit in the array, above
//               low_bit, whose value is different that the value of
//               low_bit.  Returns low_bit again if all bits higher
//               than low_bit have the same value.
//
//               This can be used to quickly iterate through all of
//               the bits in the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1956  7 low_bit 1 1886  
418 0 0 6 439 1886 0 0 304 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_num_words
//       Access: Published
//  Description: Returns the number of possibly-unique words stored in
//               the array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1956  
419 0 0 7 440 1962 0 0 410 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::get_word
//       Access: Published
//  Description: Returns the nth word in the array.  It is valid for n
//               to be greater than get_num_words(), but the return
//               value beyond get_num_words() will always be the same.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1956  1 n 1 1886  
420 0 0 4 441 1889 0 0 351 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::set_word
//       Access: Published
//  Description: Replaces the nth word in the array.  If n >=
//               get_num_words(), this automatically extends the
//               array.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1955  1 n 1 1886  5 value 1 1958  
421 0 0 4 442 1889 0 0 318 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::invert_in_place
//       Access: Published
//  Description: Inverts all the bits in the BitArray.  This is
//               equivalent to array = ~array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1955  
422 0 0 6 443 1900 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::has_bits_in_common
//       Access: Published
//  Description: Returns true if this BitArray has any "one" bits in
//               common with the other one, false otherwise.
//
//               This is equivalent to (array & other) != 0, but may
//               be faster.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1956  5 other 1 1956  
423 0 0 4 444 1889 0 0 253 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::clear
//       Access: Published
//  Description: Sets all the bits in the BitArray off.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1955  
424 0 0 4 445 1889 0 0 443 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::output
//       Access: Published
//  Description: Writes the BitArray out as a hex number.  For a
//               BitArray, this is always the same as output_hex();
//               it's too confusing for the output format to change
//               back and forth at runtime.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1956  3 out 1 1893  
425 0 0 4 446 1889 0 0 312 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::output_binary
//       Access: Published
//  Description: Writes the BitArray out as a binary number, with
//               spaces every four bits.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1956  3 out 1 1893  12 spaces_every 1 1886  
426 0 0 4 447 1889 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::output_hex
//       Access: Published
//  Description: Writes the BitArray out as a hexadecimal number, with
//               spaces every four digits.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1956  3 out 1 1893  12 spaces_every 1 1886  
427 0 0 4 448 1889 0 0 317 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::write
//       Access: Published
//  Description: Writes the BitArray out as a binary or a hex number,
//               according to the number of bits.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1956  3 out 1 1893  12 indent_level 1 1886  
428 0 0 6 449 1900 0 0 0 2 4 this 3 1956  5 other 1 1956  
429 0 0 6 450 1900 0 0 0 2 4 this 3 1956  5 other 1 1956  
430 0 0 6 451 1900 0 0 0 2 4 this 3 1956  5 other 1 1956  
431 0 0 6 452 1886 0 0 487 ////////////////////////////////////////////////////////////////////
//     Function: BitArray::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this BitArray sorts
//               before the indicated other BitArray, greater than zero
//               if it sorts after, or 0 if they are equivalent.  This
//               is based on the same ordering defined by operator <.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1956  5 other 1 1956  
432 0 0 7 453 1955 1269 0 0 2 4 this 3 1956  5 other 1 1956  
433 0 0 7 454 1955 1269 0 0 2 4 this 3 1956  5 other 1 1956  
434 0 0 7 455 1955 1269 0 0 2 4 this 3 1956  5 other 1 1956  
435 0 0 7 456 1955 1269 0 0 1 4 this 3 1956  
436 0 0 7 457 1955 1269 0 0 2 4 this 3 1956  5 shift 1 1886  
437 0 0 7 458 1955 1269 0 0 2 4 this 3 1956  5 shift 1 1886  
438 0 0 6 459 1955 0 0 0 2 4 this 3 1955  5 other 1 1956  
439 0 0 6 460 1955 0 0 0 2 4 this 3 1955  5 other 1 1956  
440 0 0 6 461 1955 0 0 0 2 4 this 3 1955  5 other 1 1956  
441 0 0 6 462 1955 0 0 0 2 4 this 3 1955  5 shift 1 1886  
442 0 0 6 463 1955 0 0 0 2 4 this 3 1955  5 shift 1 1886  
443 0 0 7 464 1896 0 0 0 0 
444 0 0 7 466 1963 1340 0 539 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: The default constructor must do nothing, because we
//               can't guarantee ordering of static initializers.  If
//               the constructor tried to initialize its value, it
//               might happen after the value had already been set
//               previously by another static initializer!
//////////////////////////////////////////////////////////////////// 0 
445 0 0 7 466 1963 1340 0 229 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1964  
446 0 0 7 466 1963 1340 0 399 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: Constructs a ButtonHandle with the corresponding
//               index number, which may have been returned by an
//               earlier call to ButtonHandle::get_index().
//////////////////////////////////////////////////////////////////// 1 5 index 1 1886  
447 0 0 7 466 1963 1340 0 644 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::Constructor
//       Access: Published
//  Description: Constructs a ButtonHandle with the corresponding
//               name, which is looked up in the ButtonRegistry.
//               This exists for the purpose of being able to
//               automatically coerce a string into a ButtonHandle;
//               for most purposes, you should use either the static
//               KeyboardButton/MouseButton getters or
//               ButtonRegistry::register_button().
//////////////////////////////////////////////////////////////////// 1 4 name 1 1885  
448 0 0 6 467 1900 0 0 0 2 4 this 3 1964  5 other 1 1964  
449 0 0 6 468 1900 0 0 0 2 4 this 3 1964  5 other 1 1964  
450 0 0 6 469 1900 0 0 0 2 4 this 3 1964  5 other 1 1964  
451 0 0 6 470 1900 0 0 0 2 4 this 3 1964  5 other 1 1964  
452 0 0 6 471 1900 0 0 0 2 4 this 3 1964  5 other 1 1964  
453 0 0 6 472 1900 0 0 0 2 4 this 3 1964  5 other 1 1964  
454 0 0 6 473 1886 0 0 467 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::compare_to
//       Access: Published
//  Description: Sorts ButtonHandles arbitrarily (according to <, >,
//               etc.).  Returns a number less than 0 if this type
//               sorts before the other one, greater than zero if it
//               sorts after, 0 if they are equivalent.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1964  5 other 1 1964  
455 0 0 6 474 1882 0 0 265 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_hash
//       Access: Published
//  Description: Returns a hash code suitable for phash_map.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1964  
456 0 0 6 475 1885 0 0 250 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_name
//       Access: Public
//  Description: Returns the name of the button.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1964  
457 0 0 6 476 1900 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::has_ascii_equivalent
//       Access: Published
//  Description: Returns true if the button was created with an ASCII
//               equivalent code (e.g. for a standard keyboard
//               button).
//////////////////////////////////////////////////////////////////// 1 4 this 3 1964  
458 0 0 6 477 1966 0 0 346 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_ascii_equivalent
//       Access: Published
//  Description: Returns the character code associated with the
//               button, or '\0' if no ASCII code was associated.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1964  
459 0 0 7 478 1963 1340 0 692 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_alias
//       Access: Published
//  Description: Returns the alias (alternate name) associated with
//               the button, if any, or ButtonHandle::none() if the
//               button has no alias.
//
//               Each button is allowed to have one alias, and
//               multiple different buttons can refer to the same
//               alias.  The alias should be the more general name for
//               the button, for instance, shift is an alias for
//               lshift, but not vice-versa.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1964  
460 0 0 6 479 1900 0 0 532 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::matches
//       Access: Published
//  Description: Returns true if this ButtonHandle is the same as the
//               other one, or if the other one is an alias for this
//               one.  (Does not return true if this button is an
//               alias for the other one, however.)
//
//               This is a more general comparison than operator ==.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1964  5 other 1 1964  
461 0 0 6 480 1886 0 0 664 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::get_index
//       Access: Published
//  Description: Returns the integer index associated with this
//               ButtonHandle. Each different ButtonHandle will have a
//               different index.  However, you probably shouldn't be
//               using this method; you should just treat the
//               ButtonHandles as opaque classes.  This is provided
//               for the convenience of non-C++ scripting languages to
//               build a hashtable of ButtonHandles.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1964  
462 0 0 4 481 1889 0 0 219 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1964  3 out 1 1893  
463 0 0 7 482 1963 1340 0 321 ////////////////////////////////////////////////////////////////////
//     Function: ButtonHandle::none
//       Access: Published, Static
//  Description: Returns a special zero-valued ButtonHandle that is
//               used to indicate no button.
//////////////////////////////////////////////////////////////////// 0 
464 0 0 7 484 1896 0 0 0 0 
465 0 0 6 483 1900 0 0 0 1 4 this 3 1964  
466 0 0 7 487 1963 1340 0 396 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::get_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated name.  If there is no such ButtonHandle,
//               registers a new one and returns it.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1967  4 name 1 1885  
467 0 0 7 488 1963 1340 0 391 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::find_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated name.  If there is no such ButtonHandle,
//               returns ButtonHandle::none().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1967  4 name 1 1885  
468 0 0 7 489 1963 1340 0 419 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::find_ascii_button
//       Access: Published
//  Description: Finds a ButtonHandle in the registry matching the
//               indicated ASCII equivalent character.  If there is no
//               such ButtonHandle, returns ButtonHandle::none().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1968  16 ascii_equivalent 1 1966  
469 0 0 4 490 1889 0 0 220 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::write
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1968  3 out 1 1893  
470 0 0 6 491 1967 0 0 300 ////////////////////////////////////////////////////////////////////
//     Function: ButtonRegistry::ptr
//       Access: Published, Static
//  Description: Returns the pointer to the global ButtonRegistry
//               object.
//////////////////////////////////////////////////////////////////// 0 
471 0 0 6 495 1886 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_num_buttons
//       Access: Published
//  Description: Returns the number of buttons that this button
//               mapping specifies.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1970  
472 0 0 7 496 1963 1340 0 307 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_raw_button
//       Access: Published
//  Description: Returns the underlying raw button associated with
//               the nth button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1970  1 i 1 1886  
473 0 0 7 497 1963 1340 0 411 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the button that the given button is mapped
//               to, or ButtonHandle::none() if this map does not
//               specify a mapped button for the given raw button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1970  3 raw 1 1963  
474 0 0 7 497 1963 1340 0 332 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the nth mapped button, meaning the button
//               that the nth raw button is mapped to.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1970  1 i 1 1886  
475 0 0 7 497 1963 1340 0 411 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button
//       Access: Published
//  Description: Returns the button that the given button is mapped
//               to, or ButtonHandle::none() if this map does not
//               specify a mapped button for the given raw button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1970  8 raw_name 1 1885  
476 0 0 6 498 1885 0 0 664 ////////////////////////////////////////////////////////////////////
//     Function: ButtoMap::get_mapped_button_label
//       Access: Published
//  Description: If the button map specifies a special name for the
//               button (eg. if the operating system or keyboard
//               device has a localized name describing the key),
//               returns it, or the empty string otherwise.
//
//               Note that this is not the same as
//               get_mapped_button().get_name(), which returns the
//               name of the Panda event associated with the button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1970  3 raw 1 1963  
477 0 0 6 498 1885 0 0 381 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::get_mapped_button_label
//       Access: Published
//  Description: Returns the label associated with the nth mapped
//               button, meaning the button that the nth raw
//               button is mapped to.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1970  1 i 1 1886  
478 0 0 6 498 1885 0 0 664 ////////////////////////////////////////////////////////////////////
//     Function: ButtoMap::get_mapped_button_label
//       Access: Published
//  Description: If the button map specifies a special name for the
//               button (eg. if the operating system or keyboard
//               device has a localized name describing the key),
//               returns it, or the empty string otherwise.
//
//               Note that this is not the same as
//               get_mapped_button().get_name(), which returns the
//               name of the Panda event associated with the button.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1970  8 raw_name 1 1885  
479 0 0 4 499 1889 0 0 217 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1970  3 out 1 1893  
480 0 0 4 500 1889 0 0 216 ////////////////////////////////////////////////////////////////////
//     Function: ButtonMap::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 1970  3 out 1 1893  12 indent_level 1 1886  
481 0 0 7 501 1896 0 0 0 0 
482 0 0 4 504 1889 0 0 230 ////////////////////////////////////////////////////////////////////
//     Function: CallbackObject::output
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1972  3 out 1 1893  
483 0 0 7 505 1974 1358 0 0 1 8 function 1 1879  
484 0 0 7 506 1896 0 0 0 0 
485 0 0 6 509 1886 0 0 290 ////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::get_cache_ref_count
//       Access: Published
//  Description: Returns the current reference count.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1975  
486 0 0 4 510 1889 0 0 355 ////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::cache_ref
//       Access: Published
//  Description: Explicitly increments the cache reference count and
//               the normal reference count simultaneously.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1975  
487 0 0 6 511 1900 0 0 479 ////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::cache_unref
//       Access: Published
//  Description: Explicitly decrements the cache reference count and
//               the normal reference count simultaneously.
//
//               The return value is true if the new reference count
//               is nonzero, false if it is zero.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1975  
488 0 0 6 512 1900 0 0 359 ////////////////////////////////////////////////////////////////////
//     Function: CachedTypedWritableReferenceCount::test_ref_count_integrity
//       Access: Published
//  Description: Does some easy checks to make sure that the reference
//               count isn't completely bogus.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1975  
489 0 0 7 513 1896 0 0 0 0 
490 0 0 4 515 1889 0 0 228 ////////////////////////////////////////////////////////////////////
//     Function: CallbackData::output
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 1977  3 out 1 1893  
491 0 0 4 516 1889 0 0 408 ////////////////////////////////////////////////////////////////////
//     Function: CallbackData::upcall
//       Access: Published, Virtual
//  Description: You should make this call during the callback if you
//               want to continue the normal function that would have
//               been done in the absence of a callback.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1979  
492 0 0 7 517 1896 0 0 0 0 
493 0 0 7 520 1980 1358 0 0 1 8 function 1 1879  
494 0 0 4 521 1889 0 0 0 2 4 this 3 1980  4 size 1 1882  
495 0 0 4 524 1889 0 0 0 2 4 this 3 1980  8 function 1 1879  
496 0 0 6 525 1879 0 0 0 1 4 this 3 1980  
497 0 0 7 526 1896 0 0 0 0 
498 0 0 7 528 1981 1380 0 218 ////////////////////////////////////////////////////////////////////
//     Function: TimeVal::contructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
499 0 0 6 529 1813 0 0 215 ////////////////////////////////////////////////////////////////////
//     Function: TimeVal::get_sec
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 1982  
500 0 0 6 530 1813 0 0 216 ////////////////////////////////////////////////////////////////////
//     Function: TimeVal::get_usec
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 1982  
501 0 0 4 535 1889 0 0 0 2 4 this 3 1981  5 value 1 1812  
502 0 0 4 534 1889 0 0 0 1 4 this 3 1982  
503 0 0 7 540 1984 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
504 0 0 7 540 1984 0 0 229 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1985  
505 0 0 4 541 1889 0 0 2596 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_mode
//       Access: Published
//  Description: Changes the mode of the clock.  Normally, the clock
//               is in mode M_normal. In this mode, each call to
//               tick() will set the value returned by
//               get_frame_time() to the current real time; thus, the
//               clock simply reports time advancing.
//
//               Other possible modes:
//
//               M_non_real_time - the clock ignores real time
//               completely; at each call to tick(), it pretends that
//               exactly dt seconds have elapsed since the last call
//               to tick().  You may set the value of dt with
//               set_dt() or set_frame_rate().
//
//               M_limited - the clock will run as fast as it can, as
//               in M_normal, but will not run faster than the rate
//               specified by set_frame_rate().  If the application
//               would run faster than this rate, the clock will slow
//               down the application.
//
//               M_integer - the clock will run as fast as it can, but
//               the rate will be constrained to be an integer
//               multiple or divisor of the rate specified by
//               set_frame_rate().  The clock will slow down the
//               application a bit to guarantee this.
//
//               M_integer_limited - a combination of M_limited and
//               M_integer; the clock will not run faster than
//               set_frame_rate(), and if it runs slower, it will run
//               at a integer divisor of that rate.
//
//               M_forced - the clock forces the application to run at
//               the rate specified by set_frame_rate().  If the
//               application would run faster than this rate, the
//               clock will slow down the application; if the
//               application would run slower than this rate, the
//               clock slows down time so that the application
//               believes it is running at the given rate.
//
//               M_degrade - the clock runs at real time, but the
//               application is slowed down by a set factor of its
//               frame rate, specified by set_degrade_factor().
//
//               M_slave - the clock does not advance, but relies on
//               the user to call set_frame_time() and/or
//               set_frame_count() each frame.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  4 mode 1 1816  
506 0 0 6 542 1816 0 0 293 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_mode
//       Access: Published
//  Description: Returns the current mode of the clock.  See
//               set_mode().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1985  
507 0 0 6 543 1899 0 0 656 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_frame_time
//       Access: Published
//  Description: Returns the time in seconds as of the last time
//               tick() was called (typically, this will be as of the
//               start of the current frame).
//
//               This is generally the kind of time you want to ask
//               for in most rendering and animation contexts, since
//               it's important that all of the animation for a given
//               frame remains in sync with each other.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1985  14 current_thread 1 1987  
508 0 0 6 544 1899 0 0 769 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_real_time
//       Access: Published
//  Description: Returns the actual number of seconds elapsed since
//               the ClockObject was created, or since it was last
//               reset.  This is useful for doing real timing
//               measurements, e.g. for performance statistics.
//
//               This returns the most precise timer we have for short
//               time intervals, but it may tend to drift over the
//               long haul.  If more accurate timekeeping is needed
//               over a long period of time, use get_long_time()
//               instead.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1985  
509 0 0 6 545 1899 0 0 773 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_long_time
//       Access: Published
//  Description: Returns the actual number of seconds elapsed since
//               the ClockObject was created, or since it was last
//               reset.
//
//               This is similar to get_real_time(), except that it
//               uses the most accurate counter we have over a long
//               period of time, and so it is less likely to drift.
//               However, it may not be very precise for measuring
//               short intervals.  On Windows, for instace, this is
//               only accurate to within about 55 milliseconds.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1985  
510 0 0 4 546 1889 0 0 299 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::reset
//       Access: Published
//  Description: Simultaneously resets both the time and the frame
//               count to zero.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1984  
511 0 0 4 547 1889 0 0 607 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_real_time
//       Access: Published
//  Description: Resets the clock to the indicated time.  This
//               changes only the real time of the clock as reported
//               by get_real_time(), but does not immediately change
//               the time reported by get_frame_time()--that will
//               change after the next call to tick().  Also see
//               reset(), set_frame_time(), and set_frame_count().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  4 time 1 1899  
512 0 0 4 548 1889 0 0 477 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_time
//       Access: Published
//  Description: Changes the time as reported for the current frame to
//               the indicated time.  Normally, the way to adjust the
//               frame time is via tick(); this function is provided
//               only for occasional special adjustments.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1984  4 time 1 1899  14 current_thread 1 1987  
513 0 0 4 549 1889 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_count
//       Access: Published
//  Description: Resets the number of frames counted to the indicated
//               number.  Also see reset(), set_real_time(), and
//               set_frame_time().
//////////////////////////////////////////////////////////////////// 3 4 this 3 1984  11 frame_count 1 1886  14 current_thread 1 1987  
514 0 0 6 550 1886 0 0 457 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_frame_count
//       Access: Published
//  Description: Returns the number of times tick() has been called
//               since the ClockObject was created, or since it was
//               last reset.  This is generally the number of frames
//               that have been rendered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1985  14 current_thread 1 1987  
515 0 0 6 551 1899 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_net_frame_rate
//       Access: Published
//  Description: Returns the average frame rate since the last reset.
//               This is simply the total number of frames divided by
//               the total elapsed time.  This reports the virtual
//               frame rate if the clock is in (or has been in)
//               M_non_real_time mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1985  14 current_thread 1 1987  
516 0 0 6 552 1899 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_dt
//       Access: Published
//  Description: Returns the elapsed time for the previous frame: the
//               number of seconds elapsed between the last two calls
//               to tick().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1985  14 current_thread 1 1987  
517 0 0 4 553 1889 0 0 575 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_dt
//       Access: Published
//  Description: In non-real-time mode, sets the number of seconds
//               that should appear to elapse between frames.  In
//               forced mode or limited mode, sets our target dt.  In
//               normal mode, this has no effect.  
//
//               Also see set_frame_rate(), which is a different way
//               to specify the same quantity.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  2 dt 1 1899  
518 0 0 4 554 1889 0 0 583 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_frame_rate
//       Access: Published
//  Description: In non-real-time mode, sets the number of frames per
//               second that we should appear to be running.  In forced
//               mode or limited mode, sets our target frame rate.  In
//               normal mode, this has no effect.
//
//               Also see set_dt(), which is a different way to
//               specify the same quantity.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  10 frame_rate 1 1899  
519 0 0 6 555 1899 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_max_dt
//       Access: Published
//  Description: Returns the current maximum allowable time elapsed
//               between any two frames.  See set_max_dt().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1985  
520 0 0 4 556 1889 0 0 872 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_max_dt
//       Access: Published
//  Description: Sets a limit on the value returned by get_dt().  If
//               this value is less than zero, no limit is imposed;
//               otherwise, this is the maximum value that will ever
//               be returned by get_dt(), regardless of how much time
//               has actually elapsed between frames.
//
//               This limit is only imposed in real-time mode; in
//               non-real-time mode, the dt is fixed anyway and max_dt
//               is ignored.
//
//               This is generally used to guarantee reasonable
//               behavior even in the presence of a very slow or
//               chuggy frame rame.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  6 max_dt 1 1899  
521 0 0 6 557 1899 0 0 544 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_degrade_factor
//       Access: Published
//  Description: In degrade mode, returns the ratio by which the
//               performance is degraded.  A value of 2.0 causes the
//               clock to be slowed down by a factor of two (reducing
//               performance to 1/2 what would be otherwise).
//
//               This has no effect if mode is not M_degrade.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1985  
522 0 0 4 558 1889 0 0 541 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_degrade_factor
//       Access: Published
//  Description: In degrade mode, sets the ratio by which the
//               performance is degraded.  A value of 2.0 causes the
//               clock to be slowed down by a factor of two (reducing
//               performance to 1/2 what would be otherwise).
//
//               This has no effect if mode is not M_degrade.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  14 degrade_factor 1 1899  
523 0 0 4 559 1889 0 0 729 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::set_average_frame_rate_interval
//       Access: Published
//  Description: Specifies the interval of time (in seconds) over
//               which get_average_frame_rate() averages the number of
//               frames per second to compute the frame rate.
//               Changing this does not necessarily immediately change
//               the result of get_average_frame_rate(), until this
//               interval of time has elapsed again.
//
//               Setting this to zero disables the computation of
//               get_average_frame_rate().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  4 time 1 1899  
524 0 0 6 560 1899 0 0 423 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_average_frame_rate_interval
//       Access: Published
//  Description: Returns the interval of time (in seconds) over
//               which get_average_frame_rate() averages the number of frames
//               per second to compute the frame rate.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1985  
525 0 0 6 561 1899 0 0 500 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_average_frame_rate
//       Access: Published
//  Description: Returns the average frame rate in number of frames
//               per second over the last
//               get_average_frame_rate_interval() seconds.  This
//               measures the virtual frame rate if the clock is in
//               M_non_real_time mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1985  14 current_thread 1 1987  
526 0 0 6 562 1899 0 0 343 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_max_frame_duration
//       Access: Published
//  Description: Returns the maximum frame duration over the last
//               get_average_frame_rate_interval() seconds.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1985  14 current_thread 1 1987  
527 0 0 6 563 1899 0 0 915 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::calc_frame_time_deviation
//       Access: Published
//  Description: Returns the standard deviation of the frame times of
//               the frames rendered over the past
//               get_average_frame_rate_interval() seconds.  This
//               number gives an estimate of the chugginess of the
//               frame rate; if it is large, there is a large
//               variation in the frame rate; if is small, all of the
//               frames are consistent in length.
//
//               A large value might also represent just a recent
//               change in frame rate, for instance, because the
//               camera has just rotated from looking at a simple
//               scene to looking at a more complex scene.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1985  14 current_thread 1 1987  
528 0 0 4 564 1889 0 0 566 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::tick
//       Access: Published
//  Description: Instructs the clock that a new frame has just begun.
//               In normal, real-time mode, get_frame_time() will
//               henceforth report the time as of this instant as the
//               current start-of-frame time.  In non-real-time mode,
//               get_frame_time() will be incremented by the value of
//               dt.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  14 current_thread 1 1987  
529 0 0 4 565 1889 0 0 756 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::sync_frame_time
//       Access: Published
//  Description: Resets the frame time to the current real time.  This
//               is similar to tick(), except that it does not advance
//               the frame counter and does not affect dt.  This is
//               intended to be used in the middle of a particularly
//               long frame to compensate for the time that has
//               already elapsed.
//
//               In non-real-time mode, this function has no effect
//               (because in this mode all frames take the same length
//               of time).
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  14 current_thread 1 1987  
530 0 0 6 566 1900 0 0 609 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::check_errors
//       Access: Published
//  Description: Returns true if a clock error was detected since the
//               last time check_errors() was called.  A clock error
//               means that something happened, an OS or BIOS bug, for
//               instance, that makes the current value of the clock
//               somewhat suspect, and an application may wish to
//               resynchronize with any external clocks.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1984  14 current_thread 1 1987  
531 0 0 7 567 1984 0 0 408 ////////////////////////////////////////////////////////////////////
//     Function: ClockObject::get_global_clock
//       Access: Published
//  Description: Returns a pointer to the global ClockObject.  This is
//               the ClockObject that most code should use for
//               handling scene graph rendering and animation.
//////////////////////////////////////////////////////////////////// 0 
532 0 0 7 568 1896 0 0 0 0 
533 0 0 4 576 1889 0 0 279 ////////////////////////////////////////////////////////////////////
//     Function: CopyOnWriteObject::cache_ref
//       Access: Published
//  Description: See CachedTypedWritableReferenceCount::cache_ref().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1989  
534 0 0 7 577 1896 0 0 0 0 
535 0 0 7 581 1991 0 0 229 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
536 0 0 6 582 1900 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Opens the indicated filename for reading.  Returns
//               true on success, false on failure.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1991  4 file 1 1992  
537 0 0 6 582 1900 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Opens the indicated filename for reading.  Returns
//               true on success, false on failure.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1991  8 filename 1 1921  
538 0 0 6 582 1900 0 0 504 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::open
//       Access: Published
//  Description: Starts reading from the indicated stream.  Returns
//               true on success, false on failure.  The
//               DatagramInputFile does not take ownership of the
//               stream; you are responsible for closing or deleting
//               it when you are done.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1991  2 in 1 1995  8 filename 1 1921  
539 0 0 6 583 1995 0 0 279 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::get_stream
//       Access: Published
//  Description: Returns the istream represented by the input file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1991  
540 0 0 4 584 1889 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::close
//       Access: Published
//  Description: Closes the file.  This is also implicitly done when
//               the DatagramInputFile destructs.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1991  
541 0 0 6 585 1900 0 0 535 ////////////////////////////////////////////////////////////////////
//     Function: DatagramInputFile::read_header
//       Access: Published
//  Description: Reads a sequence of bytes from the beginning of the
//               datagram file.  This may be called any number of
//               times after the file has been opened and before the
//               first datagram is read.  It may not be called once
//               the first datagram has been read.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1991  6 header 1 1912  9 num_bytes 1 1882  
542 0 0 7 587 1997 1429 0 0 0 
543 0 0 7 587 1997 1429 0 0 1 4 copy 1 1998  
544 0 0 6 588 1997 0 0 0 2 4 this 3 1997  4 copy 1 1998  
545 0 0 7 589 1997 1429 0 0 0 
546 0 0 7 590 1997 1429 0 0 0 
547 0 0 7 591 1997 1429 0 0 1 7 on_bits 1 1886  
548 0 0 7 592 1997 1429 0 0 1 5 index 1 1886  
549 0 0 7 593 1997 1429 0 0 2 7 low_bit 1 1886  4 size 1 1886  
550 0 0 6 595 1900 0 0 0 0 
551 0 0 6 596 1886 0 0 0 0 
552 0 0 6 597 1886 0 0 0 0 
553 0 0 6 598 1900 0 0 0 2 4 this 3 1998  5 index 1 1886  
554 0 0 4 599 1889 0 0 0 2 4 this 3 1997  5 index 1 1886  
555 0 0 4 600 1889 0 0 0 2 4 this 3 1997  5 index 1 1886  
556 0 0 4 601 1889 0 0 0 3 4 this 3 1997  5 index 1 1886  5 value 1 1900  
557 0 0 6 602 1900 0 0 0 1 4 this 3 1998  
558 0 0 6 603 1900 0 0 0 1 4 this 3 1998  
559 0 0 6 604 1949 0 0 0 3 4 this 3 1998  7 low_bit 1 1886  4 size 1 1886  
560 0 0 4 605 1889 0 0 0 4 4 this 3 1997  5 value 1 1949  7 low_bit 1 1886  4 size 1 1886  
561 0 0 6 606 1900 0 0 0 3 4 this 3 1998  7 low_bit 1 1886  4 size 1 1886  
562 0 0 6 607 1900 0 0 0 3 4 this 3 1998  7 low_bit 1 1886  4 size 1 1886  
563 0 0 4 608 1889 0 0 0 3 4 this 3 1997  7 low_bit 1 1886  4 size 1 1886  
564 0 0 4 609 1889 0 0 0 3 4 this 3 1997  7 low_bit 1 1886  4 size 1 1886  
565 0 0 4 610 1889 0 0 0 4 4 this 3 1997  5 value 1 1900  7 low_bit 1 1886  4 size 1 1886  
566 0 0 6 611 1886 0 0 0 1 4 this 3 1998  
567 0 0 6 612 1886 0 0 0 1 4 this 3 1998  
568 0 0 6 613 1886 0 0 0 1 4 this 3 1998  
569 0 0 6 614 1886 0 0 0 1 4 this 3 1998  
570 0 0 6 615 1886 0 0 0 1 4 this 3 1998  
571 0 0 6 616 1886 0 0 0 1 4 this 3 1998  
572 0 0 6 617 1886 0 0 0 2 4 this 3 1998  7 low_bit 1 1886  
573 0 0 4 618 1889 0 0 0 1 4 this 3 1997  
574 0 0 6 619 1900 0 0 0 2 4 this 3 1998  5 other 1 1998  
575 0 0 4 620 1889 0 0 0 1 4 this 3 1997  
576 0 0 4 621 1889 0 0 0 2 4 this 3 1998  3 out 1 1893  
577 0 0 4 622 1889 0 0 0 3 4 this 3 1998  3 out 1 1893  12 spaces_every 1 1886  
578 0 0 4 623 1889 0 0 0 3 4 this 3 1998  3 out 1 1893  12 spaces_every 1 1886  
579 0 0 4 624 1889 0 0 0 3 4 this 3 1998  3 out 1 1893  12 indent_level 1 1886  
580 0 0 6 625 1900 0 0 0 2 4 this 3 1998  5 other 1 1998  
581 0 0 6 626 1900 0 0 0 2 4 this 3 1998  5 other 1 1998  
582 0 0 6 627 1900 0 0 0 2 4 this 3 1998  5 other 1 1998  
583 0 0 6 628 1886 0 0 0 2 4 this 3 1998  5 other 1 1998  
584 0 0 7 629 1997 1429 0 0 2 4 this 3 1998  5 other 1 1998  
585 0 0 7 630 1997 1429 0 0 2 4 this 3 1998  5 other 1 1998  
586 0 0 7 631 1997 1429 0 0 2 4 this 3 1998  5 other 1 1998  
587 0 0 7 632 1997 1429 0 0 1 4 this 3 1998  
588 0 0 7 633 1997 1429 0 0 2 4 this 3 1998  5 shift 1 1886  
589 0 0 7 634 1997 1429 0 0 2 4 this 3 1998  5 shift 1 1886  
590 0 0 6 635 1997 0 0 0 2 4 this 3 1997  5 other 1 1998  
591 0 0 6 636 1997 0 0 0 2 4 this 3 1997  5 other 1 1998  
592 0 0 6 637 1997 0 0 0 2 4 this 3 1997  5 other 1 1998  
593 0 0 6 638 1997 0 0 0 2 4 this 3 1997  5 shift 1 1886  
594 0 0 6 639 1997 0 0 0 2 4 this 3 1997  5 shift 1 1886  
595 0 0 7 640 1896 0 0 0 0 
596 0 0 7 643 2000 1483 0 0 0 
597 0 0 7 643 2000 1483 0 0 1 4 copy 1 2001  
598 0 0 6 644 2000 0 0 0 2 4 this 3 2000  4 copy 1 2001  
599 0 0 7 645 2000 1483 0 0 0 
600 0 0 7 646 2000 1483 0 0 0 
601 0 0 7 647 2000 1483 0 0 1 7 on_bits 1 1886  
602 0 0 7 648 2000 1483 0 0 1 5 index 1 1886  
603 0 0 7 649 2000 1483 0 0 2 7 low_bit 1 1886  4 size 1 1886  
604 0 0 6 651 1900 0 0 0 0 
605 0 0 6 652 1886 0 0 0 0 
606 0 0 6 653 1886 0 0 0 0 
607 0 0 6 654 1900 0 0 0 2 4 this 3 2001  5 index 1 1886  
608 0 0 4 655 1889 0 0 0 2 4 this 3 2000  5 index 1 1886  
609 0 0 4 656 1889 0 0 0 2 4 this 3 2000  5 index 1 1886  
610 0 0 4 657 1889 0 0 0 3 4 this 3 2000  5 index 1 1886  5 value 1 1900  
611 0 0 6 658 1900 0 0 0 1 4 this 3 2001  
612 0 0 6 659 1900 0 0 0 1 4 this 3 2001  
613 0 0 6 660 1949 0 0 0 3 4 this 3 2001  7 low_bit 1 1886  4 size 1 1886  
614 0 0 4 661 1889 0 0 0 4 4 this 3 2000  5 value 1 1949  7 low_bit 1 1886  4 size 1 1886  
615 0 0 6 662 1900 0 0 0 3 4 this 3 2001  7 low_bit 1 1886  4 size 1 1886  
616 0 0 6 663 1900 0 0 0 3 4 this 3 2001  7 low_bit 1 1886  4 size 1 1886  
617 0 0 4 664 1889 0 0 0 3 4 this 3 2000  7 low_bit 1 1886  4 size 1 1886  
618 0 0 4 665 1889 0 0 0 3 4 this 3 2000  7 low_bit 1 1886  4 size 1 1886  
619 0 0 4 666 1889 0 0 0 4 4 this 3 2000  5 value 1 1900  7 low_bit 1 1886  4 size 1 1886  
620 0 0 6 667 1886 0 0 0 1 4 this 3 2001  
621 0 0 6 668 1886 0 0 0 1 4 this 3 2001  
622 0 0 6 669 1886 0 0 0 1 4 this 3 2001  
623 0 0 6 670 1886 0 0 0 1 4 this 3 2001  
624 0 0 6 671 1886 0 0 0 1 4 this 3 2001  
625 0 0 6 672 1886 0 0 0 1 4 this 3 2001  
626 0 0 6 673 1886 0 0 0 2 4 this 3 2001  7 low_bit 1 1886  
627 0 0 4 674 1889 0 0 0 1 4 this 3 2000  
628 0 0 6 675 1900 0 0 0 2 4 this 3 2001  5 other 1 2001  
629 0 0 4 676 1889 0 0 0 1 4 this 3 2000  
630 0 0 4 677 1889 0 0 0 2 4 this 3 2001  3 out 1 1893  
631 0 0 4 678 1889 0 0 0 3 4 this 3 2001  3 out 1 1893  12 spaces_every 1 1886  
632 0 0 4 679 1889 0 0 0 3 4 this 3 2001  3 out 1 1893  12 spaces_every 1 1886  
633 0 0 4 680 1889 0 0 0 3 4 this 3 2001  3 out 1 1893  12 indent_level 1 1886  
634 0 0 6 681 1900 0 0 0 2 4 this 3 2001  5 other 1 2001  
635 0 0 6 682 1900 0 0 0 2 4 this 3 2001  5 other 1 2001  
636 0 0 6 683 1900 0 0 0 2 4 this 3 2001  5 other 1 2001  
637 0 0 6 684 1886 0 0 0 2 4 this 3 2001  5 other 1 2001  
638 0 0 7 685 2000 1483 0 0 2 4 this 3 2001  5 other 1 2001  
639 0 0 7 686 2000 1483 0 0 2 4 this 3 2001  5 other 1 2001  
640 0 0 7 687 2000 1483 0 0 2 4 this 3 2001  5 other 1 2001  
641 0 0 7 688 2000 1483 0 0 1 4 this 3 2001  
642 0 0 7 689 2000 1483 0 0 2 4 this 3 2001  5 shift 1 1886  
643 0 0 7 690 2000 1483 0 0 2 4 this 3 2001  5 shift 1 1886  
644 0 0 6 691 2000 0 0 0 2 4 this 3 2000  5 other 1 2001  
645 0 0 6 692 2000 0 0 0 2 4 this 3 2000  5 other 1 2001  
646 0 0 6 693 2000 0 0 0 2 4 this 3 2000  5 other 1 2001  
647 0 0 6 694 2000 0 0 0 2 4 this 3 2000  5 shift 1 1886  
648 0 0 6 695 2000 0 0 0 2 4 this 3 2000  5 shift 1 1886  
649 0 0 7 696 1896 0 0 0 0 
650 0 0 7 700 1963 1340 0 394 ////////////////////////////////////////////////////////////////////
//     Function: KeyboardButton::ascii_key
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               particular ASCII character, if there is one, or
//               ButtonHandle::none() if there is not.
//////////////////////////////////////////////////////////////////// 1 16 ascii_equivalent 1 1966  
651 0 0 7 701 1963 1340 0 0 0 
652 0 0 7 702 1963 1340 0 0 0 
653 0 0 7 703 1963 1340 0 0 0 
654 0 0 7 704 1963 1340 0 0 0 
655 0 0 7 705 1963 1340 0 0 0 
656 0 0 7 706 1963 1340 0 0 0 
657 0 0 7 707 1963 1340 0 0 0 
658 0 0 7 708 1963 1340 0 0 0 
659 0 0 7 709 1963 1340 0 0 0 
660 0 0 7 710 1963 1340 0 0 0 
661 0 0 7 711 1963 1340 0 0 0 
662 0 0 7 712 1963 1340 0 0 0 
663 0 0 7 713 1963 1340 0 0 0 
664 0 0 7 714 1963 1340 0 0 0 
665 0 0 7 715 1963 1340 0 0 0 
666 0 0 7 716 1963 1340 0 0 0 
667 0 0 7 717 1963 1340 0 0 0 
668 0 0 7 718 1963 1340 0 59 // PC keyboards don't have these four buttons, but Macs do. 0 
669 0 0 7 719 1963 1340 0 0 0 
670 0 0 7 720 1963 1340 0 0 0 
671 0 0 7 721 1963 1340 0 0 0 
672 0 0 7 722 1963 1340 0 0 0 
673 0 0 7 723 1963 1340 0 0 0 
674 0 0 7 724 1963 1340 0 0 0 
675 0 0 7 725 1963 1340 0 0 0 
676 0 0 7 726 1963 1340 0 0 0 
677 0 0 7 727 1963 1340 0 0 0 
678 0 0 7 728 1963 1340 0 0 0 
679 0 0 7 729 1963 1340 0 0 0 
680 0 0 7 730 1963 1340 0 0 0 
681 0 0 7 731 1963 1340 0 27 // delete is a C++ keyword. 0 
682 0 0 7 732 1963 1340 0 27 // delete is a C++ keyword. 0 
683 0 0 7 733 1963 1340 0 0 0 
684 0 0 7 734 1963 1340 0 0 0 
685 0 0 7 735 1963 1340 0 0 0 
686 0 0 7 736 1963 1340 0 0 0 
687 0 0 7 737 1963 1340 0 0 0 
688 0 0 7 738 1963 1340 0 0 0 
689 0 0 7 739 1963 1340 0 0 0 
690 0 0 7 740 1963 1340 0 0 0 
691 0 0 7 741 1963 1340 0 0 0 
692 0 0 7 742 1963 1340 0 0 0 
693 0 0 7 743 1963 1340 0 0 0 
694 0 0 7 744 1963 1340 0 0 0 
695 0 0 7 745 1963 1340 0 0 0 
696 0 0 7 746 1963 1340 0 0 0 
697 0 0 7 747 1963 1340 0 0 0 
698 0 0 7 748 1963 1340 0 0 0 
699 0 0 7 749 1963 1340 0 0 0 
700 0 0 7 750 1963 1340 0 0 0 
701 0 0 7 751 1963 1340 0 0 0 
702 0 0 7 758 2003 1588 0 227 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
703 0 0 7 758 2003 1588 0 232 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 2004  
704 0 0 6 760 2003 0 0 0 2 4 this 3 2003  4 copy 1 2004  
705 0 0 6 761 1900 0 0 0 2 4 this 3 2004  5 other 1 2004  
706 0 0 6 762 1900 0 0 0 2 4 this 3 2004  5 other 1 2004  
707 0 0 6 763 1900 0 0 0 2 4 this 3 2004  5 other 1 2004  
708 0 0 7 764 2003 1588 0 0 2 4 this 3 2004  5 other 1 2004  
709 0 0 7 765 2003 1588 0 0 2 4 this 3 2004  5 other 1 2004  
710 0 0 6 766 2003 0 0 0 2 4 this 3 2003  5 other 1 2004  
711 0 0 6 767 2003 0 0 0 2 4 this 3 2003  5 other 1 2004  
712 0 0 4 768 1889 0 0 698 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::set_button_list
//       Access: Published
//  Description: Sets the list of buttons to watch to be the same as
//               that of the other ModifierButtons object.  This makes
//               the lists pointer equivalent (until one or the other
//               is later modified).
//
//               This will preserve the state of any button that was
//               on the original list and is also on the new lists.
//               Any other buttons will get reset to the default state
//               of "up".
//////////////////////////////////////////////////////////////////// 2 4 this 3 2003  5 other 1 2004  
713 0 0 6 769 1900 0 0 504 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::matches
//       Access: Published
//  Description: Returns true if the set of buttons indicated as down
//               by this ModifierButtons object is the same set of
//               buttons indicated as down by the other
//               ModifierButtons object.  The buttons indicated as up
//               are not relevant.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2004  5 other 1 2004  
714 0 0 6 770 1900 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::add_button
//       Access: Published
//  Description: Adds the indicated button to the set of buttons that
//               will be monitored for upness and downness.  Returns
//               true if the button was added, false if it was already
//               being monitored or if too many buttons are currently
//               being monitored.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2003  6 button 1 1963  
715 0 0 6 771 1900 0 0 339 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::has_button
//       Access: Published
//  Description: Returns true if the indicated button is in the set of
//               buttons being monitored, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2004  6 button 1 1963  
716 0 0 6 772 1900 0 0 623 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::remove_button
//       Access: Published
//  Description: Removes the indicated button from the set of buttons
//               being monitored.  Returns true if the button was
//               removed, false if it was not being monitored in the
//               first place.
//
//               Unlike the other methods, you cannot remove a button
//               by removing its alias; you have to remove exactly the
//               button itself.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2003  6 button 1 1963  
717 0 0 6 773 1886 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_num_buttons
//       Access: Published
//  Description: Returns the number of buttons that the
//               ModifierButtons object is monitoring (e.g. the number
//               of buttons passed to add_button()).
//////////////////////////////////////////////////////////////////// 1 4 this 3 2004  
718 0 0 7 774 1963 1340 0 446 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_button
//       Access: Published
//  Description: Returns the nth button that the ModifierButtons
//               object is monitoring (the nth button passed to
//               add_button()).  This must be in the range 0 <= index
//               < get_num_buttons().
//////////////////////////////////////////////////////////////////// 2 4 this 3 2004  5 index 1 1886  
719 0 0 6 775 1900 0 0 597 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::button_down
//       Access: Published
//  Description: Records that a particular button has been pressed.
//               If the given button is one of the buttons that is
//               currently being monitored, this will update the
//               internal state appropriately; otherwise, it will do
//               nothing.  Returns true if the button is one that was
//               monitored, or false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2003  6 button 1 1963  
720 0 0 6 776 1900 0 0 596 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::button_up
//       Access: Published
//  Description: Records that a particular button has been released.
//               If the given button is one of the buttons that is
//               currently being monitored, this will update the
//               internal state appropriately; otherwise, it will do
//               nothing.  Returns true if the button is one that was
//               monitored, or false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2003  6 button 1 1963  
721 0 0 4 777 1889 0 0 303 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::all_buttons_up
//       Access: Published
//  Description: Marks all monitored buttons as being in the "up"
//               state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2003  
722 0 0 6 778 1900 0 0 401 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_down
//       Access: Published
//  Description: Returns true if the indicated button is known to be
//               down, or false if it is known to be up or if it is
//               not in the set of buttons being tracked.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2004  6 button 1 1963  
723 0 0 6 778 1900 0 0 332 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_down
//       Access: Published
//  Description: Returns true if the indicated button is known to be
//               down, or false if it is known to be up.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2004  5 index 1 1886  
724 0 0 6 779 1900 0 0 340 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::is_any_down
//       Access: Published
//  Description: Returns true if any of the tracked button are known
//               to be down, or false if all of them are up.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2004  
725 0 0 6 780 1885 0 0 397 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::get_prefix
//       Access: Published
//  Description: Returns a string which can be used to prefix any
//               button name or event name with the unique set of
//               modifier buttons currently being held.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2004  
726 0 0 4 781 1889 0 0 298 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::output
//       Access: Published
//  Description: Writes a one-line summary of the buttons known to be
//               down.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2004  3 out 1 1893  
727 0 0 4 782 1889 0 0 365 ////////////////////////////////////////////////////////////////////
//     Function: ModifierButtons::write
//       Access: Published
//  Description: Writes a multi-line summary including all of the
//               buttons being monitored and which ones are known to
//               be down.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2004  3 out 1 1893  
728 0 0 7 784 1963 1340 0 424 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::button
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               particular numbered mouse button (zero-based), if
//               there is one, or ButtonHandle::none() if there is
//               not.
//////////////////////////////////////////////////////////////////// 1 13 button_number 1 1886  
729 0 0 7 785 1963 1340 0 302 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::one
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               first mouse button.
//////////////////////////////////////////////////////////////////// 0 
730 0 0 7 786 1963 1340 0 303 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::two
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               second mouse button.
//////////////////////////////////////////////////////////////////// 0 
731 0 0 7 787 1963 1340 0 304 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::three
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               third mouse button.
//////////////////////////////////////////////////////////////////// 0 
732 0 0 7 788 1963 1340 0 304 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::four
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               fourth mouse button.
//////////////////////////////////////////////////////////////////// 0 
733 0 0 7 789 1963 1340 0 303 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::five
//       Access: Public, Static
//  Description: Returns the ButtonHandle associated with the
//               fifth mouse button.
//////////////////////////////////////////////////////////////////// 0 
734 0 0 7 790 1963 1340 0 327 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_up
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               wheel is rolled one notch upwards.
//////////////////////////////////////////////////////////////////// 0 
735 0 0 7 791 1963 1340 0 331 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_down
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               wheel is rolled one notch downwards.
//////////////////////////////////////////////////////////////////// 0 
736 0 0 7 792 1963 1340 0 396 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_left
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               is scrolled to the left. Usually, you'll only
//               find the horizontal scroll on laptops.
//////////////////////////////////////////////////////////////////// 0 
737 0 0 7 793 1963 1340 0 398 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::wheel_right
//       Access: Public, Static
//  Description: Returns the ButtonHandle generated when the mouse
//               is scrolled to the right. Usually, you'll only
//               find the horizontal scroll on laptops.
//////////////////////////////////////////////////////////////////// 0 
738 0 0 6 794 1900 0 0 353 ////////////////////////////////////////////////////////////////////
//     Function: MouseButton::is_mouse_button
//       Access: Public, Static
//  Description: Returns true if the indicated ButtonHandle is a mouse
//               button, false if it is some other kind of button.
//////////////////////////////////////////////////////////////////// 1 6 button 1 1963  
739 0 0 7 797 2006 1630 0 221 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
740 0 0 7 797 2006 1630 0 226 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 2007  
741 0 0 6 798 2006 0 0 0 2 4 this 3 2006  4 copy 1 2007  
742 0 0 6 799 1899 0 0 215 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_x
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 2007  
743 0 0 6 800 1899 0 0 215 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_y
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 2007  
744 0 0 6 801 1900 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::get_in_window
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 2007  
745 0 0 4 802 1889 0 0 216 ////////////////////////////////////////////////////////////////////
//     Function: MouseData::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 2007  3 out 1 1893  
746 0 0 6 805 1886 0 0 280 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::get_node_ref_count
//       Access: Published
//  Description: Returns the current reference count.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2009  
747 0 0 4 806 1889 0 0 662 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::node_ref
//       Access: Published
//  Description: Explicitly increments the reference count.
//
//               This function is const, even though it changes the
//               object, because generally fiddling with an object's
//               reference count isn't considered part of fiddling
//               with the object.  An object might be const in other
//               ways, but we still need to accurately count the
//               number of references to it.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2009  
748 0 0 6 807 1900 0 0 468 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::node_unref
//       Access: Published
//  Description: Explicitly decrements the node reference count and
//               the normal reference count simultaneously.
//
//               The return value is true if the new reference count
//               is nonzero, false if it is zero.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2009  
749 0 0 6 808 1900 0 0 350 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::test_ref_count_integrity
//       Access: Published
//  Description: Does some easy checks to make sure that the reference
//               count isn't completely bogus.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2009  
750 0 0 6 810 1886 0 0 600 ////////////////////////////////////////////////////////////////////
//     Function: NodeCachedReferenceCount::get_referenced_bits
//       Access: Published
//  Description: Returns the union of the values defined in the
//               Referenced enum that represents the various things
//               that appear to be holding a pointer to this object.
//
//               If R_node is included, at least one node is holding a
//               pointer; if R_cache is included, at least one cache
//               element is.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2009  
751 0 0 7 811 1896 0 0 0 0 
752 0 0 7 813 2011 1644 0 223 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
753 0 0 7 813 2011 1644 0 239 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Constructor (from BitArray)
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 from 1 1956  
754 0 0 7 813 2011 1644 0 228 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 1959  
755 0 0 6 814 2011 0 0 236 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Copy Assignment Operator
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 2011  4 copy 1 1959  
756 0 0 7 815 2011 1644 0 323 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray with an infinite array of bits,
//               all on.
//////////////////////////////////////////////////////////////////// 0 
757 0 0 7 816 2011 1644 0 290 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named all_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose bits are all off.
//////////////////////////////////////////////////////////////////// 0 
758 0 0 7 817 2011 1644 0 301 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named lower_on constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose lower on_bits bits are on.
//////////////////////////////////////////////////////////////////// 1 7 on_bits 1 1886  
759 0 0 7 818 2011 1644 0 295 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named bit constructor
//       Access: Published, Static
//  Description: Returns a SparseArray with only the indicated bit on.
//////////////////////////////////////////////////////////////////// 1 5 index 1 1886  
760 0 0 7 819 2011 1644 0 329 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::Named range constructor
//       Access: Published, Static
//  Description: Returns a SparseArray whose size bits, beginning at
//               low_bit, are on.
//////////////////////////////////////////////////////////////////// 2 7 low_bit 1 1886  4 size 1 1886  
761 0 0 6 821 1900 0 0 723 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_max_num_bits
//       Access: Published, Static
//  Description: Returns true if there is a maximum number of bits
//               that may be stored in this structure, false
//               otherwise.  If this returns true, the number may be
//               queried in get_max_num_bits().
//
//               This method always returns false.  The SparseArray has
//               no maximum number of bits.  This method is defined so
//               generic programming algorithms can use BitMask or
//               SparseArray interchangeably.
//////////////////////////////////////////////////////////////////// 0 
762 0 0 6 822 1886 0 0 758 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_max_num_bits
//       Access: Published, Static
//  Description: If get_max_num_bits() returned true, this method may
//               be called to return the maximum number of bits that
//               may be stored in this structure.  It is an error to
//               call this if get_max_num_bits() return false.
//
//               It is always an error to call this method.  The
//               SparseArray has no maximum number of bits.  This method
//               is defined so generic programming algorithms can use
//               BitMask or SparseArray interchangeably.
//////////////////////////////////////////////////////////////////// 0 
763 0 0 6 823 1886 0 0 607 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_bits
//       Access: Published
//  Description: Returns the current number of possibly different bits
//               in this array.  There are actually an infinite number
//               of bits, but every bit higher than this bit will have
//               the same value, either 0 or 1 (see
//               get_highest_bits()).
//
//               This number may grow and/or shrink automatically as
//               needed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
764 0 0 6 824 1900 0 0 445 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_bit
//       Access: Published
//  Description: Returns true if the nth bit is set, false if it is
//               cleared.  It is valid for n to increase beyond
//               get_num_bits(), but the return value get_num_bits()
//               will always be the same.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  5 index 1 1886  
765 0 0 4 825 1889 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_bit
//       Access: Published
//  Description: Sets the nth bit on.  If n >= get_num_bits(), this
//               automatically extends the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2011  5 index 1 1886  
766 0 0 4 826 1889 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear_bit
//       Access: Published
//  Description: Sets the nth bit off.  If n >= get_num_bits(), this
//               automatically extends the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2011  5 index 1 1886  
767 0 0 4 827 1889 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_bit_to
//       Access: Published
//  Description: Sets the nth bit either on or off, according to the
//               indicated bool value.
//////////////////////////////////////////////////////////////////// 3 4 this 3 2011  5 index 1 1886  5 value 1 1900  
768 0 0 6 828 1900 0 0 367 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_bits
//       Access: Published
//  Description: Returns true if the infinite set of bits beyond
//               get_num_bits() are all on, or false of they are all
//               off.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
769 0 0 6 829 1900 0 0 297 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_zero
//       Access: Published
//  Description: Returns true if the entire bitmask is zero, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
770 0 0 6 830 1900 0 0 298 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_all_on
//       Access: Published
//  Description: Returns true if the entire bitmask is one, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
771 0 0 6 831 1900 0 0 311 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_any_of
//       Access: Published
//  Description: Returns true if any bit in the indicated range is
//               set, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1959  7 low_bit 1 1886  4 size 1 1886  
772 0 0 6 832 1900 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_all_of
//       Access: Published
//  Description: Returns true if all bits in the indicated range are
//               set, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 1959  7 low_bit 1 1886  4 size 1 1886  
773 0 0 4 833 1889 0 0 258 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_range
//       Access: Published
//  Description: Sets the indicated range of bits on.
//////////////////////////////////////////////////////////////////// 3 4 this 3 2011  7 low_bit 1 1886  4 size 1 1886  
774 0 0 4 834 1889 0 0 261 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear_range
//       Access: Published
//  Description: Sets the indicated range of bits off.
//////////////////////////////////////////////////////////////////// 3 4 this 3 2011  7 low_bit 1 1886  4 size 1 1886  
775 0 0 4 835 1889 0 0 278 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::set_range_to
//       Access: Published
//  Description: Sets the indicated range of bits to either on or off.
//////////////////////////////////////////////////////////////////// 4 4 this 3 2011  5 value 1 1900  7 low_bit 1 1886  4 size 1 1886  
776 0 0 6 836 1886 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_on_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 1 in the
//               array.  Returns -1 if there are an infinite number of
//               1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
777 0 0 6 837 1886 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_off_bits
//       Access: Published
//  Description: Returns the number of bits that are set to 0 in the
//               array.  Returns -1 if there are an infinite number of
//               0 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
778 0 0 6 838 1886 0 0 395 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_lowest_on_bit
//       Access: Published
//  Description: Returns the index of the lowest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there are an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
779 0 0 6 839 1886 0 0 396 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_lowest_off_bit
//       Access: Published
//  Description: Returns the index of the lowest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there are an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
780 0 0 6 840 1886 0 0 393 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_on_bit
//       Access: Published
//  Description: Returns the index of the highest 1 bit in the array.
//               Returns -1 if there are no 1 bits or if there an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
781 0 0 6 841 1886 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_highest_off_bit
//       Access: Published
//  Description: Returns the index of the highest 0 bit in the array.
//               Returns -1 if there are no 0 bits or if there an
//               infinite number of 1 bits.
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
782 0 0 6 842 1886 0 0 594 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_next_higher_different_bit
//       Access: Published
//  Description: Returns the index of the next bit in the array, above
//               low_bit, whose value is different that the value of
//               low_bit.  Returns low_bit again if all bits higher
//               than low_bit have the same value.
//
//               This can be used to quickly iterate through all of
//               the bits in the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  7 low_bit 1 1886  
783 0 0 4 843 1889 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::invert_in_place
//       Access: Published
//  Description: Inverts all the bits in the SparseArray.  This is
//               equivalent to array = ~array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2011  
784 0 0 6 844 1900 0 0 446 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::has_bits_in_common
//       Access: Published
//  Description: Returns true if this SparseArray has any "one" bits in
//               common with the other one, false otherwise.
//
//               This is equivalent to (array & other) != 0, but may
//               be faster.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  5 other 1 1959  
785 0 0 4 845 1889 0 0 259 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::clear
//       Access: Published
//  Description: Sets all the bits in the SparseArray off.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2011  
786 0 0 4 846 1889 0 0 219 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  3 out 1 1893  
787 0 0 6 847 1900 0 0 0 2 4 this 3 1959  5 other 1 1959  
788 0 0 6 848 1900 0 0 0 2 4 this 3 1959  5 other 1 1959  
789 0 0 6 849 1900 0 0 0 2 4 this 3 1959  5 other 1 1959  
790 0 0 6 850 1886 0 0 513 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this SparseArray
//               sorts before the indicated other SparseArray, greater
//               than zero if it sorts after, or 0 if they are
//               equivalent.  This is based on the same ordering
//               defined by operator <.
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  5 other 1 1959  
791 0 0 7 851 2011 1644 0 0 2 4 this 3 1959  5 other 1 1959  
792 0 0 7 852 2011 1644 0 0 2 4 this 3 1959  5 other 1 1959  
793 0 0 7 853 2011 1644 0 0 2 4 this 3 1959  5 other 1 1959  
794 0 0 7 854 2011 1644 0 0 1 4 this 3 1959  
795 0 0 7 855 2011 1644 0 0 2 4 this 3 1959  5 shift 1 1886  
796 0 0 7 856 2011 1644 0 0 2 4 this 3 1959  5 shift 1 1886  
797 0 0 6 857 2011 0 0 0 2 4 this 3 2011  5 other 1 1959  
798 0 0 6 858 2011 0 0 0 2 4 this 3 2011  5 other 1 1959  
799 0 0 6 859 2011 0 0 0 2 4 this 3 2011  5 other 1 1959  
800 0 0 6 860 2011 0 0 0 2 4 this 3 2011  5 shift 1 1886  
801 0 0 6 861 2011 0 0 0 2 4 this 3 2011  5 shift 1 1886  
802 0 0 6 862 1900 0 0 614 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::is_inverse
//       Access: Published
//  Description: If this is true, the SparseArray is actually defined
//               as a list of subranges of integers that are *not* in
//               the set.  If this is false (the default), then the
//               subranges define the integers that *are* in the set.
//               This affects the interpretation of the values
//               returned by iterating through get_num_subranges().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
803 0 0 6 863 1886 0 0 515 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_num_subranges
//       Access: Published
//  Description: Returns the number of separate subranges stored in
//               the SparseArray.  You can use this limit to iterate
//               through the subranges, calling get_subrange_begin()
//               and get_subrange_end() for each one.
//
//               Also see is_inverse().
//////////////////////////////////////////////////////////////////// 1 4 this 3 1959  
804 0 0 6 864 1886 0 0 345 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_subrange_begin
//       Access: Published
//  Description: Returns the first numeric element in the nth
//               subrange.
//
//               Also see is_inverse().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  1 n 1 1886  
805 0 0 6 865 1886 0 0 353 ////////////////////////////////////////////////////////////////////
//     Function: SparseArray::get_subrange_end
//       Access: Published
//  Description: Returns the last numeric element, plus one, in the
//               nth subrange.
//
//               Also see is_inverse().
//////////////////////////////////////////////////////////////////// 2 4 this 3 1959  1 n 1 1886  
806 0 0 7 866 1896 0 0 0 0 
807 0 0 7 868 1896 0 0 280 ////////////////////////////////////////////////////////////////////
//     Function: ParamValueBase::get_value_type
//       Access: Published, Virtual
//  Description: Returns the type of the underlying value.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2012  
808 0 0 4 869 1889 0 0 0 2 4 this 3 2012  3 out 1 1893  
809 0 0 7 870 1896 0 0 0 0 
810 0 0 7 872 2016 975 0 230 ////////////////////////////////////////////////////////////////////
//     Function: ParamTypedRefCount::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 5 value 1 2014  
811 0 0 7 873 2019 0 0 273 ////////////////////////////////////////////////////////////////////
//     Function: ParamTypedRefCount::get_value
//       Access: Published
//  Description: Retrieves the value stored in the parameter.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2017  
812 0 0 7 874 1896 0 0 0 0 
813 0 0 7 876 2020 975 0 0 1 5 value 1 1885  
814 0 0 4 877 1889 0 0 0 2 4 this 3 2020  5 value 1 1885  
815 0 0 6 878 1885 0 0 0 1 4 this 3 2021  
816 0 0 7 879 1896 0 0 0 0 
817 0 0 7 882 2023 975 0 0 1 5 value 1 1885  
818 0 0 4 883 1889 0 0 0 2 4 this 3 2023  5 value 1 1885  
819 0 0 6 884 1885 0 0 0 1 4 this 3 2024  
820 0 0 7 885 1896 0 0 0 0 
821 0 0 7 888 2029 975 0 0 1 5 value 1 2026  
822 0 0 4 889 1889 0 0 0 2 4 this 3 2029  5 value 1 2026  
823 0 0 6 890 2026 0 0 0 1 4 this 3 2030  
824 0 0 7 891 1896 0 0 0 0 
825 0 0 7 894 2035 975 0 0 1 5 value 1 2032  
826 0 0 4 895 1889 0 0 0 2 4 this 3 2035  5 value 1 2032  
827 0 0 6 896 2032 0 0 0 1 4 this 3 2036  
828 0 0 7 897 1896 0 0 0 0 
829 0 0 7 900 2041 975 0 0 1 5 value 1 2038  
830 0 0 4 901 1889 0 0 0 2 4 this 3 2041  5 value 1 2038  
831 0 0 6 902 2038 0 0 0 1 4 this 3 2042  
832 0 0 7 903 1896 0 0 0 0 
833 0 0 7 906 2047 975 0 0 1 5 value 1 2044  
834 0 0 4 907 1889 0 0 0 2 4 this 3 2047  5 value 1 2044  
835 0 0 6 908 2044 0 0 0 1 4 this 3 2048  
836 0 0 7 909 1896 0 0 0 0 
837 0 0 7 912 2053 975 0 0 1 5 value 1 2050  
838 0 0 4 913 1889 0 0 0 2 4 this 3 2053  5 value 1 2050  
839 0 0 6 914 2050 0 0 0 1 4 this 3 2054  
840 0 0 7 915 1896 0 0 0 0 
841 0 0 7 918 2059 975 0 0 1 5 value 1 2056  
842 0 0 4 919 1889 0 0 0 2 4 this 3 2059  5 value 1 2056  
843 0 0 6 920 2056 0 0 0 1 4 this 3 2060  
844 0 0 7 921 1896 0 0 0 0 
845 0 0 7 924 2065 975 0 0 1 5 value 1 2062  
846 0 0 4 925 1889 0 0 0 2 4 this 3 2065  5 value 1 2062  
847 0 0 6 926 2062 0 0 0 1 4 this 3 2066  
848 0 0 7 927 1896 0 0 0 0 
849 0 0 7 930 2071 975 0 0 1 5 value 1 2068  
850 0 0 4 931 1889 0 0 0 2 4 this 3 2071  5 value 1 2068  
851 0 0 6 932 2068 0 0 0 1 4 this 3 2072  
852 0 0 7 933 1896 0 0 0 0 
853 0 0 7 936 2077 975 0 0 1 5 value 1 2074  
854 0 0 4 937 1889 0 0 0 2 4 this 3 2077  5 value 1 2074  
855 0 0 6 938 2074 0 0 0 1 4 this 3 2078  
856 0 0 7 939 1896 0 0 0 0 
857 0 0 7 942 2083 975 0 0 1 5 value 1 2080  
858 0 0 4 943 1889 0 0 0 2 4 this 3 2083  5 value 1 2080  
859 0 0 6 944 2080 0 0 0 1 4 this 3 2084  
860 0 0 7 945 1896 0 0 0 0 
861 0 0 7 948 2089 975 0 0 1 5 value 1 2086  
862 0 0 4 949 1889 0 0 0 2 4 this 3 2089  5 value 1 2086  
863 0 0 6 950 2086 0 0 0 1 4 this 3 2090  
864 0 0 7 951 1896 0 0 0 0 
865 0 0 7 954 2095 975 0 0 1 5 value 1 2092  
866 0 0 4 955 1889 0 0 0 2 4 this 3 2095  5 value 1 2092  
867 0 0 6 956 2092 0 0 0 1 4 this 3 2096  
868 0 0 7 957 1896 0 0 0 0 
869 0 0 7 960 2101 975 0 0 1 5 value 1 2098  
870 0 0 4 961 1889 0 0 0 2 4 this 3 2101  5 value 1 2098  
871 0 0 6 962 2098 0 0 0 1 4 this 3 2102  
872 0 0 7 963 1896 0 0 0 0 
873 0 0 7 971 1896 0 0 0 0 
874 0 0 7 974 2104 1760 0 275 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::Constructor
//       Access: Published
//  Description: Create a free id pool in the range [min:max].
//////////////////////////////////////////////////////////////////// 2 3 min 1 1949  3 max 1 1949  
875 0 0 6 976 1949 0 0 381 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::allocate
//       Access: Published
//  Description: Returns an id between _min and _max (that were passed
//               to the constructor).
//               IndexEnd is returned if no ids are available.
//////////////////////////////////////////////////////////////////// 1 4 this 3 2104  
876 0 0 4 977 1889 0 0 893 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::initial_reserve_id
//       Access: Published
//  Description: This may be called to mark a particular id as having
//               already been allocated (for instance, by a prior
//               pass).  The specified id is removed from the
//               available pool.
//
//               Because of the limitations of this algorithm, this is
//               most efficient when it is called before the first
//               call to allocate(), and when all the calls to
//               initial_reserve_id() are made in descending order by
//               id.  However, this is a performance warning only; if
//               performance is not an issue, any id may be reserved
//               at any time.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2104  2 id 1 1949  
877 0 0 4 978 1889 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::free
//       Access: Published
//  Description: Free an allocated index (index must be between _min
//               and _max that were passed to the constructor).
//////////////////////////////////////////////////////////////////// 2 4 this 3 2104  5 index 1 1949  
878 0 0 6 979 2107 0 0 350 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::fraction_used
//       Access: Published
//  Description: return the decimal fraction of the pool that is used.
//               The range is 0 to 1.0 (e.g. 75% would be 0.75).
//////////////////////////////////////////////////////////////////// 1 4 this 3 2105  
879 0 0 4 980 1889 0 0 256 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::output
//       Access: Published
//  Description: ...intended for debugging only.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2105  3 out 1 1893  
880 0 0 4 981 1889 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: UniqueIdAllocator::write
//       Access: Published
//  Description: ...intended for debugging only.
//////////////////////////////////////////////////////////////////// 2 4 this 3 2105  3 out 1 1893  
881 0 0 6 571 1818 0 0 0 1 3 str 1 1885  
882 0 0 6 572 1885 0 0 0 1 2 cs 1 1818  
883 0 0 6 573 2109 0 0 0 0 
884 0 0 6 574 2109 0 0 0 0 
885 0 0 6 753 2111 0 0 957 ////////////////////////////////////////////////////////////////////
//     Function: load_prc_file
//  Description: A convenience function for loading explicit prc files
//               from a disk file or from within a multifile (via the
//               virtual file system).  Save the return value and pass
//               it to unload_prc_file() if you ever want to unload
//               this file later.
//
//               The filename is first searched along the default prc
//               search path, and then also along the model path, for
//               convenience.
//
//               This function is defined in putil instead of in dtool
//               with the read of the prc stuff, so that it can take
//               advantage of the virtual file system (which is
//               defined in express), and the model path (which is in
//               putil).
//////////////////////////////////////////////////////////////////// 1 8 filename 1 1921  
886 0 0 6 754 2111 0 0 680 ////////////////////////////////////////////////////////////////////
//     Function: load_prc_file_data
//  Description: Another convenience function to load a prc file from
//               an explicit string, which represents the contents of
//               the prc file.
//
//               The first parameter is an arbitrary name to assign to
//               this in-memory prc file.  Supply a filename if the
//               data was read from a file, or use any other name that
//               is meaningful to you.  The name is only used when the
//               set of loaded prc files is listed.
//////////////////////////////////////////////////////////////////// 2 4 name 1 1885  4 data 1 1885  
887 0 0 6 755 1900 0 0 0 1 4 page 1 2111  
888 0 0 4 756 1889 0 0 0 1 4 hash 1 2113  
889 0 0 6 983 1879 0 0 0 2 10 this_class 1 1879  4 data 1 1885  
890 0 0 6 984 1879 0 0 0 3 9 unpickler 1 1879  10 this_class 1 1879  4 data 1 1885  
346
1769 29 ConstPointerToArray< ushort > 0 141313 29 ConstPointerToArray< ushort > 29 ConstPointerToArray< ushort > 0 0 0 1 894 904 0 9 895 896 897 898 899 900 901 902 903 0 0 1 0 1770 0 0 0 0 0

1770 28 PointerToArrayBase< ushort > 0 26625 28 PointerToArrayBase< ushort > 28 PointerToArrayBase< ushort > 0 0 0 0 893 0 0 0 0 1 0 1771 0 0 0 0 0

1771 49 PointerToBase< ReferenceCountedVector< ushort > > 0 43009 49 PointerToBase< ReferenceCountedVector< ushort > > 49 PointerToBase< ReferenceCountedVector< ushort > > 0 0 0 0 0 0 2 891 892 0 0 1 0 1772 0 0 0 0 0

1772 13 PointerToVoid 0 2049 13 PointerToVoid 13 PointerToVoid 0 0 0 0 0 0 0 0 0 0 0 0 635
////////////////////////////////////////////////////////////////////
//       Class : PointerToVoid
// Description : This is the non-template part of the base class for
//               PointerTo and ConstPointerTo.  It is necessary so we
//               can keep a pointer to a non-template class within the
//               ReferenceCount object, to implement weak reference
//               pointers--we need to have something to clean up when
//               the ReferenceCount object destructs.
//
//               This is the base class for PointerToBase<T>.
////////////////////////////////////////////////////////////////////

1773 24 PointerToArray< ushort > 0 141313 24 PointerToArray< ushort > 24 PointerToArray< ushort > 0 0 0 1 905 922 0 16 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 0 0 1 0 1770 0 0 0 0 0

1774 7 CString 0 1050625 20 basic_string< char > 20 basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

1775 13 AnimInterface 0 26625 13 AnimInterface 13 AnimInterface 0 0 0 0 923 0 17 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 0 0 0 0 0 464
////////////////////////////////////////////////////////////////////
//       Class : AnimInterface
// Description : This is the fundamental interface for things that
//               have a play/loop/stop type interface for frame-based
//               animation, such as animated characters.  This is the
//               base class for AnimControl and other, similar
//               classes.
////////////////////////////////////////////////////////////////////

1776 16 AutoTextureScale 0 532481 16 AutoTextureScale 16 AutoTextureScale 0 0 0 0 0 0 0 0 0 0 5 8 ATS_none 8 ATS_none 0
0 8 ATS_down 8 ATS_down 0
1 6 ATS_up 6 ATS_up 0
2 7 ATS_pad 7 ATS_pad 0
3 15 ATS_unspecified 15 ATS_unspecified 0
4 0 0

1777 9 UpdateSeq 0 141313 9 UpdateSeq 9 UpdateSeq 0 0 0 1 941 961 0 19 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 0 0 0 0 0 1140
////////////////////////////////////////////////////////////////////
//       Class : UpdateSeq
// Description : This is a sequence number that increments
//               monotonically.  It can be used to track cache
//               updates, or serve as a kind of timestamp for any
//               changing properties.
//
//               A special class is used instead of simply an int, so
//               we can elegantly handle such things as wraparound and
//               special cases.  There are two special cases.
//               Firstly, a sequence number is 'initial' when it is
//               first created.  This sequence is older than any other
//               sequence number.  Secondly, a sequence number may be
//               explicitly set to 'old'.  This is older than any
//               other sequence number except 'initial'.  Finally, we
//               have the explicit number 'fresh', which is newer
//               than any other sequence number.  All other sequences
//               are numeric and are monotonically increasing.
////////////////////////////////////////////////////////////////////

1778 13 TypedWritable 0 75777 13 TypedWritable 13 TypedWritable 0 0 0 0 0 0 7 962 963 964 965 966 967 968 0 0 1 0 1779 0 0 0 0 341
////////////////////////////////////////////////////////////////////
//       Class : TypedWritable
// Description : Base class for objects that can be written to and
//               read from Bam files.
//
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

1779 11 TypedObject 0 2049 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 3561
////////////////////////////////////////////////////////////////////
//       Class : TypedObject
// Description : This is an abstract class that all classes which
//               use TypeHandle, and also provide virtual functions to
//               support polymorphism, should inherit from.  Each
//               derived class should define get_type(), which should
//               return the specific type of the derived class.
//               Inheriting from this automatically provides support
//               for is_of_type() and is_exact_type().
//
//               All classes that inherit directly or indirectly from
//               TypedObject should redefine get_type() and
//               force_init_type(), as shown below.  Some classes that
//               do not inherit from TypedObject may still declare
//               TypeHandles for themselves by defining methods called
//               get_class_type() and init_type().  Classes such as
//               these may serve as base classes, but the dynamic type
//               identification system will be limited.  Classes that
//               do not inherit from TypedObject need not define the
//               virtual functions get_type() and force_init_type()
//               (or any other virtual functions).
//
//               There is a specific layout for defining the
//               overrides from this class.  Keeping the definitions
//               formatted just like these examples will allow
//               someone in the future to use a sed (or similar)
//               script to make global changes, if necessary.  Avoid
//               rearranging the braces or the order of the functions
//               unless you're ready to change them in every file all
//               at once.
//
//               What follows are some examples that can be used in
//               new classes that you create.
//
//               @par In the class definition (.h file):
//               @code
//               public:
//                 static TypeHandle get_class_type() {
//                   return _type_handle;
//                 }
//                 static void init_type() {
//                   <<<BaseClassOne>>>::init_type();
//                   <<<BaseClassTwo>>>::init_type();
//                   <<<BaseClassN>>>::init_type();
//                   register_type(_type_handle, "<<<ThisClassStringName>>>",
//                                 <<<BaseClassOne>>>::get_class_type(),
//                                 <<<BaseClassTwo>>>::get_class_type(),
//                                 <<<BaseClassN>>>::get_class_type());
//                 }
//                 virtual TypeHandle get_type() const {
//                   return get_class_type();
//                 }
//                 virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
//
//               private:
//                 static TypeHandle _type_handle;
//               @endcode
//
//               @par In the class .cxx file:
//               @code
//               TypeHandle <<<ThisClassStringName>>>::_type_handle;
//               @endcode
//
//               @par In the class config_<<<PackageName>>>.cxx file:
//               @code
//               ConfigureFn(config_<<<PackageName>>>) {
//                 <<<ClassOne>>>::init_type();
//                 <<<ClassTwo>>>::init_type();
//                 <<<ClassN>>>::init_type();
//               }
//               @endcode
////////////////////////////////////////////////////////////////////

1780 27 TypedWritableReferenceCount 0 141313 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 975 0 2 973 974 0 0 2 3 1778 969 970 3 1781 971 972 0 0 722
////////////////////////////////////////////////////////////////////
//       Class : TypedWritableReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedWritable and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedWritables and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

1781 14 ReferenceCount 0 2049 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 425
////////////////////////////////////////////////////////////////////
//       Class : ReferenceCount
// Description : A base class for all things that want to be
//               reference-counted.  ReferenceCount works in
//               conjunction with PointerTo to automatically delete
//               objects when the last pointer to them goes away.
////////////////////////////////////////////////////////////////////

1782 14 BamCacheRecord 0 26625 14 BamCacheRecord 14 BamCacheRecord 0 0 0 0 980 0 19 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 0 0 2 3 1780 976 977 3 1783 978 979 0 0 469
////////////////////////////////////////////////////////////////////
//       Class : BamCacheRecord
// Description : An instance of this class is written to the front of
//               a Bam or Txo file to make the file a cached instance
//               of some other loadable resource.  This record
//               contains information needed to test the validity of
//               the cache.
////////////////////////////////////////////////////////////////////

1783 14 LinkedListNode 0 1050625 14 LinkedListNode 14 LinkedListNode 0 0 0 0 0 0 0 0 0 0 0 0 762
////////////////////////////////////////////////////////////////////
//       Class : LinkedListNode
// Description : This just stores the pointers to implement a
//               doubly-linked list of some kind of object.  There are
//               occasions when a hand-rolled linked list is more
//               appropriate than an STL container.
//
//               Typically, each node of the linked list, as well as
//               the root of the list, will inherit from this class.
//
//               Note that this class is not inherently thread-safe;
//               derived classes are responsible for protecting any
//               calls into it within mutexes, if necessary.
////////////////////////////////////////////////////////////////////

1784 8 BamCache 0 26625 8 BamCache 8 BamCache 0 0 0 1 1000 1001 0 22 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 0 0 0 0 0 948
////////////////////////////////////////////////////////////////////
//       Class : BamCache
// Description : This class maintains a cache of Bam and/or Txo
//               objects generated from model files and texture images
//               (as well as possibly other kinds of loadable objects
//               that can be stored in bam file format).
//
//               This class also maintains a persistent index that
//               lists all of the cached objects (see BamCacheIndex).
//               We go through some considerable effort to make sure
//               this index gets saved correctly to disk, even in the
//               presence of multiple different processes writing to
//               the same index, and without relying too heavily on
//               low-level os-provided file locks (which work poorly
//               with C++ iostreams).
////////////////////////////////////////////////////////////////////

1785 8 BamEnums 0 141313 8 BamEnums 8 BamEnums 0 0 0 0 1024 0 0 0 0 0 0 3 1786 1787 1788 288
////////////////////////////////////////////////////////////////////
//       Class : BamEnums
// Description : This class exists just to provide scoping for the
//               enums shared by BamReader and BamWriter.
////////////////////////////////////////////////////////////////////

1786 9 BamEndian 0 794624 19 BamEnums::BamEndian 19 BamEnums::BamEndian 1785 0 0 0 0 0 0 0 0 0 3 12 BE_bigendian 22 BamEnums::BE_bigendian 0
0 15 BE_littleendian 25 BamEnums::BE_littleendian 0
1 9 BE_native 19 BamEnums::BE_native 0
1 0 345
// This defines an enumerated type used to represent the endianness of
// certain numeric values stored in a Bam file.  It really has only
// two possible values, either BE_bigendian or BE_littleendian; but
// through a preprocessor trick we also add BE_native, which is the
// same numerically as whichever value the hardware supports natively.

1787 13 BamObjectCode 0 794624 23 BamEnums::BamObjectCode 23 BamEnums::BamObjectCode 1785 0 0 0 0 0 0 0 0 0 5 8 BOC_push 18 BamEnums::BOC_push 0
0 7 BOC_pop 17 BamEnums::BOC_pop 0
1 11 BOC_adjunct 21 BamEnums::BOC_adjunct 0
2 10 BOC_remove 20 BamEnums::BOC_remove 0
3 13 BOC_file_data 23 BamEnums::BOC_file_data 0
4 0 565
// This is the code written along with each object.  It is used to
// control object scoping.  A BOC_push includes an object
// definition, and will always be eventually paired with a BOC_pop
// (which does not).  A BOC_adjunct includes an object definition
// but does not push the level; it is associated with the current
// level.  BOC_remove lists object ID's that have been deallocated
// on the sender end.  BOC_file_data may appear at any level and
// indicates the following datagram contains auxiliary file data
// that may be referenced by a later object.

1788 14 BamTextureMode 0 794624 24 BamEnums::BamTextureMode 24 BamEnums::BamTextureMode 1785 0 0 0 0 0 0 0 0 0 5 13 BTM_unchanged 23 BamEnums::BTM_unchanged 0
0 12 BTM_fullpath 22 BamEnums::BTM_fullpath 0
1 12 BTM_relative 22 BamEnums::BTM_relative 0
2 12 BTM_basename 22 BamEnums::BTM_basename 0
3 11 BTM_rawdata 21 BamEnums::BTM_rawdata 0
4 0 76
// This enum is used to control how textures are written to a bam
// stream.

1789 13 LoaderOptions 0 141313 13 LoaderOptions 13 LoaderOptions 0 0 0 1 1025 1036 0 10 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 0 0 0 0 2 1790 1791 257
////////////////////////////////////////////////////////////////////
//       Class : LoaderOptions
// Description : Specifies parameters that may be passed to the
//               loader.
////////////////////////////////////////////////////////////////////

1790 11 LoaderFlags 0 794624 26 LoaderOptions::LoaderFlags 26 LoaderOptions::LoaderFlags 1789 0 0 0 0 0 0 0 0 0 10 9 LF_search 24 LoaderOptions::LF_search 0
1 16 LF_report_errors 31 LoaderOptions::LF_report_errors 0
2 19 LF_convert_skeleton 34 LoaderOptions::LF_convert_skeleton 0
4 19 LF_convert_channels 34 LoaderOptions::LF_convert_channels 0
8 15 LF_convert_anim 30 LoaderOptions::LF_convert_anim 22
// skeleton + channels
12 16 LF_no_disk_cache 31 LoaderOptions::LF_no_disk_cache 20
// disallow BamCache
16 15 LF_no_ram_cache 30 LoaderOptions::LF_no_ram_cache 21
// disallow ModelPool
32 11 LF_no_cache 26 LoaderOptions::LF_no_cache 19
// no_disk + no_ram
48 13 LF_cache_only 28 LoaderOptions::LF_cache_only 23
// fail if not in cache
64 17 LF_allow_instance 32 LoaderOptions::LF_allow_instance 35
// returned pointer might be shared
128 0 33
// Flags for loading model files.

1791 12 TextureFlags 0 794624 27 LoaderOptions::TextureFlags 27 LoaderOptions::TextureFlags 1789 0 0 0 0 0 0 0 0 0 7 10 TF_preload 25 LoaderOptions::TF_preload 30
// Texture will have RAM image
4 17 TF_preload_simple 32 LoaderOptions::TF_preload_simple 37
// Texture will have simple RAM image
8 11 TF_allow_1d 26 LoaderOptions::TF_allow_1d 40
// If texture is Nx1, make a 1-d texture
16 19 TF_generate_mipmaps 34 LoaderOptions::TF_generate_mipmaps 30
// Consider generating mipmaps
32 12 TF_multiview 27 LoaderOptions::TF_multiview 36
// Load a multiview texture in pages
64 10 TF_integer 25 LoaderOptions::TF_integer 35
// Load as an integer (RGB) texture
128 8 TF_float 23 LoaderOptions::TF_float 43
// Load as a floating-point (depth) texture
256 0 35
// Flags for loading texture files.

1792 9 BamReader 0 26625 9 BamReader 9 BamReader 0 0 0 1 1037 1038 0 18 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 0 0 1 0 1785 0 0 0 0 1870
////////////////////////////////////////////////////////////////////
//       Class : BamReader
// Description : This is the fundamental interface for extracting
//               binary objects from a Bam file, as generated by a
//               BamWriter.
//
//               A Bam file can be thought of as a linear collection
//               of objects.  Each object is an instance of a class
//               that inherits, directly or indirectly, from
//               TypedWritable.  The objects may include pointers to
//               other objects within the Bam file; the BamReader
//               automatically manages these (with help from code
//               within each class) and restores the pointers
//               correctly.
//
//               This is the abstract interface and does not
//               specifically deal with disk files, but rather with a
//               DatagramGenerator of some kind, which is simply a
//               linear source of Datagrams.  It is probably from a
//               disk file, but it might conceivably be streamed
//               directly from a network or some such nonsense.
//
//               Bam files are most often used to store scene graphs
//               or subgraphs, and by convention they are given
//               filenames ending in the extension ".bam" when they
//               are used for this purpose.  However, a Bam file may
//               store any arbitrary list of TypedWritable objects;
//               in this more general usage, they are given filenames
//               ending in ".boo" to differentiate them from the more
//               common scene graph files.
//
//               See also BamFile, which defines a higher-level
//               interface to read and write Bam files on disk.
////////////////////////////////////////////////////////////////////

1793 9 BamWriter 0 26625 9 BamWriter 9 BamWriter 0 0 0 1 1057 1058 0 11 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 0 0 1 0 1785 0 0 0 0 1949
////////////////////////////////////////////////////////////////////
//       Class : BamWriter
// Description : This is the fundamental interface for writing binary
//               objects to a Bam file, to be extracted later by a
//               BamReader.
//
//               A Bam file can be thought of as a linear collection
//               of objects.  Each object is an instance of a class
//               that inherits, directly or indirectly, from
//               TypedWritable.  The objects may include pointers to
//               other objects; the BamWriter automatically manages
//               these (with help from code within each class) and
//               writes all referenced objects to the file in such a
//               way that the pointers may be correctly restored
//               later.
//
//               This is the abstract interface and does not
//               specifically deal with disk files, but rather with a
//               DatagramSink of some kind, which simply accepts a
//               linear stream of Datagrams.  It is probably written
//               to a disk file, but it might conceivably be streamed
//               directly to a network or some such nonsense.
//
//               Bam files are most often used to store scene graphs
//               or subgraphs, and by convention they are given
//               filenames ending in the extension ".bam" when they
//               are used for this purpose.  However, a Bam file may
//               store any arbitrary list of TypedWritable objects;
//               in this more general usage, they are given filenames
//               ending in ".boo" to differentiate them from the more
//               common scene graph files.
//
//               See also BamFile, which defines a higher-level
//               interface to read and write Bam files on disk.
////////////////////////////////////////////////////////////////////

1794 24 BitMask< PN_uint16, 16 > 0 26625 24 BitMask< PN_uint16, 16 > 24 BitMask< PN_uint16, 16 > 0 0 0 1 1070 1077 0 62 1071 1072 1073 1074 1075 1076 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 0 0 0 0 0 0

1795 9 BitMask16 0 2105345 9 BitMask16 9 BitMask16 0 0 1794 0 0 0 0 0 0 0 0 0 0

1796 24 BitMask< PN_uint32, 32 > 0 26625 24 BitMask< PN_uint32, 32 > 24 BitMask< PN_uint32, 32 > 0 0 0 1 1134 1141 0 62 1135 1136 1137 1138 1139 1140 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 0 0 0 0 0 0

1797 9 BitMask32 0 2105345 9 BitMask32 9 BitMask32 0 0 1796 0 0 0 0 0 0 0 0 0 0

1798 24 BitMask< PN_uint64, 64 > 0 26625 24 BitMask< PN_uint64, 64 > 24 BitMask< PN_uint64, 64 > 0 0 0 1 1198 1205 0 62 1199 1200 1201 1202 1203 1204 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 0 0 0 0 0 0

1799 9 BitMask64 0 2105345 9 BitMask64 9 BitMask64 0 0 1798 0 0 0 0 0 0 0 0 0 0

1800 13 BitMaskNative 0 1 13 BitMaskNative 13 BitMaskNative 0 0 0 0 0 0 0 0 0 0 0 0 0

1801 8 BitArray 0 26625 8 BitArray 8 BitArray 0 0 0 1 1262 1269 0 57 1263 1264 1265 1266 1267 1268 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 0 0 0 0 1 1802 425
////////////////////////////////////////////////////////////////////
//       Class : BitArray
// Description : A dynamic array with an unlimited number of bits.
//
//               This is similar to a BitMask, except it appears to
//               contain an infinite number of bits.  You can use it
//               very much as you would use a BitMask.
////////////////////////////////////////////////////////////////////

1802 0 0 794624 10 BitArray:: 0 1801 0 0 0 0 0 0 0 0 0 1 17 num_bits_per_word 27 BitArray::num_bits_per_word 0
32 0 0

1803 12 ButtonHandle 0 141313 12 ButtonHandle 12 ButtonHandle 0 0 0 1 1321 1340 0 17 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1339 0 1 1338 0 0 0 364
////////////////////////////////////////////////////////////////////
//       Class : ButtonHandle
// Description : A ButtonHandle represents a single button from any
//               device, including keyboard buttons and mouse buttons
//               (but see KeyboardButton and MouseButton).
////////////////////////////////////////////////////////////////////

1804 14 ButtonRegistry 0 141313 14 ButtonRegistry 14 ButtonRegistry 0 0 0 0 1346 0 5 1341 1342 1343 1344 1345 0 0 0 0 0 409
////////////////////////////////////////////////////////////////////
//       Class : ButtonRegistry
// Description : The ButtonRegistry class maintains all the assigned
//               ButtonHandles in a given system.  There should be only
//               one ButtonRegistry class during the lifetime of the
//               application.
////////////////////////////////////////////////////////////////////

1805 9 ButtonMap 0 141313 9 ButtonMap 9 ButtonMap 0 0 0 0 1354 0 7 1347 1348 1349 1350 1351 1352 1353 0 0 1 0 1806 0 0 0 0 571
////////////////////////////////////////////////////////////////////
//       Class : ButtonMap
// Description : This class represents a map containing all of the
//               buttons of a (keyboard) device, though it can also
//               be used as a generic mapping between ButtonHandles.
//               It maps an underlying 'raw' button to a 'virtual'
//               button, which may optionally be associated with an
//               appropriate platform-specific name for the button.
////////////////////////////////////////////////////////////////////

1806 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 710
////////////////////////////////////////////////////////////////////
//       Class : TypedReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedObject and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedObjects and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

1807 14 CallbackObject 0 141313 14 CallbackObject 14 CallbackObject 0 0 0 0 1358 0 3 1355 1356 1357 0 0 1 0 1806 0 0 0 0 527
////////////////////////////////////////////////////////////////////
//       Class : CallbackObject
// Description : This is a generic object that can be assigned to a
//               callback at various points in the rendering process.
//               This is actually a base class for a handful of
//               specialized callback object types.  You can also
//               subclass it yourself to make your own callback
//               handler.
////////////////////////////////////////////////////////////////////

1808 33 CachedTypedWritableReferenceCount 0 43009 33 CachedTypedWritableReferenceCount 33 CachedTypedWritableReferenceCount 0 0 0 0 0 0 5 1359 1360 1361 1362 1363 0 0 1 0 1780 0 0 0 0 1112
////////////////////////////////////////////////////////////////////
//       Class : CachedTypedWritableReferenceCount
// Description : This is a special extension to ReferenceCount that
//               includes dual reference counts: the standard
//               reference count number, which includes all references
//               to the object, and a separate number (the cache
//               reference count) that counts the number of references
//               to the object just within its cache alone.  When
//               get_ref_count() == get_cache_ref_count(), the object
//               is not referenced outside the cache.
//
//               The cache refs must be explicitly maintained; there
//               is no PointerTo<> class to maintain the cache
//               reference counts automatically.  The cache reference
//               count is automatically included in the overall
//               reference count: calling cache_ref() and
//               cache_unref() automatically calls ref() and unref().
////////////////////////////////////////////////////////////////////

1809 12 CallbackData 0 141313 12 CallbackData 12 CallbackData 0 0 0 0 1367 0 3 1364 1365 1366 0 0 1 0 1779 0 0 0 0 610
////////////////////////////////////////////////////////////////////
//       Class : CallbackData
// Description : This is a generic data block that is passed along to
//               a CallbackObject when a callback is made.  It
//               contains data specific to the particular callback
//               type in question.
//
//               This is actually an abstract base class and contains
//               no data.  Specializations of this class will contain
//               the actual data relevant to each callback type.
////////////////////////////////////////////////////////////////////

1810 20 PythonCallbackObject 0 75777 20 PythonCallbackObject 20 PythonCallbackObject 0 0 0 1 1368 1358 0 6 1369 1370 1371 1372 1373 1374 0 0 1 0 1807 0 0 0 0 371
////////////////////////////////////////////////////////////////////
//       Class : PythonCallbackObject
// Description : This is a specialization on CallbackObject to allow
//               a callback to directly call an arbitarary Python
//               function.  Powerful!  But use with caution.
////////////////////////////////////////////////////////////////////

1811 7 TimeVal 0 141313 7 TimeVal 7 TimeVal 0 0 0 1 1375 1380 1 2115 2 1376 1377 0 0 0 0 0 0

1812 9 ulong [2] 0 4202496 9 ulong [2] 9 ulong [2] 0 0 1813 2 0 0 0 0 0 0 0 0 0 0

1813 5 ulong 0 2105344 5 ulong 5 ulong 0 0 1814 0 0 0 0 0 0 0 0 0 0

1814 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

1815 11 ClockObject 0 75777 11 ClockObject 11 ClockObject 0 0 0 1 1381 0 0 28 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 0 0 1 0 1781 0 0 0 1 1816 1457
////////////////////////////////////////////////////////////////////
//       Class : ClockObject
// Description : A ClockObject keeps track of elapsed real time and
//               discrete time.  In normal mode, get_frame_time()
//               returns the time as of the last time tick() was
//               called.  This is the "discrete" time, and is usually
//               used to get the time as of, for instance, the
//               beginning of the current frame.
//
//               In other modes, as set by set_mode() or the
//               clock-mode config variable, get_frame_time() may
//               return other values to simulate different timing
//               effects, for instance to perform non-real-time
//               animation.  See set_mode().
//
//               In all modes, get_real_time() always returns the
//               elapsed real time in seconds since the ClockObject
//               was constructed, or since it was last reset.
//
//               You can create your own ClockObject whenever you want
//               to have your own local timer.  There is also a
//               default, global ClockObject intended to represent
//               global time for the application; this is normally set
//               up to tick every frame so that its get_frame_time()
//               will return the time for the current frame.
////////////////////////////////////////////////////////////////////

1816 4 Mode 0 794624 17 ClockObject::Mode 17 ClockObject::Mode 1815 0 0 0 0 0 0 0 0 0 8 8 M_normal 21 ClockObject::M_normal 0
0 15 M_non_real_time 28 ClockObject::M_non_real_time 0
1 8 M_forced 21 ClockObject::M_forced 0
2 9 M_degrade 22 ClockObject::M_degrade 0
3 7 M_slave 20 ClockObject::M_slave 0
4 9 M_limited 22 ClockObject::M_limited 0
5 9 M_integer 22 ClockObject::M_integer 0
6 17 M_integer_limited 30 ClockObject::M_integer_limited 0
7 0 0

1817 11 CollideMask 0 2105345 11 CollideMask 11 CollideMask 0 0 1797 0 0 0 0 0 0 0 0 0 0

1818 10 ColorSpace 0 532481 10 ColorSpace 10 ColorSpace 0 0 0 0 0 0 0 0 0 0 4 14 CS_unspecified 14 CS_unspecified 105
// This value is not a color space, but is used to indicate that
// a color space has not been specified.
0 9 CS_linear 9 CS_linear 388
// CS_linear is not a color space per se, but represents the
// working color space of graphics APIs, which is linearized.  Since
// the conversion from sRGB to linear is defined, one could posit
// that it has the ITU-R BT.709 primaries, but this isn't meaningful
// as modern graphics APIs do not perform color management.
// All colors in Panda3D are linear unless otherwise specified.
1 7 CS_sRGB 7 CS_sRGB 107
// This is the standard, gamma-2.2-corrected sRGB color space, as
// used by the majority of image formats.
2 8 CS_scRGB 8 CS_scRGB 110
// This is a 16-bit encoded linear color space capable of encoding
// color values in the -0.5...7.4999 range.
3 0 0

1819 17 CopyOnWriteObject 0 141313 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 1416 0 2 1414 1415 0 0 1 0 1808 0 0 0 0 376
////////////////////////////////////////////////////////////////////
//       Class : CopyOnWriteObject
// Description : This base class provides basic reference counting,
//               but also can be used with a CopyOnWritePointer to
//               provide get_read_pointer() and get_write_pointer().
////////////////////////////////////////////////////////////////////

1820 17 DatagramInputFile 0 75777 17 DatagramInputFile 17 DatagramInputFile 0 0 0 1 1417 0 0 4 1418 1419 1420 1421 0 0 1 0 1821 0 0 0 0 340
////////////////////////////////////////////////////////////////////
//       Class : DatagramInputFile
// Description : This class can be used to read a binary file that
//               consists of an arbitrary header followed by a number
//               of datagrams.
////////////////////////////////////////////////////////////////////

1821 17 DatagramGenerator 0 2049 17 DatagramGenerator 17 DatagramGenerator 0 0 0 0 0 0 0 0 0 0 0 0 335
////////////////////////////////////////////////////////////////////
//       Class : DatagramGenerator
// Description : This class defines the abstract interace to any
//               source of datagrams, whether it be from a file or
//               from the net.
////////////////////////////////////////////////////////////////////

1822 30 DoubleBitMask< BitMaskNative > 0 26625 30 DoubleBitMask< BitMaskNative > 30 DoubleBitMask< BitMaskNative > 0 0 0 1 1422 1429 0 52 1423 1424 1425 1426 1427 1428 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 0 0 0 0 0 0

1823 19 DoubleBitMaskNative 0 2105345 19 DoubleBitMaskNative 19 DoubleBitMaskNative 0 0 1822 0 0 0 0 0 0 0 0 0 0

1824 36 DoubleBitMask< DoubleBitMaskNative > 0 26625 36 DoubleBitMask< DoubleBitMaskNative > 36 DoubleBitMask< DoubleBitMaskNative > 0 0 0 1 1476 1483 0 52 1477 1478 1479 1480 1481 1482 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 0 0 0 0 0 0

1825 17 QuadBitMaskNative 0 2105345 17 QuadBitMaskNative 17 QuadBitMaskNative 0 0 1824 0 0 0 0 0 0 0 0 0 0

1826 8 DrawMask 0 2105345 8 DrawMask 8 DrawMask 0 0 1797 0 0 0 0 0 0 0 0 0 0

1827 14 KeyboardButton 0 141313 14 KeyboardButton 14 KeyboardButton 0 0 0 0 1582 0 52 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 0 0 0 0 0 369
////////////////////////////////////////////////////////////////////
//       Class : KeyboardButton
// Description : This class is just used as a convenient namespace for
//               grouping all of these handy functions that return
//               buttons which map to standard keyboard keys.
////////////////////////////////////////////////////////////////////

1828 15 ModifierButtons 0 26625 15 ModifierButtons 15 ModifierButtons 0 0 0 1 1587 1588 0 23 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1 2116 0 0 0 0 343
////////////////////////////////////////////////////////////////////
//       Class : ModifierButtons
// Description : This class monitors the state of a number of
//               individual buttons and tracks whether each button is
//               known to be down or up.
////////////////////////////////////////////////////////////////////

1829 11 MouseButton 0 141313 11 MouseButton 11 MouseButton 0 0 0 0 1623 0 11 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 0 0 0 0 0 366
////////////////////////////////////////////////////////////////////
//       Class : MouseButton
// Description : This class is just used as a convenient namespace for
//               grouping all of these handy functions that return
//               buttons which map to standard mouse buttons.
////////////////////////////////////////////////////////////////////

1830 9 MouseData 0 141313 9 MouseData 9 MouseData 0 0 0 1 1624 1630 0 5 1625 1626 1627 1628 1629 0 0 0 0 0 326
////////////////////////////////////////////////////////////////////
//       Class : MouseData
// Description : Holds the data that might be generated by a 2-d
//               pointer input device, such as the mouse in the
//               GraphicsWindow.
////////////////////////////////////////////////////////////////////

1831 24 NodeCachedReferenceCount 0 43009 24 NodeCachedReferenceCount 24 NodeCachedReferenceCount 0 0 0 0 0 0 6 1631 1632 1633 1634 1635 1636 0 0 1 0 1808 0 0 0 1 1832 2143
////////////////////////////////////////////////////////////////////
//       Class : NodeCachedReferenceCount
// Description : This class further specializes
//               CachedTypedWritableReferenceCount to also add a
//               node_ref_count, for the purposes of counting the
//               number of times the object is referenced by a "node",
//               presumably a PandaNode.
//
//               This essentially combines the functionality of
//               NodeReferenceCount and
//               CachedTypedWritableReferenceCount, so that a
//               derivative of this object actually has three
//               counters: the standard reference count, the "cache"
//               reference count, and the "node" reference count.
//               Rather than multiply inheriting from the two
//               reference count classes, we inherit only from
//               CachedTypedWritableReferenceCount and simply
//               duplicate the functionality of NodeReferenceCount, to
//               avoid all of the problems associated with multiple
//               inheritance.
//
//               The intended design is to use this as a base class
//               for RenderState and TransformState, both of which are
//               held by PandaNodes, and also have caches which are
//               independently maintained.  By keeping track of how
//               many nodes hold a pointer to a particular object, we
//               can classify each object into node-referenced,
//               cache-referenced, or other, which is primarily useful
//               for PStats reporting.
//
//               As with CachedTypedWritableReferenceCount's
//               cache_ref() and cache_unref(), the new methods
//               node_ref() and node_unref() automatically increment
//               and decrement the primary reference count as well.
//               In this case, however, there does exist a
//               NodePointerTo<> class to maintain the node_ref
//               counters automatically.
////////////////////////////////////////////////////////////////////

1832 10 Referenced 0 794624 36 NodeCachedReferenceCount::Referenced 36 NodeCachedReferenceCount::Referenced 1831 0 0 0 0 0 0 0 0 0 2 6 R_node 32 NodeCachedReferenceCount::R_node 0
1 7 R_cache 33 NodeCachedReferenceCount::R_cache 0
2 0 0

1833 11 SparseArray 0 26625 11 SparseArray 11 SparseArray 0 0 0 1 1637 1644 0 52 1638 1639 1640 1641 1642 1643 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 0 0 0 0 0 1136
////////////////////////////////////////////////////////////////////
//       Class : SparseArray
// Description : This class records a set of integers, where each
//               integer is either present or not present in the set.
//
//               It is similar in principle and in interface to a
//               BitArray (which can be thought of as a set of
//               integers, one integer corresponding to each different
//               bit position), but the SparseArray is implemented as
//               a list of min/max subrange lists, rather than as a
//               bitmask.  
//
//               This makes it particularly efficient for storing sets
//               which consist of large sections of consecutively
//               included or consecutively excluded elements, with
//               arbitrarily large integers, but particularly
//               inefficient for doing boolean operations such as & or
//               |.
//
//               Also, unlike BitArray, the SparseArray can store
//               negative integers.
////////////////////////////////////////////////////////////////////

1834 14 ParamValueBase 0 75777 14 ParamValueBase 14 ParamValueBase 0 0 0 0 975 0 3 1691 1692 1693 0 0 1 0 1780 0 0 0 0 348
////////////////////////////////////////////////////////////////////
//       Class : ParamValueBase
// Description : A non-template base class of ParamValue (below),
//               which serves mainly to define the placeholder for the
//               virtual output function.
////////////////////////////////////////////////////////////////////

1835 18 ParamTypedRefCount 0 75777 18 ParamTypedRefCount 18 ParamTypedRefCount 0 0 0 1 1694 975 0 2 1695 1696 0 0 1 0 1834 0 0 0 0 354
////////////////////////////////////////////////////////////////////
//       Class : ParamTypedRefCount
// Description : A class object for storing specifically objects of
//               type TypedReferenceCount, which is different than
//               TypedWritableReferenceCount.
////////////////////////////////////////////////////////////////////

1836 20 ParamValue< string > 0 75777 20 ParamValue< string > 20 ParamValue< string > 0 0 0 1 1697 975 0 3 1698 1699 1700 0 0 1 0 1834 0 0 0 0 0

1837 11 ParamString 0 2105345 11 ParamString 11 ParamString 0 0 1836 0 0 0 0 0 0 0 0 0 0

1838 21 ParamValue< wstring > 0 75777 21 ParamValue< wstring > 21 ParamValue< wstring > 0 0 0 1 1701 975 0 3 1702 1703 1704 0 0 1 0 1834 0 0 0 0 0

1839 12 ParamWstring 0 2105345 12 ParamWstring 12 ParamWstring 0 0 1838 0 0 0 0 0 0 0 0 0 0

1840 24 ParamValue< LVecBase2d > 0 75777 24 ParamValue< LVecBase2d > 24 ParamValue< LVecBase2d > 0 0 0 1 1705 975 0 3 1706 1707 1708 0 0 1 0 1834 0 0 0 0 0

1841 14 ParamVecBase2d 0 2105345 14 ParamVecBase2d 14 ParamVecBase2d 0 0 1840 0 0 0 0 0 0 0 0 0 0

1842 24 ParamValue< LVecBase2f > 0 75777 24 ParamValue< LVecBase2f > 24 ParamValue< LVecBase2f > 0 0 0 1 1709 975 0 3 1710 1711 1712 0 0 1 0 1834 0 0 0 0 0

1843 14 ParamVecBase2f 0 2105345 14 ParamVecBase2f 14 ParamVecBase2f 0 0 1842 0 0 0 0 0 0 0 0 0 0

1844 24 ParamValue< LVecBase2i > 0 75777 24 ParamValue< LVecBase2i > 24 ParamValue< LVecBase2i > 0 0 0 1 1713 975 0 3 1714 1715 1716 0 0 1 0 1834 0 0 0 0 0

1845 14 ParamVecBase2i 0 2105345 14 ParamVecBase2i 14 ParamVecBase2i 0 0 1844 0 0 0 0 0 0 0 0 0 0

1846 24 ParamValue< LVecBase3d > 0 75777 24 ParamValue< LVecBase3d > 24 ParamValue< LVecBase3d > 0 0 0 1 1717 975 0 3 1718 1719 1720 0 0 1 0 1834 0 0 0 0 0

1847 14 ParamVecBase3d 0 2105345 14 ParamVecBase3d 14 ParamVecBase3d 0 0 1846 0 0 0 0 0 0 0 0 0 0

1848 24 ParamValue< LVecBase3f > 0 75777 24 ParamValue< LVecBase3f > 24 ParamValue< LVecBase3f > 0 0 0 1 1721 975 0 3 1722 1723 1724 0 0 1 0 1834 0 0 0 0 0

1849 14 ParamVecBase3f 0 2105345 14 ParamVecBase3f 14 ParamVecBase3f 0 0 1848 0 0 0 0 0 0 0 0 0 0

1850 24 ParamValue< LVecBase3i > 0 75777 24 ParamValue< LVecBase3i > 24 ParamValue< LVecBase3i > 0 0 0 1 1725 975 0 3 1726 1727 1728 0 0 1 0 1834 0 0 0 0 0

1851 14 ParamVecBase3i 0 2105345 14 ParamVecBase3i 14 ParamVecBase3i 0 0 1850 0 0 0 0 0 0 0 0 0 0

1852 24 ParamValue< LVecBase4d > 0 75777 24 ParamValue< LVecBase4d > 24 ParamValue< LVecBase4d > 0 0 0 1 1729 975 0 3 1730 1731 1732 0 0 1 0 1834 0 0 0 0 0

1853 14 ParamVecBase4d 0 2105345 14 ParamVecBase4d 14 ParamVecBase4d 0 0 1852 0 0 0 0 0 0 0 0 0 0

1854 24 ParamValue< LVecBase4f > 0 75777 24 ParamValue< LVecBase4f > 24 ParamValue< LVecBase4f > 0 0 0 1 1733 975 0 3 1734 1735 1736 0 0 1 0 1834 0 0 0 0 0

1855 14 ParamVecBase4f 0 2105345 14 ParamVecBase4f 14 ParamVecBase4f 0 0 1854 0 0 0 0 0 0 0 0 0 0

1856 24 ParamValue< LVecBase4i > 0 75777 24 ParamValue< LVecBase4i > 24 ParamValue< LVecBase4i > 0 0 0 1 1737 975 0 3 1738 1739 1740 0 0 1 0 1834 0 0 0 0 0

1857 14 ParamVecBase4i 0 2105345 14 ParamVecBase4i 14 ParamVecBase4i 0 0 1856 0 0 0 0 0 0 0 0 0 0

1858 23 ParamValue< LMatrix3d > 0 75777 23 ParamValue< LMatrix3d > 23 ParamValue< LMatrix3d > 0 0 0 1 1741 975 0 3 1742 1743 1744 0 0 1 0 1834 0 0 0 0 0

1859 13 ParamMatrix3d 0 2105345 13 ParamMatrix3d 13 ParamMatrix3d 0 0 1858 0 0 0 0 0 0 0 0 0 0

1860 23 ParamValue< LMatrix3f > 0 75777 23 ParamValue< LMatrix3f > 23 ParamValue< LMatrix3f > 0 0 0 1 1745 975 0 3 1746 1747 1748 0 0 1 0 1834 0 0 0 0 0

1861 13 ParamMatrix3f 0 2105345 13 ParamMatrix3f 13 ParamMatrix3f 0 0 1860 0 0 0 0 0 0 0 0 0 0

1862 23 ParamValue< LMatrix4d > 0 75777 23 ParamValue< LMatrix4d > 23 ParamValue< LMatrix4d > 0 0 0 1 1749 975 0 3 1750 1751 1752 0 0 1 0 1834 0 0 0 0 0

1863 13 ParamMatrix4d 0 2105345 13 ParamMatrix4d 13 ParamMatrix4d 0 0 1862 0 0 0 0 0 0 0 0 0 0

1864 23 ParamValue< LMatrix4f > 0 75777 23 ParamValue< LMatrix4f > 23 ParamValue< LMatrix4f > 0 0 0 1 1753 975 0 3 1754 1755 1756 0 0 1 0 1834 0 0 0 0 0

1865 13 ParamMatrix4f 0 2105345 13 ParamMatrix4f 13 ParamMatrix4f 0 0 1864 0 0 0 0 0 0 0 0 0 0

1866 13 ParamVecBase2 0 2105345 13 ParamVecBase2 13 ParamVecBase2 0 0 1843 0 0 0 0 0 0 0 0 0 0

1867 13 ParamVecBase3 0 2105345 13 ParamVecBase3 13 ParamVecBase3 0 0 1849 0 0 0 0 0 0 0 0 0 0

1868 13 ParamVecBase4 0 2105345 13 ParamVecBase4 13 ParamVecBase4 0 0 1855 0 0 0 0 0 0 0 0 0 0

1869 12 ParamMatrix3 0 2105345 12 ParamMatrix3 12 ParamMatrix3 0 0 1861 0 0 0 0 0 0 0 0 0 0

1870 12 ParamMatrix4 0 2105345 12 ParamMatrix4 12 ParamMatrix4 0 0 1865 0 0 0 0 0 0 0 0 0 0

1871 20 WritableConfigurable 0 141313 20 WritableConfigurable 20 WritableConfigurable 0 0 0 0 1758 0 1 1757 0 0 1 0 1778 0 0 0 0 666
////////////////////////////////////////////////////////////////////
//       Class : WritableConfigurable
// Description : Defined as a fix to allow creating Configurable and
//               Writable objects.  Otherwise the compiler gets
//               confused since both TypedWritable and Configurable
//               inherit from TypedObject.
//
//               An object that has data or parameters that are set
//               less frequently (at least occasionally) than every
//               frame.  We can cache the configuration info by
//               by using the "dirty" flag.
////////////////////////////////////////////////////////////////////

1872 17 UniqueIdAllocator 0 26625 17 UniqueIdAllocator 17 UniqueIdAllocator 0 0 0 1 1759 1760 0 6 1761 1762 1763 1764 1765 1766 0 0 0 0 0 1207
////////////////////////////////////////////////////////////////////
//       Class : UniqueIdAllocator
// Description : Manage a set of ID values from min to max inclusive.
//               The ID numbers that are freed will be allocated
//               (reused) in the same order.  I.e. the oldest ID numbers
//               will be allocated.
//
//               This implementation will use 4 bytes per id number,
//               plus a few bytes of management data.  e.g. 10,000
//               ID numbers will use 40KB.
//
//               Also be advised that ID -1 and -2 are used internally by
//               the allocator.  If allocate returns IndexEnd (-1) then
//               the allocator is out of free ID numbers.
//
//               There are other implementations that can better leverage
//               runs of used or unused IDs or use bit arrays for the
//               IDs.  But, it takes extra work to track the age of
//               freed IDs, which is required for what we wanted.  If
//               you would like to kick around other implementation
//               ideas, please contact Schuyler.
////////////////////////////////////////////////////////////////////

1873 10 PortalMask 0 2105345 10 PortalMask 10 PortalMask 0 0 1797 0 0 0 0 0 0 0 0 0 0

1874 37 ConstPointerToArray< ushort > const * 0 8576 37 ConstPointerToArray< ushort > const * 37 ConstPointerToArray< ushort > const * 0 0 1875 0 0 0 0 0 0 0 0 0 0

1875 35 ConstPointerToArray< ushort > const 0 8832 35 ConstPointerToArray< ushort > const 35 ConstPointerToArray< ushort > const 0 0 1769 0 0 0 0 0 0 0 0 0 0

1876 31 ConstPointerToArray< ushort > * 0 8576 31 ConstPointerToArray< ushort > * 31 ConstPointerToArray< ushort > * 0 0 1769 0 0 0 0 0 0 0 0 0 0

1877 32 PointerToArray< ushort > const * 0 8576 32 PointerToArray< ushort > const * 32 PointerToArray< ushort > const * 0 0 1878 0 0 0 0 0 0 0 0 0 0

1878 30 PointerToArray< ushort > const 0 8832 30 PointerToArray< ushort > const 30 PointerToArray< ushort > const 0 0 1773 0 0 0 0 0 0 0 0 0 0

1879 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 1880 0 0 0 0 0 0 0 0 0 0

1880 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 1881 0 0 0 0 0 0 0 0 0 0

1881 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

1882 6 size_t 0 2105344 6 size_t 6 size_t 0 0 1814 0 0 0 0 0 0 0 0 0 0

1883 6 ushort 0 2105344 6 ushort 6 ushort 0 0 1884 0 0 0 0 0 0 0 0 0 0

1884 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0

1885 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

1886 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

1887 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 1888 0 0 0 0 0 0 0 0 0 0

1888 9 Py_buffer 0 1024 9 Py_buffer 9 Py_buffer 0 0 0 0 0 0 0 0 0 0 0 0 0

1889 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

1890 51 PointerToBase< ReferenceCountedVector< ushort > > * 0 8576 51 PointerToBase< ReferenceCountedVector< ushort > > * 51 PointerToBase< ReferenceCountedVector< ushort > > * 0 0 1771 0 0 0 0 0 0 0 0 0 0

1891 57 PointerToBase< ReferenceCountedVector< ushort > > const * 0 8576 57 PointerToBase< ReferenceCountedVector< ushort > > const * 57 PointerToBase< ReferenceCountedVector< ushort > > const * 0 0 1892 0 0 0 0 0 0 0 0 0 0

1892 55 PointerToBase< ReferenceCountedVector< ushort > > const 0 8832 55 PointerToBase< ReferenceCountedVector< ushort > > const 55 PointerToBase< ReferenceCountedVector< ushort > > const 0 0 1771 0 0 0 0 0 0 0 0 0 0

1893 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 1894 0 0 0 0 0 0 0 0 0 0

1894 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

1895 26 PointerToArray< ushort > * 0 8576 26 PointerToArray< ushort > * 26 PointerToArray< ushort > * 0 0 1773 0 0 0 0 0 0 0 0 0 0

1896 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 1897 0 0 0 0 0 0 0 0 0 0

1897 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 1098
////////////////////////////////////////////////////////////////////
//       Class : TypeHandle
// Description : TypeHandle is the identifier used to differentiate
//               C++ class types.  Any C++ classes that inherit from
//               some base class, and must be differentiated at run
//               time, should store a static TypeHandle object that
//               can be queried through a static member function
//               named get_class_type().  Most of the time, it is also
//               desirable to inherit from TypedObject, which provides
//               some virtual functions to return the TypeHandle for a
//               particular instance.
//
//               At its essence, a TypeHandle is simply a unique
//               identifier that is assigned by the TypeRegistry.  The
//               TypeRegistry stores a tree of TypeHandles, so that
//               ancestry of a particular type may be queried, and the
//               type name may be retrieved for run-time display.
////////////////////////////////////////////////////////////////////

1898 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 1775 0 0 0 0 0 0 0 0 0 0

1899 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

1900 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

1901 21 AnimInterface const * 0 8576 21 AnimInterface const * 21 AnimInterface const * 0 0 1902 0 0 0 0 0 0 0 0 0 0

1902 19 AnimInterface const 0 8832 19 AnimInterface const 19 AnimInterface const 0 0 1775 0 0 0 0 0 0 0 0 0 0

1903 11 UpdateSeq * 0 8576 11 UpdateSeq * 11 UpdateSeq * 0 0 1777 0 0 0 0 0 0 0 0 0 0

1904 17 UpdateSeq const * 0 8576 17 UpdateSeq const * 17 UpdateSeq const * 0 0 1905 0 0 0 0 0 0 0 0 0 0

1905 15 UpdateSeq const 0 8832 15 UpdateSeq const 15 UpdateSeq const 0 0 1777 0 0 0 0 0 0 0 0 0 0

1906 7 Integer 0 2367488 21 AtomicAdjust::Integer 21 AtomicAdjust::Integer 1907 0 1908 0 0 0 0 0 0 0 0 0 0

1907 12 AtomicAdjust 0 1024 12 AtomicAdjust 12 AtomicAdjust 0 0 0 0 0 0 0 0 0 0 0 0 0

1908 8 long int 0 8210 8 long int 8 long int 0 1 0 0 0 0 0 0 0 0 0 0 0

1909 15 TypedWritable * 0 8576 15 TypedWritable * 15 TypedWritable * 0 0 1778 0 0 0 0 0 0 0 0 0 0

1910 21 TypedWritable const * 0 8576 21 TypedWritable const * 21 TypedWritable const * 0 0 1911 0 0 0 0 0 0 0 0 0 0

1911 19 TypedWritable const 0 8832 19 TypedWritable const 19 TypedWritable const 0 0 1778 0 0 0 0 0 0 0 0 0 0

1912 8 string * 0 8576 8 string * 8 string * 0 0 1913 0 0 0 0 0 0 0 0 0 0

1913 6 string 0 2105344 6 string 6 string 0 0 1774 0 0 0 0 0 0 0 0 0 0

1914 11 BamWriter * 0 8576 11 BamWriter * 11 BamWriter * 0 0 1793 0 0 0 0 0 0 0 0 0 0

1915 11 BamReader * 0 8576 11 BamReader * 11 BamReader * 0 0 1792 0 0 0 0 0 0 0 0 0 0

1916 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 1780 0 0 0 0 0 0 0 0 0 0

1917 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 1781 0 0 0 0 0 0 0 0 0 0

1918 22 BamCacheRecord const * 0 8576 22 BamCacheRecord const * 22 BamCacheRecord const * 0 0 1919 0 0 0 0 0 0 0 0 0 0

1919 20 BamCacheRecord const 0 8832 20 BamCacheRecord const 20 BamCacheRecord const 0 0 1782 0 0 0 0 0 0 0 0 0 0

1920 16 BamCacheRecord * 0 8576 16 BamCacheRecord * 16 BamCacheRecord * 0 0 1782 0 0 0 0 0 0 0 0 0 0

1921 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 1922 0 0 0 0 0 0 0 0 0 0

1922 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 1923 0 0 0 0 0 0 0 0 0 0

1923 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 869
////////////////////////////////////////////////////////////////////
//       Class : Filename
// Description : The name of a file, such as a texture file or an Egg
//               file.  Stores the full pathname, and includes
//               functions for extracting out the directory prefix
//               part and the file extension and stuff.
//
//               A Filename is also aware of the mapping between the
//               Unix-like filename convention we use internally, and
//               the local OS's specific filename convention, and it
//               knows how to perform basic OS-specific I/O, like
//               testing for file existence and searching a
//               searchpath, as well as the best way to open an
//               fstream for reading or writing.
////////////////////////////////////////////////////////////////////

1924 6 time_t 0 2105344 6 time_t 6 time_t 0 0 1925 0 0 0 0 0 0 0 0 0 0

1925 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

1926 10 BamCache * 0 8576 10 BamCache * 10 BamCache * 0 0 1784 0 0 0 0 0 0 0 0 0 0

1927 16 BamCache const * 0 8576 16 BamCache const * 16 BamCache const * 0 0 1928 0 0 0 0 0 0 0 0 0 0

1928 14 BamCache const 0 8832 14 BamCache const 14 BamCache const 0 0 1784 0 0 0 0 0 0 0 0 0 0

1929 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 1923 0 0 0 0 0 0 0 0 0 0

1930 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 1931 0 0 0 0 0 0 0 0 0 0

1931 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 1789 0 0 0 0 0 0 0 0 0 0

1932 15 LoaderOptions * 0 8576 15 LoaderOptions * 15 LoaderOptions * 0 0 1789 0 0 0 0 0 0 0 0 0 0

1933 19 DatagramGenerator * 0 8576 19 DatagramGenerator * 19 DatagramGenerator * 0 0 1821 0 0 0 0 0 0 0 0 0 0

1934 9 AuxData * 0 8576 20 BamReader::AuxData * 20 BamReader::AuxData * 0 0 1935 0 0 0 0 0 0 0 0 0 0

1935 7 AuxData 0 1312768 18 BamReader::AuxData 18 BamReader::AuxData 1792 0 0 0 0 0 0 0 0 0 0 0 187
// Inherit from this class to piggyback additional temporary data on
// the bamReader (via set_aux_data() and get_aux_data()) for any
// particular objects during the bam reading process.

1936 17 BamReader const * 0 8576 17 BamReader const * 17 BamReader const * 0 0 1937 0 0 0 0 0 0 0 0 0 0

1937 15 BamReader const 0 8832 15 BamReader const 15 BamReader const 0 0 1792 0 0 0 0 0 0 0 0 0 0

1938 14 DatagramSink * 0 8576 14 DatagramSink * 14 DatagramSink * 0 0 1939 0 0 0 0 0 0 0 0 0 0

1939 12 DatagramSink 0 2048 12 DatagramSink 12 DatagramSink 0 0 0 0 0 0 0 0 0 0 0 0 340
////////////////////////////////////////////////////////////////////
//       Class : DatagramSink
// Description : This class defines the abstract interface to sending
//               datagrams to any target, whether it be into a file
//               or across the net
////////////////////////////////////////////////////////////////////

1940 17 BamWriter const * 0 8576 17 BamWriter const * 17 BamWriter const * 0 0 1941 0 0 0 0 0 0 0 0 0 0

1941 15 BamWriter const 0 8832 15 BamWriter const 15 BamWriter const 0 0 1793 0 0 0 0 0 0 0 0 0 0

1942 26 BitMask< PN_uint16, 16 > * 0 8576 26 BitMask< PN_uint16, 16 > * 26 BitMask< PN_uint16, 16 > * 0 0 1794 0 0 0 0 0 0 0 0 0 0

1943 32 BitMask< PN_uint16, 16 > const * 0 8576 32 BitMask< PN_uint16, 16 > const * 32 BitMask< PN_uint16, 16 > const * 0 0 1944 0 0 0 0 0 0 0 0 0 0

1944 30 BitMask< PN_uint16, 16 > const 0 8832 30 BitMask< PN_uint16, 16 > const 30 BitMask< PN_uint16, 16 > const 0 0 1794 0 0 0 0 0 0 0 0 0 0

1945 9 PN_uint16 0 2105344 9 PN_uint16 9 PN_uint16 0 0 1884 0 0 0 0 0 0 0 0 0 0

1946 26 BitMask< PN_uint32, 32 > * 0 8576 26 BitMask< PN_uint32, 32 > * 26 BitMask< PN_uint32, 32 > * 0 0 1796 0 0 0 0 0 0 0 0 0 0

1947 32 BitMask< PN_uint32, 32 > const * 0 8576 32 BitMask< PN_uint32, 32 > const * 32 BitMask< PN_uint32, 32 > const * 0 0 1948 0 0 0 0 0 0 0 0 0 0

1948 30 BitMask< PN_uint32, 32 > const 0 8832 30 BitMask< PN_uint32, 32 > const 30 BitMask< PN_uint32, 32 > const 0 0 1796 0 0 0 0 0 0 0 0 0 0

1949 9 PN_uint32 0 2105344 9 PN_uint32 9 PN_uint32 0 0 1925 0 0 0 0 0 0 0 0 0 0

1950 26 BitMask< PN_uint64, 64 > * 0 8576 26 BitMask< PN_uint64, 64 > * 26 BitMask< PN_uint64, 64 > * 0 0 1798 0 0 0 0 0 0 0 0 0 0

1951 32 BitMask< PN_uint64, 64 > const * 0 8576 32 BitMask< PN_uint64, 64 > const * 32 BitMask< PN_uint64, 64 > const * 0 0 1952 0 0 0 0 0 0 0 0 0 0

1952 30 BitMask< PN_uint64, 64 > const 0 8832 30 BitMask< PN_uint64, 64 > const 30 BitMask< PN_uint64, 64 > const 0 0 1798 0 0 0 0 0 0 0 0 0 0

1953 9 PN_uint64 0 2105344 9 PN_uint64 9 PN_uint64 0 0 1954 0 0 0 0 0 0 0 0 0 0

1954 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

1955 10 BitArray * 0 8576 10 BitArray * 10 BitArray * 0 0 1801 0 0 0 0 0 0 0 0 0 0

1956 16 BitArray const * 0 8576 16 BitArray const * 16 BitArray const * 0 0 1957 0 0 0 0 0 0 0 0 0 0

1957 14 BitArray const 0 8832 14 BitArray const 14 BitArray const 0 0 1801 0 0 0 0 0 0 0 0 0 0

1958 8 WordType 0 2367488 18 BitArray::WordType 18 BitArray::WordType 1801 0 1949 0 0 0 0 0 0 0 0 0 0

1959 19 SparseArray const * 0 8576 19 SparseArray const * 19 SparseArray const * 0 0 1960 0 0 0 0 0 0 0 0 0 0

1960 17 SparseArray const 0 8832 17 SparseArray const 17 SparseArray const 0 0 1833 0 0 0 0 0 0 0 0 0 0

1961 8 MaskType 0 2367488 18 BitArray::MaskType 18 BitArray::MaskType 1801 0 1800 0 0 0 0 0 0 0 0 0 0

1962 10 MaskType * 0 8576 20 BitArray::MaskType * 20 BitArray::MaskType * 0 0 1961 0 0 0 0 0 0 0 0 0 0

1963 14 ButtonHandle * 0 8576 14 ButtonHandle * 14 ButtonHandle * 0 0 1803 0 0 0 0 0 0 0 0 0 0

1964 20 ButtonHandle const * 0 8576 20 ButtonHandle const * 20 ButtonHandle const * 0 0 1965 0 0 0 0 0 0 0 0 0 0

1965 18 ButtonHandle const 0 8832 18 ButtonHandle const 18 ButtonHandle const 0 0 1803 0 0 0 0 0 0 0 0 0 0

1966 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0

1967 16 ButtonRegistry * 0 8576 16 ButtonRegistry * 16 ButtonRegistry * 0 0 1804 0 0 0 0 0 0 0 0 0 0

1968 22 ButtonRegistry const * 0 8576 22 ButtonRegistry const * 22 ButtonRegistry const * 0 0 1969 0 0 0 0 0 0 0 0 0 0

1969 20 ButtonRegistry const 0 8832 20 ButtonRegistry const 20 ButtonRegistry const 0 0 1804 0 0 0 0 0 0 0 0 0 0

1970 17 ButtonMap const * 0 8576 17 ButtonMap const * 17 ButtonMap const * 0 0 1971 0 0 0 0 0 0 0 0 0 0

1971 15 ButtonMap const 0 8832 15 ButtonMap const 15 ButtonMap const 0 0 1805 0 0 0 0 0 0 0 0 0 0

1972 22 CallbackObject const * 0 8576 22 CallbackObject const * 22 CallbackObject const * 0 0 1973 0 0 0 0 0 0 0 0 0 0

1973 20 CallbackObject const 0 8832 20 CallbackObject const 20 CallbackObject const 0 0 1807 0 0 0 0 0 0 0 0 0 0

1974 16 CallbackObject * 0 8576 16 CallbackObject * 16 CallbackObject * 0 0 1807 0 0 0 0 0 0 0 0 0 0

1975 41 CachedTypedWritableReferenceCount const * 0 8576 41 CachedTypedWritableReferenceCount const * 41 CachedTypedWritableReferenceCount const * 0 0 1976 0 0 0 0 0 0 0 0 0 0

1976 39 CachedTypedWritableReferenceCount const 0 8832 39 CachedTypedWritableReferenceCount const 39 CachedTypedWritableReferenceCount const 0 0 1808 0 0 0 0 0 0 0 0 0 0

1977 20 CallbackData const * 0 8576 20 CallbackData const * 20 CallbackData const * 0 0 1978 0 0 0 0 0 0 0 0 0 0

1978 18 CallbackData const 0 8832 18 CallbackData const 18 CallbackData const 0 0 1809 0 0 0 0 0 0 0 0 0 0

1979 14 CallbackData * 0 8576 14 CallbackData * 14 CallbackData * 0 0 1809 0 0 0 0 0 0 0 0 0 0

1980 22 PythonCallbackObject * 0 8576 22 PythonCallbackObject * 22 PythonCallbackObject * 0 0 1810 0 0 0 0 0 0 0 0 0 0

1981 9 TimeVal * 0 8576 9 TimeVal * 9 TimeVal * 0 0 1811 0 0 0 0 0 0 0 0 0 0

1982 15 TimeVal const * 0 8576 15 TimeVal const * 15 TimeVal const * 0 0 1983 0 0 0 0 0 0 0 0 0 0

1983 13 TimeVal const 0 8832 13 TimeVal const 13 TimeVal const 0 0 1811 0 0 0 0 0 0 0 0 0 0

1984 13 ClockObject * 0 8576 13 ClockObject * 13 ClockObject * 0 0 1815 0 0 0 0 0 0 0 0 0 0

1985 19 ClockObject const * 0 8576 19 ClockObject const * 19 ClockObject const * 0 0 1986 0 0 0 0 0 0 0 0 0 0

1986 17 ClockObject const 0 8832 17 ClockObject const 17 ClockObject const 0 0 1815 0 0 0 0 0 0 0 0 0 0

1987 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 1988 0 0 0 0 0 0 0 0 0 0

1988 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 668
////////////////////////////////////////////////////////////////////
//       Class : Thread
// Description : A thread; that is, a lightweight process.  This is an
//               abstract base class; to use it, you must subclass
//               from it and redefine thread_main().
//
//               The thread itself will keep a reference count on the
//               Thread object while it is running; when the thread
//               returns from its root function, the Thread object
//               will automatically be destructed if no other pointers
//               are referencing it.
////////////////////////////////////////////////////////////////////

1989 25 CopyOnWriteObject const * 0 8576 25 CopyOnWriteObject const * 25 CopyOnWriteObject const * 0 0 1990 0 0 0 0 0 0 0 0 0 0

1990 23 CopyOnWriteObject const 0 8832 23 CopyOnWriteObject const 23 CopyOnWriteObject const 0 0 1819 0 0 0 0 0 0 0 0 0 0

1991 19 DatagramInputFile * 0 8576 19 DatagramInputFile * 19 DatagramInputFile * 0 0 1820 0 0 0 0 0 0 0 0 0 0

1992 21 FileReference const * 0 8576 21 FileReference const * 21 FileReference const * 0 0 1993 0 0 0 0 0 0 0 0 0 0

1993 19 FileReference const 0 8832 19 FileReference const 19 FileReference const 0 0 1994 0 0 0 0 0 0 0 0 0 0

1994 13 FileReference 0 2048 13 FileReference 13 FileReference 0 0 0 0 0 0 0 0 0 0 0 0 354
////////////////////////////////////////////////////////////////////
//       Class : FileReference
// Description : Keeps a reference-counted pointer to a file on disk.
//               As long as the FileReference is held, someone
//               presumably has a use for this file.
////////////////////////////////////////////////////////////////////

1995 9 istream * 0 8576 9 istream * 9 istream * 0 0 1996 0 0 0 0 0 0 0 0 0 0

1996 7 istream 0 2048 7 istream 7 istream 0 0 0 0 0 0 0 0 0 0 0 0 0

1997 32 DoubleBitMask< BitMaskNative > * 0 8576 32 DoubleBitMask< BitMaskNative > * 32 DoubleBitMask< BitMaskNative > * 0 0 1822 0 0 0 0 0 0 0 0 0 0

1998 38 DoubleBitMask< BitMaskNative > const * 0 8576 38 DoubleBitMask< BitMaskNative > const * 38 DoubleBitMask< BitMaskNative > const * 0 0 1999 0 0 0 0 0 0 0 0 0 0

1999 36 DoubleBitMask< BitMaskNative > const 0 8832 36 DoubleBitMask< BitMaskNative > const 36 DoubleBitMask< BitMaskNative > const 0 0 1822 0 0 0 0 0 0 0 0 0 0

2000 38 DoubleBitMask< DoubleBitMaskNative > * 0 8576 38 DoubleBitMask< DoubleBitMaskNative > * 38 DoubleBitMask< DoubleBitMaskNative > * 0 0 1824 0 0 0 0 0 0 0 0 0 0

2001 44 DoubleBitMask< DoubleBitMaskNative > const * 0 8576 44 DoubleBitMask< DoubleBitMaskNative > const * 44 DoubleBitMask< DoubleBitMaskNative > const * 0 0 2002 0 0 0 0 0 0 0 0 0 0

2002 42 DoubleBitMask< DoubleBitMaskNative > const 0 8832 42 DoubleBitMask< DoubleBitMaskNative > const 42 DoubleBitMask< DoubleBitMaskNative > const 0 0 1824 0 0 0 0 0 0 0 0 0 0

2003 17 ModifierButtons * 0 8576 17 ModifierButtons * 17 ModifierButtons * 0 0 1828 0 0 0 0 0 0 0 0 0 0

2004 23 ModifierButtons const * 0 8576 23 ModifierButtons const * 23 ModifierButtons const * 0 0 2005 0 0 0 0 0 0 0 0 0 0

2005 21 ModifierButtons const 0 8832 21 ModifierButtons const 21 ModifierButtons const 0 0 1828 0 0 0 0 0 0 0 0 0 0

2006 11 MouseData * 0 8576 11 MouseData * 11 MouseData * 0 0 1830 0 0 0 0 0 0 0 0 0 0

2007 17 MouseData const * 0 8576 17 MouseData const * 17 MouseData const * 0 0 2008 0 0 0 0 0 0 0 0 0 0

2008 15 MouseData const 0 8832 15 MouseData const 15 MouseData const 0 0 1830 0 0 0 0 0 0 0 0 0 0

2009 32 NodeCachedReferenceCount const * 0 8576 32 NodeCachedReferenceCount const * 32 NodeCachedReferenceCount const * 0 0 2010 0 0 0 0 0 0 0 0 0 0

2010 30 NodeCachedReferenceCount const 0 8832 30 NodeCachedReferenceCount const 30 NodeCachedReferenceCount const 0 0 1831 0 0 0 0 0 0 0 0 0 0

2011 13 SparseArray * 0 8576 13 SparseArray * 13 SparseArray * 0 0 1833 0 0 0 0 0 0 0 0 0 0

2012 22 ParamValueBase const * 0 8576 22 ParamValueBase const * 22 ParamValueBase const * 0 0 2013 0 0 0 0 0 0 0 0 0 0

2013 20 ParamValueBase const 0 8832 20 ParamValueBase const 20 ParamValueBase const 0 0 1834 0 0 0 0 0 0 0 0 0 0

2014 27 TypedReferenceCount const * 0 8576 27 TypedReferenceCount const * 27 TypedReferenceCount const * 0 0 2015 0 0 0 0 0 0 0 0 0 0

2015 25 TypedReferenceCount const 0 8832 25 TypedReferenceCount const 25 TypedReferenceCount const 0 0 1806 0 0 0 0 0 0 0 0 0 0

2016 20 ParamTypedRefCount * 0 8576 20 ParamTypedRefCount * 20 ParamTypedRefCount * 0 0 1835 0 0 0 0 0 0 0 0 0 0

2017 26 ParamTypedRefCount const * 0 8576 26 ParamTypedRefCount const * 26 ParamTypedRefCount const * 0 0 2018 0 0 0 0 0 0 0 0 0 0

2018 24 ParamTypedRefCount const 0 8832 24 ParamTypedRefCount const 24 ParamTypedRefCount const 0 0 1835 0 0 0 0 0 0 0 0 0 0

2019 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 1806 0 0 0 0 0 0 0 0 0 0

2020 22 ParamValue< string > * 0 8576 22 ParamValue< string > * 22 ParamValue< string > * 0 0 1836 0 0 0 0 0 0 0 0 0 0

2021 28 ParamValue< string > const * 0 8576 28 ParamValue< string > const * 28 ParamValue< string > const * 0 0 2022 0 0 0 0 0 0 0 0 0 0

2022 26 ParamValue< string > const 0 8832 26 ParamValue< string > const 26 ParamValue< string > const 0 0 1836 0 0 0 0 0 0 0 0 0 0

2023 23 ParamValue< wstring > * 0 8576 23 ParamValue< wstring > * 23 ParamValue< wstring > * 0 0 1838 0 0 0 0 0 0 0 0 0 0

2024 29 ParamValue< wstring > const * 0 8576 29 ParamValue< wstring > const * 29 ParamValue< wstring > const * 0 0 2025 0 0 0 0 0 0 0 0 0 0

2025 27 ParamValue< wstring > const 0 8832 27 ParamValue< wstring > const 27 ParamValue< wstring > const 0 0 1838 0 0 0 0 0 0 0 0 0 0

2026 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 2027 0 0 0 0 0 0 0 0 0 0

2027 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 2028 0 0 0 0 0 0 0 0 0 0

2028 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 263
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2029 26 ParamValue< LVecBase2d > * 0 8576 26 ParamValue< LVecBase2d > * 26 ParamValue< LVecBase2d > * 0 0 1840 0 0 0 0 0 0 0 0 0 0

2030 32 ParamValue< LVecBase2d > const * 0 8576 32 ParamValue< LVecBase2d > const * 32 ParamValue< LVecBase2d > const * 0 0 2031 0 0 0 0 0 0 0 0 0 0

2031 30 ParamValue< LVecBase2d > const 0 8832 30 ParamValue< LVecBase2d > const 30 ParamValue< LVecBase2d > const 0 0 1840 0 0 0 0 0 0 0 0 0 0

2032 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 2033 0 0 0 0 0 0 0 0 0 0

2033 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 2034 0 0 0 0 0 0 0 0 0 0

2034 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 263
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2035 26 ParamValue< LVecBase2f > * 0 8576 26 ParamValue< LVecBase2f > * 26 ParamValue< LVecBase2f > * 0 0 1842 0 0 0 0 0 0 0 0 0 0

2036 32 ParamValue< LVecBase2f > const * 0 8576 32 ParamValue< LVecBase2f > const * 32 ParamValue< LVecBase2f > const * 0 0 2037 0 0 0 0 0 0 0 0 0 0

2037 30 ParamValue< LVecBase2f > const 0 8832 30 ParamValue< LVecBase2f > const 30 ParamValue< LVecBase2f > const 0 0 1842 0 0 0 0 0 0 0 0 0 0

2038 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 2039 0 0 0 0 0 0 0 0 0 0

2039 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 2040 0 0 0 0 0 0 0 0 0 0

2040 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 263
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2041 26 ParamValue< LVecBase2i > * 0 8576 26 ParamValue< LVecBase2i > * 26 ParamValue< LVecBase2i > * 0 0 1844 0 0 0 0 0 0 0 0 0 0

2042 32 ParamValue< LVecBase2i > const * 0 8576 32 ParamValue< LVecBase2i > const * 32 ParamValue< LVecBase2i > const * 0 0 2043 0 0 0 0 0 0 0 0 0 0

2043 30 ParamValue< LVecBase2i > const 0 8832 30 ParamValue< LVecBase2i > const 30 ParamValue< LVecBase2i > const 0 0 1844 0 0 0 0 0 0 0 0 0 0

2044 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 2045 0 0 0 0 0 0 0 0 0 0

2045 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 2046 0 0 0 0 0 0 0 0 0 0

2046 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2047 26 ParamValue< LVecBase3d > * 0 8576 26 ParamValue< LVecBase3d > * 26 ParamValue< LVecBase3d > * 0 0 1846 0 0 0 0 0 0 0 0 0 0

2048 32 ParamValue< LVecBase3d > const * 0 8576 32 ParamValue< LVecBase3d > const * 32 ParamValue< LVecBase3d > const * 0 0 2049 0 0 0 0 0 0 0 0 0 0

2049 30 ParamValue< LVecBase3d > const 0 8832 30 ParamValue< LVecBase3d > const 30 ParamValue< LVecBase3d > const 0 0 1846 0 0 0 0 0 0 0 0 0 0

2050 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 2051 0 0 0 0 0 0 0 0 0 0

2051 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 2052 0 0 0 0 0 0 0 0 0 0

2052 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2053 26 ParamValue< LVecBase3f > * 0 8576 26 ParamValue< LVecBase3f > * 26 ParamValue< LVecBase3f > * 0 0 1848 0 0 0 0 0 0 0 0 0 0

2054 32 ParamValue< LVecBase3f > const * 0 8576 32 ParamValue< LVecBase3f > const * 32 ParamValue< LVecBase3f > const * 0 0 2055 0 0 0 0 0 0 0 0 0 0

2055 30 ParamValue< LVecBase3f > const 0 8832 30 ParamValue< LVecBase3f > const 30 ParamValue< LVecBase3f > const 0 0 1848 0 0 0 0 0 0 0 0 0 0

2056 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 2057 0 0 0 0 0 0 0 0 0 0

2057 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 2058 0 0 0 0 0 0 0 0 0 0

2058 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2059 26 ParamValue< LVecBase3i > * 0 8576 26 ParamValue< LVecBase3i > * 26 ParamValue< LVecBase3i > * 0 0 1850 0 0 0 0 0 0 0 0 0 0

2060 32 ParamValue< LVecBase3i > const * 0 8576 32 ParamValue< LVecBase3i > const * 32 ParamValue< LVecBase3i > const * 0 0 2061 0 0 0 0 0 0 0 0 0 0

2061 30 ParamValue< LVecBase3i > const 0 8832 30 ParamValue< LVecBase3i > const 30 ParamValue< LVecBase3i > const 0 0 1850 0 0 0 0 0 0 0 0 0 0

2062 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 2063 0 0 0 0 0 0 0 0 0 0

2063 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 2064 0 0 0 0 0 0 0 0 0 0

2064 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2065 26 ParamValue< LVecBase4d > * 0 8576 26 ParamValue< LVecBase4d > * 26 ParamValue< LVecBase4d > * 0 0 1852 0 0 0 0 0 0 0 0 0 0

2066 32 ParamValue< LVecBase4d > const * 0 8576 32 ParamValue< LVecBase4d > const * 32 ParamValue< LVecBase4d > const * 0 0 2067 0 0 0 0 0 0 0 0 0 0

2067 30 ParamValue< LVecBase4d > const 0 8832 30 ParamValue< LVecBase4d > const 30 ParamValue< LVecBase4d > const 0 0 1852 0 0 0 0 0 0 0 0 0 0

2068 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 2069 0 0 0 0 0 0 0 0 0 0

2069 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 2070 0 0 0 0 0 0 0 0 0 0

2070 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2071 26 ParamValue< LVecBase4f > * 0 8576 26 ParamValue< LVecBase4f > * 26 ParamValue< LVecBase4f > * 0 0 1854 0 0 0 0 0 0 0 0 0 0

2072 32 ParamValue< LVecBase4f > const * 0 8576 32 ParamValue< LVecBase4f > const * 32 ParamValue< LVecBase4f > const * 0 0 2073 0 0 0 0 0 0 0 0 0 0

2073 30 ParamValue< LVecBase4f > const 0 8832 30 ParamValue< LVecBase4f > const 30 ParamValue< LVecBase4f > const 0 0 1854 0 0 0 0 0 0 0 0 0 0

2074 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 2075 0 0 0 0 0 0 0 0 0 0

2075 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 2076 0 0 0 0 0 0 0 0 0 0

2076 10 LVecBase4i 0 2048 10 LVecBase4i 10 LVecBase4i 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

2077 26 ParamValue< LVecBase4i > * 0 8576 26 ParamValue< LVecBase4i > * 26 ParamValue< LVecBase4i > * 0 0 1856 0 0 0 0 0 0 0 0 0 0

2078 32 ParamValue< LVecBase4i > const * 0 8576 32 ParamValue< LVecBase4i > const * 32 ParamValue< LVecBase4i > const * 0 0 2079 0 0 0 0 0 0 0 0 0 0

2079 30 ParamValue< LVecBase4i > const 0 8832 30 ParamValue< LVecBase4i > const 30 ParamValue< LVecBase4i > const 0 0 1856 0 0 0 0 0 0 0 0 0 0

2080 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 2081 0 0 0 0 0 0 0 0 0 0

2081 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 2082 0 0 0 0 0 0 0 0 0 0

2082 9 LMatrix3d 0 2048 9 LMatrix3d 9 LMatrix3d 0 0 0 0 0 0 0 4 2117 2118 2119 2120 0 0 0 0 462
////////////////////////////////////////////////////////////////////
//       Class : LMatrix3
// Description : This is a 3-by-3 transform matrix.  It typically will
//               represent either a rotation-and-scale (no
//               translation) matrix in 3-d, or a full affine matrix
//               (rotation, scale, translation) in 2-d, e.g. for a
//               texture matrix.
////////////////////////////////////////////////////////////////////

2083 25 ParamValue< LMatrix3d > * 0 8576 25 ParamValue< LMatrix3d > * 25 ParamValue< LMatrix3d > * 0 0 1858 0 0 0 0 0 0 0 0 0 0

2084 31 ParamValue< LMatrix3d > const * 0 8576 31 ParamValue< LMatrix3d > const * 31 ParamValue< LMatrix3d > const * 0 0 2085 0 0 0 0 0 0 0 0 0 0

2085 29 ParamValue< LMatrix3d > const 0 8832 29 ParamValue< LMatrix3d > const 29 ParamValue< LMatrix3d > const 0 0 1858 0 0 0 0 0 0 0 0 0 0

2086 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 2087 0 0 0 0 0 0 0 0 0 0

2087 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 2088 0 0 0 0 0 0 0 0 0 0

2088 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 4 2121 2122 2123 2124 0 0 0 0 462
////////////////////////////////////////////////////////////////////
//       Class : LMatrix3
// Description : This is a 3-by-3 transform matrix.  It typically will
//               represent either a rotation-and-scale (no
//               translation) matrix in 3-d, or a full affine matrix
//               (rotation, scale, translation) in 2-d, e.g. for a
//               texture matrix.
////////////////////////////////////////////////////////////////////

2089 25 ParamValue< LMatrix3f > * 0 8576 25 ParamValue< LMatrix3f > * 25 ParamValue< LMatrix3f > * 0 0 1860 0 0 0 0 0 0 0 0 0 0

2090 31 ParamValue< LMatrix3f > const * 0 8576 31 ParamValue< LMatrix3f > const * 31 ParamValue< LMatrix3f > const * 0 0 2091 0 0 0 0 0 0 0 0 0 0

2091 29 ParamValue< LMatrix3f > const 0 8832 29 ParamValue< LMatrix3f > const 29 ParamValue< LMatrix3f > const 0 0 1860 0 0 0 0 0 0 0 0 0 0

2092 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 2093 0 0 0 0 0 0 0 0 0 0

2093 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 2094 0 0 0 0 0 0 0 0 0 0

2094 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 3 2125 2126 2127 0 0 0 0 215
////////////////////////////////////////////////////////////////////
//       Class : LMatrix4
// Description : This is a 4-by-4 transform matrix.
////////////////////////////////////////////////////////////////////

2095 25 ParamValue< LMatrix4d > * 0 8576 25 ParamValue< LMatrix4d > * 25 ParamValue< LMatrix4d > * 0 0 1862 0 0 0 0 0 0 0 0 0 0

2096 31 ParamValue< LMatrix4d > const * 0 8576 31 ParamValue< LMatrix4d > const * 31 ParamValue< LMatrix4d > const * 0 0 2097 0 0 0 0 0 0 0 0 0 0

2097 29 ParamValue< LMatrix4d > const 0 8832 29 ParamValue< LMatrix4d > const 29 ParamValue< LMatrix4d > const 0 0 1862 0 0 0 0 0 0 0 0 0 0

2098 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 2099 0 0 0 0 0 0 0 0 0 0

2099 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 2100 0 0 0 0 0 0 0 0 0 0

2100 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 3 2128 2129 2130 0 0 0 0 215
////////////////////////////////////////////////////////////////////
//       Class : LMatrix4
// Description : This is a 4-by-4 transform matrix.
////////////////////////////////////////////////////////////////////

2101 25 ParamValue< LMatrix4f > * 0 8576 25 ParamValue< LMatrix4f > * 25 ParamValue< LMatrix4f > * 0 0 1864 0 0 0 0 0 0 0 0 0 0

2102 31 ParamValue< LMatrix4f > const * 0 8576 31 ParamValue< LMatrix4f > const * 31 ParamValue< LMatrix4f > const * 0 0 2103 0 0 0 0 0 0 0 0 0 0

2103 29 ParamValue< LMatrix4f > const 0 8832 29 ParamValue< LMatrix4f > const 29 ParamValue< LMatrix4f > const 0 0 1864 0 0 0 0 0 0 0 0 0 0

2104 19 UniqueIdAllocator * 0 8576 19 UniqueIdAllocator * 19 UniqueIdAllocator * 0 0 1872 0 0 0 0 0 0 0 0 0 0

2105 25 UniqueIdAllocator const * 0 8576 25 UniqueIdAllocator const * 25 UniqueIdAllocator const * 0 0 2106 0 0 0 0 0 0 0 0 0 0

2106 23 UniqueIdAllocator const 0 8832 23 UniqueIdAllocator const 23 UniqueIdAllocator const 0 0 1872 0 0 0 0 0 0 0 0 0 0

2107 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 2108 0 0 0 0 0 0 0 0 0 0

2108 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

2109 26 ConfigVariableSearchPath * 0 8576 26 ConfigVariableSearchPath * 26 ConfigVariableSearchPath * 0 0 2110 0 0 0 0 0 0 0 0 0 0

2110 24 ConfigVariableSearchPath 0 2048 24 ConfigVariableSearchPath 24 ConfigVariableSearchPath 0 0 0 0 0 0 0 0 0 0 0 0 1125
////////////////////////////////////////////////////////////////////
//       Class : ConfigVariableSearchPath
// Description : This is similar to a ConfigVariableList, but it
//               returns its list as a DSearchPath, as a list of
//               directories.
//
//               You may locally append directories to the end of the
//               search path with the methods here, or prepend them to
//               the beginning.  Use these methods to make adjustments
//               to the path; do not attempt to directly modify the
//               const DSearchPath object returned by get_value().
//
//               Unlike other ConfigVariable types, local changes
//               (made by calling append_directory() and
//               prepend_directory()) are specific to this particular
//               instance of the ConfigVariableSearchPath.  A separate
//               instance of the same variable, created by using the
//               same name to the constructor, will not reflect the
//               local changes.
////////////////////////////////////////////////////////////////////

2111 12 ConfigPage * 0 8576 12 ConfigPage * 12 ConfigPage * 0 0 2112 0 0 0 0 0 0 0 0 0 0

2112 10 ConfigPage 0 2048 10 ConfigPage 10 ConfigPage 0 0 0 0 0 0 0 0 0 0 0 0 493
////////////////////////////////////////////////////////////////////
//       Class : ConfigPage
// Description : A page of ConfigDeclarations that may be loaded or
//               unloaded.  Typically this represents a single .prc
//               file that is read from disk at runtime, but it may
//               also represent a list of declarations built up
//               by application code and explicitly loaded.
////////////////////////////////////////////////////////////////////

2113 9 HashVal * 0 8576 9 HashVal * 9 HashVal * 0 0 2114 0 0 0 0 0 0 0 0 0 0

2114 7 HashVal 0 2048 7 HashVal 7 HashVal 0 0 0 0 0 0 0 0 0 0 0 0 0

0
1
2115 2 tv 0 6 1812 1378 1379 11 TimeVal::tv 0

15
2116 0 0 757 11 get_buttons 15 get_num_buttons 10 get_button 
2117 0 0 2051 8 get_rows 4 size 7 get_row 
2118 0 0 2051 8 get_cols 4 size 7 get_col 
2119 0 0 2051 9 get_col2s 4 size 8 get_col2 
2120 0 0 2051 9 get_row2s 4 size 8 get_row2 
2121 0 0 2061 8 get_rows 4 size 7 get_row 
2122 0 0 2061 8 get_cols 4 size 7 get_col 
2123 0 0 2061 9 get_col2s 4 size 8 get_col2 
2124 0 0 2061 9 get_row2s 4 size 8 get_row2 
2125 0 0 2071 8 get_rows 4 size 7 get_row 
2126 0 0 2071 8 get_cols 4 size 7 get_col 
2127 0 0 2071 9 get_row3s 4 size 8 get_row3 
2128 0 0 2081 8 get_rows 4 size 7 get_row 
2129 0 0 2081 8 get_cols 4 size 7 get_col 
2130 0 0 2081 9 get_row3s 4 size 8 get_row3 
