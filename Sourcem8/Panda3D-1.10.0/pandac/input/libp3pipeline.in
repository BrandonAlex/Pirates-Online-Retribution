1436948113
2 3
13 libp3pipeline 4 kd_i 12 panda3d.core 
116
113 29 upcast_to_TypedReferenceCount 0 12 229 44 AsyncTaskBase::upcast_to_TypedReferenceCount 0 1 2 48
upcast from AsyncTaskBase to TypedReferenceCount
72
TypedReferenceCount *AsyncTaskBase::upcast_to_TypedReferenceCount(void);

114 25 downcast_to_AsyncTaskBase 0 12 230 46 TypedReferenceCount::downcast_to_AsyncTaskBase 0 1 3 50
downcast from TypedReferenceCount to AsyncTaskBase
68
AsyncTaskBase *TypedReferenceCount::downcast_to_AsyncTaskBase(void);

115 17 upcast_to_Namable 0 12 229 32 AsyncTaskBase::upcast_to_Namable 0 1 4 36
upcast from AsyncTaskBase to Namable
48
Namable *AsyncTaskBase::upcast_to_Namable(void);

116 25 downcast_to_AsyncTaskBase 0 12 231 34 Namable::downcast_to_AsyncTaskBase 0 1 5 38
downcast from Namable to AsyncTaskBase
56
AsyncTaskBase *Namable::downcast_to_AsyncTaskBase(void);

117 14 ~AsyncTaskBase 0 6 229 29 AsyncTaskBase::~AsyncTaskBase 0 0 233
////////////////////////////////////////////////////////////////////
//     Function: AsyncTaskBase::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
44
virtual AsyncTaskBase::~AsyncTaskBase(void);

118 14 get_class_type 0 4 229 29 AsyncTaskBase::get_class_type 0 1 1 0
54
static TypeHandle AsyncTaskBase::get_class_type(void);

119 29 upcast_to_TypedReferenceCount 0 12 233 37 Thread::upcast_to_TypedReferenceCount 0 1 36 41
upcast from Thread to TypedReferenceCount
65
TypedReferenceCount *Thread::upcast_to_TypedReferenceCount(void);

120 18 downcast_to_Thread 0 12 230 39 TypedReferenceCount::downcast_to_Thread 0 1 37 43
downcast from TypedReferenceCount to Thread
54
Thread *TypedReferenceCount::downcast_to_Thread(void);

121 17 upcast_to_Namable 0 12 233 25 Thread::upcast_to_Namable 0 1 38 29
upcast from Thread to Namable
41
Namable *Thread::upcast_to_Namable(void);

122 18 downcast_to_Thread 0 12 231 27 Namable::downcast_to_Thread 0 1 39 31
downcast from Namable to Thread
42
Thread *Namable::downcast_to_Thread(void);

123 7 ~Thread 0 6 233 15 Thread::~Thread 0 0 226
////////////////////////////////////////////////////////////////////
//     Function: Thread::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
30
virtual Thread::~Thread(void);

124 11 bind_thread 0 4 233 19 Thread::bind_thread 0 1 6 1438
////////////////////////////////////////////////////////////////////
//     Function: Thread::bind_thread
//       Access: Published, Static
//  Description: Returns a new Panda Thread object associated with the
//               current thread (which has been created externally).
//               This can be used to bind a unique Panda Thread object
//               with an external thread, such as a new Python thread.
//
//               It is particularly useful to bind a Panda Thread
//               object to an external thread for the purposes of
//               PStats monitoring.  Without this call, each external
//               thread will be assigned the same global
//               ExternalThread object, which means they will all
//               appear in the same PStats graph.
//
//               It is the caller's responsibility to save the
//               returned Thread pointer for the lifetime of the
//               external thread.  It is an error for the Thread
//               pointer to destruct while the external thread is
//               still in the system.
//
//               It is also an error to call this method from the main
//               thread, or twice within a given thread, unless it is
//               given the same name each time (in which case the same
//               pointer will be returned each time).
////////////////////////////////////////////////////////////////////
92
static PointerTo< Thread > Thread::bind_thread(string const &name, string const &sync_name);

125 13 get_sync_name 0 4 233 21 Thread::get_sync_name 0 1 7 565
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_sync_name
//       Access: Published
//  Description: Returns the sync name of the thread.  This name
//               collects threads into "sync groups", which are
//               expected to run synchronously.  This is mainly used
//               for the benefit of PStats; threads with the same sync
//               name can be ticked all at once via the thread_tick()
//               call.
////////////////////////////////////////////////////////////////////
55
inline string const &Thread::get_sync_name(void) const;

126 16 get_pstats_index 0 4 233 24 Thread::get_pstats_index 0 1 8 476
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_pstats_index
//       Access: Published
//  Description: Returns the PStats index associated with this thread,
//               or -1 if no index has yet been associated with this
//               thread.  This is used internally by the PStatClient;
//               you should not need to call this directly.
////////////////////////////////////////////////////////////////////
48
inline int Thread::get_pstats_index(void) const;

127 13 get_unique_id 0 4 233 21 Thread::get_unique_id 0 1 9 402
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_unique_id
//       Access: Published
//  Description: Returns a string that is guaranteed to be unique to
//               this thread, across all processes on the machine,
//               during at least the lifetime of this process.
////////////////////////////////////////////////////////////////////
48
inline string Thread::get_unique_id(void) const;

128 18 get_pipeline_stage 0 4 233 26 Thread::get_pipeline_stage 0 1 10 409
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_pipeline_stage
//       Access: Published
//  Description: Returns the Pipeline stage number associated with
//               this thread.  The default stage is 0 if no stage is
//               specified otherwise.  See set_pipeline_stage().
////////////////////////////////////////////////////////////////////
50
inline int Thread::get_pipeline_stage(void) const;

129 18 set_pipeline_stage 0 4 233 26 Thread::set_pipeline_stage 0 1 11 831
////////////////////////////////////////////////////////////////////
//     Function: Thread::set_pipeline_stage
//       Access: Published
//  Description: Specifies the Pipeline stage number associated with
//               this thread.  The default stage is 0 if no stage is
//               specified otherwise.
//
//               This must be a value in the range [0
//               .. pipeline->get_num_stages() - 1].  It specifies the
//               values that this thread observes for all pipelined
//               data.  Typically, an application thread will leave
//               this at 0, but a render thread may set it to 1 or 2
//               (to operate on the previous frame's data, or the
//               second previous frame's data).
////////////////////////////////////////////////////////////////////
52
void Thread::set_pipeline_stage(int pipeline_stage);

130 22 set_min_pipeline_stage 0 4 233 30 Thread::set_min_pipeline_stage 0 1 12 392
////////////////////////////////////////////////////////////////////
//     Function: Thread::set_min_pipeline_stage
//       Access: Published
//  Description: Sets this thread's pipeline stage number to at least
//               the indicated value, unless it is already larger.
//               See set_pipeline_stage().
////////////////////////////////////////////////////////////////////
67
inline void Thread::set_min_pipeline_stage(int min_pipeline_stage);

131 15 get_main_thread 0 4 233 23 Thread::get_main_thread 0 1 13 345
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_main_thread
//       Access: Published, Static
//  Description: Returns a pointer to the "main" Thread object--this
//               is the Thread that started the whole process.
////////////////////////////////////////////////////////////////////
52
static inline Thread *Thread::get_main_thread(void);

132 19 get_external_thread 0 4 233 27 Thread::get_external_thread 0 1 14 531
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_external_thread
//       Access: Published, Static
//  Description: Returns a pointer to the "external" Thread
//               object--this is a special Thread object that
//               corresponds to any thread spawned outside of Panda's
//               threading interface.  Note that multiple different
//               threads may share this same pointer.
////////////////////////////////////////////////////////////////////
56
static inline Thread *Thread::get_external_thread(void);

133 18 get_current_thread 0 4 233 26 Thread::get_current_thread 0 1 15 738
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_thread
//       Access: Published, Static
//  Description: Returns a pointer to the currently-executing Thread
//               object.  If this is called from the main thread, this
//               will return the same value as get_main_thread().
//
//               This will always return some valid Thread pointer.
//               It will never return NULL, even if the current thread
//               was spawned outside of Panda's threading system,
//               although all non-Panda threads will return the exact
//               same Thread pointer.
////////////////////////////////////////////////////////////////////
55
static inline Thread *Thread::get_current_thread(void);

134 26 get_current_pipeline_stage 0 4 233 34 Thread::get_current_pipeline_stage 0 1 16 485
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_pipeline_stage
//       Access: Published, Static
//  Description: Returns the integer pipeline stage associated with
//               the current thread.  This is the same thing as
//               get_current_thread()->get_pipeline_stage(), but it
//               may be faster to retrieve in some contexts.
////////////////////////////////////////////////////////////////////
59
static inline int Thread::get_current_pipeline_stage(void);

135 22 is_threading_supported 0 4 233 30 Thread::is_threading_supported 0 1 17 417
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_threading_supported
//       Access: Published, Static
//  Description: Returns true if threading support has been compiled
//               in and enabled, or false if no threading is available
//               (and Thread::start() will always fail).
////////////////////////////////////////////////////////////////////
56
static inline bool Thread::is_threading_supported(void);

136 15 is_true_threads 0 4 233 23 Thread::is_true_threads 0 1 18 461
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_true_threads
//       Access: Published, Static
//  Description: Returns true if a real threading library is available
//               that supports actual OS-implemented threads, or false
//               if the only threading we can provide is simulated
//               user-space threading.
////////////////////////////////////////////////////////////////////
49
static inline bool Thread::is_true_threads(void);

137 17 is_simple_threads 0 4 233 25 Thread::is_simple_threads 0 1 19 722
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_simple_threads
//       Access: Published, Static
//  Description: Returns true if Panda is currently compiled for
//               "simple threads", which is to say, cooperative
//               context switching only, reducing the need for quite
//               so many critical section protections.  This is not
//               necessarily the opposite of "true threads", since one
//               possible implementation of simple threads is via true
//               threads with mutex protection to ensure only one runs
//               at a time.
////////////////////////////////////////////////////////////////////
51
static inline bool Thread::is_simple_threads(void);

138 5 sleep 0 4 233 13 Thread::sleep 0 1 20 360
////////////////////////////////////////////////////////////////////
//     Function: Thread::sleep
//       Access: Published, Static
//  Description: Suspends the current thread for at least the
//               indicated amount of time.  It might be suspended for
//               longer.
////////////////////////////////////////////////////////////////////
49
static inline void Thread::sleep(double seconds);

139 11 force_yield 0 4 233 19 Thread::force_yield 0 1 21 306
////////////////////////////////////////////////////////////////////
//     Function: Thread::field_yield
//       Access: Published, Static
//  Description: Suspends the current thread for the rest of the
//               current epoch.
////////////////////////////////////////////////////////////////////
45
static inline void Thread::force_yield(void);

140 14 consider_yield 0 4 233 22 Thread::consider_yield 0 1 22 520
////////////////////////////////////////////////////////////////////
//     Function: Thread::consider_yield
//       Access: Published, Static
//  Description: Possibly suspends the current thread for the rest of
//               the current epoch, if it has run for enough this
//               epoch.  This is especially important for the simple
//               thread implementation, which relies on cooperative
//               yields like this.
////////////////////////////////////////////////////////////////////
48
static inline void Thread::consider_yield(void);

141 6 output 0 6 233 14 Thread::output 0 1 23 222
////////////////////////////////////////////////////////////////////
//     Function: Thread::output
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
48
virtual void Thread::output(ostream &out) const;

142 14 output_blocker 0 4 233 22 Thread::output_blocker 0 1 24 440
////////////////////////////////////////////////////////////////////
//     Function: Thread::output_blocker
//       Access: Published
//  Description: Writes a description of the mutex or condition
//               variable that this thread is blocked on.  Writes
//               nothing if there is no blocker, or if we are not in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
48
void Thread::output_blocker(ostream &out) const;

143 12 write_status 0 4 233 20 Thread::write_status 0 1 25 227
////////////////////////////////////////////////////////////////////
//     Function: Thread::write_status
//       Access: Published, Static
//  Description:
////////////////////////////////////////////////////////////////////
47
static void Thread::write_status(ostream &out);

144 10 is_started 0 4 233 18 Thread::is_started 0 1 26 338
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_started
//       Access: Published
//  Description: Returns true if the thread has been started, false if
//               it has not, or if join() has already been called.
////////////////////////////////////////////////////////////////////
43
inline bool Thread::is_started(void) const;

145 11 is_joinable 0 4 233 19 Thread::is_joinable 0 1 27 302
////////////////////////////////////////////////////////////////////
//     Function: Thread::is_joinable
//       Access: Published
//  Description: Returns the value of joinable that was passed to the
//               start() call.
////////////////////////////////////////////////////////////////////
44
inline bool Thread::is_joinable(void) const;

146 5 start 0 4 233 13 Thread::start 0 1 28 1333
////////////////////////////////////////////////////////////////////
//     Function: Thread::start
//       Access: Public
//  Description: Starts the thread executing.  It is only valid to
//               call this once.
//
//               The thread will begin executing its thread_main()
//               function, and will terminate when thread_main()
//               returns.
//
//               priority is intended as a hint to the relative
//               importance of this thread.  This may be ignored by
//               the thread implementation.
//
//               joinable should be set true if you intend to call
//               join() to wait for the thread to terminate, or false
//               if you don't care and you will never call join().
//               Note that the reference count on the Thread object is
//               incremented while the thread itself is running, so if
//               you just want to fire and forget a thread, you may
//               pass joinable = false, and never store the Thread
//               object.  It will automatically destruct itself when
//               it finishes.
//
//               The return value is true if the thread is
//               successfully started, false otherwise.
////////////////////////////////////////////////////////////////////
59
bool Thread::start(ThreadPriority priority, bool joinable);

147 4 join 0 4 233 12 Thread::join 0 1 29 366
////////////////////////////////////////////////////////////////////
//     Function: Thread::join
//       Access: Published
//  Description: Blocks the calling process until the thread
//               terminates.  If the thread has already terminated,
//               this returns immediately.
////////////////////////////////////////////////////////////////////
31
inline void Thread::join(void);

148 7 preempt 0 4 233 15 Thread::preempt 0 1 30 432
////////////////////////////////////////////////////////////////////
//     Function: Thread::preempt
//       Access: Published
//  Description: Indicates that this thread should run as soon as
//               possible, preemptying any other threads that may be
//               scheduled to run.  This may not be implemented on
//               every platform.
////////////////////////////////////////////////////////////////////
34
inline void Thread::preempt(void);

149 15 set_python_data 0 4 233 23 Thread::set_python_data 0 1 31 543
////////////////////////////////////////////////////////////////////
//     Function: Thread::set_python_data
//       Access: Published
//  Description: Sets an arbitrary Python object that may be
//               associated with this thread object.  This is just for
//               the purposes of associated arbitrary Python data with
//               the C++ object; other than managing the reference
//               count, the C++ code does nothing with this object.
////////////////////////////////////////////////////////////////////
52
void Thread::set_python_data(PyObject *python_data);

150 15 get_python_data 0 4 233 23 Thread::get_python_data 0 1 32 302
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_python_data
//       Access: Published
//  Description: Returns the Python object that was set with
//               set_python_data().
////////////////////////////////////////////////////////////////////
46
PyObject *Thread::get_python_data(void) const;

151 16 get_current_task 0 4 233 24 Thread::get_current_task 0 1 33 402
////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_task
//       Access: Published
//  Description: Returns the task currently executing on this thread
//               (via the AsyncTaskManager), if any, or NULL if the
//               thread is not currently servicing a task.
////////////////////////////////////////////////////////////////////
59
inline AsyncTaskBase *Thread::get_current_task(void) const;

152 16 prepare_for_exit 0 4 233 24 Thread::prepare_for_exit 0 1 34 387
////////////////////////////////////////////////////////////////////
//     Function: Thread::prepare_for_exit
//       Access: Published
//  Description: Should be called by the main thread just before
//               exiting the program, this blocks until any remaining
//               thread cleanup has finished.
////////////////////////////////////////////////////////////////////
50
static inline void Thread::prepare_for_exit(void);

153 14 get_class_type 0 4 233 22 Thread::get_class_type 0 1 35 0
47
static TypeHandle Thread::get_class_type(void);

154 7 acquire 0 4 234 20 MutexDirect::acquire 0 1 40 735
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::acquire
//       Access: Published
//  Description: Grabs the mutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the mutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const mutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see MutexHolder.
////////////////////////////////////////////////////////////////////
45
inline void MutexDirect::acquire(void) const;

155 11 try_acquire 0 4 234 24 MutexDirect::try_acquire 0 1 41 369
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
////////////////////////////////////////////////////////////////////
49
inline bool MutexDirect::try_acquire(void) const;

156 7 release 0 4 234 20 MutexDirect::release 0 1 42 515
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::release
//       Access: Published
//  Description: Releases the mutex.  It is an error to call this if
//               the mutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const mutexes, mainly to allow thread-safe
//               access to otherwise const data.
////////////////////////////////////////////////////////////////////
45
inline void MutexDirect::release(void) const;

157 15 debug_is_locked 0 4 234 28 MutexDirect::debug_is_locked 0 1 43 572
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               Mutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               MutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
////////////////////////////////////////////////////////////////////
53
inline bool MutexDirect::debug_is_locked(void) const;

158 8 set_name 0 4 234 21 MutexDirect::set_name 0 1 44 303
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
54
inline void MutexDirect::set_name(string const &name);

159 10 clear_name 0 4 234 23 MutexDirect::clear_name 0 1 45 305
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
42
inline void MutexDirect::clear_name(void);

160 8 has_name 0 4 234 21 MutexDirect::has_name 0 1 46 303
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
46
inline bool MutexDirect::has_name(void) const;

161 8 get_name 0 4 234 21 MutexDirect::get_name 0 1 47 303
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
48
inline string MutexDirect::get_name(void) const;

162 6 output 0 4 234 19 MutexDirect::output 0 1 48 311
////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::output
//       Access: Public
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in MutexDirect.
////////////////////////////////////////////////////////////////////
45
void MutexDirect::output(ostream &out) const;

163 5 Mutex 0 4 235 12 Mutex::Mutex 0 2 49 50 906
////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Mutex::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy mutexes.
////////////////////////////////////////////////////////////////////
67
inline Mutex::Mutex(void);
inline Mutex::Mutex(string const &name);

164 6 ~Mutex 0 4 235 13 Mutex::~Mutex 0 0 216
////////////////////////////////////////////////////////////////////
//     Function: Mutex::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
27
inline Mutex::~Mutex(void);

165 19 ~ConditionVarDirect 0 4 236 39 ConditionVarDirect::~ConditionVarDirect 0 0 226
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::Destructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
53
inline ConditionVarDirect::~ConditionVarDirect(void);

166 9 get_mutex 0 4 236 29 ConditionVarDirect::get_mutex 0 1 51 301
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::get_mutex
//       Access: Public
//  Description: Returns the mutex associated with this condition
//               variable.
////////////////////////////////////////////////////////////////////
62
inline MutexDirect &ConditionVarDirect::get_mutex(void) const;

167 4 wait 0 4 236 24 ConditionVarDirect::wait 0 2 52 53 1945
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::wait
//       Access: Public
//  Description: Waits on the condition.  The caller must already be
//               holding the lock associated with the condition
//               variable before calling this function.
//
//               wait() will release the lock, then go to sleep until
//               some other thread calls notify() on this condition
//               variable.  At that time at least one thread waiting
//               on the same ConditionVarDirect will grab the lock again,
//               and then return from wait().
//
//               It is possible that wait() will return even if no one
//               has called notify().  It is the responsibility of the
//               calling process to verify the condition on return
//               from wait, and possibly loop back to wait again if
//               necessary.
//
//               Note the semantics of a condition variable: the mutex
//               must be held before wait() is called, and it will
//               still be held when wait() returns.  However, it will
//               be temporarily released during the wait() call
//               itself.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::wait
//       Access: Published
//  Description: Waits on the condition, with a timeout.  The function
//               will return when the condition variable is notified,
//               or the timeout occurs.  There is no way to directly
//               tell which happened, and it is possible that neither
//               in fact happened (spurious wakeups are possible).
//
//               See wait() with no parameters for more.
////////////////////////////////////////////////////////////////////
97
inline void ConditionVarDirect::wait(void);
inline void ConditionVarDirect::wait(double timeout);

168 6 notify 0 4 236 26 ConditionVarDirect::notify 0 1 54 903
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::notify
//       Access: Public
//  Description: Informs one of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.  If multiple threads are currently waiting,
//               at least one of them will be woken up, although there
//               is no way to predict which one.  It is possible that
//               more than one thread will be woken up.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify event is lost.
////////////////////////////////////////////////////////////////////
45
inline void ConditionVarDirect::notify(void);

169 6 output 0 4 236 26 ConditionVarDirect::output 0 1 55 332
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::output
//       Access: Public
//  Description: This method is declared virtual in ConditionVarDebug,
//               but non-virtual in ConditionVarDirect.
////////////////////////////////////////////////////////////////////
52
void ConditionVarDirect::output(ostream &out) const;

170 12 ConditionVar 0 4 237 26 ConditionVar::ConditionVar 0 1 56 841
////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::Constructor
//       Access: Published
//  Description: You must pass in a Mutex to the condition variable
//               constructor.  This mutex may be shared by other
//               condition variables, if desired.  It is the caller's
//               responsibility to ensure the Mutex object does not
//               destruct during the lifetime of the condition
//               variable.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy condition variables.
////////////////////////////////////////////////////////////////////
48
inline ConditionVar::ConditionVar(Mutex &mutex);

171 13 ~ConditionVar 0 4 237 27 ConditionVar::~ConditionVar 0 0 223
////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
41
inline ConditionVar::~ConditionVar(void);

172 9 get_mutex 0 4 237 23 ConditionVar::get_mutex 0 1 57 298
////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
////////////////////////////////////////////////////////////////////
50
inline Mutex &ConditionVar::get_mutex(void) const;

173 23 ~ConditionVarFullDirect 0 4 238 47 ConditionVarFullDirect::~ConditionVarFullDirect 0 0 230
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::Destructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
61
inline ConditionVarFullDirect::~ConditionVarFullDirect(void);

174 9 get_mutex 0 4 238 33 ConditionVarFullDirect::get_mutex 0 1 58 308
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
////////////////////////////////////////////////////////////////////
66
inline MutexDirect &ConditionVarFullDirect::get_mutex(void) const;

175 4 wait 0 4 238 28 ConditionVarFullDirect::wait 0 2 59 60 1960
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::wait
//       Access: Published
//  Description: Waits on the condition.  The caller must already be
//               holding the lock associated with the condition
//               variable before calling this function.
//
//               wait() will release the lock, then go to sleep until
//               some other thread calls notify() on this condition
//               variable.  At that time at least one thread waiting
//               on the same ConditionVarFullDirect will grab the lock again,
//               and then return from wait().
//
//               It is possible that wait() will return even if no one
//               has called notify().  It is the responsibility of the
//               calling process to verify the condition on return
//               from wait, and possibly loop back to wait again if
//               necessary.
//
//               Note the semantics of a condition variable: the mutex
//               must be held before wait() is called, and it will
//               still be held when wait() returns.  However, it will
//               be temporarily released during the wait() call
//               itself.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::wait
//       Access: Published
//  Description: Waits on the condition, with a timeout.  The function
//               will return when the condition variable is notified,
//               or the timeout occurs.  There is no way to directly
//               tell which happened, and it is possible that neither
//               in fact happened (spurious wakeups are possible).
//
//               See wait() with no parameters for more.
////////////////////////////////////////////////////////////////////
105
inline void ConditionVarFullDirect::wait(void);
inline void ConditionVarFullDirect::wait(double timeout);

176 6 notify 0 4 238 30 ConditionVarFullDirect::notify 0 1 61 904
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::notify
//       Access: Published
//  Description: Informs one of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.  If multiple threads are currently waiting,
//               at least one of them will be woken up, although there
//               is no way to predict which one.  It is possible that
//               more than one thread will be woken up.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify is lost.
////////////////////////////////////////////////////////////////////
49
inline void ConditionVarFullDirect::notify(void);

177 10 notify_all 0 4 238 34 ConditionVarFullDirect::notify_all 0 1 62 673
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::notify_all
//       Access: Published
//  Description: Informs all of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify event is lost.
////////////////////////////////////////////////////////////////////
53
inline void ConditionVarFullDirect::notify_all(void);

178 6 output 0 4 238 30 ConditionVarFullDirect::output 0 1 63 344
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::output
//       Access: Public
//  Description: This method is declared virtual in ConditionVarFullDebug,
//               but non-virtual in ConditionVarFullDirect.
////////////////////////////////////////////////////////////////////
56
void ConditionVarFullDirect::output(ostream &out) const;

179 16 ConditionVarFull 0 4 239 34 ConditionVarFull::ConditionVarFull 0 1 64 849
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::Constructor
//       Access: Published
//  Description: You must pass in a Mutex to the condition variable
//               constructor.  This mutex may be shared by other
//               condition variables, if desired.  It is the caller's
//               responsibility to ensure the Mutex object does not
//               destruct during the lifetime of the condition
//               variable.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy condition variables.
////////////////////////////////////////////////////////////////////
56
inline ConditionVarFull::ConditionVarFull(Mutex &mutex);

180 17 ~ConditionVarFull 0 4 239 35 ConditionVarFull::~ConditionVarFull 0 0 227
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
49
inline ConditionVarFull::~ConditionVarFull(void);

181 9 get_mutex 0 4 239 27 ConditionVarFull::get_mutex 0 1 65 302
////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
////////////////////////////////////////////////////////////////////
54
inline Mutex &ConditionVarFull::get_mutex(void) const;

182 7 acquire 0 4 240 22 ReMutexDirect::acquire 0 2 66 67 1115
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::acquire
//       Access: Published
//  Description: Grabs the reMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the reMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const reMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see ReMutexHolder.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::acquire
//       Access: Published
//  Description: This variant on acquire() accepts the current thread as
//               a parameter, if it is already known, as an
//               optimization.
////////////////////////////////////////////////////////////////////
113
inline void ReMutexDirect::acquire(void) const;
inline void ReMutexDirect::acquire(Thread *current_thread) const;

183 11 try_acquire 0 4 240 26 ReMutexDirect::try_acquire 0 2 68 69 744
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
////////////////////////////////////////////////////////////////////
121
inline bool ReMutexDirect::try_acquire(void) const;
inline bool ReMutexDirect::try_acquire(Thread *current_thread) const;

184 12 elevate_lock 0 4 240 27 ReMutexDirect::elevate_lock 0 1 70 819
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::elevate_lock
//       Access: Published
//  Description: This method increments the lock count, assuming the
//               calling thread already holds the lock.  After this
//               call, release() will need to be called one additional
//               time to release the lock.
//
//               This method really performs the same function as
//               acquire(), but it offers a potential (slight)
//               performance benefit when the calling thread knows
//               that it already holds the lock.  It is an error to
//               call this when the calling thread does not hold the
//               lock.
////////////////////////////////////////////////////////////////////
52
inline void ReMutexDirect::elevate_lock(void) const;

185 7 release 0 4 240 22 ReMutexDirect::release 0 1 71 523
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::release
//       Access: Published
//  Description: Releases the reMutex.  It is an error to call this if
//               the reMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const reMutexes, mainly to allow thread-safe
//               access to otherwise const data.
////////////////////////////////////////////////////////////////////
47
inline void ReMutexDirect::release(void) const;

186 15 debug_is_locked 0 4 240 30 ReMutexDirect::debug_is_locked 0 1 72 578
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               ReMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               ReMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
////////////////////////////////////////////////////////////////////
55
inline bool ReMutexDirect::debug_is_locked(void) const;

187 8 set_name 0 4 240 23 ReMutexDirect::set_name 0 1 73 305
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
56
inline void ReMutexDirect::set_name(string const &name);

188 10 clear_name 0 4 240 25 ReMutexDirect::clear_name 0 1 74 307
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
44
inline void ReMutexDirect::clear_name(void);

189 8 has_name 0 4 240 23 ReMutexDirect::has_name 0 1 75 305
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
48
inline bool ReMutexDirect::has_name(void) const;

190 8 get_name 0 4 240 23 ReMutexDirect::get_name 0 1 76 305
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
50
inline string ReMutexDirect::get_name(void) const;

191 6 output 0 4 240 21 ReMutexDirect::output 0 1 77 318
////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::output
//       Access: Published
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in ReMutexDirect.
////////////////////////////////////////////////////////////////////
47
void ReMutexDirect::output(ostream &out) const;

192 7 ReMutex 0 4 241 16 ReMutex::ReMutex 0 2 78 79 652
////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
75
inline ReMutex::ReMutex(void);
inline ReMutex::ReMutex(string const &name);

193 8 ~ReMutex 0 4 241 17 ReMutex::~ReMutex 0 0 215
////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Destructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
31
inline ReMutex::~ReMutex(void);

194 14 get_class_type 0 4 242 30 ExternalThread::get_class_type 0 1 80 0
55
static TypeHandle ExternalThread::get_class_type(void);

195 15 ~ExternalThread 0 4 242 31 ExternalThread::~ExternalThread 0 0 0
38
ExternalThread::~ExternalThread(void);

196 7 acquire 0 4 243 25 LightMutexDirect::acquire 0 1 81 760
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::acquire
//       Access: Published
//  Description: Grabs the lightMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the lightMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const lightMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see LightMutexHolder.
////////////////////////////////////////////////////////////////////
50
inline void LightMutexDirect::acquire(void) const;

197 7 release 0 4 243 25 LightMutexDirect::release 0 1 82 535
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::release
//       Access: Published
//  Description: Releases the lightMutex.  It is an error to call this if
//               the lightMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const lightMutexes, mainly to allow thread-safe
//               access to otherwise const data.
////////////////////////////////////////////////////////////////////
50
inline void LightMutexDirect::release(void) const;

198 15 debug_is_locked 0 4 243 33 LightMutexDirect::debug_is_locked 0 1 83 587
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               LightMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               LightMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
////////////////////////////////////////////////////////////////////
58
inline bool LightMutexDirect::debug_is_locked(void) const;

199 8 set_name 0 4 243 26 LightMutexDirect::set_name 0 1 84 313
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::set_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
59
inline void LightMutexDirect::set_name(string const &name);

200 10 clear_name 0 4 243 28 LightMutexDirect::clear_name 0 1 85 315
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::clear_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
47
inline void LightMutexDirect::clear_name(void);

201 8 has_name 0 4 243 26 LightMutexDirect::has_name 0 1 86 313
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::has_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
51
inline bool LightMutexDirect::has_name(void) const;

202 8 get_name 0 4 243 26 LightMutexDirect::get_name 0 1 87 313
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::get_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
53
inline string LightMutexDirect::get_name(void) const;

203 6 output 0 4 243 24 LightMutexDirect::output 0 1 88 326
////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::output
//       Access: Public
//  Description: This method is declared virtual in LightMutexDebug, but
//               non-virtual in LightMutexDirect.
////////////////////////////////////////////////////////////////////
50
void LightMutexDirect::output(ostream &out) const;

204 10 LightMutex 0 4 244 22 LightMutex::LightMutex 0 2 89 90 931
////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy lightMutexes.
////////////////////////////////////////////////////////////////////
87
inline LightMutex::LightMutex(void);
inline LightMutex::LightMutex(string const &name);

205 11 ~LightMutex 0 4 244 23 LightMutex::~LightMutex 0 0 221
////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
37
inline LightMutex::~LightMutex(void);

206 7 acquire 0 4 245 27 LightReMutexDirect::acquire 0 2 91 92 1145
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::acquire
//       Access: Published
//  Description: Grabs the lightReMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the lightReMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const lightReMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see LightReMutexHolder.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::acquire
//       Access: Published
//  Description: This variant on acquire() accepts the current thread as
//               a parameter, if it is already known, as an
//               optimization.
////////////////////////////////////////////////////////////////////
123
inline void LightReMutexDirect::acquire(void) const;
inline void LightReMutexDirect::acquire(Thread *current_thread) const;

207 12 elevate_lock 0 4 245 32 LightReMutexDirect::elevate_lock 0 1 93 824
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::elevate_lock
//       Access: Published
//  Description: This method increments the lock count, assuming the
//               calling thread already holds the lock.  After this
//               call, release() will need to be called one additional
//               time to release the lock.
//
//               This method really performs the same function as
//               acquire(), but it offers a potential (slight)
//               performance benefit when the calling thread knows
//               that it already holds the lock.  It is an error to
//               call this when the calling thread does not hold the
//               lock.
////////////////////////////////////////////////////////////////////
57
inline void LightReMutexDirect::elevate_lock(void) const;

208 7 release 0 4 245 27 LightReMutexDirect::release 0 1 94 543
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::release
//       Access: Published
//  Description: Releases the lightReMutex.  It is an error to call this if
//               the lightReMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const lightReMutexes, mainly to allow thread-safe
//               access to otherwise const data.
////////////////////////////////////////////////////////////////////
52
inline void LightReMutexDirect::release(void) const;

209 15 debug_is_locked 0 4 245 35 LightReMutexDirect::debug_is_locked 0 1 95 593
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               LightReMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               LightReMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
////////////////////////////////////////////////////////////////////
60
inline bool LightReMutexDirect::debug_is_locked(void) const;

210 8 set_name 0 4 245 28 LightReMutexDirect::set_name 0 1 96 310
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
61
inline void LightReMutexDirect::set_name(string const &name);

211 10 clear_name 0 4 245 30 LightReMutexDirect::clear_name 0 1 97 312
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
49
inline void LightReMutexDirect::clear_name(void);

212 8 has_name 0 4 245 28 LightReMutexDirect::has_name 0 1 98 310
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
53
inline bool LightReMutexDirect::has_name(void) const;

213 8 get_name 0 4 245 28 LightReMutexDirect::get_name 0 1 99 310
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
////////////////////////////////////////////////////////////////////
55
inline string LightReMutexDirect::get_name(void) const;

214 6 output 0 4 245 26 LightReMutexDirect::output 0 1 100 328
////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::output
//       Access: Published
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in LightReMutexDirect.
////////////////////////////////////////////////////////////////////
52
void LightReMutexDirect::output(ostream &out) const;

215 12 LightReMutex 0 4 246 26 LightReMutex::LightReMutex 0 2 101 102 667
////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
95
inline LightReMutex::LightReMutex(void);
inline LightReMutex::LightReMutex(string const &name);

216 13 ~LightReMutex 0 4 246 27 LightReMutex::~LightReMutex 0 0 220
////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Destructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
41
inline LightReMutex::~LightReMutex(void);

217 14 get_class_type 0 4 247 26 MainThread::get_class_type 0 1 103 0
51
static TypeHandle MainThread::get_class_type(void);

218 11 ~MainThread 0 4 247 23 MainThread::~MainThread 0 0 0
30
MainThread::~MainThread(void);

219 12 PythonThread 0 4 248 26 PythonThread::PythonThread 0 1 104 224
////////////////////////////////////////////////////////////////////
//     Function: PythonThread::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
108
PythonThread::PythonThread(PyObject *function, PyObject *args, string const &name, string const &sync_name);

220 4 join 0 4 248 18 PythonThread::join 0 1 105 506
////////////////////////////////////////////////////////////////////
//     Function: PythonThread::join
//       Access: Published
//  Description: Blocks the calling process until the thread
//               terminates.  If the thread has already terminated,
//               this returns immediately.
//
//               The PythonThread flavor of this function returns the
//               same value returned by the thread function.
////////////////////////////////////////////////////////////////////
35
PyObject *PythonThread::join(void);

221 14 get_class_type 0 4 248 28 PythonThread::get_class_type 0 1 106 0
53
static TypeHandle PythonThread::get_class_type(void);

222 9 Semaphore 0 4 249 20 Semaphore::Semaphore 0 1 107 483
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Semaphore::Copy Constructor
//       Access: Private
//  Description: Do not attempt to copy semaphores.
////////////////////////////////////////////////////////////////////
51
inline Semaphore::Semaphore(int initial_count = 1);

223 10 ~Semaphore 0 4 249 21 Semaphore::~Semaphore 0 0 221
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
35
inline Semaphore::~Semaphore(void);

224 7 acquire 0 4 249 18 Semaphore::acquire 0 1 108 372
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::acquire
//       Access: Published
//  Description: Decrements the internal count.  If the count was
//               already at zero, blocks until the count is nonzero,
//               then decrements it.
////////////////////////////////////////////////////////////////////
37
inline void Semaphore::acquire(void);

225 11 try_acquire 0 4 249 22 Semaphore::try_acquire 0 1 109 342
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::try_acquire
//       Access: Published
//  Description: If the semaphore can be acquired without blocking,
//               does so and returns true.  Otherwise, returns false.
////////////////////////////////////////////////////////////////////
41
inline bool Semaphore::try_acquire(void);

226 7 release 0 4 249 18 Semaphore::release 0 1 110 401
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::release
//       Access: Published
//  Description: Increments the semaphore's internal count.  This may
//               wake up another thread blocked on acquire().
//
//               Returns the count of the semaphore upon release.
////////////////////////////////////////////////////////////////////
36
inline int Semaphore::release(void);

227 9 get_count 0 4 249 20 Semaphore::get_count 0 1 111 366
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::get_count
//       Access: Published
//  Description: Returns the current semaphore count.  Note that this
//               call is not thread-safe (the count may change at any
//               time).
////////////////////////////////////////////////////////////////////
44
inline int Semaphore::get_count(void) const;

228 6 output 0 4 249 17 Semaphore::output 0 1 112 217
////////////////////////////////////////////////////////////////////
//     Function: Semaphore::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
43
void Semaphore::output(ostream &out) const;

112
1 0 0 7 9 251 0 0 0 0 
2 0 0 7 3 253 0 0 0 1 4 this 3 252  
3 0 0 7 4 252 117 0 0 1 4 this 3 253  
4 0 0 6 6 254 0 0 0 1 4 this 3 252  
5 0 0 7 7 252 117 0 0 1 4 this 3 254  
6 0 0 7 17 256 123 0 1438 ////////////////////////////////////////////////////////////////////
//     Function: Thread::bind_thread
//       Access: Published, Static
//  Description: Returns a new Panda Thread object associated with the
//               current thread (which has been created externally).
//               This can be used to bind a unique Panda Thread object
//               with an external thread, such as a new Python thread.
//
//               It is particularly useful to bind a Panda Thread
//               object to an external thread for the purposes of
//               PStats monitoring.  Without this call, each external
//               thread will be assigned the same global
//               ExternalThread object, which means they will all
//               appear in the same PStats graph.
//
//               It is the caller's responsibility to save the
//               returned Thread pointer for the lifetime of the
//               external thread.  It is an error for the Thread
//               pointer to destruct while the external thread is
//               still in the system.
//
//               It is also an error to call this method from the main
//               thread, or twice within a given thread, unless it is
//               given the same name each time (in which case the same
//               pointer will be returned each time).
//////////////////////////////////////////////////////////////////// 2 4 name 1 255  9 sync_name 1 255  
7 0 0 6 18 255 0 0 565 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_sync_name
//       Access: Published
//  Description: Returns the sync name of the thread.  This name
//               collects threads into "sync groups", which are
//               expected to run synchronously.  This is mainly used
//               for the benefit of PStats; threads with the same sync
//               name can be ticked all at once via the thread_tick()
//               call.
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
8 0 0 6 19 259 0 0 476 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_pstats_index
//       Access: Published
//  Description: Returns the PStats index associated with this thread,
//               or -1 if no index has yet been associated with this
//               thread.  This is used internally by the PStatClient;
//               you should not need to call this directly.
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
9 0 0 6 20 255 0 0 402 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_unique_id
//       Access: Published
//  Description: Returns a string that is guaranteed to be unique to
//               this thread, across all processes on the machine,
//               during at least the lifetime of this process.
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
10 0 0 6 21 259 0 0 409 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_pipeline_stage
//       Access: Published
//  Description: Returns the Pipeline stage number associated with
//               this thread.  The default stage is 0 if no stage is
//               specified otherwise.  See set_pipeline_stage().
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
11 0 0 4 22 260 0 0 831 ////////////////////////////////////////////////////////////////////
//     Function: Thread::set_pipeline_stage
//       Access: Published
//  Description: Specifies the Pipeline stage number associated with
//               this thread.  The default stage is 0 if no stage is
//               specified otherwise.
//
//               This must be a value in the range [0
//               .. pipeline->get_num_stages() - 1].  It specifies the
//               values that this thread observes for all pipelined
//               data.  Typically, an application thread will leave
//               this at 0, but a render thread may set it to 1 or 2
//               (to operate on the previous frame's data, or the
//               second previous frame's data).
//////////////////////////////////////////////////////////////////// 2 4 this 3 256  14 pipeline_stage 1 259  
12 0 0 4 23 260 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: Thread::set_min_pipeline_stage
//       Access: Published
//  Description: Sets this thread's pipeline stage number to at least
//               the indicated value, unless it is already larger.
//               See set_pipeline_stage().
//////////////////////////////////////////////////////////////////// 2 4 this 3 256  18 min_pipeline_stage 1 259  
13 0 0 7 24 256 123 0 345 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_main_thread
//       Access: Published, Static
//  Description: Returns a pointer to the "main" Thread object--this
//               is the Thread that started the whole process.
//////////////////////////////////////////////////////////////////// 0 
14 0 0 7 25 256 123 0 531 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_external_thread
//       Access: Published, Static
//  Description: Returns a pointer to the "external" Thread
//               object--this is a special Thread object that
//               corresponds to any thread spawned outside of Panda's
//               threading interface.  Note that multiple different
//               threads may share this same pointer.
//////////////////////////////////////////////////////////////////// 0 
15 0 0 7 26 256 123 0 738 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_thread
//       Access: Published, Static
//  Description: Returns a pointer to the currently-executing Thread
//               object.  If this is called from the main thread, this
//               will return the same value as get_main_thread().
//
//               This will always return some valid Thread pointer.
//               It will never return NULL, even if the current thread
//               was spawned outside of Panda's threading system,
//               although all non-Panda threads will return the exact
//               same Thread pointer.
//////////////////////////////////////////////////////////////////// 0 
16 0 0 6 27 259 0 0 485 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_pipeline_stage
//       Access: Published, Static
//  Description: Returns the integer pipeline stage associated with
//               the current thread.  This is the same thing as
//               get_current_thread()->get_pipeline_stage(), but it
//               may be faster to retrieve in some contexts.
//////////////////////////////////////////////////////////////////// 0 
17 0 0 6 28 261 0 0 417 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_threading_supported
//       Access: Published, Static
//  Description: Returns true if threading support has been compiled
//               in and enabled, or false if no threading is available
//               (and Thread::start() will always fail).
//////////////////////////////////////////////////////////////////// 0 
18 0 0 6 29 261 0 0 461 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_true_threads
//       Access: Published, Static
//  Description: Returns true if a real threading library is available
//               that supports actual OS-implemented threads, or false
//               if the only threading we can provide is simulated
//               user-space threading.
//////////////////////////////////////////////////////////////////// 0 
19 0 0 6 30 261 0 0 722 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_simple_threads
//       Access: Published, Static
//  Description: Returns true if Panda is currently compiled for
//               "simple threads", which is to say, cooperative
//               context switching only, reducing the need for quite
//               so many critical section protections.  This is not
//               necessarily the opposite of "true threads", since one
//               possible implementation of simple threads is via true
//               threads with mutex protection to ensure only one runs
//               at a time.
//////////////////////////////////////////////////////////////////// 0 
20 0 0 4 31 260 0 0 360 ////////////////////////////////////////////////////////////////////
//     Function: Thread::sleep
//       Access: Published, Static
//  Description: Suspends the current thread for at least the
//               indicated amount of time.  It might be suspended for
//               longer.
//////////////////////////////////////////////////////////////////// 1 7 seconds 1 262  
21 0 0 4 32 260 0 0 306 ////////////////////////////////////////////////////////////////////
//     Function: Thread::field_yield
//       Access: Published, Static
//  Description: Suspends the current thread for the rest of the
//               current epoch.
//////////////////////////////////////////////////////////////////// 0 
22 0 0 4 33 260 0 0 520 ////////////////////////////////////////////////////////////////////
//     Function: Thread::consider_yield
//       Access: Published, Static
//  Description: Possibly suspends the current thread for the rest of
//               the current epoch, if it has run for enough this
//               epoch.  This is especially important for the simple
//               thread implementation, which relies on cooperative
//               yields like this.
//////////////////////////////////////////////////////////////////// 0 
23 0 0 4 34 260 0 0 222 ////////////////////////////////////////////////////////////////////
//     Function: Thread::output
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 257  3 out 1 263  
24 0 0 4 35 260 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: Thread::output_blocker
//       Access: Published
//  Description: Writes a description of the mutex or condition
//               variable that this thread is blocked on.  Writes
//               nothing if there is no blocker, or if we are not in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 257  3 out 1 263  
25 0 0 4 36 260 0 0 227 ////////////////////////////////////////////////////////////////////
//     Function: Thread::write_status
//       Access: Published, Static
//  Description:
//////////////////////////////////////////////////////////////////// 1 3 out 1 263  
26 0 0 6 37 261 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_started
//       Access: Published
//  Description: Returns true if the thread has been started, false if
//               it has not, or if join() has already been called.
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
27 0 0 6 38 261 0 0 302 ////////////////////////////////////////////////////////////////////
//     Function: Thread::is_joinable
//       Access: Published
//  Description: Returns the value of joinable that was passed to the
//               start() call.
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
28 0 0 6 39 261 0 0 1333 ////////////////////////////////////////////////////////////////////
//     Function: Thread::start
//       Access: Public
//  Description: Starts the thread executing.  It is only valid to
//               call this once.
//
//               The thread will begin executing its thread_main()
//               function, and will terminate when thread_main()
//               returns.
//
//               priority is intended as a hint to the relative
//               importance of this thread.  This may be ignored by
//               the thread implementation.
//
//               joinable should be set true if you intend to call
//               join() to wait for the thread to terminate, or false
//               if you don't care and you will never call join().
//               Note that the reference count on the Thread object is
//               incremented while the thread itself is running, so if
//               you just want to fire and forget a thread, you may
//               pass joinable = false, and never store the Thread
//               object.  It will automatically destruct itself when
//               it finishes.
//
//               The return value is true if the thread is
//               successfully started, false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 256  8 priority 1 232  8 joinable 1 261  
29 0 0 4 40 260 0 0 366 ////////////////////////////////////////////////////////////////////
//     Function: Thread::join
//       Access: Published
//  Description: Blocks the calling process until the thread
//               terminates.  If the thread has already terminated,
//               this returns immediately.
//////////////////////////////////////////////////////////////////// 1 4 this 3 256  
30 0 0 4 41 260 0 0 432 ////////////////////////////////////////////////////////////////////
//     Function: Thread::preempt
//       Access: Published
//  Description: Indicates that this thread should run as soon as
//               possible, preemptying any other threads that may be
//               scheduled to run.  This may not be implemented on
//               every platform.
//////////////////////////////////////////////////////////////////// 1 4 this 3 256  
31 0 0 4 42 260 0 0 543 ////////////////////////////////////////////////////////////////////
//     Function: Thread::set_python_data
//       Access: Published
//  Description: Sets an arbitrary Python object that may be
//               associated with this thread object.  This is just for
//               the purposes of associated arbitrary Python data with
//               the C++ object; other than managing the reference
//               count, the C++ code does nothing with this object.
//////////////////////////////////////////////////////////////////// 2 4 this 3 256  11 python_data 1 265  
32 0 0 6 43 265 0 0 302 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_python_data
//       Access: Published
//  Description: Returns the Python object that was set with
//               set_python_data().
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
33 0 0 7 44 252 117 0 402 ////////////////////////////////////////////////////////////////////
//     Function: Thread::get_current_task
//       Access: Published
//  Description: Returns the task currently executing on this thread
//               (via the AsyncTaskManager), if any, or NULL if the
//               thread is not currently servicing a task.
//////////////////////////////////////////////////////////////////// 1 4 this 3 257  
34 0 0 4 45 260 0 0 387 ////////////////////////////////////////////////////////////////////
//     Function: Thread::prepare_for_exit
//       Access: Published
//  Description: Should be called by the main thread just before
//               exiting the program, this blocks until any remaining
//               thread cleanup has finished.
//////////////////////////////////////////////////////////////////// 0 
35 0 0 7 46 251 0 0 0 0 
36 0 0 7 12 253 0 0 0 1 4 this 3 256  
37 0 0 7 13 256 123 0 0 1 4 this 3 253  
38 0 0 6 14 254 0 0 0 1 4 this 3 256  
39 0 0 7 15 256 123 0 0 1 4 this 3 254  
40 0 0 4 48 260 0 0 735 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::acquire
//       Access: Published
//  Description: Grabs the mutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the mutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const mutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see MutexHolder.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
41 0 0 6 49 261 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
42 0 0 4 50 260 0 0 515 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::release
//       Access: Published
//  Description: Releases the mutex.  It is an error to call this if
//               the mutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const mutexes, mainly to allow thread-safe
//               access to otherwise const data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
43 0 0 6 51 261 0 0 572 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               Mutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               MutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
44 0 0 4 52 260 0 0 303 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 270  4 name 1 255  
45 0 0 4 53 260 0 0 305 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 270  
46 0 0 6 54 261 0 0 303 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
47 0 0 6 55 255 0 0 303 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 268  
48 0 0 4 56 260 0 0 311 ////////////////////////////////////////////////////////////////////
//     Function: MutexDirect::output
//       Access: Public
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in MutexDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 268  3 out 1 263  
49 0 0 7 58 271 164 0 217 ////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
50 0 0 7 58 271 164 0 217 ////////////////////////////////////////////////////////////////////
//     Function: Mutex::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 name 1 255  
51 0 0 6 62 270 0 0 301 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::get_mutex
//       Access: Public
//  Description: Returns the mutex associated with this condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 4 this 3 272  
52 0 0 4 63 260 0 0 1330 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::wait
//       Access: Public
//  Description: Waits on the condition.  The caller must already be
//               holding the lock associated with the condition
//               variable before calling this function.
//
//               wait() will release the lock, then go to sleep until
//               some other thread calls notify() on this condition
//               variable.  At that time at least one thread waiting
//               on the same ConditionVarDirect will grab the lock again,
//               and then return from wait().
//
//               It is possible that wait() will return even if no one
//               has called notify().  It is the responsibility of the
//               calling process to verify the condition on return
//               from wait, and possibly loop back to wait again if
//               necessary.
//
//               Note the semantics of a condition variable: the mutex
//               must be held before wait() is called, and it will
//               still be held when wait() returns.  However, it will
//               be temporarily released during the wait() call
//               itself.
//////////////////////////////////////////////////////////////////// 1 4 this 3 274  
53 0 0 4 63 260 0 0 613 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::wait
//       Access: Published
//  Description: Waits on the condition, with a timeout.  The function
//               will return when the condition variable is notified,
//               or the timeout occurs.  There is no way to directly
//               tell which happened, and it is possible that neither
//               in fact happened (spurious wakeups are possible).
//
//               See wait() with no parameters for more.
//////////////////////////////////////////////////////////////////// 2 4 this 3 274  7 timeout 1 262  
54 0 0 4 64 260 0 0 903 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::notify
//       Access: Public
//  Description: Informs one of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.  If multiple threads are currently waiting,
//               at least one of them will be woken up, although there
//               is no way to predict which one.  It is possible that
//               more than one thread will be woken up.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify event is lost.
//////////////////////////////////////////////////////////////////// 1 4 this 3 274  
55 0 0 4 65 260 0 0 332 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarDirect::output
//       Access: Public
//  Description: This method is declared virtual in ConditionVarDebug,
//               but non-virtual in ConditionVarDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 272  3 out 1 263  
56 0 0 7 67 275 171 0 568 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::Constructor
//       Access: Published
//  Description: You must pass in a Mutex to the condition variable
//               constructor.  This mutex may be shared by other
//               condition variables, if desired.  It is the caller's
//               responsibility to ensure the Mutex object does not
//               destruct during the lifetime of the condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 5 mutex 1 271  
57 0 0 6 69 271 0 0 298 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVar::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 4 this 3 276  
58 0 0 6 72 270 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 4 this 3 278  
59 0 0 4 73 260 0 0 1341 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::wait
//       Access: Published
//  Description: Waits on the condition.  The caller must already be
//               holding the lock associated with the condition
//               variable before calling this function.
//
//               wait() will release the lock, then go to sleep until
//               some other thread calls notify() on this condition
//               variable.  At that time at least one thread waiting
//               on the same ConditionVarFullDirect will grab the lock again,
//               and then return from wait().
//
//               It is possible that wait() will return even if no one
//               has called notify().  It is the responsibility of the
//               calling process to verify the condition on return
//               from wait, and possibly loop back to wait again if
//               necessary.
//
//               Note the semantics of a condition variable: the mutex
//               must be held before wait() is called, and it will
//               still be held when wait() returns.  However, it will
//               be temporarily released during the wait() call
//               itself.
//////////////////////////////////////////////////////////////////// 1 4 this 3 280  
60 0 0 4 73 260 0 0 617 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::wait
//       Access: Published
//  Description: Waits on the condition, with a timeout.  The function
//               will return when the condition variable is notified,
//               or the timeout occurs.  There is no way to directly
//               tell which happened, and it is possible that neither
//               in fact happened (spurious wakeups are possible).
//
//               See wait() with no parameters for more.
//////////////////////////////////////////////////////////////////// 2 4 this 3 280  7 timeout 1 262  
61 0 0 4 74 260 0 0 904 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::notify
//       Access: Published
//  Description: Informs one of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.  If multiple threads are currently waiting,
//               at least one of them will be woken up, although there
//               is no way to predict which one.  It is possible that
//               more than one thread will be woken up.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify is lost.
//////////////////////////////////////////////////////////////////// 1 4 this 3 280  
62 0 0 4 75 260 0 0 673 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::notify_all
//       Access: Published
//  Description: Informs all of the other threads who are currently
//               blocked on wait() that the relevant condition has
//               changed.
//
//               The caller must be holding the mutex associated with
//               the condition variable before making this call, which
//               will not release the mutex.
//
//               If no threads are waiting, this is a no-op: the
//               notify event is lost.
//////////////////////////////////////////////////////////////////// 1 4 this 3 280  
63 0 0 4 76 260 0 0 344 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFullDirect::output
//       Access: Public
//  Description: This method is declared virtual in ConditionVarFullDebug,
//               but non-virtual in ConditionVarFullDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 278  3 out 1 263  
64 0 0 7 78 281 180 0 572 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::Constructor
//       Access: Published
//  Description: You must pass in a Mutex to the condition variable
//               constructor.  This mutex may be shared by other
//               condition variables, if desired.  It is the caller's
//               responsibility to ensure the Mutex object does not
//               destruct during the lifetime of the condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 5 mutex 1 271  
65 0 0 6 80 271 0 0 302 ////////////////////////////////////////////////////////////////////
//     Function: ConditionVarFull::get_mutex
//       Access: Published
//  Description: Returns the mutex associated with this condition
//               variable.
//////////////////////////////////////////////////////////////////// 1 4 this 3 282  
66 0 0 4 82 260 0 0 745 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::acquire
//       Access: Published
//  Description: Grabs the reMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the reMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const reMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see ReMutexHolder.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
67 0 0 4 82 260 0 0 368 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::acquire
//       Access: Published
//  Description: This variant on acquire() accepts the current thread as
//               a parameter, if it is already known, as an
//               optimization.
//////////////////////////////////////////////////////////////////// 2 4 this 3 284  14 current_thread 1 256  
68 0 0 6 83 261 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
69 0 0 6 83 261 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::try_acquire
//       Access: Published
//  Description: Returns immediately, with a true value indicating the
//               mutex has been acquired, and false indicating it has
//               not.
//////////////////////////////////////////////////////////////////// 2 4 this 3 284  14 current_thread 1 256  
70 0 0 4 84 260 0 0 819 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::elevate_lock
//       Access: Published
//  Description: This method increments the lock count, assuming the
//               calling thread already holds the lock.  After this
//               call, release() will need to be called one additional
//               time to release the lock.
//
//               This method really performs the same function as
//               acquire(), but it offers a potential (slight)
//               performance benefit when the calling thread knows
//               that it already holds the lock.  It is an error to
//               call this when the calling thread does not hold the
//               lock.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
71 0 0 4 85 260 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::release
//       Access: Published
//  Description: Releases the reMutex.  It is an error to call this if
//               the reMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const reMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
72 0 0 6 86 261 0 0 578 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               ReMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               ReMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
73 0 0 4 87 260 0 0 305 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 286  4 name 1 255  
74 0 0 4 88 260 0 0 307 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 286  
75 0 0 6 89 261 0 0 305 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
76 0 0 6 90 255 0 0 305 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 284  
77 0 0 4 91 260 0 0 318 ////////////////////////////////////////////////////////////////////
//     Function: ReMutexDirect::output
//       Access: Published
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in ReMutexDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 284  3 out 1 263  
78 0 0 7 93 287 193 0 216 ////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 0 
79 0 0 7 93 287 193 0 216 ////////////////////////////////////////////////////////////////////
//     Function: ReMutex::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 name 1 255  
80 0 0 7 96 251 0 0 0 0 
81 0 0 4 99 260 0 0 760 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::acquire
//       Access: Published
//  Description: Grabs the lightMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the lightMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const lightMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see LightMutexHolder.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
82 0 0 4 100 260 0 0 535 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::release
//       Access: Published
//  Description: Releases the lightMutex.  It is an error to call this if
//               the lightMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const lightMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
83 0 0 6 101 261 0 0 587 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               LightMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               LightMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
84 0 0 4 102 260 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::set_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 290  4 name 1 255  
85 0 0 4 103 260 0 0 315 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::clear_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 290  
86 0 0 6 104 261 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::has_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
87 0 0 6 105 255 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::get_name
//       Access: Public
//  Description: The lightMutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 288  
88 0 0 4 106 260 0 0 326 ////////////////////////////////////////////////////////////////////
//     Function: LightMutexDirect::output
//       Access: Public
//  Description: This method is declared virtual in LightMutexDebug, but
//               non-virtual in LightMutexDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 288  3 out 1 263  
89 0 0 7 108 291 205 0 222 ////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
90 0 0 7 108 291 205 0 222 ////////////////////////////////////////////////////////////////////
//     Function: LightMutex::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 name 1 255  
91 0 0 4 111 260 0 0 770 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::acquire
//       Access: Published
//  Description: Grabs the lightReMutex if it is available.  If it is not
//               available, blocks until it becomes available, then
//               grabs it.  In either case, the function does not
//               return until the lightReMutex is held; you should then call
//               unlock().
//
//               This method is considered const so that you can lock
//               and unlock const lightReMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//
//               Also see LightReMutexHolder.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
92 0 0 4 111 260 0 0 373 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::acquire
//       Access: Published
//  Description: This variant on acquire() accepts the current thread as
//               a parameter, if it is already known, as an
//               optimization.
//////////////////////////////////////////////////////////////////// 2 4 this 3 292  14 current_thread 1 256  
93 0 0 4 112 260 0 0 824 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::elevate_lock
//       Access: Published
//  Description: This method increments the lock count, assuming the
//               calling thread already holds the lock.  After this
//               call, release() will need to be called one additional
//               time to release the lock.
//
//               This method really performs the same function as
//               acquire(), but it offers a potential (slight)
//               performance benefit when the calling thread knows
//               that it already holds the lock.  It is an error to
//               call this when the calling thread does not hold the
//               lock.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
94 0 0 4 113 260 0 0 543 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::release
//       Access: Published
//  Description: Releases the lightReMutex.  It is an error to call this if
//               the lightReMutex was not already locked.
//
//               This method is considered const so that you can lock
//               and unlock const lightReMutexes, mainly to allow thread-safe
//               access to otherwise const data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
95 0 0 6 114 261 0 0 593 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::debug_is_locked
//       Access: Published
//  Description: Returns true if the current thread has locked the
//               LightReMutex, false otherwise.  This method is only intended
//               for use in debugging, hence the method name; in the
//               LightReMutexDirect case, it always returns true, since
//               there's not a reliable way to determine this
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
96 0 0 4 115 260 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::set_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 2 4 this 3 294  4 name 1 255  
97 0 0 4 116 260 0 0 312 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::clear_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 294  
98 0 0 6 117 261 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::has_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
99 0 0 6 118 255 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::get_name
//       Access: Public
//  Description: The mutex name is only defined when compiling in
//               DEBUG_THREADS mode.
//////////////////////////////////////////////////////////////////// 1 4 this 3 292  
100 0 0 4 119 260 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutexDirect::output
//       Access: Published
//  Description: This method is declared virtual in MutexDebug, but
//               non-virtual in LightReMutexDirect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 292  3 out 1 263  
101 0 0 7 121 295 216 0 221 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 0 
102 0 0 7 121 295 216 0 221 ////////////////////////////////////////////////////////////////////
//     Function: LightReMutex::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 name 1 255  
103 0 0 7 124 251 0 0 0 0 
104 0 0 7 127 296 123 0 224 ////////////////////////////////////////////////////////////////////
//     Function: PythonThread::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 4 8 function 1 265  4 args 1 265  4 name 1 255  9 sync_name 1 255  
105 0 0 6 128 265 0 0 506 ////////////////////////////////////////////////////////////////////
//     Function: PythonThread::join
//       Access: Published
//  Description: Blocks the calling process until the thread
//               terminates.  If the thread has already terminated,
//               this returns immediately.
//
//               The PythonThread flavor of this function returns the
//               same value returned by the thread function.
//////////////////////////////////////////////////////////////////// 1 4 this 3 296  
106 0 0 7 129 251 0 0 0 0 
107 0 0 7 131 297 223 0 222 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 13 initial_count 1 259  
108 0 0 4 133 260 0 0 372 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::acquire
//       Access: Published
//  Description: Decrements the internal count.  If the count was
//               already at zero, blocks until the count is nonzero,
//               then decrements it.
//////////////////////////////////////////////////////////////////// 1 4 this 3 297  
109 0 0 6 134 261 0 0 342 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::try_acquire
//       Access: Published
//  Description: If the semaphore can be acquired without blocking,
//               does so and returns true.  Otherwise, returns false.
//////////////////////////////////////////////////////////////////// 1 4 this 3 297  
110 0 0 6 135 259 0 0 401 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::release
//       Access: Published
//  Description: Increments the semaphore's internal count.  This may
//               wake up another thread blocked on acquire().
//
//               Returns the count of the semaphore upon release.
//////////////////////////////////////////////////////////////////// 1 4 this 3 297  
111 0 0 6 136 259 0 0 366 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::get_count
//       Access: Published
//  Description: Returns the current semaphore count.  Note that this
//               call is not thread-safe (the count may change at any
//               time).
//////////////////////////////////////////////////////////////////// 1 4 this 3 298  
112 0 0 4 137 260 0 0 217 ////////////////////////////////////////////////////////////////////
//     Function: Semaphore::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 298  3 out 1 263  
71
229 13 AsyncTaskBase 0 26625 13 AsyncTaskBase 13 AsyncTaskBase 0 0 0 0 117 0 1 118 0 0 2 3 230 113 114 3 231 115 116 0 0 346
////////////////////////////////////////////////////////////////////
//       Class : AsyncTaskBase
// Description : The abstract base class for AsyncTask.  This is
//               defined here only so we can store a pointer to the
//               current task on the Thread.
////////////////////////////////////////////////////////////////////

230 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 710
////////////////////////////////////////////////////////////////////
//       Class : TypedReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedObject and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedObjects and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

231 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 324
////////////////////////////////////////////////////////////////////
//       Class : Namable
// Description : A base class for all things which can have a name.
//               The name is either empty or nonempty, but it is never
//               NULL.
////////////////////////////////////////////////////////////////////

232 14 ThreadPriority 0 532481 14 ThreadPriority 14 ThreadPriority 0 0 0 0 0 0 0 0 0 0 4 6 TP_low 6 TP_low 0
0 9 TP_normal 9 TP_normal 0
1 7 TP_high 7 TP_high 0
2 9 TP_urgent 9 TP_urgent 0
3 0 243
////////////////////////////////////////////////////////////////////
// An enumerated type used by Thread to specify a suggested relative
// priority for a particular thread.
////////////////////////////////////////////////////////////////////

233 6 Thread 0 26625 6 Thread 6 Thread 0 0 0 0 123 0 30 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 0 0 2 3 230 119 120 3 231 121 122 0 0 668
////////////////////////////////////////////////////////////////////
//       Class : Thread
// Description : A thread; that is, a lightweight process.  This is an
//               abstract base class; to use it, you must subclass
//               from it and redefine thread_main().
//
//               The thread itself will keep a reference count on the
//               Thread object while it is running; when the thread
//               returns from its root function, the Thread object
//               will automatically be destructed if no other pointers
//               are referencing it.
////////////////////////////////////////////////////////////////////

234 11 MutexDirect 0 43009 11 MutexDirect 11 MutexDirect 0 0 0 0 0 0 9 154 155 156 157 158 159 160 161 162 0 0 0 0 0 364
////////////////////////////////////////////////////////////////////
//       Class : MutexDirect
// Description : This class implements a standard mutex by making
//               direct calls to the underlying implementation layer.
//               It doesn't perform any debugging operations.
////////////////////////////////////////////////////////////////////

235 5 Mutex 0 26625 5 Mutex 5 Mutex 0 0 0 1 163 164 0 0 0 0 1 0 234 0 0 0 0 0

236 18 ConditionVarDirect 0 26625 18 ConditionVarDirect 18 ConditionVarDirect 0 0 0 0 165 0 4 166 167 168 169 0 0 0 0 0 661
////////////////////////////////////////////////////////////////////
//       Class : ConditionVarDirect
// Description : A condition variable, usually used to communicate
//               information about changing state to a thread that is
//               waiting for something to happen.  A condition
//               variable can be used to "wake up" a thread when some
//               arbitrary condition has changed.
//
//               A condition variable is associated with a single
//               mutex, and several condition variables may share the
//               same mutex.
////////////////////////////////////////////////////////////////////

237 12 ConditionVar 0 26625 12 ConditionVar 12 ConditionVar 0 0 0 1 170 171 0 1 172 0 0 1 0 236 0 0 0 0 0

238 22 ConditionVarFullDirect 0 26625 22 ConditionVarFullDirect 22 ConditionVarFullDirect 0 0 0 0 173 0 5 174 175 176 177 178 0 0 0 0 0 665
////////////////////////////////////////////////////////////////////
//       Class : ConditionVarFullDirect
// Description : A condition variable, usually used to communicate
//               information about changing state to a thread that is
//               waiting for something to happen.  A condition
//               variable can be used to "wake up" a thread when some
//               arbitrary condition has changed.
//
//               A condition variable is associated with a single
//               mutex, and several condition variables may share the
//               same mutex.
////////////////////////////////////////////////////////////////////

239 16 ConditionVarFull 0 26625 16 ConditionVarFull 16 ConditionVarFull 0 0 0 1 179 180 0 1 181 0 0 1 0 238 0 0 0 0 0

240 13 ReMutexDirect 0 43009 13 ReMutexDirect 13 ReMutexDirect 0 0 0 0 0 0 10 182 183 184 185 186 187 188 189 190 191 0 0 0 0 0 368
////////////////////////////////////////////////////////////////////
//       Class : ReMutexDirect
// Description : This class implements a standard reMutex by making
//               direct calls to the underlying implementation layer.
//               It doesn't perform any debugging operations.
////////////////////////////////////////////////////////////////////

241 7 ReMutex 0 26625 7 ReMutex 7 ReMutex 0 0 0 1 192 193 0 0 0 0 1 0 240 0 0 0 0 0

242 14 ExternalThread 0 141313 14 ExternalThread 14 ExternalThread 0 0 0 0 195 0 1 194 0 0 1 0 233 0 0 0 0 356
////////////////////////////////////////////////////////////////////
//       Class : ExternalThread
// Description : The special "external thread" class.  There is one
//               instance of these in the world, and it is returned by
//               Thread::get_external_thread().
////////////////////////////////////////////////////////////////////

243 16 LightMutexDirect 0 43009 16 LightMutexDirect 16 LightMutexDirect 0 0 0 0 0 0 8 196 197 198 199 200 201 202 203 0 0 0 0 0 372
////////////////////////////////////////////////////////////////////
//       Class : LightMutexDirect
// Description : This class implements a lightweight Mutex by making
//               direct calls to the underlying implementation layer.
//               It doesn't perform any debugging operations.
////////////////////////////////////////////////////////////////////

244 10 LightMutex 0 26625 10 LightMutex 10 LightMutex 0 0 0 1 204 205 0 0 0 0 1 0 243 0 0 0 0 0

245 18 LightReMutexDirect 0 43009 18 LightReMutexDirect 18 LightReMutexDirect 0 0 0 0 0 0 9 206 207 208 209 210 211 212 213 214 0 0 0 0 0 378
////////////////////////////////////////////////////////////////////
//       Class : LightReMutexDirect
// Description : This class implements a standard lightReMutex by making
//               direct calls to the underlying implementation layer.
//               It doesn't perform any debugging operations.
////////////////////////////////////////////////////////////////////

246 12 LightReMutex 0 26625 12 LightReMutex 12 LightReMutex 0 0 0 1 215 216 0 0 0 0 1 0 245 0 0 0 0 0

247 10 MainThread 0 141313 10 MainThread 10 MainThread 0 0 0 0 218 0 1 217 0 0 1 0 233 0 0 0 0 344
////////////////////////////////////////////////////////////////////
//       Class : MainThread
// Description : The special "main thread" class.  There is one
//               instance of these in the world, and it is returned by
//               Thread::get_main_thread().
////////////////////////////////////////////////////////////////////

248 12 PythonThread 0 75777 12 PythonThread 12 PythonThread 0 0 0 1 219 123 0 2 220 221 0 0 1 0 233 0 0 0 0 376
////////////////////////////////////////////////////////////////////
//       Class : PythonThread
// Description : This class is exposed to Python to allow creation of
//               a Panda thread from the Python level.  It will spawn
//               a thread that executes an arbitrary Python functor.
////////////////////////////////////////////////////////////////////

249 9 Semaphore 0 26625 9 Semaphore 9 Semaphore 0 0 0 1 222 223 0 5 224 225 226 227 228 0 0 0 0 0 594
////////////////////////////////////////////////////////////////////
//       Class : Semaphore
// Description : A classic semaphore synchronization primitive.  
//
//               A semaphore manages an internal counter which is
//               decremented by each acquire() call and incremented by
//               each release() call. The counter can never go below
//               zero; when acquire() finds that it is zero, it
//               blocks, waiting until some other thread calls
//               release().
////////////////////////////////////////////////////////////////////

250 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 1098
////////////////////////////////////////////////////////////////////
//       Class : TypeHandle
// Description : TypeHandle is the identifier used to differentiate
//               C++ class types.  Any C++ classes that inherit from
//               some base class, and must be differentiated at run
//               time, should store a static TypeHandle object that
//               can be queried through a static member function
//               named get_class_type().  Most of the time, it is also
//               desirable to inherit from TypedObject, which provides
//               some virtual functions to return the TypeHandle for a
//               particular instance.
//
//               At its essence, a TypeHandle is simply a unique
//               identifier that is assigned by the TypeRegistry.  The
//               TypeRegistry stores a tree of TypeHandles, so that
//               ancestry of a particular type may be queried, and the
//               type name may be retrieved for run-time display.
////////////////////////////////////////////////////////////////////

251 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 250 0 0 0 0 0 0 0 0 0 0

252 15 AsyncTaskBase * 0 8576 15 AsyncTaskBase * 15 AsyncTaskBase * 0 0 229 0 0 0 0 0 0 0 0 0 0

253 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 230 0 0 0 0 0 0 0 0 0 0

254 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 231 0 0 0 0 0 0 0 0 0 0

255 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

256 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 233 0 0 0 0 0 0 0 0 0 0

257 14 Thread const * 0 8576 14 Thread const * 14 Thread const * 0 0 258 0 0 0 0 0 0 0 0 0 0

258 12 Thread const 0 8832 12 Thread const 12 Thread const 0 0 233 0 0 0 0 0 0 0 0 0 0

259 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

260 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

261 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

262 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

263 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 264 0 0 0 0 0 0 0 0 0 0

264 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

265 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 266 0 0 0 0 0 0 0 0 0 0

266 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 267 0 0 0 0 0 0 0 0 0 0

267 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

268 19 MutexDirect const * 0 8576 19 MutexDirect const * 19 MutexDirect const * 0 0 269 0 0 0 0 0 0 0 0 0 0

269 17 MutexDirect const 0 8832 17 MutexDirect const 17 MutexDirect const 0 0 234 0 0 0 0 0 0 0 0 0 0

270 13 MutexDirect * 0 8576 13 MutexDirect * 13 MutexDirect * 0 0 234 0 0 0 0 0 0 0 0 0 0

271 7 Mutex * 0 8576 7 Mutex * 7 Mutex * 0 0 235 0 0 0 0 0 0 0 0 0 0

272 26 ConditionVarDirect const * 0 8576 26 ConditionVarDirect const * 26 ConditionVarDirect const * 0 0 273 0 0 0 0 0 0 0 0 0 0

273 24 ConditionVarDirect const 0 8832 24 ConditionVarDirect const 24 ConditionVarDirect const 0 0 236 0 0 0 0 0 0 0 0 0 0

274 20 ConditionVarDirect * 0 8576 20 ConditionVarDirect * 20 ConditionVarDirect * 0 0 236 0 0 0 0 0 0 0 0 0 0

275 14 ConditionVar * 0 8576 14 ConditionVar * 14 ConditionVar * 0 0 237 0 0 0 0 0 0 0 0 0 0

276 20 ConditionVar const * 0 8576 20 ConditionVar const * 20 ConditionVar const * 0 0 277 0 0 0 0 0 0 0 0 0 0

277 18 ConditionVar const 0 8832 18 ConditionVar const 18 ConditionVar const 0 0 237 0 0 0 0 0 0 0 0 0 0

278 30 ConditionVarFullDirect const * 0 8576 30 ConditionVarFullDirect const * 30 ConditionVarFullDirect const * 0 0 279 0 0 0 0 0 0 0 0 0 0

279 28 ConditionVarFullDirect const 0 8832 28 ConditionVarFullDirect const 28 ConditionVarFullDirect const 0 0 238 0 0 0 0 0 0 0 0 0 0

280 24 ConditionVarFullDirect * 0 8576 24 ConditionVarFullDirect * 24 ConditionVarFullDirect * 0 0 238 0 0 0 0 0 0 0 0 0 0

281 18 ConditionVarFull * 0 8576 18 ConditionVarFull * 18 ConditionVarFull * 0 0 239 0 0 0 0 0 0 0 0 0 0

282 24 ConditionVarFull const * 0 8576 24 ConditionVarFull const * 24 ConditionVarFull const * 0 0 283 0 0 0 0 0 0 0 0 0 0

283 22 ConditionVarFull const 0 8832 22 ConditionVarFull const 22 ConditionVarFull const 0 0 239 0 0 0 0 0 0 0 0 0 0

284 21 ReMutexDirect const * 0 8576 21 ReMutexDirect const * 21 ReMutexDirect const * 0 0 285 0 0 0 0 0 0 0 0 0 0

285 19 ReMutexDirect const 0 8832 19 ReMutexDirect const 19 ReMutexDirect const 0 0 240 0 0 0 0 0 0 0 0 0 0

286 15 ReMutexDirect * 0 8576 15 ReMutexDirect * 15 ReMutexDirect * 0 0 240 0 0 0 0 0 0 0 0 0 0

287 9 ReMutex * 0 8576 9 ReMutex * 9 ReMutex * 0 0 241 0 0 0 0 0 0 0 0 0 0

288 24 LightMutexDirect const * 0 8576 24 LightMutexDirect const * 24 LightMutexDirect const * 0 0 289 0 0 0 0 0 0 0 0 0 0

289 22 LightMutexDirect const 0 8832 22 LightMutexDirect const 22 LightMutexDirect const 0 0 243 0 0 0 0 0 0 0 0 0 0

290 18 LightMutexDirect * 0 8576 18 LightMutexDirect * 18 LightMutexDirect * 0 0 243 0 0 0 0 0 0 0 0 0 0

291 12 LightMutex * 0 8576 12 LightMutex * 12 LightMutex * 0 0 244 0 0 0 0 0 0 0 0 0 0

292 26 LightReMutexDirect const * 0 8576 26 LightReMutexDirect const * 26 LightReMutexDirect const * 0 0 293 0 0 0 0 0 0 0 0 0 0

293 24 LightReMutexDirect const 0 8832 24 LightReMutexDirect const 24 LightReMutexDirect const 0 0 245 0 0 0 0 0 0 0 0 0 0

294 20 LightReMutexDirect * 0 8576 20 LightReMutexDirect * 20 LightReMutexDirect * 0 0 245 0 0 0 0 0 0 0 0 0 0

295 14 LightReMutex * 0 8576 14 LightReMutex * 14 LightReMutex * 0 0 246 0 0 0 0 0 0 0 0 0 0

296 14 PythonThread * 0 8576 14 PythonThread * 14 PythonThread * 0 0 248 0 0 0 0 0 0 0 0 0 0

297 11 Semaphore * 0 8576 11 Semaphore * 11 Semaphore * 0 0 249 0 0 0 0 0 0 0 0 0 0

298 17 Semaphore const * 0 8576 17 Semaphore const * 17 Semaphore const * 0 0 299 0 0 0 0 0 0 0 0 0 0

299 15 Semaphore const 0 8832 15 Semaphore const 15 Semaphore const 0 0 249 0 0 0 0 0 0 0 0 0 0

0
0
0
