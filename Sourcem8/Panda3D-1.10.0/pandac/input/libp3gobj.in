1436948159
2 3
9 libp3gobj 4 qQJq 12 panda3d.core 
1475
1549 11 AdaptiveLru 0 4 3024 24 AdaptiveLru::AdaptiveLru 0 1 1 224
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
62
AdaptiveLru::AdaptiveLru(string const &name, size_t max_size);

1550 12 ~AdaptiveLru 0 4 3024 25 AdaptiveLru::~AdaptiveLru 0 0 232
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::Destructor
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
32
AdaptiveLru::~AdaptiveLru(void);

1551 14 get_total_size 0 4 3024 27 AdaptiveLru::get_total_size 0 1 2 310
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::get_total_size
//       Access: Published
//  Description: Returns the total size of all objects currently
//               active on the LRU.
////////////////////////////////////////////////////////////////////
54
inline size_t AdaptiveLru::get_total_size(void) const;

1552 12 get_max_size 0 4 3024 25 AdaptiveLru::get_max_size 0 1 3 319
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::get_max_size
//       Access: Published
//  Description: Returns the max size of all objects that are allowed
//               to be active on the LRU.
////////////////////////////////////////////////////////////////////
52
inline size_t AdaptiveLru::get_max_size(void) const;

1553 12 set_max_size 0 4 3024 25 AdaptiveLru::set_max_size 0 1 4 385
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::set_max_size
//       Access: Published
//  Description: Changes the max size of all objects that are allowed
//               to be active on the LRU.
//
//               If the size is (size_t)-1, there is no limit.
////////////////////////////////////////////////////////////////////
55
inline void AdaptiveLru::set_max_size(size_t max_size);

1554 17 count_active_size 0 4 3024 30 AdaptiveLru::count_active_size 0 1 5 339
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::count_active_size
//       Access: Published
//  Description: Returns the total size of the pages that were
//               enqueued since the last call to begin_epoch().
////////////////////////////////////////////////////////////////////
50
size_t AdaptiveLru::count_active_size(void) const;

1555 14 consider_evict 0 4 3024 27 AdaptiveLru::consider_evict 0 1 6 277
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::consider_evict
//       Access: Published
//  Description: Evicts a sequence of objects if the queue is full.
////////////////////////////////////////////////////////////////////
46
inline void AdaptiveLru::consider_evict(void);

1556 8 evict_to 0 4 3024 21 AdaptiveLru::evict_to 0 1 7 373
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::evict_to
//       Access: Published
//  Description: Evicts a sequence of objects until the queue fits
//               within the indicated target size, regardless of its
//               normal max size.
////////////////////////////////////////////////////////////////////
54
inline void AdaptiveLru::evict_to(size_t target_size);

1557 11 begin_epoch 0 4 3024 24 AdaptiveLru::begin_epoch 0 1 8 443
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::begin_epoch
//       Access: Published
//  Description: Marks the end of the previous epoch and the beginning
//               of the next one.  This will evict any objects that
//               are pending eviction, and also update any internal
//               bookkeeping.
////////////////////////////////////////////////////////////////////
36
void AdaptiveLru::begin_epoch(void);

1558 8 validate 0 4 3024 21 AdaptiveLru::validate 0 1 9 365
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::validate
//       Access: Published
//  Description: Checks that the LRU is internally self-consistent.
//               Returns true if successful, false if there is some
//               problem.
////////////////////////////////////////////////////////////////////
40
inline bool AdaptiveLru::validate(void);

1559 6 output 0 4 3024 19 AdaptiveLru::output 0 1 10 219
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
45
void AdaptiveLru::output(ostream &out) const;

1560 5 write 0 4 3024 18 AdaptiveLru::write 0 1 11 227
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
62
void AdaptiveLru::write(ostream &out, int indent_level) const;

1561 10 set_weight 0 4 3024 23 AdaptiveLru::set_weight 0 1 12 515
// The following methods are specific to AdaptiveLru, and do not
// exist in the SimpleLru implementation.  In most cases, the
// defaults will be sufficient, so you do not need to mess with
// them.

////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::set_weight
//       Access: Published
//  Description: Specifies the weight value used to compute the
//               exponential moving average.
////////////////////////////////////////////////////////////////////
56
inline void AdaptiveLru::set_weight(PN_stdfloat weight);

1562 10 get_weight 0 4 3024 23 AdaptiveLru::get_weight 0 1 13 312
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::get_weight
//       Access: Published
//  Description: Returns the weight value used to compute the
//               exponential moving average.
////////////////////////////////////////////////////////////////////
55
inline PN_stdfloat AdaptiveLru::get_weight(void) const;

1563 25 set_max_updates_per_frame 0 4 3024 38 AdaptiveLru::set_max_updates_per_frame 0 1 14 486
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::set_max_updates_per_frame
//       Access: Published
//  Description: Specifies the maximum number of pages the AdaptiveLru
//               will update each frame.  This is a performance
//               optimization: keeping this number low limits the
//               impact of the AdaptiveLru's adaptive algorithm.
////////////////////////////////////////////////////////////////////
78
inline void AdaptiveLru::set_max_updates_per_frame(int max_updates_per_frame);

1564 25 get_max_updates_per_frame 0 4 3024 38 AdaptiveLru::get_max_updates_per_frame 0 1 15 330
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::get_max_updates_per_frame
//       Access: Published
//  Description: Returns the maximum number of pages the AdaptiveLru
//               will update each frame.
////////////////////////////////////////////////////////////////////
62
inline int AdaptiveLru::get_max_updates_per_frame(void) const;

1565 36 upcast_to_AdaptiveLruPageDynamicList 0 12 3026 53 AdaptiveLruPage::upcast_to_AdaptiveLruPageDynamicList 0 0 57
upcast from AdaptiveLruPage to AdaptiveLruPageDynamicList
88
AdaptiveLruPageDynamicList *AdaptiveLruPage::upcast_to_AdaptiveLruPageDynamicList(void);

1566 27 downcast_to_AdaptiveLruPage 0 12 3027 55 AdaptiveLruPageDynamicList::downcast_to_AdaptiveLruPage 0 0 59
downcast from AdaptiveLruPageDynamicList to AdaptiveLruPage
79
AdaptiveLruPage *AdaptiveLruPageDynamicList::downcast_to_AdaptiveLruPage(void);

1567 35 upcast_to_AdaptiveLruPageStaticList 0 12 3026 52 AdaptiveLruPage::upcast_to_AdaptiveLruPageStaticList 0 0 56
upcast from AdaptiveLruPage to AdaptiveLruPageStaticList
86
AdaptiveLruPageStaticList *AdaptiveLruPage::upcast_to_AdaptiveLruPageStaticList(void);

1568 27 downcast_to_AdaptiveLruPage 0 12 3028 54 AdaptiveLruPageStaticList::downcast_to_AdaptiveLruPage 0 0 58
downcast from AdaptiveLruPageStaticList to AdaptiveLruPage
78
AdaptiveLruPage *AdaptiveLruPageStaticList::downcast_to_AdaptiveLruPage(void);

1569 15 AdaptiveLruPage 0 4 3026 32 AdaptiveLruPage::AdaptiveLruPage 0 2 16 17 463
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::Constructor
//       Access: Protected
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::Copy Constructor
//       Access: Protected
//  Description: 
////////////////////////////////////////////////////////////////////
113
AdaptiveLruPage::AdaptiveLruPage(size_t lru_size);
AdaptiveLruPage::AdaptiveLruPage(AdaptiveLruPage const &copy);

1570 10 operator = 0 4 3026 27 AdaptiveLruPage::operator = 0 1 18 0
62
void AdaptiveLruPage::operator =(AdaptiveLruPage const &copy);

1571 16 ~AdaptiveLruPage 0 6 3026 33 AdaptiveLruPage::~AdaptiveLruPage 0 0 236
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::Destructor
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
48
virtual AdaptiveLruPage::~AdaptiveLruPage(void);

1572 7 get_lru 0 4 3026 24 AdaptiveLruPage::get_lru 0 1 19 335
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::enqueue_lru
//       Access: Published
//  Description: Returns the LRU that manages this page, or NULL if it
//               is not currently managed by any LRU.
////////////////////////////////////////////////////////////////////
57
inline AdaptiveLru *AdaptiveLruPage::get_lru(void) const;

1573 11 enqueue_lru 0 4 3026 28 AdaptiveLruPage::enqueue_lru 0 1 20 445
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::enqueue_lru
//       Access: Published
//  Description: Adds the page to the LRU for the first time, or marks
//               it recently-accessed if it has already been added.
//
//               If lru is NULL, it means to remove this page from its
//               LRU.
////////////////////////////////////////////////////////////////////
52
void AdaptiveLruPage::enqueue_lru(AdaptiveLru *lru);

1574 11 dequeue_lru 0 4 3026 28 AdaptiveLruPage::dequeue_lru 0 1 21 266
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::dequeue_lru
//       Access: Published
//  Description: Removes the page from its AdaptiveLru.
////////////////////////////////////////////////////////////////////
47
inline void AdaptiveLruPage::dequeue_lru(void);

1575 13 mark_used_lru 0 4 3026 30 AdaptiveLruPage::mark_used_lru 0 2 22 23 835
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::mark_used_lru
//       Access: Published
//  Description: To be called when the page is used; this will move it
//               to the tail of the AdaptiveLru queue it is already on.
//
//               This method is const because it's not technically
//               modifying the contents of the page itself.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::mark_used_lru
//       Access: Published
//  Description: To be called when the page is used; this will move it
//               to the tail of the specified AdaptiveLru queue.
////////////////////////////////////////////////////////////////////
117
inline void AdaptiveLruPage::mark_used_lru(void) const;
inline void AdaptiveLruPage::mark_used_lru(AdaptiveLru *lru);

1576 12 get_lru_size 0 4 3026 29 AdaptiveLruPage::get_lru_size 0 1 24 320
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::get_lru_size
//       Access: Published
//  Description: Returns the size of this page as reported to the LRU,
//               presumably in bytes.
////////////////////////////////////////////////////////////////////
56
inline size_t AdaptiveLruPage::get_lru_size(void) const;

1577 12 set_lru_size 0 4 3026 29 AdaptiveLruPage::set_lru_size 0 1 25 330
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::set_lru_size
//       Access: Published
//  Description: Specifies the size of this page, presumably in bytes,
//               although any unit is possible.
////////////////////////////////////////////////////////////////////
59
inline void AdaptiveLruPage::set_lru_size(size_t lru_size);

1578 9 evict_lru 0 6 3026 26 AdaptiveLruPage::evict_lru 0 1 26 814
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::evict_lru
//       Access: Published, Virtual
//  Description: Evicts the page from the LRU.  Called internally when
//               the LRU determines that it is full.  May also be
//               called externally when necessary to explicitly evict
//               the page.
//
//               It is legal for this method to either evict the page
//               as requested, do nothing (in which case the eviction
//               will be requested again at the next epoch), or
//               requeue itself on the tail of the queue (in which
//               case the eviction will be requested again much
//               later).
////////////////////////////////////////////////////////////////////
46
virtual void AdaptiveLruPage::evict_lru(void);

1579 6 output 0 6 3026 23 AdaptiveLruPage::output 0 1 27 232
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
57
virtual void AdaptiveLruPage::output(ostream &out) const;

1580 5 write 0 6 3026 22 AdaptiveLruPage::write 0 1 28 231
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
74
virtual void AdaptiveLruPage::write(ostream &out, int indent_level) const;

1581 14 get_num_frames 0 4 3026 31 AdaptiveLruPage::get_num_frames 0 1 29 409
// Not defined in SimpleLruPage.

////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::get_num_frames
//       Access: Published
//  Description: Returns the number of frames since the page was first
//               added to its LRU.  Returns 0 if it does not have an
//               LRU.
////////////////////////////////////////////////////////////////////
57
unsigned int AdaptiveLruPage::get_num_frames(void) const;

1582 23 get_num_inactive_frames 0 4 3026 40 AdaptiveLruPage::get_num_inactive_frames 0 1 30 386
////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::get_num_inactive_frames
//       Access: Published
//  Description: Returns the number of frames since the page was last
//               accessed on its LRU.  Returns 0 if it does not have
//               an LRU.
////////////////////////////////////////////////////////////////////
66
unsigned int AdaptiveLruPage::get_num_inactive_frames(void) const;

1583 10 ~GeomEnums 0 4 3029 21 GeomEnums::~GeomEnums 0 0 0
28
GeomEnums::~GeomEnums(void);

1584 23 GeomVertexAnimationSpec 0 4 3037 48 GeomVertexAnimationSpec::GeomVertexAnimationSpec 0 2 31 32 479
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
157
inline GeomVertexAnimationSpec::GeomVertexAnimationSpec(void);
inline GeomVertexAnimationSpec::GeomVertexAnimationSpec(GeomVertexAnimationSpec const &other);

1585 10 operator = 0 4 3037 35 GeomVertexAnimationSpec::operator = 0 1 33 0
86
inline void GeomVertexAnimationSpec::operator =(GeomVertexAnimationSpec const &other);

1586 18 get_animation_type 0 4 3037 43 GeomVertexAnimationSpec::get_animation_type 0 1 34 315
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::get_animation_type
//       Access: Published
//  Description: Returns the type of animation represented by this
//               spec.
////////////////////////////////////////////////////////////////////
88
inline GeomEnums::AnimationType GeomVertexAnimationSpec::get_animation_type(void) const;

1587 18 get_num_transforms 0 4 3037 43 GeomVertexAnimationSpec::get_num_transforms 0 1 35 479
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::get_num_transforms
//       Access: Published
//  Description: This is only meaningful for animation_type
//               AT_hardware.  It specifies the maximum number of
//               transforms that might be simultaneously applied to
//               any one vertex by the data in this format.
////////////////////////////////////////////////////////////////////
67
inline int GeomVertexAnimationSpec::get_num_transforms(void) const;

1588 22 get_indexed_transforms 0 4 3037 47 GeomVertexAnimationSpec::get_indexed_transforms 0 1 36 529
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::get_indexed_transforms
//       Access: Published
//  Description: This is only meaningful for animation_type
//               AT_hardware.  If true, it indicates that the format
//               uses indexed animation tables.  It is false if each
//               vertex will reference the first _num_transforms
//               table entries only.
////////////////////////////////////////////////////////////////////
72
inline bool GeomVertexAnimationSpec::get_indexed_transforms(void) const;

1589 8 set_none 0 4 3037 33 GeomVertexAnimationSpec::set_none 0 1 37 313
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::set_none
//       Access: Published
//  Description: Specifies that no vertex animation is represented by
//               this spec.
////////////////////////////////////////////////////////////////////
52
inline void GeomVertexAnimationSpec::set_none(void);

1590 9 set_panda 0 4 3037 34 GeomVertexAnimationSpec::set_panda 0 1 38 419
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::set_panda
//       Access: Published
//  Description: Specifies that vertex animation is to be performed by
//               Panda.  This is the most general setting and can
//               handle any kind of vertex animation represented.
////////////////////////////////////////////////////////////////////
53
inline void GeomVertexAnimationSpec::set_panda(void);

1591 12 set_hardware 0 4 3037 37 GeomVertexAnimationSpec::set_hardware 0 1 39 721
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::set_hardware
//       Access: Published
//  Description: Specifies that vertex animation is to be performed by
//               the graphics hardware (or at least by the graphics
//               backend API, which is actually still free to animate
//               the vertices on the CPU).
//
//               This is only legal if the graphics hardware can
//               support the specified limits on number of transforms
//               and/or indexed transforms.  Also, no current graphics
//               API's support morphing.
////////////////////////////////////////////////////////////////////
95
inline void GeomVertexAnimationSpec::set_hardware(int num_transforms, bool indexed_transforms);

1592 6 output 0 4 3037 31 GeomVertexAnimationSpec::output 0 1 40 231
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
57
void GeomVertexAnimationSpec::output(ostream &out) const;

1593 24 ~GeomVertexAnimationSpec 0 4 3037 49 GeomVertexAnimationSpec::~GeomVertexAnimationSpec 0 0 0
56
GeomVertexAnimationSpec::~GeomVertexAnimationSpec(void);

1594 4 make 0 4 3038 18 InternalName::make 0 2 41 42 1119
////////////////////////////////////////////////////////////////////
//     Function: InternalName::make
//       Access: Public, Static
//  Description: The public interface for constructing an InternalName
//               pointer.  This will return a new InternalName
//               representing the indicated name, if this is the first
//               time the particular name has been requested; if the
//               name is already in use, it will return the existing
//               pointer.
//
//               If the string contains the '.' character, the string
//               will be divided at the dots and the so-defined
//               hierarchy of names will be registered.  This is
//               handled transparently.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: InternalName::make
//       Access: Published, Static
//  Description: Make using a string and an integer.  Concatenates
//               the two.
////////////////////////////////////////////////////////////////////
157
static PointerTo< InternalName > InternalName::make(string const &name, int index);
static PointerTo< InternalName > InternalName::make(PyStringObject *str);

1595 6 append 0 4 3038 20 InternalName::append 0 1 43 475
////////////////////////////////////////////////////////////////////
//     Function: InternalName::append
//       Access: Published
//  Description: Constructs a new InternalName based on this name,
//               with the indicated string following it.  This is a
//               cheaper way to construct a hierarchical name than
//               InternalName::make(parent->get_name() + ".basename").
////////////////////////////////////////////////////////////////////
71
PointerTo< InternalName > InternalName::append(string const &basename);

1596 10 get_parent 0 4 3038 24 InternalName::get_parent 0 1 44 328
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_parent
//       Access: Published
//  Description: Return the parent of this InternalName.  All names
//               have a parent, except the root name.
////////////////////////////////////////////////////////////////////
58
inline InternalName *InternalName::get_parent(void) const;

1597 8 get_name 0 4 3038 22 InternalName::get_name 0 1 45 320
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_name
//       Access: Published
//  Description: Returns the complete name represented by the
//               InternalName and all of its parents.
////////////////////////////////////////////////////////////////////
42
string InternalName::get_name(void) const;

1598 4 join 0 4 3038 18 InternalName::join 0 1 46 293
////////////////////////////////////////////////////////////////////
//     Function: InternalName::join
//       Access: Published
//  Description: Like get_name, but uses a custom separator instead
//               of ".".
////////////////////////////////////////////////////////////////////
51
string InternalName::join(string const &sep) const;

1599 12 get_basename 0 4 3038 26 InternalName::get_basename 0 1 47 404
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_basename
//       Access: Published
//  Description: Return the name represented by just this particular
//               InternalName object, ignoring its parents names.
//               This is everything after the rightmost dot.
////////////////////////////////////////////////////////////////////
60
inline string const &InternalName::get_basename(void) const;

1600 13 find_ancestor 0 4 3038 27 InternalName::find_ancestor 0 1 48 584
////////////////////////////////////////////////////////////////////
//     Function: InternalName::find_ancestor
//       Access: Published
//  Description: Returns the index of the ancestor with the indicated
//               basename, or -1 if no ancestor has that basename.
//               Returns 0 if this name has the basename.
//
//               This index value may be passed to get_ancestor() or
//               get_net_basename() to retrieve more information about
//               the indicated name.
////////////////////////////////////////////////////////////////////
62
int InternalName::find_ancestor(string const &basename) const;

1601 12 get_ancestor 0 4 3038 26 InternalName::get_ancestor 0 1 49 481
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_ancestor
//       Access: Published
//  Description: Returns the ancestor with the indicated index number.
//               0 is this name itself, 1 is the name's parent, 2 is
//               the parent's parent, and so on.  If there are not
//               enough ancestors, returns the root InternalName.
////////////////////////////////////////////////////////////////////
60
InternalName const *InternalName::get_ancestor(int n) const;

1602 7 get_top 0 4 3038 21 InternalName::get_top 0 1 50 460
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_top
//       Access: Published
//  Description: Returns the oldest ancestor in the InternalName's
//               chain, not counting the root.  This will be the first
//               name in the string, e.g. "texcoord.foo.bar" will
//               return the InternalName "texcoord".
////////////////////////////////////////////////////////////////////
54
InternalName const *InternalName::get_top(void) const;

1603 16 get_net_basename 0 4 3038 30 InternalName::get_net_basename 0 1 51 456
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_net_basename
//       Access: Published
//  Description: Returns the basename of this name prefixed by the
//               indicated number of ancestors.  0 is this name's
//               basename, 1 is parent.basename, 2 is
//               grandparent.parent.basename, and so on.
////////////////////////////////////////////////////////////////////
51
string InternalName::get_net_basename(int n) const;

1604 6 output 0 4 3038 20 InternalName::output 0 1 52 219
////////////////////////////////////////////////////////////////////
//     Function: InternalName::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
46
void InternalName::output(ostream &out) const;

1605 8 get_root 0 4 3038 22 InternalName::get_root 0 1 53 474
// Some predefined built-in names.

////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_root
//       Access: Published, Static
//  Description: Returns the standard root InternalName.  This is the
//               root of all other InternalNames.  It has no name
//               itself, and it is the only InternalName with no
//               parent.
////////////////////////////////////////////////////////////////////
69
static inline PointerTo< InternalName > InternalName::get_root(void);

1606 9 get_error 0 4 3038 23 InternalName::get_error 0 1 54 273
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_error
//       Access: Published, Static
//  Description: Returns the standard InternalName "error".
////////////////////////////////////////////////////////////////////
70
static inline PointerTo< InternalName > InternalName::get_error(void);

1607 10 get_vertex 0 4 3038 24 InternalName::get_vertex 0 1 55 400
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_vertex
//       Access: Published, Static
//  Description: Returns the standard InternalName "vertex".  This is
//               the column header for the 3-d or 4-d vertex position
//               information for each vertex.
////////////////////////////////////////////////////////////////////
71
static inline PointerTo< InternalName > InternalName::get_vertex(void);

1608 10 get_normal 0 4 3038 24 InternalName::get_normal 0 1 56 381
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_normal
//       Access: Published, Static
//  Description: Returns the standard InternalName "normal".  This is
//               the column header for the 3-d lighting normal for
//               each vertex.
////////////////////////////////////////////////////////////////////
71
static inline PointerTo< InternalName > InternalName::get_normal(void);

1609 11 get_tangent 0 4 3038 25 InternalName::get_tangent 0 1 57 593
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_tangent
//       Access: Published, Static
//  Description: Returns the standard InternalName "tangent".  This is
//               the column header for the tangent vector associated
//               with each vertex, which is a unit vector
//               usually perpendicular to the normal and in the
//               direction of the U texture coordinate change.  It is
//               used for deriving bump maps.
////////////////////////////////////////////////////////////////////
72
static inline PointerTo< InternalName > InternalName::get_tangent(void);

1610 16 get_tangent_name 0 4 3038 30 InternalName::get_tangent_name 0 1 58 457
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_tangent_name
//       Access: Published, Static
//  Description: Returns the InternalName "tangent.name", where name
//               is the supplied string.  This is the column header
//               for the tangent associated with the named texture
//               coordinate set.
////////////////////////////////////////////////////////////////////
91
static inline PointerTo< InternalName > InternalName::get_tangent_name(string const &name);

1611 12 get_binormal 0 4 3038 26 InternalName::get_binormal 0 1 59 634
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_binormal
//       Access: Published, Static
//  Description: Returns the standard InternalName "binormal".  This is
//               the column header for the tangent vector associated
//               with each vertex, which is a unit vector
//               usually perpendicular to both the normal and the
//               tangent, and in the direction of the V texture
//               coordinate change.  It is used for deriving bump
//               maps.
////////////////////////////////////////////////////////////////////
73
static inline PointerTo< InternalName > InternalName::get_binormal(void);

1612 17 get_binormal_name 0 4 3038 31 InternalName::get_binormal_name 0 1 60 460
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_binormal_name
//       Access: Published, Static
//  Description: Returns the InternalName "binormal.name", where name
//               is the supplied string.  This is the column header
//               for the binormal associated with the named texture
//               coordinate set.
////////////////////////////////////////////////////////////////////
92
static inline PointerTo< InternalName > InternalName::get_binormal_name(string const &name);

1613 12 get_texcoord 0 4 3038 26 InternalName::get_texcoord 0 1 61 517
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_texcoord
//       Access: Published, Static
//  Description: Returns the standard InternalName "texcoord".  This
//               is the column header for the default texture
//               coordinate set for each vertex.  It is also used for
//               identifying the default texture coordinate set in a
//               TextureStage.
////////////////////////////////////////////////////////////////////
73
static inline PointerTo< InternalName > InternalName::get_texcoord(void);

1614 17 get_texcoord_name 0 4 3038 31 InternalName::get_texcoord_name 0 1 62 548
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_texcoord_name
//       Access: Published, Static
//  Description: Returns the InternalName "texcoord.name", where name
//               is the supplied string.  This is the column header
//               for the named texture coordinate set for each vertex.
//               It is also used for identifying the named texture
//               coordinate set in a TextureStage.
////////////////////////////////////////////////////////////////////
92
static inline PointerTo< InternalName > InternalName::get_texcoord_name(string const &name);

1615 9 get_color 0 4 3038 23 InternalName::get_color 0 1 63 383
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_color
//       Access: Published, Static
//  Description: Returns the standard InternalName "color".  This is
//               the column header for the 4-component color value for
//               each vertex.
////////////////////////////////////////////////////////////////////
70
static inline PointerTo< InternalName > InternalName::get_color(void);

1616 10 get_rotate 0 4 3038 24 InternalName::get_rotate 0 1 64 500
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_rotate
//       Access: Published, Static
//  Description: Returns the standard InternalName "rotate".  This is
//               the column header for the floating-point rotate
//               value, which represents a number of degrees
//               counter-clockwise to rotate each point or point
//               sprite.
////////////////////////////////////////////////////////////////////
71
static inline PointerTo< InternalName > InternalName::get_rotate(void);

1617 8 get_size 0 4 3038 22 InternalName::get_size 0 1 65 505
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_size
//       Access: Published, Static
//  Description: Returns the standard InternalName "size".  This is
//               the column header for the floating-point size value,
//               which overrides the thickness parameter of the
//               RenderModeAttrib on a per-vertex (e.g. per-point)
//               basis.
////////////////////////////////////////////////////////////////////
69
static inline PointerTo< InternalName > InternalName::get_size(void);

1618 16 get_aspect_ratio 0 4 3038 30 InternalName::get_aspect_ratio 0 1 66 535
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_aspect_ratio
//       Access: Published, Static
//  Description: Returns the standard InternalName "aspect_ratio".
//               This is the column header for the floating-point
//               aspect ratio value, which is used to define
//               non-square points.  This number is the ratio x / y,
//               where y is the point size (above).
////////////////////////////////////////////////////////////////////
77
static inline PointerTo< InternalName > InternalName::get_aspect_ratio(void);

1619 19 get_transform_blend 0 4 3038 33 InternalName::get_transform_blend 0 1 67 553
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_transform_blend
//       Access: Published, Static
//  Description: Returns the standard InternalName "transform_blend".
//               This is the column header for the integer
//               transform_blend index, which is used to define vertex
//               animation on the CPU by indexing to a particular
//               vertex weighting from the TransformBlendTable.
////////////////////////////////////////////////////////////////////
80
static inline PointerTo< InternalName > InternalName::get_transform_blend(void);

1620 20 get_transform_weight 0 4 3038 34 InternalName::get_transform_weight 0 1 68 823
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_transform_weight
//       Access: Published, Static
//  Description: Returns the standard InternalName "transform_weight".
//               This is the column header for the n-component
//               transform_weight value, which is used in conjuntion
//               with "transform_index" to define vertex animation on
//               the graphics card.  The transform_weight value
//               specifies the weight of the nth transform.  By
//               convention, there are 1 fewer weight values than
//               transforms, since the weights are assumed to sum to 1
//               (and the last value is therefore implicit).
////////////////////////////////////////////////////////////////////
81
static inline PointerTo< InternalName > InternalName::get_transform_weight(void);

1621 19 get_transform_index 0 4 3038 33 InternalName::get_transform_index 0 1 69 795
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_transform_index
//       Access: Published, Static
//  Description: Returns the standard InternalName "transform_index".
//               This is the column header for the n-component
//               transform_index value, which is used in conjuntion
//               with "transform_weight" to define vertex animation on
//               the graphics card.  The transform_index value
//               specifies the nth transform, by lookup in the
//               TransformTable.  The transform_index column may be
//               omitted, in which case the nth transform is the nth
//               entry in the table.
////////////////////////////////////////////////////////////////////
80
static inline PointerTo< InternalName > InternalName::get_transform_index(void);

1622 9 get_morph 0 4 3038 23 InternalName::get_morph 0 1 70 655
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_morph
//       Access: Published, Static
//  Description: Returns an InternalName derived from the given base
//               column name and the given slider name, which is the
//               column header for the offset vector that should be
//               applied to the base column name when the named morph
//               slider is engaged.
//
//               Each morph slider requires a set of n morph columns,
//               one for each base column it applies to.
////////////////////////////////////////////////////////////////////
108
static inline PointerTo< InternalName > InternalName::get_morph(InternalName *column, string const &slider);

1623 9 get_index 0 4 3038 23 InternalName::get_index 0 1 71 515
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_index
//       Access: Published, Static
//  Description: Returns the standard InternalName "index".  This is
//               the column header for the integer vertex index.  It
//               is not used in the vertex data itself, but is used in
//               the GeomPrimitive structure to index into the vertex
//               data.
////////////////////////////////////////////////////////////////////
70
static inline PointerTo< InternalName > InternalName::get_index(void);

1624 9 get_world 0 4 3038 23 InternalName::get_world 0 1 72 342
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_world
//       Access: Published, Static
//  Description: Returns the standard InternalName "world".  This is
//               used as a keyword in the shader subsystem.
////////////////////////////////////////////////////////////////////
70
static inline PointerTo< InternalName > InternalName::get_world(void);

1625 10 get_camera 0 4 3038 24 InternalName::get_camera 0 1 73 344
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_camera
//       Access: Published, Static
//  Description: Returns the standard InternalName "camera".  This is
//               used as a keyword in the shader subsystem.
////////////////////////////////////////////////////////////////////
71
static inline PointerTo< InternalName > InternalName::get_camera(void);

1626 9 get_model 0 4 3038 23 InternalName::get_model 0 1 74 342
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_model
//       Access: Published, Static
//  Description: Returns the standard InternalName "model".  This is
//               used as a keyword in the shader subsystem.
////////////////////////////////////////////////////////////////////
70
static inline PointerTo< InternalName > InternalName::get_model(void);

1627 8 get_view 0 4 3038 22 InternalName::get_view 0 1 75 340
////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_view
//       Access: Published, Static
//  Description: Returns the standard InternalName "view".  This is
//               used as a keyword in the shader subsystem.
////////////////////////////////////////////////////////////////////
69
static inline PointerTo< InternalName > InternalName::get_view(void);

1628 14 get_class_type 0 4 3038 28 InternalName::get_class_type 0 1 76 0
53
static TypeHandle InternalName::get_class_type(void);

1629 16 GeomVertexColumn 0 4 3040 34 GeomVertexColumn::GeomVertexColumn 0 2 77 78 789
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::Default Constructor
//       Access: Private
//  Description: Creates an invalid column.  Used only when constructing
//               from a bam file.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
308
inline GeomVertexColumn::GeomVertexColumn(CPT_InternalName name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents, int start, int column_alignment = 0, int num_elements = 0, int element_stride = 0);
inline GeomVertexColumn::GeomVertexColumn(GeomVertexColumn const &copy);

1630 10 operator = 0 4 3040 28 GeomVertexColumn::operator = 0 1 79 0
64
void GeomVertexColumn::operator =(GeomVertexColumn const &copy);

1631 17 ~GeomVertexColumn 0 4 3040 35 GeomVertexColumn::~GeomVertexColumn 0 0 227
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
49
inline GeomVertexColumn::~GeomVertexColumn(void);

1632 8 get_name 0 4 3040 26 GeomVertexColumn::get_name 0 1 80 541
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_name
//       Access: Published
//  Description: Returns the name of this particular data field,
//               e.g. "vertex" or "normal".  The name may be a
//               user-defined string, or it may be one of the standard
//               system-defined field types.  Only the system-defined
//               field types are used for the actual rendering.
////////////////////////////////////////////////////////////////////
66
inline InternalName const *GeomVertexColumn::get_name(void) const;

1633 18 get_num_components 0 4 3040 36 GeomVertexColumn::get_num_components 0 1 81 464
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_num_components
//       Access: Published
//  Description: Returns the number of components of the column:
//               the number of instances of the NumericType in each
//               element.  This is usually, but not always, the same
//               thing as get_num_values().
////////////////////////////////////////////////////////////////////
60
inline int GeomVertexColumn::get_num_components(void) const;

1634 14 get_num_values 0 4 3040 32 GeomVertexColumn::get_num_values 0 1 82 648
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_num_values
//       Access: Published
//  Description: Returns the number of numeric values of the column:
//               the number of distinct numeric values that go into
//               each element.  This is usually, but not always, the
//               same thing as get_num_components(); the difference is
//               in the case of a composite numeric type like
//               NT_packed_dcba, which has four numeric values per
//               component.
////////////////////////////////////////////////////////////////////
56
inline int GeomVertexColumn::get_num_values(void) const;

1635 16 get_num_elements 0 4 3040 34 GeomVertexColumn::get_num_elements 0 1 83 343
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_num_elements
//       Access: Published
//  Description: Returns the number of times this column is repeated.
//               This is usually 1, except for matrices.
////////////////////////////////////////////////////////////////////
58
inline int GeomVertexColumn::get_num_elements(void) const;

1636 16 get_numeric_type 0 4 3040 34 GeomVertexColumn::get_numeric_type 0 1 84 319
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_numeric_type
//       Access: Published
//  Description: Returns the token representing the numeric type of
//               the data storage.
////////////////////////////////////////////////////////////////////
77
inline GeomEnums::NumericType GeomVertexColumn::get_numeric_type(void) const;

1637 12 get_contents 0 4 3040 30 GeomVertexColumn::get_contents 0 1 85 319
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_contents
//       Access: Published
//  Description: Returns the token representing the semantic meaning of
//               the stored value.
////////////////////////////////////////////////////////////////////
70
inline GeomEnums::Contents GeomVertexColumn::get_contents(void) const;

1638 9 get_start 0 4 3040 27 GeomVertexColumn::get_start 0 1 86 392
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_start
//       Access: Published
//  Description: Returns the byte within the array record at which
//               this column starts.  This can be set to non-zero
//               to implement interleaved arrays.
////////////////////////////////////////////////////////////////////
51
inline int GeomVertexColumn::get_start(void) const;

1639 20 get_column_alignment 0 4 3040 38 GeomVertexColumn::get_column_alignment 0 1 87 601
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_column_alignment
//       Access: Published
//  Description: Returns the alignment requirements for this column.
//               If this is greater than 1, it restricts the column to
//               appear only on memory addresses that are integer
//               multiples of this value; this has implications for
//               this column's start value, as well as the stride of
//               the resulting array.
////////////////////////////////////////////////////////////////////
62
inline int GeomVertexColumn::get_column_alignment(void) const;

1640 18 get_element_stride 0 4 3040 36 GeomVertexColumn::get_element_stride 0 1 88 388
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_element_stride
//       Access: Published
//  Description: This value is only relevant for matrix types.
//               Returns the number of bytes to add to access the
//               next row of the matrix.
////////////////////////////////////////////////////////////////////
60
inline int GeomVertexColumn::get_element_stride(void) const;

1641 19 get_component_bytes 0 4 3040 37 GeomVertexColumn::get_component_bytes 0 1 89 351
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_component_bytes
//       Access: Published
//  Description: Returns the number of bytes used by each component
//               (that is, by one element of the numeric type).
////////////////////////////////////////////////////////////////////
61
inline int GeomVertexColumn::get_component_bytes(void) const;

1642 15 get_total_bytes 0 4 3040 33 GeomVertexColumn::get_total_bytes 0 1 90 347
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_total_bytes
//       Access: Published
//  Description: Returns the number of bytes used by each element of
//               the column: component_bytes * num_components.
////////////////////////////////////////////////////////////////////
57
inline int GeomVertexColumn::get_total_bytes(void) const;

1643 21 has_homogeneous_coord 0 4 3040 39 GeomVertexColumn::has_homogeneous_coord 0 1 91 727
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::has_homogeneous_coord
//       Access: Published
//  Description: Returns true if this Contents type is one that
//               includes a homogeneous coordinate in the fourth
//               component, or false otherwise.  If this is true,
//               correct operation on the vertex data may require
//               scaling by the homogeneous coordinate from time to
//               time (but in general this is handled automatically if
//               you use the 3-component or smaller forms of
//               get_data() and set_data()).
////////////////////////////////////////////////////////////////////
64
inline bool GeomVertexColumn::has_homogeneous_coord(void) const;

1644 13 overlaps_with 0 4 3040 31 GeomVertexColumn::overlaps_with 0 1 92 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::overlaps_with
//       Access: Published
//  Description: Returns true if this column overlaps with any of
//               the bytes in the indicated range, false if it does
//               not.
////////////////////////////////////////////////////////////////////
81
inline bool GeomVertexColumn::overlaps_with(int start_byte, int num_bytes) const;

1645 22 is_bytewise_equivalent 0 4 3040 40 GeomVertexColumn::is_bytewise_equivalent 0 1 93 419
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::is_bytewise_equivalent
//       Access: Published
//  Description: Returns true if the data store of this column is
//               exactly the same as that of the other, irrespective
//               of name or start position within the record.
////////////////////////////////////////////////////////////////////
90
inline bool GeomVertexColumn::is_bytewise_equivalent(GeomVertexColumn const &other) const;

1646 8 set_name 0 4 3040 26 GeomVertexColumn::set_name 0 1 94 393
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_name
//       Access: Published
//  Description: Replaces the name of an existing column.  This is
//               only legal on an unregistered format (i.e. when
//               constructing the format initially).
////////////////////////////////////////////////////////////////////
52
void GeomVertexColumn::set_name(InternalName *name);

1647 18 set_num_components 0 4 3040 36 GeomVertexColumn::set_num_components 0 1 95 418
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_num_components
//       Access: Published
//  Description: Changes the number of components of an existing
//               column.  This is only legal on an unregistered format
//               (i.e. when constructing the format initially).
////////////////////////////////////////////////////////////////////
62
void GeomVertexColumn::set_num_components(int num_components);

1648 16 set_numeric_type 0 4 3040 34 GeomVertexColumn::set_numeric_type 0 1 96 405
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_numeric_type
//       Access: Published
//  Description: Changes the numeric type an existing column.  This is
//               only legal on an unregistered format (i.e. when
//               constructing the format initially).
////////////////////////////////////////////////////////////////////
77
void GeomVertexColumn::set_numeric_type(GeomEnums::NumericType numeric_type);

1649 12 set_contents 0 4 3040 30 GeomVertexColumn::set_contents 0 1 97 407
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_contents
//       Access: Published
//  Description: Changes the semantic meaning of an existing column.
//               This is only legal on an unregistered format
//               (i.e. when constructing the format initially).
////////////////////////////////////////////////////////////////////
66
void GeomVertexColumn::set_contents(GeomEnums::Contents contents);

1650 9 set_start 0 4 3040 27 GeomVertexColumn::set_start 0 1 98 398
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_start
//       Access: Published
//  Description: Changes the start byte of an existing column.
//               This is only legal on an unregistered format
//               (i.e. when constructing the format initially).
////////////////////////////////////////////////////////////////////
44
void GeomVertexColumn::set_start(int start);

1651 20 set_column_alignment 0 4 3040 38 GeomVertexColumn::set_column_alignment 0 1 99 415
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_column_alignment
//       Access: Published
//  Description: Changes the column alignment of an existing column.
//               This is only legal on an unregistered format
//               (i.e. when constructing the format initially).
////////////////////////////////////////////////////////////////////
66
void GeomVertexColumn::set_column_alignment(int column_alignment);

1652 6 output 0 4 3040 24 GeomVertexColumn::output 0 1 100 223
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
50
void GeomVertexColumn::output(ostream &out) const;

1653 37 upcast_to_TypedWritableReferenceCount 0 12 3041 60 GeomVertexArrayFormat::upcast_to_TypedWritableReferenceCount 0 1 136 64
upcast from GeomVertexArrayFormat to TypedWritableReferenceCount
96
TypedWritableReferenceCount *GeomVertexArrayFormat::upcast_to_TypedWritableReferenceCount(void);

1654 33 downcast_to_GeomVertexArrayFormat 0 12 3039 62 TypedWritableReferenceCount::downcast_to_GeomVertexArrayFormat 0 1 137 66
downcast from TypedWritableReferenceCount to GeomVertexArrayFormat
92
GeomVertexArrayFormat *TypedWritableReferenceCount::downcast_to_GeomVertexArrayFormat(void);

1655 19 upcast_to_GeomEnums 0 12 3041 42 GeomVertexArrayFormat::upcast_to_GeomEnums 0 1 138 46
upcast from GeomVertexArrayFormat to GeomEnums
60
GeomEnums *GeomVertexArrayFormat::upcast_to_GeomEnums(void);

1656 33 downcast_to_GeomVertexArrayFormat 0 12 3029 44 GeomEnums::downcast_to_GeomVertexArrayFormat 0 1 139 48
downcast from GeomEnums to GeomVertexArrayFormat
74
GeomVertexArrayFormat *GeomEnums::downcast_to_GeomVertexArrayFormat(void);

1657 21 GeomVertexArrayFormat 0 4 3041 44 GeomVertexArrayFormat::GeomVertexArrayFormat 0 6 101 102 103 104 105 106 1413
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
1456
GeomVertexArrayFormat::GeomVertexArrayFormat(void);
GeomVertexArrayFormat::GeomVertexArrayFormat(GeomVertexArrayFormat const &copy);
GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0);
GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1);
GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2);
GeomVertexArrayFormat::GeomVertexArrayFormat(CPT_InternalName name0, int num_components0, GeomEnums::NumericType numeric_type0, GeomEnums::Contents contents0, CPT_InternalName name1, int num_components1, GeomEnums::NumericType numeric_type1, GeomEnums::Contents contents1, CPT_InternalName name2, int num_components2, GeomEnums::NumericType numeric_type2, GeomEnums::Contents contents2, CPT_InternalName name3, int num_components3, GeomEnums::NumericType numeric_type3, GeomEnums::Contents contents3);

1658 10 operator = 0 4 3041 33 GeomVertexArrayFormat::operator = 0 1 107 0
74
void GeomVertexArrayFormat::operator =(GeomVertexArrayFormat const &copy);

1659 22 ~GeomVertexArrayFormat 0 6 3041 45 GeomVertexArrayFormat::~GeomVertexArrayFormat 0 0 241
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
60
virtual GeomVertexArrayFormat::~GeomVertexArrayFormat(void);

1660 5 unref 0 6 3041 28 GeomVertexArrayFormat::unref 0 1 108 380
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::unref
//       Access: Published, Virtual
//  Description: This method overrides ReferenceCount::unref() to
//               unregister the object when its reference count goes
//               to zero.
////////////////////////////////////////////////////////////////////
54
virtual bool GeomVertexArrayFormat::unref(void) const;

1661 13 is_registered 0 4 3041 36 GeomVertexArrayFormat::is_registered 0 1 109 468
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::is_registered
//       Access: Published
//  Description: Returns true if this format has been registered,
//               false if it has not.  It may not be used for a Geom
//               until it has been registered, but once registered, it
//               may no longer be modified.
////////////////////////////////////////////////////////////////////
61
inline bool GeomVertexArrayFormat::is_registered(void) const;

1662 15 register_format 0 4 3041 38 GeomVertexArrayFormat::register_format 0 1 110 774
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::register_format
//       Access: Published, Static
//  Description: Adds the indicated format to the registry, if there
//               is not an equivalent format already there; in either
//               case, returns the pointer to the equivalent format
//               now in the registry.
//
//               This is similar to
//               GeomVertexFormat::register_format(), except that you
//               generally need not call it explicitly.  Calling
//               GeomVertexFormat::register_format() automatically
//               registers all of the nested array formats.
////////////////////////////////////////////////////////////////////
130
static inline ConstPointerTo< GeomVertexArrayFormat > GeomVertexArrayFormat::register_format(GeomVertexArrayFormat const *format);

1663 10 get_stride 0 4 3041 33 GeomVertexArrayFormat::get_stride 0 1 111 322
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_stride
//       Access: Published
//  Description: Returns the total number of bytes reserved in the
//               array for each vertex.
////////////////////////////////////////////////////////////////////
57
inline int GeomVertexArrayFormat::get_stride(void) const;

1664 10 set_stride 0 4 3041 33 GeomVertexArrayFormat::set_stride 0 1 112 443
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::set_stride
//       Access: Published
//  Description: Changes the total number of bytes reserved in the
//               array for each vertex.  You may not reduce this below
//               get_total_bytes(), but you may increase it
//               arbitrarily.
////////////////////////////////////////////////////////////////////
58
inline void GeomVertexArrayFormat::set_stride(int stride);

1665 10 get_pad_to 0 4 3041 33 GeomVertexArrayFormat::get_pad_to 0 1 113 659
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_pad_to
//       Access: Published
//  Description: Returns the byte divisor to which the data record
//               must be padded to meet hardware limitations.  For
//               instance, if this is 4, the stride will be
//               automatically rounded up to the next multiple of 4
//               bytes.  This value is automatically increased as
//               needed to ensure the individual numeric components in
//               the array are word-aligned.
////////////////////////////////////////////////////////////////////
57
inline int GeomVertexArrayFormat::get_pad_to(void) const;

1666 10 set_pad_to 0 4 3041 33 GeomVertexArrayFormat::set_pad_to 0 1 114 666
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::set_pad_to
//       Access: Published
//  Description: Explicitly sets the byte divisor to which the data
//               record must be padded to meet hardware limitations.
//               See get_pad_to().  Normally it is not necessary to
//               call this unless you have some specific requirements
//               for row-to-row data alignment.  Note that this value
//               may be automatically increased at each subsequent
//               call to add_column().
////////////////////////////////////////////////////////////////////
58
inline void GeomVertexArrayFormat::set_pad_to(int pad_to);

1667 11 get_divisor 0 4 3041 34 GeomVertexArrayFormat::get_divisor 0 1 115 482
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_divisor
//       Access: Published
//  Description: Returns the divisor attribute for the data in this
//               array.  If 0, it contains per-vertex data.  If 1,
//               it contains per-instance data.  If higher than 1,
//               the read row is advanced for each n instances.
////////////////////////////////////////////////////////////////////
58
inline int GeomVertexArrayFormat::get_divisor(void) const;

1668 11 set_divisor 0 4 3041 34 GeomVertexArrayFormat::set_divisor 0 1 116 474
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::set_divisor
//       Access: Published
//  Description: Set this to 0 to indicate that this array contains
//               per-vertex data, or to 1 to indicate that it
//               contains per-instance data.  If higher than 1,
//               the read row is advanced for each n instances.
////////////////////////////////////////////////////////////////////
60
inline void GeomVertexArrayFormat::set_divisor(int divisor);

1669 15 get_total_bytes 0 4 3041 38 GeomVertexArrayFormat::get_total_bytes 0 1 117 380
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_total_bytes
//       Access: Published
//  Description: Returns the total number of bytes used by the data
//               types within the format, including gaps between
//               elements.
////////////////////////////////////////////////////////////////////
62
inline int GeomVertexArrayFormat::get_total_bytes(void) const;

1670 10 add_column 0 4 3041 33 GeomVertexArrayFormat::add_column 0 2 118 119 1461
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::add_column
//       Access: Published
//  Description: Adds a new column to the specification.  This is a
//               table of per-vertex floating-point numbers such as
//               "vertex" or "normal"; you must specify where in each
//               record the table starts, and how many components
//               (dimensions) exist per vertex.
//
//               The return value is the index number of the new data
//               type.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::add_column
//       Access: Published
//  Description: Adds a new column to the specification.  This is a
//               table of per-vertex floating-point numbers such as
//               "vertex" or "normal"; you must specify where in each
//               record the table starts, and how many components
//               (dimensions) exist per vertex.
//
//               Adding a column with the same name as a previous
//               type, or that overlaps with one or more previous
//               types, quietly removes the previous type(s).
//
//               The return value is the index number of the new data
//               type.
////////////////////////////////////////////////////////////////////
261
int GeomVertexArrayFormat::add_column(CPT_InternalName name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents, int start = -1, int column_alignment = 0);
int GeomVertexArrayFormat::add_column(GeomVertexColumn const &column);

1671 13 remove_column 0 4 3041 36 GeomVertexArrayFormat::remove_column 0 1 120 346
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::remove_column
//       Access: Published
//  Description: Removes the column with the indicated name, if
//               any.  This leaves a gap in the byte structure.
////////////////////////////////////////////////////////////////////
68
void GeomVertexArrayFormat::remove_column(InternalName const *name);

1672 13 clear_columns 0 4 3041 36 GeomVertexArrayFormat::clear_columns 0 1 121 343
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::clear_columns
//       Access: Published
//  Description: Removes all columns previously added, sets the
//               stride to zero, and prepares to start over.
////////////////////////////////////////////////////////////////////
48
void GeomVertexArrayFormat::clear_columns(void);

1673 12 pack_columns 0 4 3041 35 GeomVertexArrayFormat::pack_columns 0 1 122 272
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::pack_columns
//       Access: Published
//  Description: Removes wasted space between columns.
////////////////////////////////////////////////////////////////////
47
void GeomVertexArrayFormat::pack_columns(void);

1674 27 align_columns_for_animation 0 4 3041 50 GeomVertexArrayFormat::align_columns_for_animation 0 1 123 648
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::align_columns_for_animation
//       Access: Published
//  Description: Reprocesses the columns in the format to align the
//               C_point and C_vector columns to 16-byte boundaries to
//               allow for the more efficient SSE2 operations
//               (assuming SSE2 is enabled in the build).
//
//               The caller is responsible for testing
//               vertex_animation_align_16 to decide whether to call
//               this method.
////////////////////////////////////////////////////////////////////
62
void GeomVertexArrayFormat::align_columns_for_animation(void);

1675 15 get_num_columns 0 4 3041 38 GeomVertexArrayFormat::get_num_columns 0 1 124 308
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_num_columns
//       Access: Published
//  Description: Returns the number of different columns in the
//               array.
////////////////////////////////////////////////////////////////////
62
inline int GeomVertexArrayFormat::get_num_columns(void) const;

1676 10 get_column 0 4 3041 33 GeomVertexArrayFormat::get_column 0 3 125 126 127 984
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_column
//       Access: Published
//  Description: Returns the ith column of the array.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_column
//       Access: Published
//  Description: Returns the specification with the indicated name, or
//               NULL if the name is not used.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_column
//       Access: Published
//  Description: Returns the first specification that overlaps with
//               any of the indicated bytes in the range, or NULL if
//               none do.
////////////////////////////////////////////////////////////////////
265
inline GeomVertexColumn const *GeomVertexArrayFormat::get_column(int i) const;
GeomVertexColumn const *GeomVertexArrayFormat::get_column(InternalName const *name) const;
GeomVertexColumn const *GeomVertexArrayFormat::get_column(int start_byte, int num_bytes) const;

1677 10 has_column 0 4 3041 33 GeomVertexArrayFormat::has_column 0 1 128 314
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::has_column
//       Access: Published
//  Description: Returns true if the array has the named column,
//               false otherwise.
////////////////////////////////////////////////////////////////////
78
inline bool GeomVertexArrayFormat::has_column(InternalName const *name) const;

1678 17 is_data_subset_of 0 4 3041 40 GeomVertexArrayFormat::is_data_subset_of 0 1 129 614
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::is_data_subset_of
//       Access: Published
//  Description: Returns true if all of the fields in this array
//               format are also present and equivalent in the other
//               array format, and in the same byte positions, and the
//               stride is the same.  That is, true if this format can
//               share the same data pointer as the other format (with
//               possibly some unused gaps).
////////////////////////////////////////////////////////////////////
88
bool GeomVertexArrayFormat::is_data_subset_of(GeomVertexArrayFormat const &other) const;

1679 18 count_unused_space 0 4 3041 41 GeomVertexArrayFormat::count_unused_space 0 1 130 330
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::count_unused_space
//       Access: Published
//  Description: Returns the number of bytes per row that are not
//               assigned to any column.
////////////////////////////////////////////////////////////////////
58
int GeomVertexArrayFormat::count_unused_space(void) const;

1680 6 output 0 4 3041 29 GeomVertexArrayFormat::output 0 1 131 228
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
55
void GeomVertexArrayFormat::output(ostream &out) const;

1681 5 write 0 4 3041 28 GeomVertexArrayFormat::write 0 1 132 227
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::write
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
76
void GeomVertexArrayFormat::write(ostream &out, int indent_level = 0) const;

1682 15 write_with_data 0 4 3041 38 GeomVertexArrayFormat::write_with_data 0 1 133 237
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::write_with_data
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
121
void GeomVertexArrayFormat::write_with_data(ostream &out, int indent_level, GeomVertexArrayData const *array_data) const;

1683 17 get_format_string 0 4 3041 40 GeomVertexArrayFormat::get_format_string 0 1 134 532
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_format_string
//       Access: Published
//  Description: Returns a string with format codes representing the
//               exact memory layout of the columns in memory, as
//               understood by Python's struct module.
//               If pad is true, extra padding bytes are added to
//               the end as 'x' characters as needed.
////////////////////////////////////////////////////////////////////
68
string GeomVertexArrayFormat::get_format_string(bool pad = 1) const;

1684 14 get_class_type 0 4 3041 37 GeomVertexArrayFormat::get_class_type 0 1 135 0
62
static TypeHandle GeomVertexArrayFormat::get_class_type(void);

1685 37 upcast_to_TypedWritableReferenceCount 0 12 3042 55 GeomVertexFormat::upcast_to_TypedWritableReferenceCount 0 1 197 59
upcast from GeomVertexFormat to TypedWritableReferenceCount
91
TypedWritableReferenceCount *GeomVertexFormat::upcast_to_TypedWritableReferenceCount(void);

1686 28 downcast_to_GeomVertexFormat 0 12 3039 57 TypedWritableReferenceCount::downcast_to_GeomVertexFormat 0 1 198 61
downcast from TypedWritableReferenceCount to GeomVertexFormat
82
GeomVertexFormat *TypedWritableReferenceCount::downcast_to_GeomVertexFormat(void);

1687 19 upcast_to_GeomEnums 0 12 3042 37 GeomVertexFormat::upcast_to_GeomEnums 0 1 199 41
upcast from GeomVertexFormat to GeomEnums
55
GeomEnums *GeomVertexFormat::upcast_to_GeomEnums(void);

1688 28 downcast_to_GeomVertexFormat 0 12 3029 39 GeomEnums::downcast_to_GeomVertexFormat 0 1 200 43
downcast from GeomEnums to GeomVertexFormat
64
GeomVertexFormat *GeomEnums::downcast_to_GeomVertexFormat(void);

1689 16 GeomVertexFormat 0 4 3042 34 GeomVertexFormat::GeomVertexFormat 0 3 140 141 142 693
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
186
GeomVertexFormat::GeomVertexFormat(void);
GeomVertexFormat::GeomVertexFormat(GeomVertexArrayFormat const *array_format);
GeomVertexFormat::GeomVertexFormat(GeomVertexFormat const &copy);

1690 10 operator = 0 4 3042 28 GeomVertexFormat::operator = 0 1 143 0
64
void GeomVertexFormat::operator =(GeomVertexFormat const &copy);

1691 17 ~GeomVertexFormat 0 6 3042 35 GeomVertexFormat::~GeomVertexFormat 0 0 236
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
50
virtual GeomVertexFormat::~GeomVertexFormat(void);

1692 5 unref 0 6 3042 23 GeomVertexFormat::unref 0 1 144 375
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::unref
//       Access: Published, Virtual
//  Description: This method overrides ReferenceCount::unref() to
//               unregister the object when its reference count goes
//               to zero.
////////////////////////////////////////////////////////////////////
49
virtual bool GeomVertexFormat::unref(void) const;

1693 13 is_registered 0 4 3042 31 GeomVertexFormat::is_registered 0 1 145 463
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::is_registered
//       Access: Published
//  Description: Returns true if this format has been registered,
//               false if it has not.  It may not be used for a Geom
//               until it has been registered, but once registered, it
//               may no longer be modified.
////////////////////////////////////////////////////////////////////
56
inline bool GeomVertexFormat::is_registered(void) const;

1694 15 register_format 0 4 3042 33 GeomVertexFormat::register_format 0 2 146 147 1213
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::register_format
//       Access: Published, Static
//  Description: Adds the indicated format to the registry, if there
//               is not an equivalent format already there; in either
//               case, returns the pointer to the equivalent format
//               now in the registry.
//
//               This must be called before a format may be used in a
//               Geom.  After this call, you should discard the
//               original pointer you passed in (which may or may not
//               now be invalid) and let its reference count decrement
//               normally; you should use only the returned value from
//               this point on.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::register_format
//       Access: Published, Static
//  Description: This flavor of register_format() implicitly creates a
//               one-array vertex format from the array definition.
////////////////////////////////////////////////////////////////////
236
static inline ConstPointerTo< GeomVertexFormat > GeomVertexFormat::register_format(GeomVertexFormat const *format);
static inline ConstPointerTo< GeomVertexFormat > GeomVertexFormat::register_format(GeomVertexArrayFormat const *format);

1695 13 get_animation 0 4 3042 31 GeomVertexFormat::get_animation 0 1 148 351
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_animation
//       Access: Published
//  Description: Returns the GeomVertexAnimationSpec that indicates
//               how this format's vertices are set up for animation.
////////////////////////////////////////////////////////////////////
82
inline GeomVertexAnimationSpec const &GeomVertexFormat::get_animation(void) const;

1696 13 set_animation 0 4 3042 31 GeomVertexFormat::set_animation 0 1 149 555
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::set_animation
//       Access: Published
//  Description: Resets the GeomVertexAnimationSpec that indicates
//               how this format's vertices are set up for animation.
//               You should also, of course, change the columns in the
//               tables accordingly.
//
//               This may not be called once the format has been
//               registered.
////////////////////////////////////////////////////////////////////
86
inline void GeomVertexFormat::set_animation(GeomVertexAnimationSpec const &animation);

1697 24 get_post_animated_format 0 4 3042 42 GeomVertexFormat::get_post_animated_format 0 1 150 646
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_post_animated_format
//       Access: Published
//  Description: Returns a suitable vertex format for sending the
//               animated vertices to the graphics backend.  This is
//               the same format as the source format, with the
//               CPU-animation data elements removed.
//
//               This may only be called after the format has been
//               registered.  The return value will have been already
//               registered.
////////////////////////////////////////////////////////////////////
90
ConstPointerTo< GeomVertexFormat > GeomVertexFormat::get_post_animated_format(void) const;

1698 16 get_union_format 0 4 3042 34 GeomVertexFormat::get_union_format 0 1 151 791
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_union_format
//       Access: Published
//  Description: Returns a new GeomVertexFormat that includes all of
//               the columns defined in either this GeomVertexFormat
//               or the other one.  If any column is defined in both
//               formats with different sizes (for instance, texcoord2
//               vs. texcoord3), the new format will include the
//               larger of the two definitions.
//
//               This may only be called after both source formats
//               have been registered.  The return value will also
//               have been already registered.
////////////////////////////////////////////////////////////////////
107
ConstPointerTo< GeomVertexFormat > GeomVertexFormat::get_union_format(GeomVertexFormat const *other) const;

1699 14 get_num_arrays 0 4 3042 32 GeomVertexFormat::get_num_arrays 0 1 152 506
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_arrays
//       Access: Published
//  Description: Returns the number of individual arrays required by
//               the format.  If the array data is completely
//               interleaved, this will be 1; if it is completely
//               parallel, this will be the same as the number of data
//               types.
////////////////////////////////////////////////////////////////////
56
inline int GeomVertexFormat::get_num_arrays(void) const;

1700 9 get_array 0 4 3042 27 GeomVertexFormat::get_array 0 1 153 304
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_array
//       Access: Published
//  Description: Returns the description of the nth array used by the
//               format.
////////////////////////////////////////////////////////////////////
81
inline GeomVertexArrayFormat const *GeomVertexFormat::get_array(int array) const;

1701 12 modify_array 0 4 3042 30 GeomVertexFormat::modify_array 0 1 154 470
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::modify_array
//       Access: Published
//  Description: Returns a modifiable pointer to the indicated array.
//               This means duplicating it if it is shared or
//               registered.
//
//               This may not be called once the format has been
//               registered.
////////////////////////////////////////////////////////////////////
65
GeomVertexArrayFormat *GeomVertexFormat::modify_array(int array);

1702 9 set_array 0 4 3042 27 GeomVertexFormat::set_array 0 1 155 371
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::set_array
//       Access: Published
//  Description: Replaces the definition of the indicated array.
//
//               This may not be called once the format has been
//               registered.
////////////////////////////////////////////////////////////////////
81
void GeomVertexFormat::set_array(int array, GeomVertexArrayFormat const *format);

1703 12 remove_array 0 4 3042 30 GeomVertexFormat::remove_array 0 1 156 365
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::remove_array
//       Access: Published
//  Description: Removes the nth array from the format.
//
//               This may not be called once the format has been
//               registered.
////////////////////////////////////////////////////////////////////
47
void GeomVertexFormat::remove_array(int array);

1704 9 add_array 0 4 3042 27 GeomVertexFormat::add_array 0 1 157 534
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::add_array
//       Access: Published
//  Description: Adds the indicated array definition to the list of
//               arrays included within this vertex format definition.
//               The return value is the index number of the new
//               array.
//
//               This may not be called once the format has been
//               registered.
////////////////////////////////////////////////////////////////////
75
int GeomVertexFormat::add_array(GeomVertexArrayFormat const *array_format);

1705 12 insert_array 0 4 3042 30 GeomVertexFormat::insert_array 0 1 158 570
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::insert_array
//       Access: Published
//  Description: Adds the indicated array definition to the list of
//               arrays at the indicated position.  This works just
//               like add_array(), except that you can specify which
//               array index the new array should have.
//
//               This may not be called once the format has been
//               registered.
////////////////////////////////////////////////////////////////////
90
void GeomVertexFormat::insert_array(int array, GeomVertexArrayFormat const *array_format);

1706 12 clear_arrays 0 4 3042 30 GeomVertexFormat::clear_arrays 0 1 159 413
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::clear_arrays
//       Access: Published
//  Description: Removes all of the array definitions from the format
//               and starts over.
//
//               This may not be called once the format has been
//               registered.
////////////////////////////////////////////////////////////////////
42
void GeomVertexFormat::clear_arrays(void);

1707 19 remove_empty_arrays 0 4 3042 37 GeomVertexFormat::remove_empty_arrays 0 1 160 376
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::remove_empty_arrays
//       Access: Published
//  Description: Removes the arrays that define no columns.
//
//               This may not be called once the format has been
//               registered.
////////////////////////////////////////////////////////////////////
49
void GeomVertexFormat::remove_empty_arrays(void);

1708 15 get_num_columns 0 4 3042 33 GeomVertexFormat::get_num_columns 0 1 161 336
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_columns
//       Access: Published
//  Description: Returns the total number of different columns in
//               the specification, across all arrays.
////////////////////////////////////////////////////////////////////
50
int GeomVertexFormat::get_num_columns(void) const;

1709 14 get_array_with 0 4 3042 32 GeomVertexFormat::get_array_with 0 2 162 163 1372
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_array_with
//       Access: Published
//  Description: Returns the index number of the array with the
//               ith column.
//
//               The return value can be passed to get_array_format()
//               to get the format of the array.  It may also be
//               passed to GeomVertexData::get_array_data() or
//               get_data() or set_data() to manipulate the actual
//               array data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_array_with
//       Access: Published
//  Description: Returns the index number of the array with the
//               indicated column, or -1 if no arrays contained
//               that name.
//
//               The return value can be passed to get_array_format()
//               to get the format of the array.  It may also be
//               passed to GeomVertexData::get_array_data() or
//               get_data() or set_data() to manipulate the actual
//               array data.
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
120
int GeomVertexFormat::get_array_with(int i) const;
int GeomVertexFormat::get_array_with(InternalName const *name) const;

1710 10 get_column 0 4 3042 28 GeomVertexFormat::get_column 0 2 164 165 751
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_column
//       Access: Published
//  Description: Returns the ith column of the specification,
//               across all arrays.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_column
//       Access: Published
//  Description: Returns the specification with the indicated name, or
//               NULL if the name is not used.  Use get_array_with()
//               to determine which array this column is associated
//               with.
////////////////////////////////////////////////////////////////////
152
GeomVertexColumn const *GeomVertexFormat::get_column(int i) const;
GeomVertexColumn const *GeomVertexFormat::get_column(InternalName const *name) const;

1711 10 has_column 0 4 3042 28 GeomVertexFormat::has_column 0 1 166 310
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::has_column
//       Access: Published
//  Description: Returns true if the format has the named column,
//               false otherwise.
////////////////////////////////////////////////////////////////////
73
inline bool GeomVertexFormat::has_column(InternalName const *name) const;

1712 13 remove_column 0 4 3042 31 GeomVertexFormat::remove_column 0 1 167 697
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::remove_column
//       Access: Published
//  Description: Removes the named column from the format, from
//               whichever array it exists in.  If there are other
//               columns remaining in the array, the array is left
//               with a gap where the column used to be; if this
//               was the only column in the array, the array is
//               removed (unless keep_empty_array is true).
//
//               This may not be called once the format has been
//               registered.
////////////////////////////////////////////////////////////////////
90
void GeomVertexFormat::remove_column(InternalName const *name, bool keep_empty_array = 0);

1713 12 pack_columns 0 4 3042 30 GeomVertexFormat::pack_columns 0 1 168 267
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::pack_columns
//       Access: Published
//  Description: Removes wasted space between columns.
////////////////////////////////////////////////////////////////////
42
void GeomVertexFormat::pack_columns(void);

1714 27 align_columns_for_animation 0 4 3042 45 GeomVertexFormat::align_columns_for_animation 0 1 169 552
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::align_columns_for_animation
//       Access: Published
//  Description: Reprocesses the columns in the format to align the
//               C_point and C_vector columns to 16-byte boundaries to
//               allow for the more efficient SSE2 operations
//               (assuming SSE2 is enabled in the build).
//
//               Also see maybe_align_columns_for_animation().
////////////////////////////////////////////////////////////////////
57
void GeomVertexFormat::align_columns_for_animation(void);

1715 33 maybe_align_columns_for_animation 0 4 3042 51 GeomVertexFormat::maybe_align_columns_for_animation 0 1 170 439
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::maybe_align_columns_for_animation
//       Access: Published
//  Description: Calls align_columns_for_animation() if this format's
//               AnimationSpec indicates that it contains animated
//               vertices, and if vertex-animation-align-16 is true.
////////////////////////////////////////////////////////////////////
63
void GeomVertexFormat::maybe_align_columns_for_animation(void);

1716 14 get_num_points 0 4 3042 32 GeomVertexFormat::get_num_points 0 1 171 427
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_points
//       Access: Published
//  Description: Returns the number of columns within the format
//               that represent points in space.
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
56
inline int GeomVertexFormat::get_num_points(void) const;

1717 9 get_point 0 4 3042 27 GeomVertexFormat::get_point 0 1 172 497
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_point
//       Access: Published
//  Description: Returns the name of the nth point column.  This
//               represents a point in space, which should be
//               transformed by any spatial transform matrix.
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
68
inline InternalName const *GeomVertexFormat::get_point(int n) const;

1718 15 get_num_vectors 0 4 3042 33 GeomVertexFormat::get_num_vectors 0 1 173 432
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_vectors
//       Access: Published
//  Description: Returns the number of columns within the format
//               that represent directional vectors.
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
57
inline int GeomVertexFormat::get_num_vectors(void) const;

1719 10 get_vector 0 4 3042 28 GeomVertexFormat::get_vector 0 1 174 532
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_vector
//       Access: Published
//  Description: Returns the name of the nth vector column.  This
//               represents a directional vector, which should be
//               transformed by any spatial transform matrix as a
//               vector.
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
69
inline InternalName const *GeomVertexFormat::get_vector(int n) const;

1720 17 get_num_texcoords 0 4 3042 35 GeomVertexFormat::get_num_texcoords 0 1 175 434
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_texcoords
//       Access: Published
//  Description: Returns the number of columns within the format
//               that represent texture coordinates.
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
59
inline int GeomVertexFormat::get_num_texcoords(void) const;

1721 12 get_texcoord 0 4 3042 30 GeomVertexFormat::get_texcoord 0 1 176 429
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_texcoord
//       Access: Published
//  Description: Returns the name of the nth texcoord column.  This
//               represents a texture coordinate.
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
71
inline InternalName const *GeomVertexFormat::get_texcoord(int n) const;

1722 14 get_num_morphs 0 4 3042 32 GeomVertexFormat::get_num_morphs 0 1 177 424
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_morphs
//       Access: Published
//  Description: Returns the number of columns within the format
//               that represent morph deltas.
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
56
inline int GeomVertexFormat::get_num_morphs(void) const;

1723 16 get_morph_slider 0 4 3042 34 GeomVertexFormat::get_morph_slider 0 1 178 587
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_morph_slider
//       Access: Published
//  Description: Returns the slider name associated with the nth morph
//               column.  This is the name of the slider that will
//               control the morph, and should be defined within the
//               SliderTable associated with the GeomVertexData.
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
75
inline InternalName const *GeomVertexFormat::get_morph_slider(int n) const;

1724 14 get_morph_base 0 4 3042 32 GeomVertexFormat::get_morph_base 0 1 179 562
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_morph_base
//       Access: Published
//  Description: Returns the name of the base column that the nth
//               morph modifies.  This column will also be defined
//               within the format, and can be retrieved via
//               get_array_with() and/or get_column().
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
73
inline InternalName const *GeomVertexFormat::get_morph_base(int n) const;

1725 15 get_morph_delta 0 4 3042 33 GeomVertexFormat::get_morph_delta 0 1 180 685
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_morph_delta
//       Access: Published
//  Description: Returns the name of the column that defines the
//               nth morph.  This contains the delta offsets that are
//               to be applied to the column defined by
//               get_morph_base().  This column will be defined
//               within the format, and can be retrieved via
//               get_array_with() and/or get_column().
//
//               This may only be called after the format has been
//               registered.
////////////////////////////////////////////////////////////////////
74
inline InternalName const *GeomVertexFormat::get_morph_delta(int n) const;

1726 6 output 0 4 3042 24 GeomVertexFormat::output 0 1 181 223
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
50
void GeomVertexFormat::output(ostream &out) const;

1727 5 write 0 4 3042 23 GeomVertexFormat::write 0 1 182 222
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::write
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
71
void GeomVertexFormat::write(ostream &out, int indent_level = 0) const;

1728 15 write_with_data 0 4 3042 33 GeomVertexFormat::write_with_data 0 1 183 232
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::write_with_data
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
105
void GeomVertexFormat::write_with_data(ostream &out, int indent_level, GeomVertexData const *data) const;

1729 6 get_v3 0 4 3042 24 GeomVertexFormat::get_v3 0 1 184 529
// Some standard vertex formats.  No particular requirement to use
// one of these, but the DirectX renderers can use these formats
// directly, whereas any other format will have to be converted
// first.

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3
//       Access: Published, Static
//  Description: Returns a standard vertex format with just a
//               3-component vertex position.
////////////////////////////////////////////////////////////////////
69
static inline GeomVertexFormat const *GeomVertexFormat::get_v3(void);

1730 8 get_v3n3 0 4 3042 26 GeomVertexFormat::get_v3n3 0 1 185 344
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 3-component
//               normal and a 3-component vertex position.
////////////////////////////////////////////////////////////////////
71
static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3(void);

1731 8 get_v3t2 0 4 3042 26 GeomVertexFormat::get_v3t2 0 1 186 378
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3t2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair and a 3-component vertex
//               position.
////////////////////////////////////////////////////////////////////
71
static inline GeomVertexFormat const *GeomVertexFormat::get_v3t2(void);

1732 10 get_v3n3t2 0 4 3042 28 GeomVertexFormat::get_v3n3t2 0 1 187 403
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3t2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a 3-component normal, and a
//               3-component vertex position.
////////////////////////////////////////////////////////////////////
73
static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3t2(void);

1733 8 get_v3cp 0 4 3042 26 GeomVertexFormat::get_v3cp 0 1 188 612
// These formats, with the DirectX-style packed color, may not be
// supported directly by OpenGL.  If you use them and the driver
// does not support them, the GLGraphicsStateGuardian will
// automatically convert to native OpenGL form (with a small
// runtime overhead).

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3cp
//       Access: Published, Static
//  Description: Returns a standard vertex format with a packed
//               color and a 3-component vertex position.
////////////////////////////////////////////////////////////////////
71
static inline GeomVertexFormat const *GeomVertexFormat::get_v3cp(void);

1734 10 get_v3cpt2 0 4 3042 28 GeomVertexFormat::get_v3cpt2 0 1 189 397
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3cpt2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a packed color, and a
//               3-component vertex position.
////////////////////////////////////////////////////////////////////
73
static inline GeomVertexFormat const *GeomVertexFormat::get_v3cpt2(void);

1735 10 get_v3n3cp 0 4 3042 28 GeomVertexFormat::get_v3n3cp 0 1 190 380
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3cp
//       Access: Published, Static
//  Description: Returns a standard vertex format with a packed
//               color, a 3-component normal, and a 3-component vertex
//               position.
////////////////////////////////////////////////////////////////////
73
static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3cp(void);

1736 12 get_v3n3cpt2 0 4 3042 30 GeomVertexFormat::get_v3n3cpt2 0 1 191 438
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3cpt2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a packed color, a
//               3-component normal, and a 3-component vertex
//               position.
////////////////////////////////////////////////////////////////////
75
static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3cpt2(void);

1737 8 get_v3c4 0 4 3042 26 GeomVertexFormat::get_v3c4 0 1 192 663
// These formats, with an OpenGL-style four-byte color, are not
// supported directly by DirectX.  If you use them, the
// DXGraphicsStateGuardian will automatically convert to DirectX
// form (with a larger runtime overhead, since DirectX8, and old
// DirectX9 drivers, require everything to be interleaved together).

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3c4
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 4-component
//               color and a 3-component vertex position.
////////////////////////////////////////////////////////////////////
71
static inline GeomVertexFormat const *GeomVertexFormat::get_v3c4(void);

1738 10 get_v3c4t2 0 4 3042 28 GeomVertexFormat::get_v3c4t2 0 1 193 402
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3c4t2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a 4-component color, and a
//               3-component vertex position.
////////////////////////////////////////////////////////////////////
73
static inline GeomVertexFormat const *GeomVertexFormat::get_v3c4t2(void);

1739 10 get_v3n3c4 0 4 3042 28 GeomVertexFormat::get_v3n3c4 0 1 194 385
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3c4
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 4-component
//               color, a 3-component normal, and a 3-component vertex
//               position.
////////////////////////////////////////////////////////////////////
73
static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3c4(void);

1740 12 get_v3n3c4t2 0 4 3042 30 GeomVertexFormat::get_v3n3c4t2 0 1 195 443
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3c4t2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a 4-component color, a
//               3-component normal, and a 3-component vertex
//               position.
////////////////////////////////////////////////////////////////////
75
static inline GeomVertexFormat const *GeomVertexFormat::get_v3n3c4t2(void);

1741 14 get_class_type 0 4 3042 32 GeomVertexFormat::get_class_type 0 1 196 0
57
static TypeHandle GeomVertexFormat::get_class_type(void);

1742 24 upcast_to_LinkedListNode 0 12 3043 35 SimpleLru::upcast_to_LinkedListNode 0 1 212 39
upcast from SimpleLru to LinkedListNode
58
LinkedListNode *SimpleLru::upcast_to_LinkedListNode(void);

1743 21 downcast_to_SimpleLru 0 12 3044 37 LinkedListNode::downcast_to_SimpleLru 0 1 213 41
downcast from LinkedListNode to SimpleLru
55
SimpleLru *LinkedListNode::downcast_to_SimpleLru(void);

1744 17 upcast_to_Namable 0 12 3043 28 SimpleLru::upcast_to_Namable 0 1 214 32
upcast from SimpleLru to Namable
44
Namable *SimpleLru::upcast_to_Namable(void);

1745 21 downcast_to_SimpleLru 0 12 3025 30 Namable::downcast_to_SimpleLru 0 1 215 34
downcast from Namable to SimpleLru
48
SimpleLru *Namable::downcast_to_SimpleLru(void);

1746 9 SimpleLru 0 4 3043 20 SimpleLru::SimpleLru 0 1 201 222
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
58
SimpleLru::SimpleLru(string const &name, size_t max_size);

1747 10 ~SimpleLru 0 4 3043 21 SimpleLru::~SimpleLru 0 0 230
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::Destructor
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
28
SimpleLru::~SimpleLru(void);

1748 14 get_total_size 0 4 3043 25 SimpleLru::get_total_size 0 1 202 308
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::get_total_size
//       Access: Published
//  Description: Returns the total size of all objects currently
//               active on the LRU.
////////////////////////////////////////////////////////////////////
52
inline size_t SimpleLru::get_total_size(void) const;

1749 12 get_max_size 0 4 3043 23 SimpleLru::get_max_size 0 1 203 317
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::get_max_size
//       Access: Published
//  Description: Returns the max size of all objects that are allowed
//               to be active on the LRU.
////////////////////////////////////////////////////////////////////
50
inline size_t SimpleLru::get_max_size(void) const;

1750 12 set_max_size 0 4 3043 23 SimpleLru::set_max_size 0 1 204 383
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::set_max_size
//       Access: Published
//  Description: Changes the max size of all objects that are allowed
//               to be active on the LRU.
//
//               If the size is (size_t)-1, there is no limit.
////////////////////////////////////////////////////////////////////
53
inline void SimpleLru::set_max_size(size_t max_size);

1751 17 count_active_size 0 4 3043 28 SimpleLru::count_active_size 0 1 205 337
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::count_active_size
//       Access: Published
//  Description: Returns the total size of the pages that were
//               enqueued since the last call to begin_epoch().
////////////////////////////////////////////////////////////////////
48
size_t SimpleLru::count_active_size(void) const;

1752 14 consider_evict 0 4 3043 25 SimpleLru::consider_evict 0 1 206 275
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::consider_evict
//       Access: Published
//  Description: Evicts a sequence of objects if the queue is full.
////////////////////////////////////////////////////////////////////
44
inline void SimpleLru::consider_evict(void);

1753 8 evict_to 0 4 3043 19 SimpleLru::evict_to 0 1 207 371
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::evict_to
//       Access: Published
//  Description: Evicts a sequence of objects until the queue fits
//               within the indicated target size, regardless of its
//               normal max size.
////////////////////////////////////////////////////////////////////
52
inline void SimpleLru::evict_to(size_t target_size);

1754 11 begin_epoch 0 4 3043 22 SimpleLru::begin_epoch 0 1 208 441
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::begin_epoch
//       Access: Published
//  Description: Marks the end of the previous epoch and the beginning
//               of the next one.  This will evict any objects that
//               are pending eviction, and also update any internal
//               bookkeeping.
////////////////////////////////////////////////////////////////////
41
inline void SimpleLru::begin_epoch(void);

1755 8 validate 0 4 3043 19 SimpleLru::validate 0 1 209 363
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::validate
//       Access: Published
//  Description: Checks that the LRU is internally self-consistent.
//               Returns true if successful, false if there is some
//               problem.
////////////////////////////////////////////////////////////////////
38
inline bool SimpleLru::validate(void);

1756 6 output 0 4 3043 17 SimpleLru::output 0 1 210 217
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
43
void SimpleLru::output(ostream &out) const;

1757 5 write 0 4 3043 16 SimpleLru::write 0 1 211 225
////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
60
void SimpleLru::write(ostream &out, int indent_level) const;

1758 24 upcast_to_LinkedListNode 0 12 3045 39 SimpleLruPage::upcast_to_LinkedListNode 0 1 229 43
upcast from SimpleLruPage to LinkedListNode
62
LinkedListNode *SimpleLruPage::upcast_to_LinkedListNode(void);

1759 25 downcast_to_SimpleLruPage 0 12 3044 41 LinkedListNode::downcast_to_SimpleLruPage 0 1 230 45
downcast from LinkedListNode to SimpleLruPage
63
SimpleLruPage *LinkedListNode::downcast_to_SimpleLruPage(void);

1760 13 SimpleLruPage 0 4 3045 28 SimpleLruPage::SimpleLruPage 0 2 216 217 459
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::Constructor
//       Access: Protected
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::Copy Constructor
//       Access: Protected
//  Description: 
////////////////////////////////////////////////////////////////////
117
inline SimpleLruPage::SimpleLruPage(size_t lru_size);
inline SimpleLruPage::SimpleLruPage(SimpleLruPage const &copy);

1761 10 operator = 0 4 3045 25 SimpleLruPage::operator = 0 1 218 0
65
inline void SimpleLruPage::operator =(SimpleLruPage const &copy);

1762 14 ~SimpleLruPage 0 6 3045 29 SimpleLruPage::~SimpleLruPage 0 0 234
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::Destructor
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
44
virtual SimpleLruPage::~SimpleLruPage(void);

1763 7 get_lru 0 4 3045 22 SimpleLruPage::get_lru 0 1 219 329
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::get_lru
//       Access: Published
//  Description: Returns the LRU that manages this page, or NULL if it
//               is not currently managed by any LRU.
////////////////////////////////////////////////////////////////////
53
inline SimpleLru *SimpleLruPage::get_lru(void) const;

1764 11 enqueue_lru 0 4 3045 26 SimpleLruPage::enqueue_lru 0 1 220 443
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::enqueue_lru
//       Access: Published
//  Description: Adds the page to the LRU for the first time, or marks
//               it recently-accessed if it has already been added.
//
//               If lru is NULL, it means to remove this page from its
//               LRU.
////////////////////////////////////////////////////////////////////
48
void SimpleLruPage::enqueue_lru(SimpleLru *lru);

1765 11 dequeue_lru 0 4 3045 26 SimpleLruPage::dequeue_lru 0 1 221 262
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::dequeue_lru
//       Access: Published
//  Description: Removes the page from its SimpleLru.
////////////////////////////////////////////////////////////////////
45
inline void SimpleLruPage::dequeue_lru(void);

1766 13 mark_used_lru 0 4 3045 28 SimpleLruPage::mark_used_lru 0 2 222 223 827
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::mark_used_lru
//       Access: Published
//  Description: To be called when the page is used; this will move it
//               to the tail of the SimpleLru queue it is already on.
//
//               This method is const because it's not technically
//               modifying the contents of the page itself.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::mark_used_lru
//       Access: Published
//  Description: To be called when the page is used; this will move it
//               to the tail of the specified SimpleLru queue.
////////////////////////////////////////////////////////////////////
111
inline void SimpleLruPage::mark_used_lru(void) const;
inline void SimpleLruPage::mark_used_lru(SimpleLru *lru);

1767 12 get_lru_size 0 4 3045 27 SimpleLruPage::get_lru_size 0 1 224 318
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::get_lru_size
//       Access: Published
//  Description: Returns the size of this page as reported to the LRU,
//               presumably in bytes.
////////////////////////////////////////////////////////////////////
54
inline size_t SimpleLruPage::get_lru_size(void) const;

1768 12 set_lru_size 0 4 3045 27 SimpleLruPage::set_lru_size 0 1 225 328
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::set_lru_size
//       Access: Published
//  Description: Specifies the size of this page, presumably in bytes,
//               although any unit is possible.
////////////////////////////////////////////////////////////////////
57
inline void SimpleLruPage::set_lru_size(size_t lru_size);

1769 9 evict_lru 0 6 3045 24 SimpleLruPage::evict_lru 0 1 226 812
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::evict_lru
//       Access: Published, Virtual
//  Description: Evicts the page from the LRU.  Called internally when
//               the LRU determines that it is full.  May also be
//               called externally when necessary to explicitly evict
//               the page.
//
//               It is legal for this method to either evict the page
//               as requested, do nothing (in which case the eviction
//               will be requested again at the next epoch), or
//               requeue itself on the tail of the queue (in which
//               case the eviction will be requested again much
//               later).
////////////////////////////////////////////////////////////////////
44
virtual void SimpleLruPage::evict_lru(void);

1770 6 output 0 6 3045 21 SimpleLruPage::output 0 1 227 230
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
55
virtual void SimpleLruPage::output(ostream &out) const;

1771 5 write 0 6 3045 20 SimpleLruPage::write 0 1 228 229
////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
72
virtual void SimpleLruPage::write(ostream &out, int indent_level) const;

1772 24 upcast_to_LinkedListNode 0 12 3046 41 SimpleAllocator::upcast_to_LinkedListNode 0 1 241 45
upcast from SimpleAllocator to LinkedListNode
64
LinkedListNode *SimpleAllocator::upcast_to_LinkedListNode(void);

1773 27 downcast_to_SimpleAllocator 0 12 3044 43 LinkedListNode::downcast_to_SimpleAllocator 0 1 242 47
downcast from LinkedListNode to SimpleAllocator
67
SimpleAllocator *LinkedListNode::downcast_to_SimpleAllocator(void);

1774 15 SimpleAllocator 0 4 3046 32 SimpleAllocator::SimpleAllocator 0 1 231 228
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
70
inline SimpleAllocator::SimpleAllocator(size_t max_size, Mutex &lock);

1775 16 ~SimpleAllocator 0 6 3046 33 SimpleAllocator::~SimpleAllocator 0 0 236
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::Destructor
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
48
virtual SimpleAllocator::~SimpleAllocator(void);

1776 5 alloc 0 4 3046 22 SimpleAllocator::alloc 0 1 232 451
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::alloc
//       Access: Published
//  Description: Allocates a new block.  Returns NULL if a block of the
//               requested size cannot be allocated.
//
//               To free the allocated block, call block->free(), or
//               simply delete the block pointer.
////////////////////////////////////////////////////////////////////
65
inline SimpleAllocatorBlock *SimpleAllocator::alloc(size_t size);

1777 8 is_empty 0 4 3046 25 SimpleAllocator::is_empty 0 1 233 336
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::is_empty
//       Access: Published
//  Description: Returns true if there are no blocks allocated on this
//               page, or false if there is at least one.
////////////////////////////////////////////////////////////////////
50
inline bool SimpleAllocator::is_empty(void) const;

1778 14 get_total_size 0 4 3046 31 SimpleAllocator::get_total_size 0 1 234 275
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::get_total_size
//       Access: Published
//  Description: Returns the total size of allocated objects.
////////////////////////////////////////////////////////////////////
58
inline size_t SimpleAllocator::get_total_size(void) const;

1779 12 get_max_size 0 4 3046 29 SimpleAllocator::get_max_size 0 1 235 279
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::get_max_size
//       Access: Published
//  Description: Returns the available space for allocated objects.
////////////////////////////////////////////////////////////////////
56
inline size_t SimpleAllocator::get_max_size(void) const;

1780 12 set_max_size 0 4 3046 29 SimpleAllocator::set_max_size 0 1 236 417
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::set_max_size
//       Access: Published
//  Description: Changes the available space for allocated objects.
//               This will not affect any already-allocated objects,
//               but will have an effect on future calls to alloc().
////////////////////////////////////////////////////////////////////
59
inline void SimpleAllocator::set_max_size(size_t max_size);

1781 14 get_contiguous 0 4 3046 31 SimpleAllocator::get_contiguous 0 1 237 595
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::get_contiguous
//       Access: Published
//  Description: Returns an upper-bound estimate of the size of the
//               largest contiguous block that may be allocated.  It
//               is guaranteed that an attempt to allocate a block
//               larger than this will fail, though it is not
//               guaranteed that an attempt to allocate a block this
//               size or smaller will succeed.
////////////////////////////////////////////////////////////////////
58
inline size_t SimpleAllocator::get_contiguous(void) const;

1782 15 get_first_block 0 4 3046 32 SimpleAllocator::get_first_block 0 1 238 338
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::get_first_block
//       Access: Published
//  Description: Returns a pointer to the first allocated block, or
//               NULL if there are no allocated blocks.
////////////////////////////////////////////////////////////////////
74
inline SimpleAllocatorBlock *SimpleAllocator::get_first_block(void) const;

1783 6 output 0 4 3046 23 SimpleAllocator::output 0 1 239 223
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
49
void SimpleAllocator::output(ostream &out) const;

1784 5 write 0 4 3046 22 SimpleAllocator::write 0 1 240 222
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
48
void SimpleAllocator::write(ostream &out) const;

1785 21 ~SimpleAllocatorBlock 0 4 3047 43 SimpleAllocatorBlock::~SimpleAllocatorBlock 0 0 304
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::Destructor
//       Access: Published
//  Description: The block automatically frees itself when it
//               destructs.
////////////////////////////////////////////////////////////////////
57
inline SimpleAllocatorBlock::~SimpleAllocatorBlock(void);

1786 4 free 0 4 3047 26 SimpleAllocatorBlock::free 0 1 243 255
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::free
//       Access: Published
//  Description: Releases the allocated space.
////////////////////////////////////////////////////////////////////
45
inline void SimpleAllocatorBlock::free(void);

1787 13 get_allocator 0 4 3047 35 SimpleAllocatorBlock::get_allocator 0 1 244 351
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_allocator
//       Access: Published
//  Description: Returns the SimpleAllocator object that owns this
//               block.  Returns NULL if the block has been freed.
////////////////////////////////////////////////////////////////////
72
inline SimpleAllocator *SimpleAllocatorBlock::get_allocator(void) const;

1788 9 get_start 0 4 3047 31 SimpleAllocatorBlock::get_start 0 1 245 347
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_start
//       Access: Published
//  Description: Returns the starting point of this block.  It is an
//               error to call this if the block has been freed.
////////////////////////////////////////////////////////////////////
58
inline size_t SimpleAllocatorBlock::get_start(void) const;

1789 8 get_size 0 4 3047 30 SimpleAllocatorBlock::get_size 0 1 246 336
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_size
//       Access: Published
//  Description: Returns the size of this block.  It is an
//               error to call this if the block has been freed.
////////////////////////////////////////////////////////////////////
57
inline size_t SimpleAllocatorBlock::get_size(void) const;

1790 7 is_free 0 4 3047 29 SimpleAllocatorBlock::is_free 0 1 247 315
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::is_free
//       Access: Published
//  Description: Returns true if the block has been freed, false if it
//               is still valid.
////////////////////////////////////////////////////////////////////
54
inline bool SimpleAllocatorBlock::is_free(void) const;

1791 12 get_max_size 0 4 3047 34 SimpleAllocatorBlock::get_max_size 0 1 248 344
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_max_size
//       Access: Published
//  Description: Returns the maximum size this block can be
//               reallocated to, as limited by the following block.
////////////////////////////////////////////////////////////////////
61
inline size_t SimpleAllocatorBlock::get_max_size(void) const;

1792 7 realloc 0 4 3047 29 SimpleAllocatorBlock::realloc 0 1 249 392
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::realloc
//       Access: Published
//  Description: Changes the size of this block to the specified size.
//               Returns true if the change is accepted, false if
//               there was not enough room.
////////////////////////////////////////////////////////////////////
55
inline bool SimpleAllocatorBlock::realloc(size_t size);

1793 14 get_next_block 0 4 3047 36 SimpleAllocatorBlock::get_next_block 0 1 250 359
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_next_block
//       Access: Published
//  Description: Returns a pointer to the next allocated block in the
//               chain, or NULL if there are no more allocated blocks.
////////////////////////////////////////////////////////////////////
78
inline SimpleAllocatorBlock *SimpleAllocatorBlock::get_next_block(void) const;

1794 6 output 0 4 3047 28 SimpleAllocatorBlock::output 0 1 251 228
////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
54
void SimpleAllocatorBlock::output(ostream &out) const;

1795 8 is_valid 0 4 3048 28 VertexDataSaveFile::is_valid 0 1 252 364
////////////////////////////////////////////////////////////////////
//     Function: VertexDataSaveFile::is_valid
//       Access: Public
//  Description: Returns true if the save file was successfully
//               created and is ready for use, false if there was an
//               error.
////////////////////////////////////////////////////////////////////
53
inline bool VertexDataSaveFile::is_valid(void) const;

1796 19 get_total_file_size 0 4 3048 39 VertexDataSaveFile::get_total_file_size 0 1 253 334
////////////////////////////////////////////////////////////////////
//     Function: VertexDataSaveFile::get_total_file_size
//       Access: Public
//  Description: Returns the amount of space consumed by the save
//               file, including unused portions.
////////////////////////////////////////////////////////////////////
66
inline size_t VertexDataSaveFile::get_total_file_size(void) const;

1797 18 get_used_file_size 0 4 3048 38 VertexDataSaveFile::get_used_file_size 0 1 254 326
////////////////////////////////////////////////////////////////////
//     Function: VertexDataSaveFile::get_used_file_size
//       Access: Public
//  Description: Returns the amount of space within the save file that
//               is currently in use.
////////////////////////////////////////////////////////////////////
65
inline size_t VertexDataSaveFile::get_used_file_size(void) const;

1798 25 upcast_to_SimpleAllocator 0 12 3049 41 VertexDataPage::upcast_to_SimpleAllocator 0 1 273 45
upcast from VertexDataPage to SimpleAllocator
65
SimpleAllocator *VertexDataPage::upcast_to_SimpleAllocator(void);

1799 26 downcast_to_VertexDataPage 0 12 3046 43 SimpleAllocator::downcast_to_VertexDataPage 0 1 274 47
downcast from SimpleAllocator to VertexDataPage
66
VertexDataPage *SimpleAllocator::downcast_to_VertexDataPage(void);

1800 23 upcast_to_SimpleLruPage 0 12 3049 39 VertexDataPage::upcast_to_SimpleLruPage 0 1 275 43
upcast from VertexDataPage to SimpleLruPage
61
SimpleLruPage *VertexDataPage::upcast_to_SimpleLruPage(void);

1801 26 downcast_to_VertexDataPage 0 12 3045 41 SimpleLruPage::downcast_to_VertexDataPage 0 1 276 45
downcast from SimpleLruPage to VertexDataPage
64
VertexDataPage *SimpleLruPage::downcast_to_VertexDataPage(void);

1802 13 get_ram_class 0 4 3049 29 VertexDataPage::get_ram_class 0 1 255 384
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_ram_class
//       Access: Published
//  Description: Returns the current ram class of the array.  If this
//               is other than RC_resident, the array data is not
//               resident in memory.
////////////////////////////////////////////////////////////////////
74
inline VertexDataPage::RamClass VertexDataPage::get_ram_class(void) const;

1803 21 get_pending_ram_class 0 4 3049 37 VertexDataPage::get_pending_ram_class 0 1 256 484
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_pending_ram_class
//       Access: Published
//  Description: Returns the pending ram class of the array.  If this
//               is different from get_ram_class(), this page has been
//               queued to be processed by the thread.  Eventually the
//               page will be set to this ram class.
////////////////////////////////////////////////////////////////////
82
inline VertexDataPage::RamClass VertexDataPage::get_pending_ram_class(void) const;

1804 16 request_resident 0 4 3049 32 VertexDataPage::request_resident 0 1 257 379
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::request_resident
//       Access: Published
//  Description: Ensures that the page will become resident soon.
//               Future calls to get_page_data() will eventually
//               return non-NULL.
////////////////////////////////////////////////////////////////////
51
inline void VertexDataPage::request_resident(void);

1805 5 alloc 0 4 3049 21 VertexDataPage::alloc 0 1 258 450
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::alloc
//       Access: Published
//  Description: Allocates a new block.  Returns NULL if a block of the
//               requested size cannot be allocated.
//
//               To free the allocated block, call block->free(), or
//               simply delete the block pointer.
////////////////////////////////////////////////////////////////////
59
inline VertexDataBlock *VertexDataPage::alloc(size_t size);

1806 15 get_first_block 0 4 3049 31 VertexDataPage::get_first_block 0 1 259 337
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_first_block
//       Access: Published
//  Description: Returns a pointer to the first allocated block, or
//               NULL if there are no allocated blocks.
////////////////////////////////////////////////////////////////////
68
inline VertexDataBlock *VertexDataPage::get_first_block(void) const;

1807 8 get_book 0 4 3049 24 VertexDataPage::get_book 0 1 260 274
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_book
//       Access: Published
//  Description: Returns a pointer to the book that owns this page.
////////////////////////////////////////////////////////////////////
60
inline VertexDataBook *VertexDataPage::get_book(void) const;

1808 14 get_global_lru 0 4 3049 30 VertexDataPage::get_global_lru 0 1 261 377
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_global_lru
//       Access: Published, Static
//  Description: Returns a pointer to the global LRU object that
//               manages the VertexDataPage's with the indicated
//               RamClass.
////////////////////////////////////////////////////////////////////
89
static inline SimpleLru *VertexDataPage::get_global_lru(VertexDataPage::RamClass rclass);

1809 15 get_pending_lru 0 4 3049 31 VertexDataPage::get_pending_lru 0 1 262 392
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_pending_lru
//       Access: Published, Static
//  Description: Returns a pointer to the global LRU object that
//               manages the VertexDataPage's that are pending
//               processing by the thread.
////////////////////////////////////////////////////////////////////
63
static inline SimpleLru *VertexDataPage::get_pending_lru(void);

1810 13 get_save_file 0 4 3049 29 VertexDataPage::get_save_file 0 1 263 378
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_save_file
//       Access: Published, Static
//  Description: Returns the global VertexDataSaveFile that will be
//               used to save vertex data buffers to disk when
//               necessary.
////////////////////////////////////////////////////////////////////
70
static inline VertexDataSaveFile *VertexDataPage::get_save_file(void);

1811 12 save_to_disk 0 4 3049 28 VertexDataPage::save_to_disk 0 1 264 467
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::save_to_disk
//       Access: Published
//  Description: Writes the page to disk, but does not evict it from
//               memory or affect its LRU status.  If it gets evicted
//               later without having been modified, it will not need
//               to write itself to disk again.
////////////////////////////////////////////////////////////////////
47
inline bool VertexDataPage::save_to_disk(void);

1812 15 get_num_threads 0 4 3049 31 VertexDataPage::get_num_threads 0 1 265 589
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_num_threads
//       Access: Published, Static
//  Description: Returns the number of threads that have been spawned
//               to service vertex paging requests, or 0 if no threads
//               have been spawned (which may mean either that all
//               paging requests will be handled by the main thread,
//               or simply that no paging requests have yet been
//               issued).
////////////////////////////////////////////////////////////////////
56
static inline int VertexDataPage::get_num_threads(void);

1813 21 get_num_pending_reads 0 4 3049 37 VertexDataPage::get_num_pending_reads 0 1 266 342
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_num_pending_reads
//       Access: Published, Static
//  Description: Returns the number of read requests that are waiting
//               to be serviced by a thread.
////////////////////////////////////////////////////////////////////
62
static inline int VertexDataPage::get_num_pending_reads(void);

1814 22 get_num_pending_writes 0 4 3049 38 VertexDataPage::get_num_pending_writes 0 1 267 344
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_num_pending_writes
//       Access: Published, Static
//  Description: Returns the number of write requests that are waiting
//               to be serviced by a thread.
////////////////////////////////////////////////////////////////////
63
static inline int VertexDataPage::get_num_pending_writes(void);

1815 12 stop_threads 0 4 3049 28 VertexDataPage::stop_threads 0 1 268 397
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::stop_threads
//       Access: Published, Static
//  Description: Call this to stop the paging threads, if they were
//               started.  This may block until all of the pending
//               tasks have been completed.
////////////////////////////////////////////////////////////////////
47
static void VertexDataPage::stop_threads(void);

1816 13 flush_threads 0 4 3049 29 VertexDataPage::flush_threads 0 1 269 323
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::flush_threads
//       Access: Published, Static
//  Description: Waits for all of the pending thread tasks to finish
//               before returning.
////////////////////////////////////////////////////////////////////
48
static void VertexDataPage::flush_threads(void);

1817 6 output 0 6 3049 22 VertexDataPage::output 0 1 270 231
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
56
virtual void VertexDataPage::output(ostream &out) const;

1818 5 write 0 6 3049 21 VertexDataPage::write 0 1 271 230
////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
73
virtual void VertexDataPage::write(ostream &out, int indent_level) const;

1819 14 get_class_type 0 4 3049 30 VertexDataPage::get_class_type 0 1 272 0
55
static TypeHandle VertexDataPage::get_class_type(void);

1820 14 VertexDataBook 0 4 3051 30 VertexDataBook::VertexDataBook 0 1 277 227
////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
50
VertexDataBook::VertexDataBook(size_t block_size);

1821 15 ~VertexDataBook 0 4 3051 31 VertexDataBook::~VertexDataBook 0 0 226
////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
38
VertexDataBook::~VertexDataBook(void);

1822 5 alloc 0 4 3051 21 VertexDataBook::alloc 0 1 278 305
////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::alloc
//       Access: Published
//  Description: Allocates and returns a new VertexDataBuffer of the
//               requested size.
////////////////////////////////////////////////////////////////////
59
inline VertexDataBlock *VertexDataBook::alloc(size_t size);

1823 13 get_num_pages 0 4 3051 29 VertexDataBook::get_num_pages 0 1 279 278
////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::get_num_pages
//       Access: Published
//  Description: Returns the number of pages created for the book.
////////////////////////////////////////////////////////////////////
53
inline int VertexDataBook::get_num_pages(void) const;

1824 21 count_total_page_size 0 4 3051 37 VertexDataBook::count_total_page_size 0 2 280 281 709
////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::count_total_page_size
//       Access: Published
//  Description: Returns the total size of all bytes owned by all
//               pages owned by this book.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::count_total_page_size
//       Access: Published
//  Description: Returns the total size of all bytes owned by all
//               pages owned by this book that have the indicated ram
//               class.
////////////////////////////////////////////////////////////////////
145
size_t VertexDataBook::count_total_page_size(void) const;
size_t VertexDataBook::count_total_page_size(VertexDataPage::RamClass ram_class) const;

1825 20 count_allocated_size 0 4 3051 36 VertexDataBook::count_allocated_size 0 2 282 283 715
////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::count_allocated_size
//       Access: Published
//  Description: Returns the total size of all bytes allocated within
//               pages owned by this book.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::count_allocated_size
//       Access: Published
//  Description: Returns the total size of all bytes allocated within
//               pages owned by this book that have the indicated ram
//               class.
////////////////////////////////////////////////////////////////////
143
size_t VertexDataBook::count_allocated_size(void) const;
size_t VertexDataBook::count_allocated_size(VertexDataPage::RamClass ram_class) const;

1826 12 save_to_disk 0 4 3051 28 VertexDataBook::save_to_disk 0 1 284 486
////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::save_to_disk
//       Access: Published
//  Description: Writes all pages to disk immediately, just in case
//               they get evicted later.  It makes sense to make this
//               call just before taking down a loading screen, to
//               minimize chugs from saving pages inadvertently later.
////////////////////////////////////////////////////////////////////
40
void VertexDataBook::save_to_disk(void);

1827 30 upcast_to_SimpleAllocatorBlock 0 12 3052 47 VertexDataBlock::upcast_to_SimpleAllocatorBlock 0 1 287 51
upcast from VertexDataBlock to SimpleAllocatorBlock
76
SimpleAllocatorBlock *VertexDataBlock::upcast_to_SimpleAllocatorBlock(void);

1828 27 downcast_to_VertexDataBlock 0 12 3047 49 SimpleAllocatorBlock::downcast_to_VertexDataBlock 0 1 288 53
downcast from SimpleAllocatorBlock to VertexDataBlock
73
VertexDataBlock *SimpleAllocatorBlock::downcast_to_VertexDataBlock(void);

1829 24 upcast_to_ReferenceCount 0 12 3052 41 VertexDataBlock::upcast_to_ReferenceCount 0 1 289 45
upcast from VertexDataBlock to ReferenceCount
64
ReferenceCount *VertexDataBlock::upcast_to_ReferenceCount(void);

1830 27 downcast_to_VertexDataBlock 0 12 3053 43 ReferenceCount::downcast_to_VertexDataBlock 0 1 290 47
downcast from ReferenceCount to VertexDataBlock
67
VertexDataBlock *ReferenceCount::downcast_to_VertexDataBlock(void);

1831 8 get_page 0 4 3052 25 VertexDataBlock::get_page 0 1 285 296
////////////////////////////////////////////////////////////////////
//     Function: VertexDataBlock::get_page
//       Access: Published
//  Description: Returns the page from which this buffer was
//               allocated.
////////////////////////////////////////////////////////////////////
61
inline VertexDataPage *VertexDataBlock::get_page(void) const;

1832 14 get_next_block 0 4 3052 31 VertexDataBlock::get_next_block 0 1 286 354
////////////////////////////////////////////////////////////////////
//     Function: VertexDataBlock::get_next_block
//       Access: Published
//  Description: Returns a pointer to the next allocated block in the
//               chain, or NULL if there are no more allocated blocks.
////////////////////////////////////////////////////////////////////
68
inline VertexDataBlock *VertexDataBlock::get_next_block(void) const;

1833 16 ~VertexDataBlock 0 4 3052 33 VertexDataBlock::~VertexDataBlock 0 0 0
40
VertexDataBlock::~VertexDataBlock(void);

1834 27 upcast_to_CopyOnWriteObject 0 12 3055 48 GeomVertexArrayData::upcast_to_CopyOnWriteObject 0 1 325 52
upcast from GeomVertexArrayData to CopyOnWriteObject
74
CopyOnWriteObject *GeomVertexArrayData::upcast_to_CopyOnWriteObject(void);

1835 31 downcast_to_GeomVertexArrayData 0 12 3056 50 CopyOnWriteObject::downcast_to_GeomVertexArrayData 0 1 326 54
downcast from CopyOnWriteObject to GeomVertexArrayData
78
GeomVertexArrayData *CopyOnWriteObject::downcast_to_GeomVertexArrayData(void);

1836 23 upcast_to_SimpleLruPage 0 12 3055 44 GeomVertexArrayData::upcast_to_SimpleLruPage 0 1 327 48
upcast from GeomVertexArrayData to SimpleLruPage
66
SimpleLruPage *GeomVertexArrayData::upcast_to_SimpleLruPage(void);

1837 31 downcast_to_GeomVertexArrayData 0 12 3045 46 SimpleLruPage::downcast_to_GeomVertexArrayData 0 1 328 50
downcast from SimpleLruPage to GeomVertexArrayData
74
GeomVertexArrayData *SimpleLruPage::downcast_to_GeomVertexArrayData(void);

1838 19 upcast_to_GeomEnums 0 12 3055 40 GeomVertexArrayData::upcast_to_GeomEnums 0 1 329 44
upcast from GeomVertexArrayData to GeomEnums
58
GeomEnums *GeomVertexArrayData::upcast_to_GeomEnums(void);

1839 31 downcast_to_GeomVertexArrayData 0 12 3029 42 GeomEnums::downcast_to_GeomVertexArrayData 0 1 330 46
downcast from GeomEnums to GeomVertexArrayData
70
GeomVertexArrayData *GeomEnums::downcast_to_GeomVertexArrayData(void);

1840 19 GeomVertexArrayData 0 4 3055 40 GeomVertexArrayData::GeomVertexArrayData 0 2 291 292 808
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::Default Constructor
//       Access: Private
//  Description: Constructs an invalid object.  This is only used when
//               reading from the bam file.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
201
explicit GeomVertexArrayData::GeomVertexArrayData(GeomVertexArrayFormat const *array_format, GeomEnums::UsageHint usage_hint);
GeomVertexArrayData::GeomVertexArrayData(GeomVertexArrayData const &copy);

1841 10 operator = 0 4 3055 31 GeomVertexArrayData::operator = 0 1 293 0
70
void GeomVertexArrayData::operator =(GeomVertexArrayData const &copy);

1842 20 ~GeomVertexArrayData 0 6 3055 41 GeomVertexArrayData::~GeomVertexArrayData 0 0 240
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::Destructor
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
56
virtual GeomVertexArrayData::~GeomVertexArrayData(void);

1843 12 operator new 0 4 3055 33 GeomVertexArrayData::operator new 0 1 294 0
132
inline void *GeomVertexArrayData::operator new(size_t size);
inline void *GeomVertexArrayData::operator new(size_t size, void *ptr);

1844 15 operator delete 0 4 3055 36 GeomVertexArrayData::operator delete 0 0 0
126
inline void GeomVertexArrayData::operator delete(void *ptr);
inline void GeomVertexArrayData::operator delete(void *, void *);

1845 12 validate_ptr 0 4 3055 33 GeomVertexArrayData::validate_ptr 0 0 0
70
static inline bool GeomVertexArrayData::validate_ptr(void const *ptr);

1846 10 compare_to 0 4 3055 31 GeomVertexArrayData::compare_to 0 1 295 330
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::compare_to
//       Access: Published
//  Description: Returns 0 if the two arrays are equivalent, even if
//               they are not the same pointer.
////////////////////////////////////////////////////////////////////
76
int GeomVertexArrayData::compare_to(GeomVertexArrayData const &other) const;

1847 16 get_array_format 0 4 3055 37 GeomVertexArrayData::get_array_format 0 1 296 289
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_array_format
//       Access: Published
//  Description: Returns the format object that describes this array.
////////////////////////////////////////////////////////////////////
86
inline GeomVertexArrayFormat const *GeomVertexArrayData::get_array_format(void) const;

1848 14 get_usage_hint 0 4 3055 35 GeomVertexArrayData::get_usage_hint 0 1 297 409
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_usage_hint
//       Access: Published
//  Description: Returns the usage hint that describes to the
//               rendering backend how often the vertex data will be
//               modified and/or rendered.  See geomEnums.h.
////////////////////////////////////////////////////////////////////
76
inline GeomEnums::UsageHint GeomVertexArrayData::get_usage_hint(void) const;

1849 14 set_usage_hint 0 4 3055 35 GeomVertexArrayData::set_usage_hint 0 1 298 514
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::set_usage_hint
//       Access: Published
//  Description: Changes the UsageHint hint for this array.  See
//               get_usage_hint().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
74
void GeomVertexArrayData::set_usage_hint(GeomEnums::UsageHint usage_hint);

1850 10 has_column 0 4 3055 31 GeomVertexArrayData::has_column 0 1 299 404
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::has_column
//       Access: Published
//  Description: Returns true if the array has the named column,
//               false otherwise.  This is really just a shortcut for
//               asking the same thing from the format.
////////////////////////////////////////////////////////////////////
76
inline bool GeomVertexArrayData::has_column(InternalName const *name) const;

1851 12 get_num_rows 0 4 3055 33 GeomVertexArrayData::get_num_rows 0 1 300 454
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_num_rows
//       Access: Published
//  Description: Returns the number of rows stored in the array,
//               based on the number of bytes and the stride.  This
//               should be the same for all arrays within a given
//               GeomVertexData object.
////////////////////////////////////////////////////////////////////
57
inline int GeomVertexArrayData::get_num_rows(void) const;

1852 12 set_num_rows 0 4 3055 33 GeomVertexArrayData::set_num_rows 0 1 301 1075
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::set_num_rows
//       Access: Published
//  Description: Sets the length of the array to n rows.
//
//               Normally, you would not call this directly, since all
//               of the arrays in a particular GeomVertexData must
//               have the same number of rows; instead, call
//               GeomVertexData::set_num_rows().
//
//               The return value is true if the number of rows
//               was changed, false if the object already contained n
//               rows (or if there was some error).
//
//               The new vertex data is initialized to 0, including
//               the "color" column (but see
//               GeomVertexData::set_num_rows()).
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
53
inline bool GeomVertexArrayData::set_num_rows(int n);

1853 20 unclean_set_num_rows 0 4 3055 41 GeomVertexArrayData::unclean_set_num_rows 0 1 302 757
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::unclean_set_num_rows
//       Access: Published
//  Description: This method behaves like set_num_rows(), except the
//               new data is not initialized.  Furthermore, after this
//               call, *any* of the data in the GeomVertexArrayData
//               may be uninitialized, including the earlier rows.
//
//               Normally, you would not call this directly, since all
//               of the arrays in a particular GeomVertexData must
//               have the same number of rows; instead, call
//               GeomVertexData::unclean_set_num_rows().
////////////////////////////////////////////////////////////////////
61
inline bool GeomVertexArrayData::unclean_set_num_rows(int n);

1854 16 reserve_num_rows 0 4 3055 37 GeomVertexArrayData::reserve_num_rows 0 1 303 611
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::reserve_num_rows
//       Access: Published
//  Description: This ensures that enough memory space for n rows is
//               allocated, so that you may increase the number of
//               rows to n without causing a new memory allocation.
//               This is a performance optimization only; it is
//               especially useful when you know ahead of time that
//               you will be adding n rows to the data.
////////////////////////////////////////////////////////////////////
57
inline bool GeomVertexArrayData::reserve_num_rows(int n);

1855 10 clear_rows 0 4 3055 31 GeomVertexArrayData::clear_rows 0 1 304 329
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::clear_rows
//       Access: Published
//  Description: Removes all of the rows in the array.
//               Functionally equivalent to set_num_rows(0).
////////////////////////////////////////////////////////////////////
50
inline void GeomVertexArrayData::clear_rows(void);

1856 19 get_data_size_bytes 0 4 3055 40 GeomVertexArrayData::get_data_size_bytes 0 1 305 288
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_data_size_bytes
//       Access: Published
//  Description: Returns the number of bytes stored in the array.
////////////////////////////////////////////////////////////////////
64
inline int GeomVertexArrayData::get_data_size_bytes(void) const;

1857 12 get_modified 0 4 3055 33 GeomVertexArrayData::get_modified 0 1 306 377
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the array vertex data is
//               modified.
////////////////////////////////////////////////////////////////////
63
inline UpdateSeq GeomVertexArrayData::get_modified(void) const;

1858 6 output 0 6 3055 27 GeomVertexArrayData::output 0 1 307 227
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
61
virtual void GeomVertexArrayData::output(ostream &out) const;

1859 5 write 0 6 3055 26 GeomVertexArrayData::write 0 1 308 226
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
82
virtual void GeomVertexArrayData::write(ostream &out, int indent_level = 0) const;

1860 16 request_resident 0 4 3055 37 GeomVertexArrayData::request_resident 0 1 309 566
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::request_resident
//       Access: Published
//  Description: Returns true if the vertex data is currently resident
//               in memory.  If this returns true, the next call to
//               get_handle()->get_read_pointer() will probably not
//               block.  If this returns false, the vertex data will
//               be brought back into memory shortly; try again later.
////////////////////////////////////////////////////////////////////
62
inline bool GeomVertexArrayData::request_resident(void) const;

1861 10 get_handle 0 4 3055 31 GeomVertexArrayData::get_handle 0 1 310 529
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_handle
//       Access: Published
//  Description: Returns an object that can be used to read the actual
//               data bytes stored in the array.  Calling this method
//               locks the data, and will block any other threads
//               attempting to read or write the data, until the
//               returned object destructs.
////////////////////////////////////////////////////////////////////
138
inline ConstPointerTo< GeomVertexArrayDataHandle > GeomVertexArrayData::get_handle(Thread *current_thread = (get_current_thread())) const;

1862 13 modify_handle 0 4 3055 34 GeomVertexArrayData::modify_handle 0 1 311 541
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::modify_handle
//       Access: Published
//  Description: Returns an object that can be used to read or write
//               the actual data bytes stored in the array.  Calling
//               this method locks the data, and will block any other
//               threads attempting to read or write the data, until
//               the returned object destructs.
////////////////////////////////////////////////////////////////////
130
inline PointerTo< GeomVertexArrayDataHandle > GeomVertexArrayData::modify_handle(Thread *current_thread = (get_current_thread()));

1863 7 prepare 0 4 3055 28 GeomVertexArrayData::prepare 0 1 312 648
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::prepare
//       Access: Public
//  Description: Indicates that the data should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.  This will ensure the
//               data is already loaded into the GSG if it is expected
//               to be rendered soon.
//
//               Use this function instead of prepare_now() to preload
//               datas from a user interface standpoint.
////////////////////////////////////////////////////////////////////
77
void GeomVertexArrayData::prepare(PreparedGraphicsObjects *prepared_objects);

1864 11 is_prepared 0 4 3055 32 GeomVertexArrayData::is_prepared 0 1 313 383
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::is_prepared
//       Access: Published
//  Description: Returns true if the data has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
////////////////////////////////////////////////////////////////////
87
bool GeomVertexArrayData::is_prepared(PreparedGraphicsObjects *prepared_objects) const;

1865 11 prepare_now 0 4 3055 32 GeomVertexArrayData::prepare_now 0 1 314 894
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::prepare_now
//       Access: Public
//  Description: Creates a context for the data on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) VertexBufferContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               datas.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a data does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
////////////////////////////////////////////////////////////////////
129
VertexBufferContext *GeomVertexArrayData::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg);

1866 7 release 0 4 3055 28 GeomVertexArrayData::release 0 1 315 400
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::release
//       Access: Public
//  Description: Frees the data context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
////////////////////////////////////////////////////////////////////
77
bool GeomVertexArrayData::release(PreparedGraphicsObjects *prepared_objects);

1867 11 release_all 0 4 3055 32 GeomVertexArrayData::release_all 0 1 316 398
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::release_all
//       Access: Public
//  Description: Frees the context allocated on all objects for which
//               the data has been declared.  Returns the number of
//               contexts which have been freed.
////////////////////////////////////////////////////////////////////
43
int GeomVertexArrayData::release_all(void);

1868 19 get_independent_lru 0 4 3055 40 GeomVertexArrayData::get_independent_lru 0 1 317 399
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_independent_lru
//       Access: Published, Static
//  Description: Returns a pointer to the global LRU object that
//               manages the GeomVertexArrayData's that have not (yet)
//               been paged out.
////////////////////////////////////////////////////////////////////
72
static inline SimpleLru *GeomVertexArrayData::get_independent_lru(void);

1869 13 get_small_lru 0 4 3055 34 GeomVertexArrayData::get_small_lru 0 1 318 400
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_small_lru
//       Access: Published, Static
//  Description: Returns a pointer to the global LRU object that
//               manages the GeomVertexArrayData's that are deemed too
//               small to be paged out.
////////////////////////////////////////////////////////////////////
66
static inline SimpleLru *GeomVertexArrayData::get_small_lru(void);

1870 9 lru_epoch 0 4 3055 30 GeomVertexArrayData::lru_epoch 0 1 319 382
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::lru_epoch
//       Access: Published, Static
//  Description: Marks that an epoch has passed in each LRU.  Asks the
//               LRU's to consider whether they should perform
//               evictions.
////////////////////////////////////////////////////////////////////
49
static void GeomVertexArrayData::lru_epoch(void);

1871 8 get_book 0 4 3055 29 GeomVertexArrayData::get_book 0 1 320 338
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_book
//       Access: Published, Static
//  Description: Returns the global VertexDataBook that will be
//               used to allocate vertex data buffers.
////////////////////////////////////////////////////////////////////
66
static inline VertexDataBook &GeomVertexArrayData::get_book(void);

1872 13 __getbuffer__ 0 4 3055 34 GeomVertexArrayData::__getbuffer__ 0 2 321 322 0
173
int GeomVertexArrayData::__getbuffer__(PyObject *self, Py_buffer *view, int flags);
int GeomVertexArrayData::__getbuffer__(PyObject *self, Py_buffer *view, int flags) const;

1873 17 __releasebuffer__ 0 4 3055 38 GeomVertexArrayData::__releasebuffer__ 0 1 323 0
83
void GeomVertexArrayData::__releasebuffer__(PyObject *self, Py_buffer *view) const;

1874 14 get_class_type 0 4 3055 35 GeomVertexArrayData::get_class_type 0 1 324 0
60
static TypeHandle GeomVertexArrayData::get_class_type(void);

1875 24 upcast_to_ReferenceCount 0 12 3057 51 GeomVertexArrayDataHandle::upcast_to_ReferenceCount 0 1 355 55
upcast from GeomVertexArrayDataHandle to ReferenceCount
74
ReferenceCount *GeomVertexArrayDataHandle::upcast_to_ReferenceCount(void);

1876 37 downcast_to_GeomVertexArrayDataHandle 0 12 3053 53 ReferenceCount::downcast_to_GeomVertexArrayDataHandle 0 1 356 57
downcast from ReferenceCount to GeomVertexArrayDataHandle
87
GeomVertexArrayDataHandle *ReferenceCount::downcast_to_GeomVertexArrayDataHandle(void);

1877 19 upcast_to_GeomEnums 0 12 3057 46 GeomVertexArrayDataHandle::upcast_to_GeomEnums 0 1 357 50
upcast from GeomVertexArrayDataHandle to GeomEnums
64
GeomEnums *GeomVertexArrayDataHandle::upcast_to_GeomEnums(void);

1878 37 downcast_to_GeomVertexArrayDataHandle 0 12 3029 48 GeomEnums::downcast_to_GeomVertexArrayDataHandle 0 1 358 52
downcast from GeomEnums to GeomVertexArrayDataHandle
82
GeomVertexArrayDataHandle *GeomEnums::downcast_to_GeomVertexArrayDataHandle(void);

1879 26 ~GeomVertexArrayDataHandle 0 6 3057 53 GeomVertexArrayDataHandle::~GeomVertexArrayDataHandle 0 0 233
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::Destructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
75
virtual inline GeomVertexArrayDataHandle::~GeomVertexArrayDataHandle(void);

1880 10 get_object 0 4 3057 37 GeomVertexArrayDataHandle::get_object 0 2 331 332 474
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_object
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_object
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
157
inline GeomVertexArrayData const *GeomVertexArrayDataHandle::get_object(void) const;
inline GeomVertexArrayData *GeomVertexArrayDataHandle::get_object(void);

1881 16 get_array_format 0 4 3057 43 GeomVertexArrayDataHandle::get_array_format 0 1 333 242
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_array_format
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
92
inline GeomVertexArrayFormat const *GeomVertexArrayDataHandle::get_array_format(void) const;

1882 14 get_usage_hint 0 4 3057 41 GeomVertexArrayDataHandle::get_usage_hint 0 1 334 240
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_usage_hint
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
82
inline GeomEnums::UsageHint GeomVertexArrayDataHandle::get_usage_hint(void) const;

1883 12 get_num_rows 0 4 3057 39 GeomVertexArrayDataHandle::get_num_rows 0 1 335 238
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_num_rows
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
63
inline int GeomVertexArrayDataHandle::get_num_rows(void) const;

1884 12 set_num_rows 0 4 3057 39 GeomVertexArrayDataHandle::set_num_rows 0 1 336 236
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::set_num_rows
//       Access: Public
//  Description: 
////////////////////////////////////////////////////////////////////
52
bool GeomVertexArrayDataHandle::set_num_rows(int n);

1885 20 unclean_set_num_rows 0 4 3057 47 GeomVertexArrayDataHandle::unclean_set_num_rows 0 1 337 244
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::unclean_set_num_rows
//       Access: Public
//  Description: 
////////////////////////////////////////////////////////////////////
60
bool GeomVertexArrayDataHandle::unclean_set_num_rows(int n);

1886 16 reserve_num_rows 0 4 3057 43 GeomVertexArrayDataHandle::reserve_num_rows 0 1 338 240
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::reserve_num_rows
//       Access: Public
//  Description: 
////////////////////////////////////////////////////////////////////
56
bool GeomVertexArrayDataHandle::reserve_num_rows(int n);

1887 10 clear_rows 0 4 3057 37 GeomVertexArrayDataHandle::clear_rows 0 1 339 236
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::clear_rows
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
56
inline void GeomVertexArrayDataHandle::clear_rows(void);

1888 19 get_data_size_bytes 0 4 3057 46 GeomVertexArrayDataHandle::get_data_size_bytes 0 1 340 245
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_data_size_bytes
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
70
inline int GeomVertexArrayDataHandle::get_data_size_bytes(void) const;

1889 12 get_modified 0 4 3057 39 GeomVertexArrayDataHandle::get_modified 0 1 341 238
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_modified
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
69
inline UpdateSeq GeomVertexArrayDataHandle::get_modified(void) const;

1890 16 request_resident 0 4 3057 43 GeomVertexArrayDataHandle::request_resident 0 1 342 566
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::request_resident
//       Access: Published
//  Description: Returns true if the vertex data is currently resident
//               in memory.  If this returns true, the next call to
//               get_handle()->get_read_pointer() will probably not
//               block.  If this returns false, the vertex data will
//               be brought back into memory shortly; try again later.
////////////////////////////////////////////////////////////////////
68
inline bool GeomVertexArrayDataHandle::request_resident(void) const;

1891 11 prepare_now 0 4 3057 38 GeomVertexArrayDataHandle::prepare_now 0 1 343 900
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::prepare_now
//       Access: Public
//  Description: Creates a context for the data on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) VertexBufferContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               datas.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a data does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
////////////////////////////////////////////////////////////////////
148
inline VertexBufferContext *GeomVertexArrayDataHandle::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg) const;

1892 14 copy_data_from 0 4 3057 41 GeomVertexArrayDataHandle::copy_data_from 0 2 344 345 574
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::copy_data_from
//       Access: Public
//  Description: Copies the entire data array from the other object.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::copy_data_from
//       Access: Public
//  Description: Copies the entire data array from the buffer.
////////////////////////////////////////////////////////////////////
243
void GeomVertexArrayDataHandle::copy_data_from(GeomVertexArrayDataHandle const *other);
void GeomVertexArrayDataHandle::copy_data_from(unsigned char const *source, size_t size);
void GeomVertexArrayDataHandle::copy_data_from(PyObject *buffer);

1893 17 copy_subdata_from 0 4 3057 44 GeomVertexArrayDataHandle::copy_subdata_from 0 3 346 347 348 947
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::copy_subdata_from
//       Access: Public
//  Description: Copies a portion of the data array from the other
//               object into a portion of the data array of this
//               object.  If to_size != from_size, the size of this
//               data array is adjusted accordingly.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::copy_subdata_from
//       Access: Public
//  Description: Copies a portion of the data array from the buffer
//               into a portion of the data array of this object.
//               If to_size != from_size, the size of this data
//               array is adjusted accordingly.
////////////////////////////////////////////////////////////////////
551
void GeomVertexArrayDataHandle::copy_subdata_from(size_t to_start, size_t to_size, GeomVertexArrayDataHandle const *other, size_t from_start, size_t from_size);
void GeomVertexArrayDataHandle::copy_subdata_from(size_t to_start, size_t to_size, unsigned char const *source, size_t from_start, size_t from_size);
void GeomVertexArrayDataHandle::copy_subdata_from(size_t to_start, size_t to_size, PyObject *buffer);
void GeomVertexArrayDataHandle::copy_subdata_from(size_t to_start, size_t to_size, PyObject *buffer, size_t from_start, size_t from_size);

1894 8 get_data 0 4 3057 35 GeomVertexArrayDataHandle::get_data 0 1 349 445
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_data
//       Access: Published
//  Description: Returns the entire raw data of the
//               GeomVertexArrayData object, formatted as a string.
//               This is primarily for the benefit of high-level
//               languages such as Python.
////////////////////////////////////////////////////////////////////
62
inline string GeomVertexArrayDataHandle::get_data(void) const;

1895 8 set_data 0 4 3057 35 GeomVertexArrayDataHandle::set_data 0 1 350 415
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::set_data
//       Access: Public
//  Description: Replaces the entire raw data array with the contents
//               of the indicated string.  This is primarily for the
//               benefit of high-level languages like Python.
////////////////////////////////////////////////////////////////////
61
void GeomVertexArrayDataHandle::set_data(string const &data);

1896 11 get_subdata 0 4 3057 38 GeomVertexArrayDataHandle::get_subdata 0 1 351 453
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_subdata
//       Access: Published
//  Description: Returns a subset of the raw data of the
//               GeomVertexArrayData object, formatted as a string.
//               This is primarily for the benefit of high-level
//               languages such as Python.
////////////////////////////////////////////////////////////////////
86
inline string GeomVertexArrayDataHandle::get_subdata(size_t start, size_t size) const;

1897 11 set_subdata 0 4 3057 38 GeomVertexArrayDataHandle::set_subdata 0 1 352 518
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::set_subdata
//       Access: Public
//  Description: Replaces a portion of the data array from the
//               indicated string.  If size != data.size(), the size
//               of this data array is adjusted accordingly.
//
//               This is primarily for the benefit of high-level
//               languages like Python.
////////////////////////////////////////////////////////////////////
91
void GeomVertexArrayDataHandle::set_subdata(size_t start, size_t size, string const &data);

1898 9 mark_used 0 4 3057 36 GeomVertexArrayDataHandle::mark_used 0 1 353 271
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::mark_used
//       Access: Published
//  Description: Marks the array data recently-used.
////////////////////////////////////////////////////////////////////
61
inline void GeomVertexArrayDataHandle::mark_used(void) const;

1899 14 get_class_type 0 4 3057 41 GeomVertexArrayDataHandle::get_class_type 0 1 354 0
66
static TypeHandle GeomVertexArrayDataHandle::get_class_type(void);

1900 12 set_max_size 0 4 3058 30 GeomCacheManager::set_max_size 0 1 359 818
////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::set_max_size
//       Access: Published
//  Description: Specifies the maximum number of entries in the cache
//               for storing pre-processed data for rendering
//               vertices.  This limit is flexible, and may be
//               temporarily exceeded if many different Geoms are
//               pre-processed during the space of a single frame.
//
//               This is not a limit on the actual vertex data, which
//               is what it is; it is also not a limit on the amount
//               of memory used by the video driver or the system
//               graphics interface, which Panda has no control over.
////////////////////////////////////////////////////////////////////
63
inline void GeomCacheManager::set_max_size(int max_size) const;

1901 12 get_max_size 0 4 3058 30 GeomCacheManager::get_max_size 0 1 360 390
////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::get_max_size
//       Access: Published
//  Description: Returns the maximum number of entries in the cache
//               for storing pre-processed data for rendering
//               vertices.  See set_max_size().
////////////////////////////////////////////////////////////////////
54
inline int GeomCacheManager::get_max_size(void) const;

1902 14 get_total_size 0 4 3058 32 GeomCacheManager::get_total_size 0 1 361 285
////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::get_total_size
//       Access: Published
//  Description: Returns the number of entries currently in the cache.
////////////////////////////////////////////////////////////////////
56
inline int GeomCacheManager::get_total_size(void) const;

1903 5 flush 0 4 3058 23 GeomCacheManager::flush 0 1 362 269
////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::flush
//       Access: Published
//  Description: Immediately empties all elements in the cache.
////////////////////////////////////////////////////////////////////
35
void GeomCacheManager::flush(void);

1904 14 get_global_ptr 0 4 3058 32 GeomCacheManager::get_global_ptr 0 1 363 281
////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::get_global_ptr
//       Access: Published, Static
//  Description: Returns the global cache manager pointer.
////////////////////////////////////////////////////////////////////
64
static GeomCacheManager *GeomCacheManager::get_global_ptr(void);

1905 10 get_matrix 0 6 3059 27 VertexTransform::get_matrix 0 1 364 0
69
virtual void VertexTransform::get_matrix(LMatrix4 &matrix) const = 0;

1906 11 mult_matrix 0 6 3059 28 VertexTransform::mult_matrix 0 1 365 579
////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::mult_matrix
//       Access: Published, Virtual
//  Description: Premultiplies this transform's matrix with the
//               indicated previous matrix, so that the result is the
//               net composition of the given transform with this
//               transform.  The result is stored in the parameter
//               "result", which should not be the same matrix as
//               previous.
////////////////////////////////////////////////////////////////////
92
virtual void VertexTransform::mult_matrix(LMatrix4 &result, LMatrix4 const &previous) const;

1907 17 accumulate_matrix 0 6 3059 34 VertexTransform::accumulate_matrix 0 1 366 477
////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::accumulate_matrix
//       Access: Published, Virtual
//  Description: Adds the value of this transform's matrix, modified
//               by the indicated weight, into the indicated
//               accumulation matrix.  This is used to compute the
//               result of several blended transforms.
////////////////////////////////////////////////////////////////////
91
virtual void VertexTransform::accumulate_matrix(LMatrix4 &accum, PN_stdfloat weight) const;

1908 12 get_modified 0 4 3059 29 VertexTransform::get_modified 0 1 367 380
////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::get_modified
//       Access: Published
//  Description: Returns a sequence number that's guaranteed to change
//               at least every time the value reported by
//               get_matrix() changes.
////////////////////////////////////////////////////////////////////
77
inline UpdateSeq VertexTransform::get_modified(Thread *current_thread) const;

1909 6 output 0 6 3059 23 VertexTransform::output 0 1 368 232
////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
57
virtual void VertexTransform::output(ostream &out) const;

1910 5 write 0 6 3059 22 VertexTransform::write 0 1 369 231
////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
74
virtual void VertexTransform::write(ostream &out, int indent_level) const;

1911 17 get_next_modified 0 4 3059 34 VertexTransform::get_next_modified 0 1 370 765
////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::get_next_modified
//       Access: Public, Static
//  Description: Returns a monotonically increasing sequence.  Each
//               time this is called, a new sequence number is
//               returned, higher than the previous value.
//
//               This is used to ensure that all
//               VertexTransform::get_modified() calls return an
//               increasing number in the same space, so that
//               TransformBlend::get_modified() is easy to determine.
//               It is similar to Geom::get_modified(), but it is in a
//               different space.
////////////////////////////////////////////////////////////////////
76
static UpdateSeq VertexTransform::get_next_modified(Thread *current_thread);

1912 19 get_global_modified 0 4 3059 36 VertexTransform::get_global_modified 0 1 371 474
////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::get_global_modified
//       Access: Published, Static
//  Description: Returns the currently highest
//               VertexTransform::get_modified() value in the world.
//               This can be used as a quick way to determine if any
//               VertexTransforms have changed value recently.
////////////////////////////////////////////////////////////////////
85
static inline UpdateSeq VertexTransform::get_global_modified(Thread *current_thread);

1913 14 get_class_type 0 4 3059 31 VertexTransform::get_class_type 0 1 372 0
56
static TypeHandle VertexTransform::get_class_type(void);

1914 14 TransformTable 0 4 3060 30 TransformTable::TransformTable 0 2 373 374 461
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformTable::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
97
TransformTable::TransformTable(void);
TransformTable::TransformTable(TransformTable const &copy);

1915 10 operator = 0 4 3060 26 TransformTable::operator = 0 1 375 0
60
void TransformTable::operator =(TransformTable const &copy);

1916 13 is_registered 0 4 3060 29 TransformTable::is_registered 0 1 376 507
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::is_registered
//       Access: Published
//  Description: Returns true if this table has been registered.
//               Once it has been registered, the set of transforms in
//               a TransformTable may not be further modified; but
//               it must be registered before it can be assigned to a
//               Geom.
////////////////////////////////////////////////////////////////////
54
inline bool TransformTable::is_registered(void) const;

1917 14 register_table 0 4 3060 30 TransformTable::register_table 0 1 377 927
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::register_table
//       Access: Published, Static
//  Description: Registers a TransformTable for use.  This is
//               similar to GeomVertexFormat::register_format().  Once
//               registered, a TransformTable may no longer be
//               modified (although the individual VertexTransform
//               objects may modify their reported transforms).
//
//               This must be called before a table may be used in a
//               Geom.  After this call, you should discard the
//               original pointer you passed in (which may or may not
//               now be invalid) and let its reference count decrement
//               normally; you should use only the returned value from
//               this point on.
////////////////////////////////////////////////////////////////////
107
static inline ConstPointerTo< TransformTable > TransformTable::register_table(TransformTable const *table);

1918 18 get_num_transforms 0 4 3060 34 TransformTable::get_num_transforms 0 1 378 280
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::get_num_transforms
//       Access: Published
//  Description: Returns the number of transforms in the table.
////////////////////////////////////////////////////////////////////
58
inline int TransformTable::get_num_transforms(void) const;

1919 13 get_transform 0 4 3060 29 TransformTable::get_transform 0 1 379 268
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::get_transform
//       Access: Published
//  Description: Returns the nth transform in the table.
////////////////////////////////////////////////////////////////////
73
inline VertexTransform const *TransformTable::get_transform(int n) const;

1920 12 get_modified 0 4 3060 28 TransformTable::get_modified 0 1 380 569
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::get_modified
//       Access: Published
//  Description: Returns a sequence number that's guaranteed to change
//               at least when any VertexTransforms in the table
//               change.  (However, this is only true for a registered
//               table.  An unregistered table may or may not
//               reflect an update here when a VertexTransform
//               changes.)
////////////////////////////////////////////////////////////////////
76
inline UpdateSeq TransformTable::get_modified(Thread *current_thread) const;

1921 13 set_transform 0 4 3060 29 TransformTable::set_transform 0 1 381 310
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::set_transform
//       Access: Published
//  Description: Replaces the nth transform.  Only valid for
//               unregistered tables.
////////////////////////////////////////////////////////////////////
76
void TransformTable::set_transform(int n, VertexTransform const *transform);

1922 16 remove_transform 0 4 3060 32 TransformTable::remove_transform 0 1 382 312
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::remove_transform
//       Access: Published
//  Description: Removes the nth transform.  Only valid for
//               unregistered tables.
////////////////////////////////////////////////////////////////////
45
void TransformTable::remove_transform(int n);

1923 13 add_transform 0 4 3060 29 TransformTable::add_transform 0 1 383 562
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::add_transform
//       Access: Published
//  Description: Adds a new transform to the table and returns the
//               index number of the new transform.  Only valid for
//               unregistered tables.
//
//               This does not automatically uniquify the pointer; if
//               the transform is already present in the table, it
//               will be added twice.
////////////////////////////////////////////////////////////////////
68
int TransformTable::add_transform(VertexTransform const *transform);

1924 5 write 0 4 3060 21 TransformTable::write 0 1 384 221
////////////////////////////////////////////////////////////////////
//     Function: TransformTable::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
47
void TransformTable::write(ostream &out) const;

1925 14 get_class_type 0 4 3060 30 TransformTable::get_class_type 0 1 385 0
55
static TypeHandle TransformTable::get_class_type(void);

1926 14 TransformBlend 0 4 3061 30 TransformBlend::TransformBlend 0 6 386 387 388 389 390 391 1377
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
827
inline TransformBlend::TransformBlend(void);
inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0);
inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1);
inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2);
inline TransformBlend::TransformBlend(VertexTransform const *transform0, PN_stdfloat weight0, VertexTransform const *transform1, PN_stdfloat weight1, VertexTransform const *transform2, PN_stdfloat weight2, VertexTransform const *transform3, PN_stdfloat weight3);
inline TransformBlend::TransformBlend(TransformBlend const &copy);

1927 10 operator = 0 4 3061 26 TransformBlend::operator = 0 1 392 0
67
inline void TransformBlend::operator =(TransformBlend const &copy);

1928 15 ~TransformBlend 0 4 3061 31 TransformBlend::~TransformBlend 0 0 226
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
45
inline TransformBlend::~TransformBlend(void);

1929 10 compare_to 0 4 3061 26 TransformBlend::compare_to 0 1 393 300
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::compare_to
//       Access: Published
//  Description: Defines an arbitrary ordering for TransformBlend
//               objects.
////////////////////////////////////////////////////////////////////
66
int TransformBlend::compare_to(TransformBlend const &other) const;

1930 10 operator < 0 4 3061 26 TransformBlend::operator < 0 1 394 0
74
inline bool TransformBlend::operator <(TransformBlend const &other) const;

1931 11 operator == 0 4 3061 27 TransformBlend::operator == 0 1 395 0
75
inline bool TransformBlend::operator ==(TransformBlend const &other) const;

1932 11 operator != 0 4 3061 27 TransformBlend::operator != 0 1 396 0
75
inline bool TransformBlend::operator !=(TransformBlend const &other) const;

1933 13 add_transform 0 4 3061 29 TransformBlend::add_transform 0 1 397 344
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::add_transform
//       Access: Published
//  Description: Adds a new transform to the blend.  If the transform
//               already existed, increases its weight factor.
////////////////////////////////////////////////////////////////////
89
void TransformBlend::add_transform(VertexTransform const *transform, PN_stdfloat weight);

1934 16 remove_transform 0 4 3061 32 TransformBlend::remove_transform 0 1 398 279
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::remove_transform
//       Access: Published
//  Description: Removes the indicated transform from the blend.
////////////////////////////////////////////////////////////////////
72
void TransformBlend::remove_transform(VertexTransform const *transform);

1935 16 limit_transforms 0 4 3061 32 TransformBlend::limit_transforms 0 1 399 458
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::limit_transforms
//       Access: Published
//  Description: If the total number of transforms in the blend
//               exceeds max_transforms, removes the n least-important
//               transforms as needed to reduce the number of
//               transforms to max_transforms.
////////////////////////////////////////////////////////////////////
58
void TransformBlend::limit_transforms(int max_transforms);

1936 17 normalize_weights 0 4 3061 33 TransformBlend::normalize_weights 0 1 400 456
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::normalize_weights
//       Access: Published
//  Description: Rescales all of the weights on the various transforms
//               so that they sum to 1.0.  It is generally a good idea
//               to call this after adding or removing transforms from
//               the blend.
////////////////////////////////////////////////////////////////////
45
void TransformBlend::normalize_weights(void);

1937 13 has_transform 0 4 3061 29 TransformBlend::has_transform 0 1 401 317
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::has_transform
//       Access: Published
//  Description: Returns true if the blend has the indicated
//               transform, false otherwise.
////////////////////////////////////////////////////////////////////
75
bool TransformBlend::has_transform(VertexTransform const *transform) const;

1938 10 get_weight 0 4 3061 26 TransformBlend::get_weight 0 2 402 403 689
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_weight
//       Access: Published
//  Description: Returns the weight associated with the nth transform
//               stored in the blend object.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_weight
//       Access: Published
//  Description: Returns the weight associated with the indicated
//               transform, or 0 if there is no entry for the
//               transform.
////////////////////////////////////////////////////////////////////
139
PN_stdfloat TransformBlend::get_weight(VertexTransform const *transform) const;
inline PN_stdfloat TransformBlend::get_weight(int n) const;

1939 18 get_num_transforms 0 4 3061 34 TransformBlend::get_num_transforms 0 1 404 311
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_num_transforms
//       Access: Published
//  Description: Returns the number of transforms stored in the blend
//               object.
////////////////////////////////////////////////////////////////////
58
inline int TransformBlend::get_num_transforms(void) const;

1940 13 get_transform 0 4 3061 29 TransformBlend::get_transform 0 1 405 299
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_transform
//       Access: Published
//  Description: Returns the nth transform stored in the blend
//               object.
////////////////////////////////////////////////////////////////////
73
inline VertexTransform const *TransformBlend::get_transform(int n) const;

1941 13 set_transform 0 4 3061 29 TransformBlend::set_transform 0 1 406 300
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::set_transform
//       Access: Published
//  Description: Replaces the nth transform stored in the blend
//               object.
////////////////////////////////////////////////////////////////////
83
inline void TransformBlend::set_transform(int n, VertexTransform const *transform);

1942 10 set_weight 0 4 3061 26 TransformBlend::set_weight 0 1 407 324
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::set_weight
//       Access: Published
//  Description: Replaces the weight associated with the nth transform
//               stored in the blend object.
////////////////////////////////////////////////////////////////////
66
inline void TransformBlend::set_weight(int n, PN_stdfloat weight);

1943 12 update_blend 0 4 3061 28 TransformBlend::update_blend 0 1 408 405
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::update_blend
//       Access: Published
//  Description: Recomputes the internal representation of the blend
//               value, if necessary.  You should call this before
//               calling get_blend() or transform_point().
////////////////////////////////////////////////////////////////////
71
inline void TransformBlend::update_blend(Thread *current_thread) const;

1944 9 get_blend 0 4 3061 25 TransformBlend::get_blend 0 1 409 522
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_blend
//       Access: Published
//  Description: Returns the current value of the blend, based on the
//               current value of all of the nested transform objects
//               and their associated weights.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
////////////////////////////////////////////////////////////////////
86
inline void TransformBlend::get_blend(LMatrix4 &result, Thread *current_thread) const;

1945 15 transform_point 0 4 3061 31 TransformBlend::transform_point 0 4 410 411 412 413 1664
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::transform_point
//       Access: Published
//  Description: Transforms the indicated point by the blend matrix.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::transform_point
//       Access: Published
//  Description: Transforms the indicated point by the blend matrix.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::transform_point (double)
//       Access: Published
//  Description: Transforms the indicated point by the blend matrix.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::transform_point (double)
//       Access: Published
//  Description: Transforms the indicated point by the blend matrix.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
////////////////////////////////////////////////////////////////////
367
inline void TransformBlend::transform_point(LPoint4f &point, Thread *current_thread) const;
inline void TransformBlend::transform_point(LPoint3f &point, Thread *current_thread) const;
inline void TransformBlend::transform_point(LPoint4d &point, Thread *current_thread) const;
inline void TransformBlend::transform_point(LPoint3d &point, Thread *current_thread) const;

1946 16 transform_vector 0 4 3061 32 TransformBlend::transform_vector 0 2 414 415 835
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::transform_vector
//       Access: Published
//  Description: Transforms the indicated vector by the blend matrix.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::transform_vector (double)
//       Access: Published
//  Description: Transforms the indicated vector by the blend matrix.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
////////////////////////////////////////////////////////////////////
187
inline void TransformBlend::transform_vector(LVector3f &point, Thread *current_thread) const;
inline void TransformBlend::transform_vector(LVector3d &point, Thread *current_thread) const;

1947 12 get_modified 0 4 3061 28 TransformBlend::get_modified 0 1 416 351
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_modified
//       Access: Published
//  Description: Returns a counter which is guaranteed to increment at
//               least as often as the result of get_blend() changes.
////////////////////////////////////////////////////////////////////
76
inline UpdateSeq TransformBlend::get_modified(Thread *current_thread) const;

1948 6 output 0 4 3061 22 TransformBlend::output 0 1 417 222
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
48
void TransformBlend::output(ostream &out) const;

1949 5 write 0 4 3061 21 TransformBlend::write 0 1 418 221
////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
65
void TransformBlend::write(ostream &out, int indent_level) const;

1950 14 get_class_type 0 4 3061 30 TransformBlend::get_class_type 0 1 419 0
55
static TypeHandle TransformBlend::get_class_type(void);

1951 19 TransformBlendTable 0 4 3062 40 TransformBlendTable::TransformBlendTable 0 2 420 421 471
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
122
TransformBlendTable::TransformBlendTable(void);
TransformBlendTable::TransformBlendTable(TransformBlendTable const &copy);

1952 10 operator = 0 4 3062 31 TransformBlendTable::operator = 0 1 422 0
70
void TransformBlendTable::operator =(TransformBlendTable const &copy);

1953 14 get_num_blends 0 4 3062 35 TransformBlendTable::get_num_blends 0 1 423 322
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_num_blends
//       Access: Published
//  Description: Returns the total number of different blend
//               combinations in the table.
////////////////////////////////////////////////////////////////////
59
inline int TransformBlendTable::get_num_blends(void) const;

1954 9 get_blend 0 4 3062 30 TransformBlendTable::get_blend 0 1 424 265
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_blend
//       Access: Published
//  Description: Returns the nth blend in the table.
////////////////////////////////////////////////////////////////////
73
inline TransformBlend const &TransformBlendTable::get_blend(int n) const;

1955 12 get_modified 0 4 3062 33 TransformBlendTable::get_modified 0 1 425 382
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_modified
//       Access: Published
//  Description: Returns a counter which is guaranteed to increment at
//               least when any TransformBlends within the table
//               have changed.
////////////////////////////////////////////////////////////////////
81
inline UpdateSeq TransformBlendTable::get_modified(Thread *current_thread) const;

1956 9 set_blend 0 4 3062 30 TransformBlendTable::set_blend 0 1 426 311
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::set_blend
//       Access: Published
//  Description: Replaces the blend at the nth position with the
//               indicated value.
////////////////////////////////////////////////////////////////////
72
void TransformBlendTable::set_blend(int n, TransformBlend const &blend);

1957 12 remove_blend 0 4 3062 33 TransformBlendTable::remove_blend 0 1 427 271
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::remove_blend
//       Access: Published
//  Description: Removes the blend at the nth position.
////////////////////////////////////////////////////////////////////
46
void TransformBlendTable::remove_blend(int n);

1958 9 add_blend 0 4 3062 30 TransformBlendTable::add_blend 0 1 428 414
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::add_blend
//       Access: Published
//  Description: Adds a new blend to the table, and returns its
//               index number.  If there is already an identical blend
//               in the table, simply returns that number instead.
////////////////////////////////////////////////////////////////////
64
int TransformBlendTable::add_blend(TransformBlend const &blend);

1959 18 get_num_transforms 0 4 3062 39 TransformBlendTable::get_num_transforms 0 1 429 603
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_num_transforms
//       Access: Published
//  Description: Returns the number of unique VertexTransform objects
//               represented in the table.  This will correspond to
//               the size of the TransformTable object that would
//               represent the same table.  This is also the same
//               limit reflected by
//               GraphicsStateGuardian::get_max_vertex_transform_indices().
////////////////////////////////////////////////////////////////////
63
inline int TransformBlendTable::get_num_transforms(void) const;

1960 31 get_max_simultaneous_transforms 0 4 3062 52 TransformBlendTable::get_max_simultaneous_transforms 0 1 430 503
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_max_simultaneous_transforms
//       Access: Published
//  Description: Returns the maximum number of unique VertexTransform
//               objects that are applied to any one vertex
//               simultaneously.  This is the same limit reflected by
//               GraphicsStateGuardian::get_max_vertex_transforms().
////////////////////////////////////////////////////////////////////
76
inline int TransformBlendTable::get_max_simultaneous_transforms(void) const;

1961 8 set_rows 0 4 3062 29 TransformBlendTable::set_rows 0 1 431 383
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::set_rows
//       Access: Published
//  Description: Specifies the subset of rows (vertices) in the
//               associated GeomVertexData that this
//               TransformBlendTable actually affects.
////////////////////////////////////////////////////////////////////
67
inline void TransformBlendTable::set_rows(SparseArray const &rows);

1962 8 get_rows 0 4 3062 29 TransformBlendTable::get_rows 0 1 432 381
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_rows
//       Access: Published
//  Description: Returns the subset of rows (vertices) in the
//               associated GeomVertexData that this
//               TransformBlendTable actually affects.
////////////////////////////////////////////////////////////////////
68
inline SparseArray const &TransformBlendTable::get_rows(void) const;

1963 11 modify_rows 0 4 3062 32 TransformBlendTable::modify_rows 0 1 433 458
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::modify_rows
//       Access: Published
//  Description: Returns a modifiable reference to the SparseArray
//               that specifies the subset of rows (vertices) in the
//               associated GeomVertexData that this
//               TransformBlendTable actually affects.
////////////////////////////////////////////////////////////////////
59
inline SparseArray &TransformBlendTable::modify_rows(void);

1964 5 write 0 4 3062 26 TransformBlendTable::write 0 1 434 226
////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
70
void TransformBlendTable::write(ostream &out, int indent_level) const;

1965 14 get_class_type 0 4 3062 35 TransformBlendTable::get_class_type 0 1 435 0
60
static TypeHandle TransformBlendTable::get_class_type(void);

1966 8 get_name 0 4 3063 22 VertexSlider::get_name 0 1 436 457
////////////////////////////////////////////////////////////////////
//     Function: VertexSlider::get_name
//       Access: Published
//  Description: Returns the name of this particular slider.  Every
//               unique blend shape within a particular Geom must be
//               identified with a different name, which is shared by
//               the slider that controls it.
////////////////////////////////////////////////////////////////////
62
inline InternalName const *VertexSlider::get_name(void) const;

1967 10 get_slider 0 6 3063 24 VertexSlider::get_slider 0 1 437 0
61
virtual PN_stdfloat VertexSlider::get_slider(void) const = 0;

1968 12 get_modified 0 4 3063 26 VertexSlider::get_modified 0 1 438 377
////////////////////////////////////////////////////////////////////
//     Function: VertexSlider::get_modified
//       Access: Published
//  Description: Returns a sequence number that's guaranteed to change
//               at least every time the value reported by
//               get_slider() changes.
////////////////////////////////////////////////////////////////////
74
inline UpdateSeq VertexSlider::get_modified(Thread *current_thread) const;

1969 6 output 0 6 3063 20 VertexSlider::output 0 1 439 229
////////////////////////////////////////////////////////////////////
//     Function: VertexSlider::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
54
virtual void VertexSlider::output(ostream &out) const;

1970 5 write 0 6 3063 19 VertexSlider::write 0 1 440 228
////////////////////////////////////////////////////////////////////
//     Function: VertexSlider::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
71
virtual void VertexSlider::write(ostream &out, int indent_level) const;

1971 14 get_class_type 0 4 3063 28 VertexSlider::get_class_type 0 1 441 0
53
static TypeHandle VertexSlider::get_class_type(void);

1972 11 SliderTable 0 4 3064 24 SliderTable::SliderTable 0 2 442 443 455
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: SliderTable::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
82
SliderTable::SliderTable(void);
SliderTable::SliderTable(SliderTable const &copy);

1973 10 operator = 0 4 3064 23 SliderTable::operator = 0 1 444 0
54
void SliderTable::operator =(SliderTable const &copy);

1974 13 is_registered 0 4 3064 26 SliderTable::is_registered 0 1 445 498
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::is_registered
//       Access: Published
//  Description: Returns true if this table has been registered.
//               Once it has been registered, the set of sliders in
//               a SliderTable may not be further modified; but
//               it must be registered before it can be assigned to a
//               Geom.
////////////////////////////////////////////////////////////////////
51
inline bool SliderTable::is_registered(void) const;

1975 14 register_table 0 4 3064 27 SliderTable::register_table 0 1 446 912
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::register_table
//       Access: Published, Static
//  Description: Registers a SliderTable for use.  This is
//               similar to GeomVertexFormat::register_format().  Once
//               registered, a SliderTable may no longer be
//               modified (although the individual VertexSlider
//               objects may modify their reported sliders).
//
//               This must be called before a table may be used in a
//               Geom.  After this call, you should discard the
//               original pointer you passed in (which may or may not
//               now be invalid) and let its reference count decrement
//               normally; you should use only the returned value from
//               this point on.
////////////////////////////////////////////////////////////////////
98
static inline ConstPointerTo< SliderTable > SliderTable::register_table(SliderTable const *table);

1976 15 get_num_sliders 0 4 3064 28 SliderTable::get_num_sliders 0 1 447 271
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::get_num_sliders
//       Access: Published
//  Description: Returns the number of sliders in the table.
////////////////////////////////////////////////////////////////////
52
inline int SliderTable::get_num_sliders(void) const;

1977 10 get_slider 0 4 3064 23 SliderTable::get_slider 0 1 448 259
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::get_slider
//       Access: Published
//  Description: Returns the nth slider in the table.
////////////////////////////////////////////////////////////////////
64
inline VertexSlider const *SliderTable::get_slider(int n) const;

1978 15 get_slider_rows 0 4 3064 28 SliderTable::get_slider_rows 0 1 449 320
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::get_slider_rows
//       Access: Published
//  Description: Returns the set of rows (vertices) governed by the
//               nth slider in the table.
////////////////////////////////////////////////////////////////////
68
inline SparseArray const &SliderTable::get_slider_rows(int n) const;

1979 12 find_sliders 0 4 3064 25 SliderTable::find_sliders 0 1 450 416
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::find_sliders
//       Access: Published
//  Description: Returns a list of slider indices that represent the
//               list of sliders with the indicated name, or an empty
//               SparseArray if no slider in the table has that name.
////////////////////////////////////////////////////////////////////
84
inline SparseArray const &SliderTable::find_sliders(InternalName const *name) const;

1980 10 has_slider 0 4 3064 23 SliderTable::has_slider 0 1 451 329
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::has_slider
//       Access: Published
//  Description: Returns true if the table has at least one slider by
//               the indicated name, false otherwise.
////////////////////////////////////////////////////////////////////
68
inline bool SliderTable::has_slider(InternalName const *name) const;

1981 8 is_empty 0 4 3064 21 SliderTable::is_empty 0 1 452 309
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::is_empty
//       Access: Published
//  Description: Returns true if the table has no sliders, false if it
//               has at least one.
////////////////////////////////////////////////////////////////////
46
inline bool SliderTable::is_empty(void) const;

1982 12 get_modified 0 4 3064 25 SliderTable::get_modified 0 1 453 560
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::get_modified
//       Access: Published
//  Description: Returns a sequence number that's guaranteed to change
//               at least when any VertexSliders in the table
//               change.  (However, this is only true for a registered
//               table.  An unregistered table may or may not
//               reflect an update here when a VertexSlider
//               changes.)
////////////////////////////////////////////////////////////////////
73
inline UpdateSeq SliderTable::get_modified(Thread *current_thread) const;

1983 10 set_slider 0 4 3064 23 SliderTable::set_slider 0 1 454 301
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::set_slider
//       Access: Published
//  Description: Replaces the nth slider.  Only valid for
//               unregistered tables.
////////////////////////////////////////////////////////////////////
64
void SliderTable::set_slider(int n, VertexSlider const *slider);

1984 15 set_slider_rows 0 4 3064 28 SliderTable::set_slider_rows 0 1 455 327
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::set_slider_rows
//       Access: Published
//  Description: Replaces the rows affected by the nth slider.  Only
//               valid for unregistered tables.
////////////////////////////////////////////////////////////////////
66
void SliderTable::set_slider_rows(int n, SparseArray const &rows);

1985 13 remove_slider 0 4 3064 26 SliderTable::remove_slider 0 1 456 303
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::remove_slider
//       Access: Published
//  Description: Removes the nth slider.  Only valid for
//               unregistered tables.
////////////////////////////////////////////////////////////////////
39
void SliderTable::remove_slider(int n);

1986 10 add_slider 0 4 3064 23 SliderTable::add_slider 0 1 457 373
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::add_slider
//       Access: Published
//  Description: Adds a new slider to the table, and returns the
//               index number of the new slider.  Only valid for
//               unregistered tables.
////////////////////////////////////////////////////////////////////
81
int SliderTable::add_slider(VertexSlider const *slider, SparseArray const &rows);

1987 5 write 0 4 3064 18 SliderTable::write 0 1 458 218
////////////////////////////////////////////////////////////////////
//     Function: SliderTable::write
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
44
void SliderTable::write(ostream &out) const;

1988 14 get_class_type 0 4 3064 27 SliderTable::get_class_type 0 1 459 0
52
static TypeHandle SliderTable::get_class_type(void);

1989 27 upcast_to_CopyOnWriteObject 0 12 3065 43 GeomVertexData::upcast_to_CopyOnWriteObject 0 1 515 47
upcast from GeomVertexData to CopyOnWriteObject
69
CopyOnWriteObject *GeomVertexData::upcast_to_CopyOnWriteObject(void);

1990 26 downcast_to_GeomVertexData 0 12 3056 45 CopyOnWriteObject::downcast_to_GeomVertexData 0 1 516 49
downcast from CopyOnWriteObject to GeomVertexData
68
GeomVertexData *CopyOnWriteObject::downcast_to_GeomVertexData(void);

1991 19 upcast_to_GeomEnums 0 12 3065 35 GeomVertexData::upcast_to_GeomEnums 0 1 517 39
upcast from GeomVertexData to GeomEnums
53
GeomEnums *GeomVertexData::upcast_to_GeomEnums(void);

1992 26 downcast_to_GeomVertexData 0 12 3029 37 GeomEnums::downcast_to_GeomVertexData 0 1 518 41
downcast from GeomEnums to GeomVertexData
60
GeomVertexData *GeomEnums::downcast_to_GeomVertexData(void);

1993 14 GeomVertexData 0 4 3065 30 GeomVertexData::GeomVertexData 0 3 460 461 462 1270
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::Default Constructor
//       Access: Private
//  Description: Constructs an invalid object.  This is only used when
//               reading from the bam file.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::Constructor
//       Access: Published
//  Description: This constructor copies all of the basic properties
//               of the source VertexData, like usage_hint and
//               animation tables, but does not copy the actual data,
//               and it allows you to specify a different format.
////////////////////////////////////////////////////////////////////
286
explicit GeomVertexData::GeomVertexData(string const &name, GeomVertexFormat const *format, GeomEnums::UsageHint usage_hint);
GeomVertexData::GeomVertexData(GeomVertexData const &copy);
explicit GeomVertexData::GeomVertexData(GeomVertexData const &copy, GeomVertexFormat const *format);

1994 10 operator = 0 4 3065 26 GeomVertexData::operator = 0 1 463 0
60
void GeomVertexData::operator =(GeomVertexData const &copy);

1995 15 ~GeomVertexData 0 6 3065 31 GeomVertexData::~GeomVertexData 0 0 234
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
46
virtual GeomVertexData::~GeomVertexData(void);

1996 12 operator new 0 4 3065 28 GeomVertexData::operator new 0 1 464 0
122
inline void *GeomVertexData::operator new(size_t size);
inline void *GeomVertexData::operator new(size_t size, void *ptr);

1997 15 operator delete 0 4 3065 31 GeomVertexData::operator delete 0 0 0
116
inline void GeomVertexData::operator delete(void *ptr);
inline void GeomVertexData::operator delete(void *, void *);

1998 12 validate_ptr 0 4 3065 28 GeomVertexData::validate_ptr 0 0 0
65
static inline bool GeomVertexData::validate_ptr(void const *ptr);

1999 10 compare_to 0 4 3065 26 GeomVertexData::compare_to 0 1 465 326
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::compare_to
//       Access: Published
//  Description: Returns 0 if the two objects are equivalent, even if
//               they are not the same pointer.
////////////////////////////////////////////////////////////////////
66
int GeomVertexData::compare_to(GeomVertexData const &other) const;

2000 8 get_name 0 4 3065 24 GeomVertexData::get_name 0 1 466 376
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_name
//       Access: Published
//  Description: Returns the name passed to the constructor, if any.
//               This name is reported on the PStats graph for vertex
//               computations.
////////////////////////////////////////////////////////////////////
58
inline string const &GeomVertexData::get_name(void) const;

2001 8 set_name 0 4 3065 24 GeomVertexData::set_name 0 1 467 345
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_name
//       Access: Published
//  Description: Changes the name of the vertex data.  This name is
//               reported on the PStats graph for vertex computations.
////////////////////////////////////////////////////////////////////
50
void GeomVertexData::set_name(string const &name);

2002 14 get_usage_hint 0 4 3065 30 GeomVertexData::get_usage_hint 0 1 468 778
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_usage_hint
//       Access: Published
//  Description: Returns the usage hint that was passed to the
//               constructor, and which will be passed to each array
//               data object created initially, and arrays created as
//               the result of a convert_to() operation.  See
//               geomEnums.h.
//
//               However, each individual array may be replaced with a
//               different array object with an independent usage hint
//               specified, so there is no guarantee that the
//               individual arrays all have the same usage_hint.
////////////////////////////////////////////////////////////////////
71
inline GeomEnums::UsageHint GeomVertexData::get_usage_hint(void) const;

2003 14 set_usage_hint 0 4 3065 30 GeomVertexData::set_usage_hint 0 1 469 580
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_usage_hint
//       Access: Published
//  Description: Changes the UsageHint hint for this vertex data, and
//               for all of the arrays that share this data.  See
//               get_usage_hint().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
69
void GeomVertexData::set_usage_hint(GeomEnums::UsageHint usage_hint);

2004 10 get_format 0 4 3065 26 GeomVertexData::get_format 0 1 470 318
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_format
//       Access: Published
//  Description: Returns a pointer to the GeomVertexFormat structure
//               that defines this data.
////////////////////////////////////////////////////////////////////
70
inline GeomVertexFormat const *GeomVertexData::get_format(void) const;

2005 10 set_format 0 4 3065 26 GeomVertexData::set_format 0 1 471 585
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_format
//       Access: Published
//  Description: Changes the format of the vertex data.  If the data
//               is not empty, this will implicitly change every row
//               to match the new format.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
64
void GeomVertexData::set_format(GeomVertexFormat const *format);

2006 18 unclean_set_format 0 4 3065 34 GeomVertexData::unclean_set_format 0 1 472 784
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::unclean_set_format
//       Access: Published
//  Description: Changes the format of the vertex data, without
//               reformatting the data to match.  The data is exactly
//               the same after this operation, but will be
//               reinterpreted according to the new format.  This
//               assumes that the new format is fundamentally
//               compatible with the old format; in particular, it
//               must have the same number of arrays with the same
//               stride in each one.  No checking is performed that
//               the data remains sensible.
////////////////////////////////////////////////////////////////////
72
void GeomVertexData::unclean_set_format(GeomVertexFormat const *format);

2007 10 has_column 0 4 3065 26 GeomVertexData::has_column 0 1 473 398
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::has_column
//       Access: Published
//  Description: Returns true if the data has the named column,
//               false otherwise.  This is really just a shortcut for
//               asking the same thing from the format.
////////////////////////////////////////////////////////////////////
71
inline bool GeomVertexData::has_column(InternalName const *name) const;

2008 12 get_num_rows 0 4 3065 28 GeomVertexData::get_num_rows 0 1 474 362
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_num_rows
//       Access: Published
//  Description: Returns the number of rows stored within all the
//               arrays.  All arrays store data for the same n
//               rows.
////////////////////////////////////////////////////////////////////
52
inline int GeomVertexData::get_num_rows(void) const;

2009 12 set_num_rows 0 4 3065 28 GeomVertexData::set_num_rows 0 1 475 1162
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_num_rows
//       Access: Published
//  Description: Sets the length of the array to n rows in all of
//               the various arrays (presumably by adding rows).
//
//               The new vertex data is initialized to 0, except for
//               the "color" column, which is initialized to (1, 1, 1,
//               1).
//
//               The return value is true if the number of rows
//               was changed, false if the object already contained n
//               rows (or if there was some error).
//
//               This can be used when you know exactly how many
//               rows you will be needing.  It is faster than
//               reserve_num_rows().  Also see unclean_set_num_rows()
//               if you are planning to fill in all the data yourself.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
48
inline bool GeomVertexData::set_num_rows(int n);

2010 20 unclean_set_num_rows 0 4 3065 36 GeomVertexData::unclean_set_num_rows 0 1 476 893
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::unclean_set_num_rows
//       Access: Published
//  Description: This method behaves like set_num_rows(), except the
//               new data is not initialized.  Furthermore, after this
//               call, *any* of the data in the GeomVertexData may be
//               uninitialized, including the earlier rows.
//
//               This is intended for applications that are about to
//               completely fill the GeomVertexData with new data
//               anyway; it provides a tiny performance boost over
//               set_num_rows().
//
//               This can be used when you know exactly how many
//               rows you will be needing.  It is faster than
//               reserve_num_rows().
////////////////////////////////////////////////////////////////////
56
inline bool GeomVertexData::unclean_set_num_rows(int n);

2011 16 reserve_num_rows 0 4 3065 32 GeomVertexData::reserve_num_rows 0 1 477 799
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::reserve_num_rows
//       Access: Published
//  Description: This ensures that enough memory space for n rows is
//               allocated, so that you may increase the number of
//               rows to n without causing a new memory allocation.
//               This is a performance optimization only; it is
//               especially useful when you know ahead of time that
//               you will be adding n rows to the data.
//
//               If you know exactly how many rows you will be
//               needing, it is significantly faster to use
//               set_num_rows() or unclean_set_num_rows() instead.
////////////////////////////////////////////////////////////////////
52
inline bool GeomVertexData::reserve_num_rows(int n);

2012 10 clear_rows 0 4 3065 26 GeomVertexData::clear_rows 0 1 478 554
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_rows
//       Access: Published
//  Description: Removes all of the rows from the arrays;
//               functionally equivalent to set_num_rows(0) (but
//               faster).
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
38
void GeomVertexData::clear_rows(void);

2013 14 get_num_arrays 0 4 3065 30 GeomVertexData::get_num_arrays 0 1 479 376
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_num_arrays
//       Access: Published
//  Description: Returns the number of individual arrays stored within
//               the data.  This must match
//               get_format()->get_num_arrays().
////////////////////////////////////////////////////////////////////
54
inline int GeomVertexData::get_num_arrays(void) const;

2014 9 get_array 0 4 3065 25 GeomVertexData::get_array 0 1 480 412
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_array
//       Access: Published
//  Description: Returns a const pointer to the vertex data for the
//               indicated array, for application code to directly
//               examine (but not modify) the underlying vertex data.
////////////////////////////////////////////////////////////////////
84
inline ConstPointerTo< GeomVertexArrayData > GeomVertexData::get_array(int i) const;

2015 12 modify_array 0 4 3065 28 GeomVertexData::modify_array 0 1 481 757
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::modify_array
//       Access: Published
//  Description: Returns a modifiable pointer to the indicated vertex
//               array, so that application code may directly
//               manipulate the data.  You should avoid changing
//               the length of this array, since all of the arrays
//               should be kept in sync--use set_num_rows()
//               instead.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
76
inline PointerTo< GeomVertexArrayData > GeomVertexData::modify_array(int i);

2016 9 set_array 0 4 3065 25 GeomVertexData::set_array 0 1 482 667
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_array
//       Access: Published
//  Description: Replaces the indicated vertex data array with
//               a completely new array.  You should be careful that
//               the new array has the same length and format as the
//               old one, unless you know what you are doing.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
79
inline void GeomVertexData::set_array(int i, GeomVertexArrayData const *array);

2017 19 get_transform_table 0 4 3065 35 GeomVertexData::get_transform_table 0 1 483 868
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_transform_table
//       Access: Published
//  Description: Returns a const pointer to the TransformTable
//               assigned to this data.  Vertices within the table
//               will index into this table to indicate their
//               dynamic skinning information; this table is used when
//               the vertex animation is to be performed by the
//               graphics hardware (but also see
//               get_transform_blend_table()).
//
//               This will return NULL if the vertex data does not
//               have a TransformTable assigned (which implies the
//               vertices will not be animated by the graphics
//               hardware).
////////////////////////////////////////////////////////////////////
77
inline TransformTable const *GeomVertexData::get_transform_table(void) const;

2018 19 set_transform_table 0 4 3065 35 GeomVertexData::set_transform_table 0 1 484 708
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_transform_table
//       Access: Published
//  Description: Replaces the TransformTable on this vertex
//               data with the indicated table.  The length of this
//               table should be consistent with the maximum table
//               index assigned to the vertices under the
//               "transform_index" name.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
70
void GeomVertexData::set_transform_table(TransformTable const *table);

2019 21 clear_transform_table 0 4 3065 37 GeomVertexData::clear_transform_table 0 1 485 401
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_transform_table
//       Access: Published
//  Description: Sets the TransformTable pointer to NULL,
//               removing the table from the vertex data.  This
//               disables hardware-driven vertex animation.
////////////////////////////////////////////////////////////////////
56
inline void GeomVertexData::clear_transform_table(void);

2020 25 get_transform_blend_table 0 4 3065 41 GeomVertexData::get_transform_blend_table 0 1 486 816
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_transform_blend_table
//       Access: Published
//  Description: Returns a const pointer to the TransformBlendTable
//               assigned to this data.  Vertices within the table
//               will index into this table to indicate their
//               dynamic skinning information; this table is used when
//               the vertex animation is to be performed by the CPU
//               (but also see get_transform_table()).
//
//               This will return NULL if the vertex data does not
//               have a TransformBlendTable assigned (which implies
//               the vertices will not be animated by the CPU).
////////////////////////////////////////////////////////////////////
99
inline ConstPointerTo< TransformBlendTable > GeomVertexData::get_transform_blend_table(void) const;

2021 28 modify_transform_blend_table 0 4 3065 44 GeomVertexData::modify_transform_blend_table 0 1 487 665
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::modify_transform_blend_table
//       Access: Published
//  Description: Returns a modifiable pointer to the current
//               TransformBlendTable on this vertex data, if any, or
//               NULL if there is not a TransformBlendTable.  See
//               get_transform_blend_table().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
84
PointerTo< TransformBlendTable > GeomVertexData::modify_transform_blend_table(void);

2022 25 set_transform_blend_table 0 4 3065 41 GeomVertexData::set_transform_blend_table 0 1 488 719
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_transform_blend_table
//       Access: Published
//  Description: Replaces the TransformBlendTable on this vertex
//               data with the indicated table.  The length of this
//               table should be consistent with the maximum table
//               index assigned to the vertices under the
//               "transform_blend" name.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
81
void GeomVertexData::set_transform_blend_table(TransformBlendTable const *table);

2023 27 clear_transform_blend_table 0 4 3065 43 GeomVertexData::clear_transform_blend_table 0 1 489 407
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_transform_blend_table
//       Access: Published
//  Description: Sets the TransformBlendTable pointer to NULL,
//               removing the table from the vertex data.  This
//               disables CPU-driven vertex animation.
////////////////////////////////////////////////////////////////////
62
inline void GeomVertexData::clear_transform_blend_table(void);

2024 16 get_slider_table 0 4 3065 32 GeomVertexData::get_slider_table 0 1 490 558
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_slider_table
//       Access: Published
//  Description: Returns a const pointer to the SliderTable
//               assigned to this data.  Vertices within the vertex
//               data will look up their morph offsets, if any, within
//               this table.
//
//               This will return NULL if the vertex data does not
//               have a SliderTable assigned.
////////////////////////////////////////////////////////////////////
71
inline SliderTable const *GeomVertexData::get_slider_table(void) const;

2025 16 set_slider_table 0 4 3065 32 GeomVertexData::set_slider_table 0 1 491 777
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_slider_table
//       Access: Published
//  Description: Replaces the SliderTable on this vertex
//               data with the indicated table.  There should be an
//               entry in this table for each kind of morph offset
//               defined in the vertex data.
//
//               The SliderTable object must have been registered
//               prior to setting it on the GeomVertexData.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
64
void GeomVertexData::set_slider_table(SliderTable const *table);

2026 18 clear_slider_table 0 4 3065 34 GeomVertexData::clear_slider_table 0 1 492 392
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_slider_table
//       Access: Published
//  Description: Sets the SliderTable pointer to NULL,
//               removing the table from the vertex data.  This
//               disables morph (blend shape) animation.
////////////////////////////////////////////////////////////////////
53
inline void GeomVertexData::clear_slider_table(void);

2027 13 get_num_bytes 0 4 3065 29 GeomVertexData::get_num_bytes 0 1 493 332
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_num_bytes
//       Access: Published
//  Description: Returns the total number of bytes consumed by the
//               different arrays of the vertex data.
////////////////////////////////////////////////////////////////////
53
inline int GeomVertexData::get_num_bytes(void) const;

2028 12 get_modified 0 4 3065 28 GeomVertexData::get_modified 0 1 494 366
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the vertex data is
//               modified.
////////////////////////////////////////////////////////////////////
101
inline UpdateSeq GeomVertexData::get_modified(Thread *current_thread = (get_current_thread())) const;

2029 16 request_resident 0 4 3065 32 GeomVertexData::request_resident 0 1 495 429
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::request_resident
//       Access: Published
//  Description: Returns true if the vertex data is currently resident
//               in memory.  If this returns false, the vertex data will
//               be brought back into memory shortly; try again later.
////////////////////////////////////////////////////////////////////
50
bool GeomVertexData::request_resident(void) const;

2030 9 copy_from 0 4 3065 25 GeomVertexData::copy_from 0 1 496 1099
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::copy_from
//       Access: Published
//  Description: Copies all the data from the other array into the
//               corresponding data types in this array, by matching
//               data types name-by-name.
//
//               keep_data_objects specifies what to do when one or
//               more of the arrays can be copied without the need to
//               apply any conversion operation.  If it is true, the
//               original GeomVertexArrayData objects in this object
//               are retained, and their data arrays are copied
//               byte-by-byte from the source; if it is false, then the
//               GeomVertexArrayData objects are copied pointerwise
//               from the source.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
134
void GeomVertexData::copy_from(GeomVertexData const *source, bool keep_data_objects, Thread *current_thread = (get_current_thread()));

2031 13 copy_row_from 0 4 3065 29 GeomVertexData::copy_row_from 0 1 497 643
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::copy_row_from
//       Access: Published
//  Description: Copies a single row of the data from the other array
//               into the indicated row of this array.  In this case,
//               the source format must exactly match the destination
//               format.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
119
void GeomVertexData::copy_row_from(int dest_row, GeomVertexData const *source, int source_row, Thread *current_thread);

2032 10 convert_to 0 4 3065 26 GeomVertexData::convert_to 0 1 498 408
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::convert_to
//       Access: Published
//  Description: Returns a new GeomVertexData that represents the same
//               contents as this one, with all data types matched up
//               name-by-name to the indicated new format.
////////////////////////////////////////////////////////////////////
102
ConstPointerTo< GeomVertexData > GeomVertexData::convert_to(GeomVertexFormat const *new_format) const;

2033 11 scale_color 0 4 3065 27 GeomVertexData::scale_color 0 2 499 500 1067
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::scale_color
//       Access: Published
//  Description: Returns a new GeomVertexData object with the color
//               table modified in-place to apply the indicated scale.
//
//               If the vertex data does not include a color column, a
//               new one will not be added.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::scale_color
//       Access: Published
//  Description: Returns a new GeomVertexData object with the color
//               table replaced with a new color table that has been
//               scaled by the indicated value.  The new color table
//               will be added as a new array; if the old color table
//               was interleaved with a previous array, the previous
//               array will not be repacked.
////////////////////////////////////////////////////////////////////
282
ConstPointerTo< GeomVertexData > GeomVertexData::scale_color(LVecBase4 const &color_scale) const;
ConstPointerTo< GeomVertexData > GeomVertexData::scale_color(LVecBase4 const &color_scale, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const;

2034 9 set_color 0 4 3065 25 GeomVertexData::set_color 0 2 501 502 1054
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_color
//       Access: Published
//  Description: Returns a new GeomVertexData object with the color
//               data modified in-place with the new value.
//
//               If the vertex data does not include a color column, a
//               new one will not be added.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_color
//       Access: Published
//  Description: Returns a new GeomVertexData object with the color
//               table replaced with a new color table for which each
//               vertex has the indicated value.  The new color table
//               will be added as a new array; if the old color table
//               was interleaved with a previous array, the previous
//               array will not be repacked.
////////////////////////////////////////////////////////////////////
260
ConstPointerTo< GeomVertexData > GeomVertexData::set_color(LColor const &color) const;
ConstPointerTo< GeomVertexData > GeomVertexData::set_color(LColor const &color, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const;

2035 15 reverse_normals 0 4 3065 31 GeomVertexData::reverse_normals 0 1 503 577
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::reverse_normals
//       Access: Published
//  Description: Returns a new GeomVertexData object with the normal
//               data modified in-place, so that each lighting normal
//               is now facing in the opposite direction.
//
//               If the vertex data does not include a normal column,
//               this returns the original GeomVertexData object,
//               unchanged.
////////////////////////////////////////////////////////////////////
77
ConstPointerTo< GeomVertexData > GeomVertexData::reverse_normals(void) const;

2036 16 animate_vertices 0 4 3065 32 GeomVertexData::animate_vertices 0 1 504 1321
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::animate_vertices
//       Access: Published
//  Description: Returns a GeomVertexData that represents the results
//               of computing the vertex animation on the CPU for this
//               GeomVertexData.
//
//               If there is no CPU-defined vertex animation on this
//               object, this just returns the original object.
//
//               If there is vertex animation, but the VertexTransform
//               values have not changed since last time, this may
//               return the same pointer it returned previously.  Even
//               if the VertexTransform values have changed, it may
//               still return the same pointer, but with its contents
//               modified (this is preferred, since it allows the
//               graphics backend to update vertex buffers optimally).
//
//               If force is false, this method may return immediately
//               with stale data, if the vertex data is not completely
//               resident.  If force is true, this method will never
//               return stale data, but may block until the data is
//               available.
////////////////////////////////////////////////////////////////////
108
ConstPointerTo< GeomVertexData > GeomVertexData::animate_vertices(bool force, Thread *current_thread) const;

2037 23 clear_animated_vertices 0 4 3065 39 GeomVertexData::clear_animated_vertices 0 1 505 555
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_animated_vertices
//       Access: Published
//  Description: Removes the cache of animated vertices computed by a
//               previous call to animate_vertices() within the same
//               frame.  This will force the next call to
//               animate_vertices() to recompute these values from
//               scratch.  Normally it is not necessary to call this.
////////////////////////////////////////////////////////////////////
51
void GeomVertexData::clear_animated_vertices(void);

2038 18 transform_vertices 0 4 3065 34 GeomVertexData::transform_vertices 0 2 506 507 949
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::transform_vertices
//       Access: Published
//  Description: Applies the indicated transform matrix to all of the
//               vertices in the GeomVertexData.  The transform is
//               applied to all "point" and "vector" type columns
//               described in the format.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::transform_vertices
//       Access: Published
//  Description: Applies the indicated transform matrix to all of the
//               vertices from begin_row up to but not including
//               end_row.  The transform is applied to all "point" and
//               "vector" type columns described in the format.
////////////////////////////////////////////////////////////////////
151
void GeomVertexData::transform_vertices(LMatrix4 const &mat);
void GeomVertexData::transform_vertices(LMatrix4 const &mat, int begin_row, int end_row);

2039 14 replace_column 0 4 3065 30 GeomVertexData::replace_column 0 1 508 776
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::replace_column
//       Access: Published
//  Description: Returns a new GeomVertexData object, suitable for
//               modification, with the indicated data type replaced
//               with a new table filled with undefined values.  The
//               new table will be added as a new array; if the old
//               table was interleaved with a previous array, the
//               previous array will not be repacked.
//
//               If num_components is 0, the indicated name is simply
//               removed from the type, without replacing it with
//               anything else.
////////////////////////////////////////////////////////////////////
172
PointerTo< GeomVertexData > GeomVertexData::replace_column(InternalName *name, int num_components, GeomEnums::NumericType numeric_type, GeomEnums::Contents contents) const;

2040 6 output 0 4 3065 22 GeomVertexData::output 0 1 509 221
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
48
void GeomVertexData::output(ostream &out) const;

2041 5 write 0 4 3065 21 GeomVertexData::write 0 1 510 220
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::write
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
69
void GeomVertexData::write(ostream &out, int indent_level = 0) const;

2042 15 describe_vertex 0 4 3065 31 GeomVertexData::describe_vertex 0 1 511 324
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::describe_vertex
//       Access: Published
//  Description: Writes a verbose, human-friendly description of the
//               indicated vertex number.
////////////////////////////////////////////////////////////////////
66
void GeomVertexData::describe_vertex(ostream &out, int row) const;

2043 11 clear_cache 0 4 3065 27 GeomVertexData::clear_cache 0 1 512 556
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_cache
//       Access: Published
//  Description: Removes all of the previously-cached results of
//               convert_to().
//
//               This blows away the entire cache, upstream and
//               downstream the pipeline.  Use clear_cache_stage()
//               instead if you only want to blow away the cache at
//               the current stage and upstream.
////////////////////////////////////////////////////////////////////
39
void GeomVertexData::clear_cache(void);

2044 17 clear_cache_stage 0 4 3065 33 GeomVertexData::clear_cache_stage 0 1 513 608
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_cache_stage
//       Access: Published
//  Description: Removes all of the previously-cached results of
//               convert_to(), at the current pipeline stage and
//               upstream.  Does not affect the downstream cache.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
45
void GeomVertexData::clear_cache_stage(void);

2045 14 get_class_type 0 4 3065 30 GeomVertexData::get_class_type 0 1 514 0
55
static TypeHandle GeomVertexData::get_class_type(void);

2046 22 AnimateVerticesRequest 0 4 3066 46 AnimateVerticesRequest::AnimateVerticesRequest 0 1 519 271
////////////////////////////////////////////////////////////////////
//     Function: AnimateVerticesRequest::Constructor
//       Access: Published
//  Description: Create a new AnimateVerticesRequest.
////////////////////////////////////////////////////////////////////
88
inline AnimateVerticesRequest::AnimateVerticesRequest(GeomVertexData *geom_vertex_data);

2047 8 is_ready 0 4 3066 32 AnimateVerticesRequest::is_ready 0 1 520 322
////////////////////////////////////////////////////////////////////
//     Function: AnimateVerticesRequest::is_ready
//       Access: Published
//  Description: Returns true if this request has completed, false if
//               it is still pending.
////////////////////////////////////////////////////////////////////
57
inline bool AnimateVerticesRequest::is_ready(void) const;

2048 14 get_class_type 0 4 3066 38 AnimateVerticesRequest::get_class_type 0 1 521 0
63
static TypeHandle AnimateVerticesRequest::get_class_type(void);

2049 23 ~AnimateVerticesRequest 0 4 3066 47 AnimateVerticesRequest::~AnimateVerticesRequest 0 0 0
54
AnimateVerticesRequest::~AnimateVerticesRequest(void);

2050 14 get_class_type 0 4 3068 28 SavedContext::get_class_type 0 1 522 0
53
static TypeHandle SavedContext::get_class_type(void);

2051 13 ~SavedContext 0 4 3068 27 SavedContext::~SavedContext 0 0 0
34
SavedContext::~SavedContext(void);

2052 22 upcast_to_SavedContext 0 12 3070 37 BufferContext::upcast_to_SavedContext 0 1 528 41
upcast from BufferContext to SavedContext
58
SavedContext *BufferContext::upcast_to_SavedContext(void);

2053 25 downcast_to_BufferContext 0 12 3068 39 SavedContext::downcast_to_BufferContext 0 1 529 43
downcast from SavedContext to BufferContext
61
BufferContext *SavedContext::downcast_to_BufferContext(void);

2054 14 ~BufferContext 0 6 3070 29 BufferContext::~BufferContext 0 0 230
////////////////////////////////////////////////////////////////////
//     Function: BufferContext::Destructor
//       Access: Public, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
44
virtual BufferContext::~BufferContext(void);

2055 19 get_data_size_bytes 0 4 3070 34 BufferContext::get_data_size_bytes 0 1 523 550
////////////////////////////////////////////////////////////////////
//     Function: BufferContext::get_data_size_bytes
//       Access: Public
//  Description: Returns the number of bytes previously reported for
//               the data object.  This is used to track changes in
//               the data object's allocated size; if it changes from
//               this, we need to create a new buffer.  This is also
//               used to track memory utilization in PStats.
////////////////////////////////////////////////////////////////////
61
inline size_t BufferContext::get_data_size_bytes(void) const;

2056 12 get_modified 0 4 3070 27 BufferContext::get_modified 0 1 524 320
////////////////////////////////////////////////////////////////////
//     Function: BufferContext::get_modified
//       Access: Public
//  Description: Returns the UpdateSeq that was recorded the last time
//               mark_loaded() was called.
////////////////////////////////////////////////////////////////////
57
inline UpdateSeq BufferContext::get_modified(void) const;

2057 10 get_active 0 4 3070 25 BufferContext::get_active 0 1 525 382
////////////////////////////////////////////////////////////////////
//     Function: BufferContext::get_active
//       Access: Public
//  Description: Returns the active flag associated with this object.
//               An object is considered "active" if it was rendered
//               in the current frame.
////////////////////////////////////////////////////////////////////
50
inline bool BufferContext::get_active(void) const;

2058 12 get_resident 0 4 3070 27 BufferContext::get_resident 0 1 526 396
////////////////////////////////////////////////////////////////////
//     Function: BufferContext::get_resident
//       Access: Public
//  Description: Returns the resident flag associated with this
//               object.  An object is considered "resident" if it
//               appears to be resident in texture memory.
////////////////////////////////////////////////////////////////////
52
inline bool BufferContext::get_resident(void) const;

2059 14 get_class_type 0 4 3070 29 BufferContext::get_class_type 0 1 527 0
54
static TypeHandle BufferContext::get_class_type(void);

2060 27 upcast_to_CopyOnWriteObject 0 12 3071 42 GeomPrimitive::upcast_to_CopyOnWriteObject 0 1 603 46
upcast from GeomPrimitive to CopyOnWriteObject
68
CopyOnWriteObject *GeomPrimitive::upcast_to_CopyOnWriteObject(void);

2061 25 downcast_to_GeomPrimitive 0 12 3056 44 CopyOnWriteObject::downcast_to_GeomPrimitive 0 1 604 48
downcast from CopyOnWriteObject to GeomPrimitive
66
GeomPrimitive *CopyOnWriteObject::downcast_to_GeomPrimitive(void);

2062 19 upcast_to_GeomEnums 0 12 3071 34 GeomPrimitive::upcast_to_GeomEnums 0 1 605 38
upcast from GeomPrimitive to GeomEnums
52
GeomEnums *GeomPrimitive::upcast_to_GeomEnums(void);

2063 25 downcast_to_GeomPrimitive 0 12 3029 36 GeomEnums::downcast_to_GeomPrimitive 0 1 606 40
downcast from GeomEnums to GeomPrimitive
58
GeomPrimitive *GeomEnums::downcast_to_GeomPrimitive(void);

2064 10 operator = 0 4 3071 25 GeomPrimitive::operator = 0 1 530 0
58
void GeomPrimitive::operator =(GeomPrimitive const &copy);

2065 14 ~GeomPrimitive 0 6 3071 29 GeomPrimitive::~GeomPrimitive 0 0 233
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
44
virtual GeomPrimitive::~GeomPrimitive(void);

2066 12 operator new 0 4 3071 27 GeomPrimitive::operator new 0 1 531 0
120
inline void *GeomPrimitive::operator new(size_t size);
inline void *GeomPrimitive::operator new(size_t size, void *ptr);

2067 15 operator delete 0 4 3071 30 GeomPrimitive::operator delete 0 0 0
114
inline void GeomPrimitive::operator delete(void *ptr);
inline void GeomPrimitive::operator delete(void *, void *);

2068 12 validate_ptr 0 4 3071 27 GeomPrimitive::validate_ptr 0 0 0
64
static inline bool GeomPrimitive::validate_ptr(void const *ptr);

2069 9 make_copy 0 6 3071 24 GeomPrimitive::make_copy 0 1 532 0
76
virtual PointerTo< GeomPrimitive > GeomPrimitive::make_copy(void) const = 0;

2070 18 get_primitive_type 0 6 3071 33 GeomPrimitive::get_primitive_type 0 1 533 0
83
virtual GeomEnums::PrimitiveType GeomPrimitive::get_primitive_type(void) const = 0;

2071 18 get_geom_rendering 0 6 3071 33 GeomPrimitive::get_geom_rendering 0 1 534 397
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_geom_rendering
//       Access: Published, Virtual
//  Description: Returns the set of GeomRendering bits that represent
//               the rendering properties required to properly render
//               this primitive.
////////////////////////////////////////////////////////////////////
58
virtual int GeomPrimitive::get_geom_rendering(void) const;

2072 15 get_shade_model 0 4 3071 30 GeomPrimitive::get_shade_model 0 1 535 416
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_shade_model
//       Access: Published
//  Description: Returns the ShadeModel hint for this primitive.
//               This is intended as a hint to the renderer to tell it
//               how the per-vertex colors and normals are applied.
////////////////////////////////////////////////////////////////////
72
inline GeomEnums::ShadeModel GeomPrimitive::get_shade_model(void) const;

2073 15 set_shade_model 0 4 3071 30 GeomPrimitive::set_shade_model 0 1 536 865
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_shade_model
//       Access: Published
//  Description: Changes the ShadeModel hint for this primitive.
//               This is different from the ShadeModelAttrib that
//               might also be applied from the scene graph.  This
//               does not affect the shade model that is in effect
//               when rendering, but rather serves as a hint to the
//               renderer to tell it how the per-vertex colors and
//               normals on this primitive are applied.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
78
inline void GeomPrimitive::set_shade_model(GeomEnums::ShadeModel shade_model);

2074 14 get_usage_hint 0 4 3071 29 GeomPrimitive::get_usage_hint 0 1 537 921
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_usage_hint
//       Access: Published
//  Description: Returns the usage hint for this primitive.  See
//               geomEnums.h.  This has nothing to do with the usage
//               hint associated with the primitive's vertices; this
//               only specifies how often the vertex indices that
//               define the primitive will be modified.
//
//               It is perfectly legal (and, in fact, common) for a
//               GeomPrimitive to have UH_static on itself, while
//               referencing vertex data with UH_dynamic.  This means
//               that the vertices themselves will be animated, but
//               the primitive will always reference the same set of
//               vertices from the pool.
////////////////////////////////////////////////////////////////////
70
inline GeomEnums::UsageHint GeomPrimitive::get_usage_hint(void) const;

2075 14 set_usage_hint 0 4 3071 29 GeomPrimitive::set_usage_hint 0 1 538 512
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_usage_hint
//       Access: Published
//  Description: Changes the UsageHint hint for this primitive.  See
//               get_usage_hint().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
68
void GeomPrimitive::set_usage_hint(GeomEnums::UsageHint usage_hint);

2076 14 get_index_type 0 4 3071 29 GeomPrimitive::get_index_type 0 1 539 342
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_index_type
//       Access: Public
//  Description: Returns the numeric type of the index column.
//               Normally, this will be either NT_uint16 or NT_uint32.
////////////////////////////////////////////////////////////////////
72
inline GeomEnums::NumericType GeomPrimitive::get_index_type(void) const;

2077 14 set_index_type 0 4 3071 29 GeomPrimitive::set_index_type 0 1 540 939
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_index_type
//       Access: Published
//  Description: Changes the numeric type of the index column.
//               Normally, this should be either NT_uint16 or
//               NT_uint32.
//
//               The index type must be large enough to include all of
//               the index values in the primitive.  It may be
//               automatically elevated, if necessary, to a larger
//               index type, by a subsequent call to add_index() that
//               names an index value that does not fit in the index
//               type you specify.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
70
void GeomPrimitive::set_index_type(GeomEnums::NumericType index_type);

2078 12 is_composite 0 4 3071 27 GeomPrimitive::is_composite 0 1 541 439
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::is_composite
//       Access: Published
//  Description: Returns true if the primitive is a composite
//               primitive such as a tristrip or trifan, or false if
//               it is a fundamental primitive such as a collection of
//               triangles.
////////////////////////////////////////////////////////////////////
52
inline bool GeomPrimitive::is_composite(void) const;

2079 10 is_indexed 0 4 3071 25 GeomPrimitive::is_indexed 0 1 542 683
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::is_indexed
//       Access: Published
//  Description: Returns true if the primitive is indexed, false
//               otherwise.  An indexed primitive stores a table of
//               index numbers into its GeomVertexData, so that it can
//               reference the vertices in any order.  A nonindexed
//               primitive, on the other hand, stores only the first
//               vertex number and number of vertices used, so that it
//               can only reference the vertices consecutively.
////////////////////////////////////////////////////////////////////
50
inline bool GeomPrimitive::is_indexed(void) const;

2080 16 get_first_vertex 0 4 3071 31 GeomPrimitive::get_first_vertex 0 1 543 536
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_first_vertex
//       Access: Published
//  Description: Returns the first vertex number referenced by the
//               primitive.  This is particularly important in the
//               case of a nonindexed primitive, in which case
//               get_first_vertex() and get_num_vertices() completely
//               define the extent of the vertex range.
////////////////////////////////////////////////////////////////////
55
inline int GeomPrimitive::get_first_vertex(void) const;

2081 16 get_num_vertices 0 4 3071 31 GeomPrimitive::get_num_vertices 0 1 544 320
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_vertices
//       Access: Published
//  Description: Returns the number of indices used by all the
//               primitives in this object.
////////////////////////////////////////////////////////////////////
55
inline int GeomPrimitive::get_num_vertices(void) const;

2082 10 get_vertex 0 4 3071 25 GeomPrimitive::get_vertex 0 1 545 267
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_vertex
//       Access: Published
//  Description: Returns the ith vertex index in the table.
////////////////////////////////////////////////////////////////////
50
inline int GeomPrimitive::get_vertex(int i) const;

2083 10 add_vertex 0 4 3071 25 GeomPrimitive::add_vertex 0 1 546 780
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_vertex
//       Access: Published
//  Description: Adds the indicated vertex to the list of vertex
//               indices used by the graphics primitive type.  To
//               define a primitive, you must call add_vertex() for
//               each vertex of the new primitive, and then call
//               close_primitive() after you have specified the last
//               vertex of each primitive.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
43
void GeomPrimitive::add_vertex(int vertex);

2084 12 add_vertices 0 4 3071 27 GeomPrimitive::add_vertices 0 3 547 548 549 769
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_vertices
//       Access: Public
//  Description: Adds several vertices in a row.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_vertices
//       Access: Public
//  Description: Adds several vertices in a row.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_vertices
//       Access: Public
//  Description: Adds several vertices in a row.
////////////////////////////////////////////////////////////////////
194
inline void GeomPrimitive::add_vertices(int v1, int v2);
inline void GeomPrimitive::add_vertices(int v1, int v2, int v3);
inline void GeomPrimitive::add_vertices(int v1, int v2, int v3, int v4);

2085 24 add_consecutive_vertices 0 4 3071 39 GeomPrimitive::add_consecutive_vertices 0 1 550 531
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_consecutive_vertices
//       Access: Published
//  Description: Adds a consecutive sequence of vertices, beginning at
//               start, to the primitive.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
74
void GeomPrimitive::add_consecutive_vertices(int start, int num_vertices);

2086 17 add_next_vertices 0 4 3071 32 GeomPrimitive::add_next_vertices 0 1 551 621
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_next_vertices
//       Access: Published
//  Description: Adds the next n vertices in sequence, beginning from
//               the last vertex added to the primitive + 1.
//
//               This is most useful when you are building up a
//               primitive and a GeomVertexData at the same time, and
//               you just want the primitive to reference the first n
//               vertices from the data, then the next n, and so on.
////////////////////////////////////////////////////////////////////
56
void GeomPrimitive::add_next_vertices(int num_vertices);

2087 20 reserve_num_vertices 0 4 3071 35 GeomPrimitive::reserve_num_vertices 0 1 552 1259
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::reserve_num_vertices
//       Access: Published
//  Description: This ensures that enough memory space for n vertices
//               is allocated, so that you may increase the number of
//               vertices to n without causing a new memory
//               allocation.  This is a performance optimization only;
//               it is especially useful when you know ahead of time
//               that you will be adding n vertices to the primitive.
//
//               Note that the total you specify here should also
//               include implicit vertices which may be added at each
//               close_primitive() call, according to
//               get_num_unused_vertices_per_primitive().
//
//               Note also that making this call will implicitly make
//               the primitive indexed if it is not already, which
//               could result in a performance *penalty*.  If you
//               would prefer not to lose the nonindexed nature of
//               your existing GeomPrimitives, check is_indexed()
//               before making this call.
////////////////////////////////////////////////////////////////////
59
void GeomPrimitive::reserve_num_vertices(int num_vertices);

2088 15 close_primitive 0 4 3071 30 GeomPrimitive::close_primitive 0 1 553 654
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::close_primitive
//       Access: Published
//  Description: Indicates that the previous n calls to add_vertex(),
//               since the last call to close_primitive(), have fully
//               defined a new primitive.  Returns true if successful,
//               false otherwise.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
42
bool GeomPrimitive::close_primitive(void);

2089 14 clear_vertices 0 4 3071 29 GeomPrimitive::clear_vertices 0 1 554 527
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::clear_vertices
//       Access: Published
//  Description: Removes all of the vertices and primitives from the
//               object, so they can be re-added.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
41
void GeomPrimitive::clear_vertices(void);

2090 15 offset_vertices 0 4 3071 30 GeomPrimitive::offset_vertices 0 2 555 556 1172
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::offset_vertices
//       Access: Published
//  Description: Adds the indicated offset to all vertices used by the
//               primitive.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::offset_vertices
//       Access: Published
//  Description: Adds the indicated offset to the indicated segment
//               of vertices used by the primitive.  Unlike the
//               other version of offset_vertices, this makes the
//               geometry indexed if it isn't already.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
125
void GeomPrimitive::offset_vertices(int offset);
void GeomPrimitive::offset_vertices(int offset, int begin_row, int end_row);

2091 15 make_nonindexed 0 4 3071 30 GeomPrimitive::make_nonindexed 0 1 557 466
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_nonindexed
//       Access: Published
//  Description: Converts the primitive from indexed to nonindexed by
//               duplicating vertices as necessary into the indicated
//               dest GeomVertexData.  Note: does not support
//               primitives with strip cut indices.
////////////////////////////////////////////////////////////////////
88
void GeomPrimitive::make_nonindexed(GeomVertexData *dest, GeomVertexData const *source);

2092 13 pack_vertices 0 4 3071 28 GeomPrimitive::pack_vertices 0 1 558 383
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::pack_vertices
//       Access: Published
//  Description: Packs the vertices used by the primitive from the
//               indicated source array onto the end of the indicated
//               destination array.
////////////////////////////////////////////////////////////////////
86
void GeomPrimitive::pack_vertices(GeomVertexData *dest, GeomVertexData const *source);

2093 12 make_indexed 0 4 3071 27 GeomPrimitive::make_indexed 0 1 559 817
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_indexed
//       Access: Published
//  Description: Converts the primitive from nonindexed form to
//               indexed form.  This will simply create an index table
//               that is numbered consecutively from
//               get_first_vertex(); it does not automatically
//               collapse together identical vertices that may have
//               been split apart by a previous call to
//               make_nonindexed().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
39
void GeomPrimitive::make_indexed(void);

2094 18 get_num_primitives 0 4 3071 33 GeomPrimitive::get_num_primitives 0 1 560 372
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_primitives
//       Access: Published
//  Description: Returns the number of individual primitives stored
//               within this object.  All primitives are the same
//               type.
////////////////////////////////////////////////////////////////////
57
inline int GeomPrimitive::get_num_primitives(void) const;

2095 19 get_primitive_start 0 4 3071 34 GeomPrimitive::get_primitive_start 0 1 561 798
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_start
//       Access: Published
//  Description: Returns the element within the _vertices list at which
//               the nth primitive starts.
//
//               If i is one more than the highest valid primitive
//               vertex, the return value will be one more than the
//               last valid vertex.  Thus, it is generally true that
//               the vertices used by a particular primitive i are the
//               set get_primitive_start(n) <= vi <
//               get_primitive_start(n + 1) (although this range also
//               includes the unused vertices between primitives).
////////////////////////////////////////////////////////////////////
52
int GeomPrimitive::get_primitive_start(int n) const;

2096 17 get_primitive_end 0 4 3071 32 GeomPrimitive::get_primitive_end 0 1 562 408
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_end
//       Access: Published
//  Description: Returns the element within the _vertices list at which
//               the nth primitive ends.  This is one past the last
//               valid element for the nth primitive.
////////////////////////////////////////////////////////////////////
50
int GeomPrimitive::get_primitive_end(int n) const;

2097 26 get_primitive_num_vertices 0 4 3071 41 GeomPrimitive::get_primitive_num_vertices 0 1 563 406
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_num_vertices
//       Access: Published
//  Description: Returns the number of vertices used by the nth
//               primitive.  This is the same thing as
//               get_primitive_end(n) - get_primitive_start(n).
////////////////////////////////////////////////////////////////////
59
int GeomPrimitive::get_primitive_num_vertices(int n) const;

2098 21 get_num_used_vertices 0 4 3071 36 GeomPrimitive::get_num_used_vertices 0 1 564 579
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_used_vertices
//       Access: Published
//  Description: Returns the number of vertices used by all of the
//               primitives.  This is the same as summing
//               get_primitive_num_vertices(n) for n in
//               get_num_primitives().  It is like get_num_vertices
//               except that it excludes all of the degenerate
//               vertices and strip-cut indices.
////////////////////////////////////////////////////////////////////
53
int GeomPrimitive::get_num_used_vertices(void) const;

2099 13 get_num_faces 0 4 3071 28 GeomPrimitive::get_num_faces 0 1 565 393
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_faces
//       Access: Published
//  Description: Returns the number of triangles or other fundamental
//               type (such as line segments) represented by all the
//               primitives in this object.
////////////////////////////////////////////////////////////////////
52
inline int GeomPrimitive::get_num_faces(void) const;

2100 23 get_primitive_num_faces 0 4 3071 38 GeomPrimitive::get_primitive_num_faces 0 1 566 402
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_num_faces
//       Access: Published
//  Description: Returns the number of triangles or other fundamental
//               type (such as line segments) represented by the nth
//               primitive in this object.
////////////////////////////////////////////////////////////////////
63
inline int GeomPrimitive::get_primitive_num_faces(int n) const;

2101 14 get_min_vertex 0 4 3071 29 GeomPrimitive::get_min_vertex 0 1 567 328
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_min_vertex
//       Access: Published
//  Description: Returns the minimum vertex index number used by all
//               the primitives in this object.
////////////////////////////////////////////////////////////////////
53
inline int GeomPrimitive::get_min_vertex(void) const;

2102 24 get_primitive_min_vertex 0 4 3071 39 GeomPrimitive::get_primitive_min_vertex 0 1 568 337
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_min_vertex
//       Access: Published
//  Description: Returns the minimum vertex index number used by the
//               nth primitive in this object.
////////////////////////////////////////////////////////////////////
57
int GeomPrimitive::get_primitive_min_vertex(int n) const;

2103 14 get_max_vertex 0 4 3071 29 GeomPrimitive::get_max_vertex 0 1 569 328
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_max_vertex
//       Access: Published
//  Description: Returns the maximum vertex index number used by all
//               the primitives in this object.
////////////////////////////////////////////////////////////////////
53
inline int GeomPrimitive::get_max_vertex(void) const;

2104 24 get_primitive_max_vertex 0 4 3071 39 GeomPrimitive::get_primitive_max_vertex 0 1 570 337
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_max_vertex
//       Access: Published
//  Description: Returns the maximum vertex index number used by the
//               nth primitive in this object.
////////////////////////////////////////////////////////////////////
57
int GeomPrimitive::get_primitive_max_vertex(int n) const;

2105 9 decompose 0 4 3071 24 GeomPrimitive::decompose 0 1 571 795
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::decompose
//       Access: Published
//  Description: Decomposes a complex primitive type into a simpler
//               primitive type, for instance triangle strips to
//               triangles, and returns a pointer to the new primitive
//               definition.  If the decomposition cannot be
//               performed, this might return the original object.
//
//               This method is useful for application code that wants
//               to iterate through the set of triangles on the
//               primitive without having to write handlers for each
//               possible kind of primitive type.
////////////////////////////////////////////////////////////////////
69
ConstPointerTo< GeomPrimitive > GeomPrimitive::decompose(void) const;

2106 6 rotate 0 4 3071 21 GeomPrimitive::rotate 0 1 572 739
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::rotate
//       Access: Published
//  Description: Returns a new primitive with the shade_model reversed
//               (if it is flat shaded), if possible.  If the
//               primitive type cannot be rotated, returns the
//               original primitive, unrotated.
//
//               If the current shade_model indicates
//               flat_vertex_last, this should bring the last vertex
//               to the first position; if it indicates
//               flat_vertex_first, this should bring the first vertex
//               to the last position.
////////////////////////////////////////////////////////////////////
66
ConstPointerTo< GeomPrimitive > GeomPrimitive::rotate(void) const;

2107 10 doubleside 0 4 3071 25 GeomPrimitive::doubleside 0 1 573 842
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::doubleside
//       Access: Published
//  Description: Duplicates triangles in the primitive so that each
//               triangle is back-to-back with another triangle facing
//               in the opposite direction.  Note that this doesn't
//               affect vertex normals, so this operation alone won't
//               work in the presence of lighting (but see
//               SceneGraphReducer::doubleside()).
//
//               Also see CullFaceAttrib, which can enable rendering
//               of both sides of a triangle without having to
//               duplicate it (but which doesn't necessarily work in
//               the presence of lighting).
////////////////////////////////////////////////////////////////////
70
ConstPointerTo< GeomPrimitive > GeomPrimitive::doubleside(void) const;

2108 7 reverse 0 4 3071 22 GeomPrimitive::reverse 0 1 574 823
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::reverse
//       Access: Published
//  Description: Reverses the winding order in the primitive so that
//               each triangle is facing in the opposite direction it
//               was originally.  Note that this doesn't affect vertex
//               normals, so this operation alone won't work in the
//               presence of lighting (but see
//               SceneGraphReducer::reverse()).
//
//               Also see CullFaceAttrib, which can change the visible
//               direction of a triangle without having to duplicate
//               it (but which doesn't necessarily work in the
//               presence of lighting).
////////////////////////////////////////////////////////////////////
67
ConstPointerTo< GeomPrimitive > GeomPrimitive::reverse(void) const;

2109 17 match_shade_model 0 4 3071 32 GeomPrimitive::match_shade_model 0 1 575 672
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::match_shade_model
//       Access: Published
//  Description: Returns a new primitive that is compatible with the
//               indicated shade model, if possible, or NULL if this
//               is not possible.
//
//               In most cases, this will return either NULL or the
//               original primitive.  In the case of a
//               SM_flat_first_vertex vs. a SM_flat_last_vertex (or
//               vice-versa), however, it will return a rotated
//               primitive.
////////////////////////////////////////////////////////////////////
106
ConstPointerTo< GeomPrimitive > GeomPrimitive::match_shade_model(GeomEnums::ShadeModel shade_model) const;

2110 11 make_points 0 4 3071 26 GeomPrimitive::make_points 0 1 576 519
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_points
//       Access: Published
//  Description: Returns a new GeomPoints primitive that represents
//               each of the vertices in the original primitive,
//               rendered exactly once.  If the original primitive is
//               already a GeomPoints primitive, returns the original
//               primitive unchanged.
////////////////////////////////////////////////////////////////////
71
ConstPointerTo< GeomPrimitive > GeomPrimitive::make_points(void) const;

2111 10 make_lines 0 4 3071 25 GeomPrimitive::make_lines 0 1 577 509
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_lines
//       Access: Published
//  Description: Returns a new GeomLines primitive that represents
//               each of the edges in the original primitive rendered
//               as a line.  If the original primitive is already a
//               GeomLines primitive, returns the original primitive
//               unchanged.
////////////////////////////////////////////////////////////////////
70
ConstPointerTo< GeomPrimitive > GeomPrimitive::make_lines(void) const;

2112 12 make_patches 0 4 3071 27 GeomPrimitive::make_patches 0 1 578 738
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_patches
//       Access: Published
//  Description: Decomposes a complex primitive type into a simpler
//               primitive type, for instance triangle strips to
//               triangles, puts these in a new GeomPatches object
//               and returns a pointer to the new primitive
//               definition.  If the decomposition cannot be
//               performed, this might return the original object.
//
//               This method is useful for application code that wants
//               to use tesselation shaders on arbitrary geometry.
////////////////////////////////////////////////////////////////////
72
ConstPointerTo< GeomPrimitive > GeomPrimitive::make_patches(void) const;

2113 13 get_num_bytes 0 4 3071 28 GeomPrimitive::get_num_bytes 0 1 579 322
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_bytes
//       Access: Published
//  Description: Returns the number of bytes consumed by the primitive
//               and its index table(s).
////////////////////////////////////////////////////////////////////
45
int GeomPrimitive::get_num_bytes(void) const;

2114 19 get_data_size_bytes 0 4 3071 34 GeomPrimitive::get_data_size_bytes 0 1 580 308
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_data_size_bytes
//       Access: Published
//  Description: Returns the number of bytes stored in the vertices
//               array.
////////////////////////////////////////////////////////////////////
58
inline int GeomPrimitive::get_data_size_bytes(void) const;

2115 12 get_modified 0 4 3071 27 GeomPrimitive::get_modified 0 1 581 372
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the vertex index array is
//               modified.
////////////////////////////////////////////////////////////////////
57
inline UpdateSeq GeomPrimitive::get_modified(void) const;

2116 16 request_resident 0 4 3071 31 GeomPrimitive::request_resident 0 1 582 451
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::request_resident
//       Access: Published
//  Description: Returns true if the primitive data is currently
//               resident in memory.  If this returns false, the
//               primitive data will be brought back into memory
//               shortly; try again later.
////////////////////////////////////////////////////////////////////
49
bool GeomPrimitive::request_resident(void) const;

2117 11 check_valid 0 4 3071 26 GeomPrimitive::check_valid 0 1 583 455
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::check_valid
//       Access: Published
//  Description: Verifies that the primitive only references vertices
//               that actually exist within the indicated
//               GeomVertexData.  Returns true if the primitive
//               appears to be valid, false otherwise.
////////////////////////////////////////////////////////////////////
80
inline bool GeomPrimitive::check_valid(GeomVertexData const *vertex_data) const;

2118 6 output 0 6 3071 21 GeomPrimitive::output 0 1 584 229
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::output
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
55
virtual void GeomPrimitive::output(ostream &out) const;

2119 5 write 0 6 3071 20 GeomPrimitive::write 0 1 585 228
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::write
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
72
virtual void GeomPrimitive::write(ostream &out, int indent_level) const;

2120 12 get_vertices 0 4 3071 27 GeomPrimitive::get_vertices 0 1 586 812
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_vertices
//       Access: Published
//  Description: Returns a const pointer to the vertex index array so
//               application code can read it directly.  This might
//               return NULL if the primitive is nonindexed.  Do not
//               attempt to modify the returned array; use
//               modify_vertices() or set_vertices() for this.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
85
inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_vertices(void) const;

2121 15 modify_vertices 0 4 3071 30 GeomPrimitive::modify_vertices 0 1 587 1321
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::modify_vertices
//       Access: Published
//  Description: Returns a modifiable pointer to the vertex index
//               list, so application code can directly fiddle with
//               this data.  Use with caution, since there are no
//               checks that the data will be left in a stable state.
//
//               If this is called on a nonindexed primitive, it will
//               implicitly be converted to an indexed primitive.
//
//               If num_vertices is not -1, it specifies an artificial
//               limit to the number of vertices in the array.
//               Otherwise, all of the vertices in the array will be
//               used.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
87
PointerTo< GeomVertexArrayData > GeomPrimitive::modify_vertices(int num_vertices = -1);

2122 12 set_vertices 0 4 3071 27 GeomPrimitive::set_vertices 0 1 588 1115
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_vertices
//       Access: Published
//  Description: Completely replaces the vertex index list with a new
//               table.  Chances are good that you should also replace
//               the ends list with set_ends() at the same time.
//
//               If num_vertices is not -1, it specifies an artificial
//               limit to the number of vertices in the array.
//               Otherwise, all of the vertices in the array will be
//               used.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
93
void GeomPrimitive::set_vertices(GeomVertexArrayData const *vertices, int num_vertices = -1);

2123 23 set_nonindexed_vertices 0 4 3071 38 GeomPrimitive::set_nonindexed_vertices 0 1 589 808
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_nonindexed_vertices
//       Access: Published
//  Description: Sets the primitive up as a nonindexed primitive,
//               using the indicated vertex range.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
80
void GeomPrimitive::set_nonindexed_vertices(int first_vertex, int num_vertices);

2124 16 get_index_stride 0 4 3071 31 GeomPrimitive::get_index_stride 0 1 590 642
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_index_stride
//       Access: Published
//  Description: A convenience function to return the gap between
//               successive index numbers, in bytes, of the index
//               data.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
55
inline int GeomPrimitive::get_index_stride(void) const;

2125 19 get_strip_cut_index 0 4 3071 34 GeomPrimitive::get_strip_cut_index 0 1 591 1010
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_strip_cut_index
//       Access: Published
//  Description: If relevant, returns the index value that may be
//               used in some cases to signify the end of a
//               primitive.  This is typically the highest value
//               that the numeric type can store.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_strip_cut_index
//       Access: Private, Static
//  Description: Returns the index of the indicated type that is
//               reserved for use as a strip cut index, if enabled
//               for the primitive.  When the renderer encounters
//               this index, it will restart the primitive.  This
//               is guaranteed not to point to an actual vertex.
////////////////////////////////////////////////////////////////////
58
inline int GeomPrimitive::get_strip_cut_index(void) const;

2126 8 get_ends 0 4 3071 23 GeomPrimitive::get_ends 0 1 592 936
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_ends
//       Access: Published
//  Description: Returns a const pointer to the primitive ends
//               array so application code can read it directly.  Do
//               not attempt to modify the returned array; use
//               modify_ends() or set_ends() for this.
//
//               Note that simple primitive types, like triangles, do
//               not have a ends array: since all the primitives
//               have the same number of vertices, it is not needed.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
52
inline CPTA_int GeomPrimitive::get_ends(void) const;

2127 11 modify_ends 0 4 3071 26 GeomPrimitive::modify_ends 0 1 593 1159
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::modify_ends
//       Access: Published
//  Description: Returns a modifiable pointer to the primitive ends
//               array, so application code can directly fiddle with
//               this data.  Use with caution, since there are no
//               checks that the data will be left in a stable state.
//
//               Note that simple primitive types, like triangles, do
//               not have a ends array: since all the primitives
//               have the same number of vertices, it is not needed.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
41
PTA_int GeomPrimitive::modify_ends(void);

2128 8 set_ends 0 4 3071 23 GeomPrimitive::set_ends 0 1 594 1117
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_ends
//       Access: Published
//  Description: Completely replaces the primitive ends array with
//               a new table.  Chances are good that you should also
//               replace the vertices list with set_vertices() at the
//               same time.
//
//               Note that simple primitive types, like triangles, do
//               not have a ends array: since all the primitives
//               have the same number of vertices, it is not needed.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
44
void GeomPrimitive::set_ends(CPTA_int ends);

2129 8 get_mins 0 4 3071 23 GeomPrimitive::get_mins 0 1 595 827
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_mins
//       Access: Published
//  Description: Returns a const pointer to the primitive mins
//               array so application code can read it directly.  Do
//               not attempt to modify the returned array; use
//               set_minmax() for this.
//
//               Note that simple primitive types, like triangles, do
//               not have a mins array.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
81
inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_mins(void) const;

2130 8 get_maxs 0 4 3071 23 GeomPrimitive::get_maxs 0 1 596 818
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_maxs
//       Access: Published
//  Description: Returns a const pointer to the primitive maxs
//               array so application code can read it directly.  Do
//               not attempt to modify the returned array; use
//               set_minmax().
//
//               Note that simple primitive types, like triangles, do
//               not have a maxs array.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
81
inline ConstPointerTo< GeomVertexArrayData > GeomPrimitive::get_maxs(void) const;

2131 10 set_minmax 0 4 3071 25 GeomPrimitive::set_minmax 0 1 597 1093
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_minmax
//       Access: Published
//  Description: Explicitly specifies the minimum and maximum
//               vertices, as well as the lists of per-component min
//               and max.
//
//               Use this method with extreme caution.  It's generally
//               better to let the GeomPrimitive compute these
//               explicitly, unless for some reason you can do it
//               faster and you absolutely need the speed improvement.
//
//               Note that any modification to the vertex array will
//               normally cause this to be recomputed, unless you set
//               it immediately again.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
117
void GeomPrimitive::set_minmax(int min_vertex, int max_vertex, GeomVertexArrayData *mins, GeomVertexArrayData *maxs);

2132 12 clear_minmax 0 4 3071 27 GeomPrimitive::clear_minmax 0 1 598 643
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::clear_minmax
//       Access: Published
//  Description: Undoes a previous call to set_minmax(), and allows
//               the minimum and maximum values to be recomputed
//               normally.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
39
void GeomPrimitive::clear_minmax(void);

2133 30 get_num_vertices_per_primitive 0 6 3071 45 GeomPrimitive::get_num_vertices_per_primitive 0 1 599 948
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_vertices_per_primitive
//       Access: Published, Virtual
//  Description: If the primitive type is a simple type in which all
//               primitives have the same number of vertices, like
//               triangles, returns the number of vertices per
//               primitive.  If the primitive type is a more complex
//               type in which different primitives might have
//               different numbers of vertices, for instance a
//               triangle strip, returns 0.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
70
virtual int GeomPrimitive::get_num_vertices_per_primitive(void) const;

2134 34 get_min_num_vertices_per_primitive 0 6 3071 49 GeomPrimitive::get_min_num_vertices_per_primitive 0 1 600 654
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_min_num_vertices_per_primitive
//       Access: Published, Virtual
//  Description: Returns the minimum number of vertices that must be
//               added before close_primitive() may legally be called.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
74
virtual int GeomPrimitive::get_min_num_vertices_per_primitive(void) const;

2135 37 get_num_unused_vertices_per_primitive 0 6 3071 52 GeomPrimitive::get_num_unused_vertices_per_primitive 0 1 601 845
////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_unused_vertices_per_primitive
//       Access: Published, Virtual
//  Description: Returns the number of vertices that are added between
//               primitives that aren't, strictly speaking, part of
//               the primitives themselves.  This is used, for
//               instance, to define degenerate triangles to connect
//               otherwise disconnected triangle strips.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
////////////////////////////////////////////////////////////////////
77
virtual int GeomPrimitive::get_num_unused_vertices_per_primitive(void) const;

2136 14 get_class_type 0 4 3071 29 GeomPrimitive::get_class_type 0 1 602 0
54
static TypeHandle GeomPrimitive::get_class_type(void);

2137 12 TextureStage 0 4 3072 26 TextureStage::TextureStage 0 2 607 608 540
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::Copy Constructor
//       Access: Published
//  Description: Initialize the texture stage from other
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TextureStage::Constructor
//       Access: Published
//  Description: Initialize the texture stage at construction
////////////////////////////////////////////////////////////////////
111
explicit TextureStage::TextureStage(string const &name);
inline TextureStage::TextureStage(TextureStage &copy);

2138 10 operator = 0 4 3072 24 TextureStage::operator = 0 1 609 0
56
void TextureStage::operator =(TextureStage const &copy);

2139 8 set_name 0 4 3072 22 TextureStage::set_name 0 1 610 260
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_name
//       Access: Published
//  Description: Changes the name of this texture stage
////////////////////////////////////////////////////////////////////
55
inline void TextureStage::set_name(string const &name);

2140 8 get_name 0 4 3072 22 TextureStage::get_name 0 1 611 260
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_name
//       Access: Published
//  Description: Returns the name of this texture stage
////////////////////////////////////////////////////////////////////
56
inline string const &TextureStage::get_name(void) const;

2141 8 set_sort 0 4 3072 22 TextureStage::set_sort 0 1 612 768
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_sort
//       Access: Published
//  Description: Changes the order in which the texture associated
//               with this stage is rendered relative to the other
//               texture stages.  When geometry is rendered with
//               multiple textures, the textures are rendered in order
//               from the lowest sort number to the highest sort
//               number.
//
//               Also see set_priority(), which is used to select the
//               most important textures for rendering when some must
//               be omitted because of hardware limitations.
////////////////////////////////////////////////////////////////////
45
inline void TextureStage::set_sort(int sort);

2142 8 get_sort 0 4 3072 22 TextureStage::get_sort 0 1 613 267
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_sort
//       Access: Published
//  Description: Returns the sort order of this texture stage.
////////////////////////////////////////////////////////////////////
46
inline int TextureStage::get_sort(void) const;

2143 12 set_priority 0 4 3072 26 TextureStage::set_priority 0 1 614 919
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_priority
//       Access: Published
//  Description: Changes the relative importance of the texture
//               associated with this stage relative to the other
//               texture stages that are applied simultaneously.
//
//               This is unrelated to set_sort(), which controls the
//               order in which multiple textures are applied.  The
//               priority number is used to decide which of the
//               requested textures are to be selected for rendering
//               when more textures are requested than the hardware
//               will support.  The highest-priority n textures are
//               selected for rendering, and then rendered in order by
//               their sort factor.
////////////////////////////////////////////////////////////////////
53
inline void TextureStage::set_priority(int priority);

2144 12 get_priority 0 4 3072 26 TextureStage::get_priority 0 1 615 406
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_priority
//       Access: Published
//  Description: Returns the priority associated with this stage.
//
//               This is specially helpful for cards that do not
//               support more than n stages of multi-texturing.
////////////////////////////////////////////////////////////////////
50
inline int TextureStage::get_priority(void) const;

2145 17 set_texcoord_name 0 4 3072 31 TextureStage::set_texcoord_name 0 2 616 617 826
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_texcoord_name
//       Access: Published
//  Description: Indicate which set of UV's this texture stage will
//               use.  Geometry may have any number of associated UV
//               sets, each of which must have a unique name.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_texcoord_name
//       Access: Published
//  Description: Indicate which set of UV's this texture stage will
//               use.  Geometry may have any number of associated UV
//               sets, each of which must have a unique name.
////////////////////////////////////////////////////////////////////
138
inline void TextureStage::set_texcoord_name(InternalName *name);
inline void TextureStage::set_texcoord_name(string const &texcoord_name);

2146 17 get_texcoord_name 0 4 3072 31 TextureStage::get_texcoord_name 0 1 618 316
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_texcoord_name
//       Access: Published
//  Description: See set_texcoord_name.  The default is
//               InternalName::get_texcoord().
////////////////////////////////////////////////////////////////////
65
inline InternalName *TextureStage::get_texcoord_name(void) const;

2147 16 get_tangent_name 0 4 3072 30 TextureStage::get_tangent_name 0 1 619 403
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_tangent_name
//       Access: Published
//  Description: Returns the set of tangents this texture stage will
//               use.  This is the same as get_texcoord_name(),
//               except that the first part is "tangent".
////////////////////////////////////////////////////////////////////
64
inline InternalName *TextureStage::get_tangent_name(void) const;

2148 17 get_binormal_name 0 4 3072 31 TextureStage::get_binormal_name 0 1 620 406
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_binormal_name
//       Access: Published
//  Description: Returns the set of binormals this texture stage will
//               use.  This is the same as get_binormal_name(),
//               except that the first part is "binormal".
////////////////////////////////////////////////////////////////////
65
inline InternalName *TextureStage::get_binormal_name(void) const;

2149 8 set_mode 0 4 3072 22 TextureStage::set_mode 0 1 621 256
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_mode
//       Access: Published
//  Description: Set the mode of this texture stage
////////////////////////////////////////////////////////////////////
60
inline void TextureStage::set_mode(TextureStage::Mode mode);

2150 8 get_mode 0 4 3072 22 TextureStage::get_mode 0 1 622 251
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_mode
//       Access: Published
//  Description: Return the mode of this stage
////////////////////////////////////////////////////////////////////
61
inline TextureStage::Mode TextureStage::get_mode(void) const;

2151 17 is_fixed_function 0 4 3072 31 TextureStage::is_fixed_function 0 1 623 416
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::is_fixed_function
//       Access: Published
//  Description: Returns true if the TextureStage is relevant to
//               the classic fixed function pipeline.  This excludes
//               texture stages such as normal mapping and the like.
////////////////////////////////////////////////////////////////////
56
inline bool TextureStage::is_fixed_function(void) const;

2152 9 set_color 0 4 3072 23 TextureStage::set_color 0 1 624 251
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_color
//       Access: Published
//  Description: Set the color for this stage
////////////////////////////////////////////////////////////////////
57
inline void TextureStage::set_color(LColor const &color);

2153 9 get_color 0 4 3072 23 TextureStage::get_color 0 1 625 254
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_color
//       Access: Published
//  Description: return the color for this stage
////////////////////////////////////////////////////////////////////
50
inline LColor TextureStage::get_color(void) const;

2154 13 set_rgb_scale 0 4 3072 27 TextureStage::set_rgb_scale 0 1 626 490
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_rgb_scale
//       Access: Published
//  Description: Sets an additional factor that will scale all three
//               r, g, b components after the texture has been
//               applied.  This is used only when the mode is
//               CM_combine.
//
//               The only legal values are 1, 2, or 4.
////////////////////////////////////////////////////////////////////
55
inline void TextureStage::set_rgb_scale(int rgb_scale);

2155 13 get_rgb_scale 0 4 3072 27 TextureStage::get_rgb_scale 0 1 627 247
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_rgb_scale
//       Access: Published
//  Description: See set_rgb_scale().
////////////////////////////////////////////////////////////////////
51
inline int TextureStage::get_rgb_scale(void) const;

2156 15 set_alpha_scale 0 4 3072 29 TextureStage::set_alpha_scale 0 1 628 465
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_alpha_scale
//       Access: Published
//  Description: Sets an additional factor that will scale the
//               alpha component after the texture has been applied.
//               This is used only when the mode is CM_combine.
//
//               The only legal values are 1, 2, or 4.
////////////////////////////////////////////////////////////////////
59
inline void TextureStage::set_alpha_scale(int alpha_scale);

2157 15 get_alpha_scale 0 4 3072 29 TextureStage::get_alpha_scale 0 1 629 251
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_alpha_scale
//       Access: Published
//  Description: See set_alpha_scale().
////////////////////////////////////////////////////////////////////
53
inline int TextureStage::get_alpha_scale(void) const;

2158 16 set_saved_result 0 4 3072 30 TextureStage::set_saved_result 0 1 630 825
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_saved_result
//       Access: Published
//  Description: Sets the saved_result flag.  When this is true, the
//               output of this stage will be supplied as the
//               "last_saved_result" source for any future stages,
//               until the next TextureStage with a saved_result set
//               true is encountered.
//
//               This can be used to reuse the results of this texture
//               stage as input to more than one stage later in the
//               pipeline.
//
//               The last texture in the pipeline (the one with the
//               highest sort value) should not have this flag set.
////////////////////////////////////////////////////////////////////
62
inline void TextureStage::set_saved_result(bool saved_result);

2159 16 get_saved_result 0 4 3072 30 TextureStage::get_saved_result 0 1 631 324
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_saved_result
//       Access: Published
//  Description: Returns the current setting of the saved_result flag.
//               See set_saved_result().
////////////////////////////////////////////////////////////////////
55
inline bool TextureStage::get_saved_result(void) const;

2160 19 set_tex_view_offset 0 4 3072 33 TextureStage::set_tex_view_offset 0 1 632 654
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_tex_view_offset
//       Access: Published
//  Description: Sets the tex_view_offset value.  This is used only
//               when a special multiview texture is bound to the
//               TextureStage, and it selects the particular view of
//               the texture that is to be used.
//
//               This value is added to the similar parameter on
//               DisplayRegion to derive the final texture view index
//               that is selected for rendering.
////////////////////////////////////////////////////////////////////
67
inline void TextureStage::set_tex_view_offset(int tex_view_offset);

2161 19 get_tex_view_offset 0 4 3072 33 TextureStage::get_tex_view_offset 0 1 633 328
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_tex_view_offset
//       Access: Published
//  Description: Returns the current setting of the tex_view_offset.
//               See set_tex_view_offset().
////////////////////////////////////////////////////////////////////
57
inline int TextureStage::get_tex_view_offset(void) const;

2162 15 set_combine_rgb 0 4 3072 29 TextureStage::set_combine_rgb 0 3 634 635 636 1213
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_rgb
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a one-parameter operation.  Specifically,
//               this is CM_replace only.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_rgb
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a two-parameter operation.  Specifically,
//               this is everything except for CM_replace and
//               CM_interpolate.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_rgb
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a one-parameter operation.  Specifically,
//               this is CM_interpolate only.
////////////////////////////////////////////////////////////////////
680
inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0);
inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1);
inline void TextureStage::set_combine_rgb(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1, TextureStage::CombineSource source2, TextureStage::CombineOperand operand2);

2163 20 get_combine_rgb_mode 0 4 3072 34 TextureStage::get_combine_rgb_mode 0 1 637 258
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_mode
//       Access: Published
//  Description: Get the combine_rgb_mode
////////////////////////////////////////////////////////////////////
80
inline TextureStage::CombineMode TextureStage::get_combine_rgb_mode(void) const;

2164 28 get_num_combine_rgb_operands 0 4 3072 42 TextureStage::get_num_combine_rgb_operands 0 1 638 401
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_num_combine_rgb_operands
//       Access: Published
//  Description: Returns the number of meaningful operands that may be
//               retrieved via get_combine_rgb_sourceN() and
//               get_combine_rgb_operandN().
////////////////////////////////////////////////////////////////////
66
inline int TextureStage::get_num_combine_rgb_operands(void) const;

2165 23 get_combine_rgb_source0 0 4 3072 37 TextureStage::get_combine_rgb_source0 0 1 639 268
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_source0
//       Access: Published
//  Description: Get source0 of combine_rgb_mode
////////////////////////////////////////////////////////////////////
85
inline TextureStage::CombineSource TextureStage::get_combine_rgb_source0(void) const;

2166 24 get_combine_rgb_operand0 0 4 3072 38 TextureStage::get_combine_rgb_operand0 0 1 640 270
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_operand0
//       Access: Published
//  Description: Get operand0 of combine_rgb_mode
////////////////////////////////////////////////////////////////////
87
inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand0(void) const;

2167 23 get_combine_rgb_source1 0 4 3072 37 TextureStage::get_combine_rgb_source1 0 1 641 268
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_source1
//       Access: Published
//  Description: Get source1 of combine_rgb_mode
////////////////////////////////////////////////////////////////////
85
inline TextureStage::CombineSource TextureStage::get_combine_rgb_source1(void) const;

2168 24 get_combine_rgb_operand1 0 4 3072 38 TextureStage::get_combine_rgb_operand1 0 1 642 270
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_operand1
//       Access: Published
//  Description: Get operand1 of combine_rgb_mode
////////////////////////////////////////////////////////////////////
87
inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand1(void) const;

2169 23 get_combine_rgb_source2 0 4 3072 37 TextureStage::get_combine_rgb_source2 0 1 643 268
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_source2
//       Access: Published
//  Description: Get source2 of combine_rgb_mode
////////////////////////////////////////////////////////////////////
85
inline TextureStage::CombineSource TextureStage::get_combine_rgb_source2(void) const;

2170 24 get_combine_rgb_operand2 0 4 3072 38 TextureStage::get_combine_rgb_operand2 0 1 644 270
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_operand2
//       Access: Published
//  Description: Get operand2 of combine_rgb_mode
////////////////////////////////////////////////////////////////////
87
inline TextureStage::CombineOperand TextureStage::get_combine_rgb_operand2(void) const;

2171 17 set_combine_alpha 0 4 3072 31 TextureStage::set_combine_alpha 0 3 645 646 647 1219
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_alpha
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a one-parameter operation.  Specifically,
//               this is CM_replace only.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_alpha
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a two-parameter operation.  Specifically,
//               this is everything except for CM_replace and
//               CM_interpolate.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_alpha
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a one-parameter operation.  Specifically,
//               this is CM_interpolate only.
////////////////////////////////////////////////////////////////////
686
inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0);
inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1);
inline void TextureStage::set_combine_alpha(TextureStage::CombineMode mode, TextureStage::CombineSource source0, TextureStage::CombineOperand operand0, TextureStage::CombineSource source1, TextureStage::CombineOperand operand1, TextureStage::CombineSource source2, TextureStage::CombineOperand operand2);

2172 22 get_combine_alpha_mode 0 4 3072 36 TextureStage::get_combine_alpha_mode 0 1 648 253
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha
//       Access: Published
//  Description: Get combine_alpha_mode
////////////////////////////////////////////////////////////////////
82
inline TextureStage::CombineMode TextureStage::get_combine_alpha_mode(void) const;

2173 30 get_num_combine_alpha_operands 0 4 3072 44 TextureStage::get_num_combine_alpha_operands 0 1 649 407
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_num_combine_alpha_operands
//       Access: Published
//  Description: Returns the number of meaningful operands that may be
//               retrieved via get_combine_alpha_sourceN() and
//               get_combine_alpha_operandN().
////////////////////////////////////////////////////////////////////
68
inline int TextureStage::get_num_combine_alpha_operands(void) const;

2174 25 get_combine_alpha_source0 0 4 3072 39 TextureStage::get_combine_alpha_source0 0 1 650 272
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_source0
//       Access: Published
//  Description: Get source0 of combine_alpha_mode
////////////////////////////////////////////////////////////////////
87
inline TextureStage::CombineSource TextureStage::get_combine_alpha_source0(void) const;

2175 26 get_combine_alpha_operand0 0 4 3072 40 TextureStage::get_combine_alpha_operand0 0 1 651 274
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_operand0
//       Access: Published
//  Description: Get operand0 of combine_alpha_mode
////////////////////////////////////////////////////////////////////
89
inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand0(void) const;

2176 25 get_combine_alpha_source1 0 4 3072 39 TextureStage::get_combine_alpha_source1 0 1 652 272
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_source1
//       Access: Published
//  Description: Get source1 of combine_alpha_mode
////////////////////////////////////////////////////////////////////
87
inline TextureStage::CombineSource TextureStage::get_combine_alpha_source1(void) const;

2177 26 get_combine_alpha_operand1 0 4 3072 40 TextureStage::get_combine_alpha_operand1 0 1 653 274
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_operand1
//       Access: Published
//  Description: Get operand1 of combine_alpha_mode
////////////////////////////////////////////////////////////////////
89
inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand1(void) const;

2178 25 get_combine_alpha_source2 0 4 3072 39 TextureStage::get_combine_alpha_source2 0 1 654 272
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_source2
//       Access: Published
//  Description: Get source2 of combine_alpha_mode
////////////////////////////////////////////////////////////////////
87
inline TextureStage::CombineSource TextureStage::get_combine_alpha_source2(void) const;

2179 26 get_combine_alpha_operand2 0 4 3072 40 TextureStage::get_combine_alpha_operand2 0 1 655 274
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_operand2
//       Access: Published
//  Description: Get operand2 of combine_alpha_mode
////////////////////////////////////////////////////////////////////
89
inline TextureStage::CombineOperand TextureStage::get_combine_alpha_operand2(void) const;

2180 20 involves_color_scale 0 4 3072 34 TextureStage::involves_color_scale 0 1 656 377
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::involves_color_scale
//       Access: Published
//  Description: Returns true if the TextureStage is affected by the
//               setting of the current ColorScaleAttrib, false
//               otherwise.
////////////////////////////////////////////////////////////////////
59
inline bool TextureStage::involves_color_scale(void) const;

2181 10 uses_color 0 4 3072 24 TextureStage::uses_color 0 1 657 364
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::uses_color
//       Access: Published
//  Description: Returns true if the TextureStage makes use of
//               whatever color is specified in set_color(), false
//               otherwise.
////////////////////////////////////////////////////////////////////
49
inline bool TextureStage::uses_color(void) const;

2182 18 uses_primary_color 0 4 3072 32 TextureStage::uses_primary_color 0 1 658 331
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::uses_primary_color
//       Access: Published
//  Description: Returns true if the TextureStage makes use of
//               the CS_primary_color combine source.
////////////////////////////////////////////////////////////////////
57
inline bool TextureStage::uses_primary_color(void) const;

2183 22 uses_last_saved_result 0 4 3072 36 TextureStage::uses_last_saved_result 0 1 659 335
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::uses_last_saved_result
//       Access: Published
//  Description: Returns true if the TextureStage makes use of
//               the CS_primary_color combine source.
////////////////////////////////////////////////////////////////////
61
inline bool TextureStage::uses_last_saved_result(void) const;

2184 11 operator == 0 4 3072 25 TextureStage::operator == 0 1 660 0
71
inline bool TextureStage::operator ==(TextureStage const &other) const;

2185 11 operator != 0 4 3072 25 TextureStage::operator != 0 1 661 0
71
inline bool TextureStage::operator !=(TextureStage const &other) const;

2186 10 operator < 0 4 3072 24 TextureStage::operator < 0 1 662 0
70
inline bool TextureStage::operator <(TextureStage const &other) const;

2187 10 compare_to 0 4 3072 24 TextureStage::compare_to 0 1 663 540
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this TextureStage
//               sorts before the other one, greater than zero if it
//               sorts after, or zero if they are equivalent.  The
//               sorting order is arbitrary and largely meaningless,
//               except to differentiate different stages.
////////////////////////////////////////////////////////////////////
62
int TextureStage::compare_to(TextureStage const &other) const;

2188 5 write 0 4 3072 19 TextureStage::write 0 1 664 256
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::Destructor
//       Access: Published
//  Description: Writes the details of this stage
////////////////////////////////////////////////////////////////////
45
void TextureStage::write(ostream &out) const;

2189 6 output 0 4 3072 20 TextureStage::output 0 1 665 249
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::Destructor
//       Access: Published
//  Description: Just a single line output
////////////////////////////////////////////////////////////////////
46
void TextureStage::output(ostream &out) const;

2190 11 get_default 0 4 3072 25 TextureStage::get_default 0 1 666 447
////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_default
//       Access: Published, Static
//  Description: Returns the default TextureStage that will be used
//               for all texturing that does not name a particular
//               stage.  This generally handles the normal
//               single-texture case.
////////////////////////////////////////////////////////////////////
60
static inline TextureStage *TextureStage::get_default(void);

2191 14 get_class_type 0 4 3072 28 TextureStage::get_class_type 0 1 667 0
53
static TypeHandle TextureStage::get_class_type(void);

2192 27 upcast_to_CopyOnWriteObject 0 12 3077 33 Geom::upcast_to_CopyOnWriteObject 0 1 730 37
upcast from Geom to CopyOnWriteObject
59
CopyOnWriteObject *Geom::upcast_to_CopyOnWriteObject(void);

2193 16 downcast_to_Geom 0 12 3056 35 CopyOnWriteObject::downcast_to_Geom 0 1 731 39
downcast from CopyOnWriteObject to Geom
48
Geom *CopyOnWriteObject::downcast_to_Geom(void);

2194 19 upcast_to_GeomEnums 0 12 3077 25 Geom::upcast_to_GeomEnums 0 1 732 29
upcast from Geom to GeomEnums
43
GeomEnums *Geom::upcast_to_GeomEnums(void);

2195 16 downcast_to_Geom 0 12 3029 27 GeomEnums::downcast_to_Geom 0 1 733 31
downcast from GeomEnums to Geom
40
Geom *GeomEnums::downcast_to_Geom(void);

2196 4 Geom 0 4 3077 10 Geom::Geom 0 1 668 476
////////////////////////////////////////////////////////////////////
//     Function: Geom::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Geom::Copy Constructor
//       Access: Protected
//  Description: Use make_copy() to duplicate a Geom.
////////////////////////////////////////////////////////////////////
48
explicit Geom::Geom(GeomVertexData const *data);

2197 10 operator = 0 4 3077 16 Geom::operator = 0 1 669 0
40
void Geom::operator =(Geom const &copy);

2198 5 ~Geom 0 6 3077 11 Geom::~Geom 0 0 224
////////////////////////////////////////////////////////////////////
//     Function: Geom::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
26
virtual Geom::~Geom(void);

2199 12 operator new 0 4 3077 18 Geom::operator new 0 1 670 0
102
inline void *Geom::operator new(size_t size);
inline void *Geom::operator new(size_t size, void *ptr);

2200 15 operator delete 0 4 3077 21 Geom::operator delete 0 0 0
96
inline void Geom::operator delete(void *ptr);
inline void Geom::operator delete(void *, void *);

2201 12 validate_ptr 0 4 3077 18 Geom::validate_ptr 0 0 0
55
static inline bool Geom::validate_ptr(void const *ptr);

2202 9 make_copy 0 6 3077 15 Geom::make_copy 0 1 671 458
////////////////////////////////////////////////////////////////////
//     Function: Geom::make_copy
//       Access: Protected, Virtual
//  Description: Returns a newly-allocated Geom that is a shallow copy
//               of this one.  It will be a different Geom pointer,
//               but its internal data may or may not be shared with
//               that of the original Geom.
////////////////////////////////////////////////////////////////////
42
virtual Geom *Geom::make_copy(void) const;

2203 18 get_primitive_type 0 4 3077 24 Geom::get_primitive_type 0 1 672 664
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_primitive_type
//       Access: Published
//  Description: Returns the fundamental primitive type that is common
//               to all GeomPrimitives added within the Geom.  All
//               nested primitives within a particular Geom must be
//               the same type (that is, you can mix triangles and
//               tristrips, because they are both the same fundamental
//               type PT_polygons, but you cannot mix triangles and
//               points withn the same Geom).
////////////////////////////////////////////////////////////////////
69
inline GeomEnums::PrimitiveType Geom::get_primitive_type(void) const;

2204 15 get_shade_model 0 4 3077 21 Geom::get_shade_model 0 1 673 359
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_shade_model
//       Access: Published
//  Description: Returns the shade model common to all of the
//               individual GeomPrimitives that have been added to the
//               geom.
////////////////////////////////////////////////////////////////////
63
inline GeomEnums::ShadeModel Geom::get_shade_model(void) const;

2205 18 get_geom_rendering 0 4 3077 24 Geom::get_geom_rendering 0 1 674 374
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_geom_rendering
//       Access: Published
//  Description: Returns the set of GeomRendering bits that represent
//               the rendering properties required to properly render
//               this Geom.
////////////////////////////////////////////////////////////////////
48
inline int Geom::get_geom_rendering(void) const;

2206 14 get_usage_hint 0 4 3077 20 Geom::get_usage_hint 0 1 675 381
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_usage_hint
//       Access: Published
//  Description: Returns the minimum (i.e. most dynamic) usage_hint
//               among all of the individual GeomPrimitives that have
//               been added to the geom.
////////////////////////////////////////////////////////////////////
61
inline GeomEnums::UsageHint Geom::get_usage_hint(void) const;

2207 14 set_usage_hint 0 4 3077 20 Geom::set_usage_hint 0 1 676 558
////////////////////////////////////////////////////////////////////
//     Function: Geom::set_usage_hint
//       Access: Published
//  Description: Changes the UsageHint hint for all of the primitives
//               on this Geom to the same value.  See
//               get_usage_hint().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
59
void Geom::set_usage_hint(GeomEnums::UsageHint usage_hint);

2208 15 get_vertex_data 0 4 3077 21 Geom::get_vertex_data 0 1 677 387
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_vertex_data
//       Access: Published
//  Description: Returns a const pointer to the GeomVertexData,
//               for application code to directly examine (but not
//               modify) the geom's underlying data.
////////////////////////////////////////////////////////////////////
117
inline ConstPointerTo< GeomVertexData > Geom::get_vertex_data(Thread *current_thread = (get_current_thread())) const;

2209 18 modify_vertex_data 0 4 3077 24 Geom::modify_vertex_data 0 1 678 583
////////////////////////////////////////////////////////////////////
//     Function: Geom::modify_vertex_data
//       Access: Published
//  Description: Returns a modifiable pointer to the GeomVertexData,
//               so that application code may directly maniuplate the
//               geom's underlying data.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
59
PointerTo< GeomVertexData > Geom::modify_vertex_data(void);

2210 15 set_vertex_data 0 4 3077 21 Geom::set_vertex_data 0 1 679 512
////////////////////////////////////////////////////////////////////
//     Function: Geom::set_vertex_data
//       Access: Published
//  Description: Replaces the Geom's underlying vertex data table with
//               a completely new table.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
55
void Geom::set_vertex_data(GeomVertexData const *data);

2211 15 offset_vertices 0 4 3077 21 Geom::offset_vertices 0 1 680 847
////////////////////////////////////////////////////////////////////
//     Function: Geom::offset_vertices
//       Access: Published
//  Description: Replaces a Geom's vertex table with a new table, and
//               simultaneously adds the indicated offset to all
//               vertex references within the Geom's primitives.  This
//               is intended to be used to combine multiple
//               GeomVertexDatas from different Geoms into a single
//               big buffer, with each Geom referencing a subset of
//               the vertices in the buffer.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
67
void Geom::offset_vertices(GeomVertexData const *data, int offset);

2212 15 make_nonindexed 0 4 3077 21 Geom::make_nonindexed 0 1 681 728
////////////////////////////////////////////////////////////////////
//     Function: Geom::make_nonindexed
//       Access: Published
//  Description: Converts the geom from indexed to nonindexed by
//               duplicating vertices as necessary.  If composite_only
//               is true, then only composite primitives such as
//               trifans and tristrips are converted.  Returns the
//               number of GeomPrimitive objects converted.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
47
int Geom::make_nonindexed(bool composite_only);

2213 8 is_empty 0 4 3077 14 Geom::is_empty 0 1 682 337
////////////////////////////////////////////////////////////////////
//     Function: Geom::is_empty
//       Access: Published
//  Description: Returns true if there appear to be no vertices to be
//               rendered by this Geom, false if has some actual data.
////////////////////////////////////////////////////////////////////
39
inline bool Geom::is_empty(void) const;

2214 18 get_num_primitives 0 4 3077 24 Geom::get_num_primitives 0 1 683 395
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_num_primitives
//       Access: Published
//  Description: Returns the number of GeomPrimitive objects stored
//               within the Geom, each of which represents a number of
//               primitives of a particular type.
////////////////////////////////////////////////////////////////////
48
inline int Geom::get_num_primitives(void) const;

2215 13 get_primitive 0 4 3077 19 Geom::get_primitive 0 1 684 464
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_primitive
//       Access: Published
//  Description: Returns a const pointer to the ith GeomPrimitive
//               object stored within the Geom.  Use this call only to
//               inspect the ith object; use modify_primitive() or
//               set_primitive() if you want to modify it.
////////////////////////////////////////////////////////////////////
72
inline ConstPointerTo< GeomPrimitive > Geom::get_primitive(int i) const;

2216 16 modify_primitive 0 4 3077 22 Geom::modify_primitive 0 1 685 632
////////////////////////////////////////////////////////////////////
//     Function: Geom::modify_primitive
//       Access: Published
//  Description: Returns a modifiable pointer to the ith GeomPrimitive
//               object stored within the Geom, so application code
//               can directly manipulate the properties of this
//               primitive.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
64
inline PointerTo< GeomPrimitive > Geom::modify_primitive(int i);

2217 13 set_primitive 0 4 3077 19 Geom::set_primitive 0 1 686 514
////////////////////////////////////////////////////////////////////
//     Function: Geom::set_primitive
//       Access: Published
//  Description: Replaces the ith GeomPrimitive object stored within
//               the Geom with the new object.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
64
void Geom::set_primitive(int i, GeomPrimitive const *primitive);

2218 13 add_primitive 0 4 3077 19 Geom::add_primitive 0 1 687 637
////////////////////////////////////////////////////////////////////
//     Function: Geom::add_primitive
//       Access: Published
//  Description: Adds a new GeomPrimitive structure to the Geom
//               object.  This specifies a particular subset of
//               vertices that are used to define geometric primitives
//               of the indicated type.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
57
void Geom::add_primitive(GeomPrimitive const *primitive);

2219 16 remove_primitive 0 4 3077 22 Geom::remove_primitive 0 1 688 459
////////////////////////////////////////////////////////////////////
//     Function: Geom::remove_primitive
//       Access: Published
//  Description: Removes the ith primitive from the list.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
35
void Geom::remove_primitive(int i);

2220 16 clear_primitives 0 4 3077 22 Geom::clear_primitives 0 1 689 633
////////////////////////////////////////////////////////////////////
//     Function: Geom::clear_primitives
//       Access: Published
//  Description: Removes all the primitives from the Geom object (but
//               keeps the same table of vertices).  You may then
//               re-add primitives one at a time via calls to
//               add_primitive().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
34
void Geom::clear_primitives(void);

2221 9 decompose 0 4 3077 15 Geom::decompose 0 1 690 354
////////////////////////////////////////////////////////////////////
//     Function: Geom::decompose
//       Access: Published
//  Description: Decomposes all of the primitives within this Geom,
//               returning the result.  See
//               GeomPrimitive::decompose().
////////////////////////////////////////////////////////////////////
53
inline PointerTo< Geom > Geom::decompose(void) const;

2222 10 doubleside 0 4 3077 16 Geom::doubleside 0 1 691 357
////////////////////////////////////////////////////////////////////
//     Function: Geom::doubleside
//       Access: Published
//  Description: Doublesides all of the primitives within this Geom,
//               returning the result.  See
//               GeomPrimitive::doubleside().
////////////////////////////////////////////////////////////////////
54
inline PointerTo< Geom > Geom::doubleside(void) const;

2223 7 reverse 0 4 3077 13 Geom::reverse 0 1 692 348
////////////////////////////////////////////////////////////////////
//     Function: Geom::reverse
//       Access: Published
//  Description: Reverses all of the primitives within this Geom,
//               returning the result.  See
//               GeomPrimitive::reverse().
////////////////////////////////////////////////////////////////////
51
inline PointerTo< Geom > Geom::reverse(void) const;

2224 6 rotate 0 4 3077 12 Geom::rotate 0 1 693 345
////////////////////////////////////////////////////////////////////
//     Function: Geom::rotate
//       Access: Published
//  Description: Rotates all of the primitives within this Geom,
//               returning the result.  See
//               GeomPrimitive::rotate().
////////////////////////////////////////////////////////////////////
50
inline PointerTo< Geom > Geom::rotate(void) const;

2225 5 unify 0 4 3077 11 Geom::unify 0 1 694 890
////////////////////////////////////////////////////////////////////
//     Function: Geom::unify
//       Access: Published
//  Description: Unifies all of the primitives contained within this
//               Geom into a single (or as few as possible, within the
//               constraints of max_indices) primitive objects.  This
//               may require decomposing the primitives if, for
//               instance, the Geom contains both triangle strips and
//               triangle fans.
//
//               max_indices represents the maximum number of indices
//               that will be put in any one GeomPrimitive.  If
//               preserve_order is true, then the primitives will not
//               be reordered during the operation, even if this
//               results in a suboptimal result.
////////////////////////////////////////////////////////////////////
81
inline PointerTo< Geom > Geom::unify(int max_indices, bool preserve_order) const;

2226 11 make_points 0 4 3077 17 Geom::make_points 0 1 695 319
////////////////////////////////////////////////////////////////////
//     Function: Geom::make_points
//       Access: Published
//  Description: Returns a new Geom with points at all the vertices.
//               See GeomPrimitive::make_points().
////////////////////////////////////////////////////////////////////
55
inline PointerTo< Geom > Geom::make_points(void) const;

2227 10 make_lines 0 4 3077 16 Geom::make_lines 0 1 696 313
////////////////////////////////////////////////////////////////////
//     Function: Geom::make_lines
//       Access: Published
//  Description: Returns a new Geom with lines at all the edges.
//               See GeomPrimitive::make_lines().
////////////////////////////////////////////////////////////////////
54
inline PointerTo< Geom > Geom::make_lines(void) const;

2228 12 make_patches 0 4 3077 18 Geom::make_patches 0 1 697 323
////////////////////////////////////////////////////////////////////
//     Function: Geom::make_patches
//       Access: Published
//  Description: Returns a new Geom with each primitive converted
//               into a patch.  Calls decompose() first.
////////////////////////////////////////////////////////////////////
56
inline PointerTo< Geom > Geom::make_patches(void) const;

2229 18 decompose_in_place 0 4 3077 24 Geom::decompose_in_place 0 1 698 568
////////////////////////////////////////////////////////////////////
//     Function: Geom::decompose_in_place
//       Access: Published
//  Description: Decomposes all of the primitives within this Geom,
//               leaving the results in place.  See
//               GeomPrimitive::decompose().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
36
void Geom::decompose_in_place(void);

2230 19 doubleside_in_place 0 4 3077 25 Geom::doubleside_in_place 0 1 699 571
////////////////////////////////////////////////////////////////////
//     Function: Geom::doubleside_in_place
//       Access: Published
//  Description: Doublesides all of the primitives within this Geom,
//               leaving the results in place.  See
//               GeomPrimitive::doubleside().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
37
void Geom::doubleside_in_place(void);

2231 16 reverse_in_place 0 4 3077 22 Geom::reverse_in_place 0 1 700 562
////////////////////////////////////////////////////////////////////
//     Function: Geom::reverse_in_place
//       Access: Published
//  Description: Reverses all of the primitives within this Geom,
//               leaving the results in place.  See
//               GeomPrimitive::reverse().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
34
void Geom::reverse_in_place(void);

2232 15 rotate_in_place 0 4 3077 21 Geom::rotate_in_place 0 1 701 559
////////////////////////////////////////////////////////////////////
//     Function: Geom::rotate_in_place
//       Access: Published
//  Description: Rotates all of the primitives within this Geom,
//               leaving the results in place.  See
//               GeomPrimitive::rotate().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
33
void Geom::rotate_in_place(void);

2233 14 unify_in_place 0 4 3077 20 Geom::unify_in_place 0 1 702 1096
////////////////////////////////////////////////////////////////////
//     Function: Geom::unify_in_place
//       Access: Published
//  Description: Unifies all of the primitives contained within this
//               Geom into a single (or as few as possible, within the
//               constraints of max_indices) primitive objects.  This
//               may require decomposing the primitives if, for
//               instance, the Geom contains both triangle strips and
//               triangle fans.
//
//               max_indices represents the maximum number of indices
//               that will be put in any one GeomPrimitive.  If
//               preserve_order is true, then the primitives will not
//               be reordered during the operation, even if this
//               results in a suboptimal result.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
64
void Geom::unify_in_place(int max_indices, bool preserve_order);

2234 20 make_points_in_place 0 4 3077 26 Geom::make_points_in_place 0 1 703 567
////////////////////////////////////////////////////////////////////
//     Function: Geom::make_points_in_place
//       Access: Published
//  Description: Replaces the GeomPrimitives within this Geom with
//               corresponding GeomPoints.  See
//               GeomPrimitive::make_points().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
38
void Geom::make_points_in_place(void);

2235 19 make_lines_in_place 0 4 3077 25 Geom::make_lines_in_place 0 1 704 608
////////////////////////////////////////////////////////////////////
//     Function: Geom::make_lines_in_place
//       Access: Published
//  Description: Replaces the GeomPrimitives within this Geom with
//               corresponding GeomLines, representing a wireframe
//               of the primitives.  See GeomPrimitive::make_lines().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
37
void Geom::make_lines_in_place(void);

2236 21 make_patches_in_place 0 4 3077 27 Geom::make_patches_in_place 0 1 705 570
////////////////////////////////////////////////////////////////////
//     Function: Geom::make_patches_in_place
//       Access: Published
//  Description: Replaces the GeomPrimitives within this Geom with
//               corresponding GeomPatches.  See
//               GeomPrimitive::make_patches().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
39
void Geom::make_patches_in_place(void);

2237 20 copy_primitives_from 0 6 3077 26 Geom::copy_primitives_from 0 1 706 792
////////////////////////////////////////////////////////////////////
//     Function: Geom::copy_primitives_from
//       Access: Published, Virtual
//  Description: Copies the primitives from the indicated Geom into
//               this one.  This does require that both Geoms contain
//               the same fundamental type primitives, both have a
//               compatible shade model, and both use the same
//               GeomVertexData.  Both Geoms must also be the same
//               specific class type (i.e. if one is a GeomTextGlyph,
//               they both must be.)
//
//               Returns true if the copy is successful, or false
//               otherwise (because the Geoms were mismatched).
////////////////////////////////////////////////////////////////////
59
virtual bool Geom::copy_primitives_from(Geom const *other);

2238 13 get_num_bytes 0 4 3077 19 Geom::get_num_bytes 0 1 707 341
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_num_bytes
//       Access: Published
//  Description: Returns the number of bytes consumed by the geom and
//               its primitives (but not including its vertex table).
////////////////////////////////////////////////////////////////////
36
int Geom::get_num_bytes(void) const;

2239 12 get_modified 0 4 3077 18 Geom::get_modified 0 1 708 564
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time any of the primitives in
//               the Geom is modified, or the set of primitives is
//               modified.  However, this does not include
//               modifications to the vertex data, which should be
//               tested separately.
////////////////////////////////////////////////////////////////////
91
inline UpdateSeq Geom::get_modified(Thread *current_thread = (get_current_thread())) const;

2240 16 request_resident 0 4 3077 22 Geom::request_resident 0 1 709 571
////////////////////////////////////////////////////////////////////
//     Function: Geom::request_resident
//       Access: Published
//  Description: Returns true if all the primitive arrays are
//               currently resident in memory.  If this returns false,
//               the data will be brought back into memory shortly;
//               try again later.
//
//               This does not also test the Geom's associated
//               GeomVertexData.  That must be tested separately.
////////////////////////////////////////////////////////////////////
40
bool Geom::request_resident(void) const;

2241 18 transform_vertices 0 4 3077 24 Geom::transform_vertices 0 1 710 808
////////////////////////////////////////////////////////////////////
//     Function: Geom::transform_vertices
//       Access: Published
//  Description: Applies the indicated transform to all of the
//               vertices in the Geom.  If the Geom happens to share a
//               vertex table with another Geom, this operation will
//               duplicate the vertex table instead of breaking the
//               other Geom; however, if multiple Geoms with shared
//               tables are transformed by the same matrix, they will
//               no longer share tables after the operation.  Consider
//               using the GeomTransformer if you will be applying the
//               same transform to multiple Geoms.
////////////////////////////////////////////////////////////////////
51
void Geom::transform_vertices(LMatrix4 const &mat);

2242 11 check_valid 0 4 3077 17 Geom::check_valid 0 2 711 712 925
////////////////////////////////////////////////////////////////////
//     Function: Geom::check_valid
//       Access: Published
//  Description: Verifies that the all of the primitives within the
//               geom reference vertices that actually exist within
//               the geom's GeomVertexData.  Returns true if the geom
//               appears to be valid, false otherwise.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Geom::check_valid
//       Access: Published
//  Description: Verifies that the all of the primitives within the
//               geom reference vertices that actually exist within
//               the indicated GeomVertexData.  Returns true if the
//               geom appears to be valid, false otherwise.
////////////////////////////////////////////////////////////////////
100
bool Geom::check_valid(void) const;
bool Geom::check_valid(GeomVertexData const *vertex_data) const;

2243 10 get_bounds 0 4 3077 16 Geom::get_bounds 0 1 713 257
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_bounds
//       Access: Published
//  Description: Returns the bounding volume for the Geom.
////////////////////////////////////////////////////////////////////
105
ConstPointerTo< BoundingVolume > Geom::get_bounds(Thread *current_thread = (get_current_thread())) const;

2244 19 get_nested_vertices 0 4 3077 25 Geom::get_nested_vertices 0 1 714 316
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_nested_vertices
//       Access: Published
//  Description: Returns the number of vertices rendered by all
//               primitives within the Geom.
////////////////////////////////////////////////////////////////////
85
int Geom::get_nested_vertices(Thread *current_thread = (get_current_thread())) const;

2245 17 mark_bounds_stale 0 4 3077 23 Geom::mark_bounds_stale 0 1 715 390
////////////////////////////////////////////////////////////////////
//     Function: Geom::mark_bounds_stale
//       Access: Published
//  Description: Marks the bounding volume of the Geom as stale so
//               that it should be recomputed.  Usually it is not
//               necessary to call this explicitly.
////////////////////////////////////////////////////////////////////
48
inline void Geom::mark_bounds_stale(void) const;

2246 15 set_bounds_type 0 4 3077 21 Geom::set_bounds_type 0 1 716 969
////////////////////////////////////////////////////////////////////
//     Function: Geom::set_bounds_type
//       Access: Published
//  Description: Specifies the desired type of bounding volume that
//               will be created for this Geom.  This is normally
//               BoundingVolume::BT_default, which means to set the
//               type according to the config variable "bounds-type".
//
//               If this is BT_sphere or BT_box, a BoundingSphere or
//               BoundingBox is explicitly created.  If it is BT_best,
//               a BoundingBox is created.
//
//               This affects the implicit bounding volume only.  If
//               an explicit bounding volume is set on the Geom with
//               set_bounds(), that bounding volume type is used.
//               (This is different behavior from the similar method
//               on PandaNode.)
////////////////////////////////////////////////////////////////////
74
inline void Geom::set_bounds_type(BoundingVolume::BoundsType bounds_type);

2247 15 get_bounds_type 0 4 3077 21 Geom::get_bounds_type 0 1 717 298
////////////////////////////////////////////////////////////////////
//     Function: Geom::get_bounds_type
//       Access: Published
//  Description: Returns the bounding volume type set with
//               set_bounds_type().
////////////////////////////////////////////////////////////////////
68
inline BoundingVolume::BoundsType Geom::get_bounds_type(void) const;

2248 10 set_bounds 0 4 3077 16 Geom::set_bounds 0 1 718 726
////////////////////////////////////////////////////////////////////
//     Function: Geom::set_bounds
//       Access: Published
//  Description: Resets the bounding volume so that it is the
//               indicated volume.  When it is explicitly set, the
//               bounding volume will no longer be automatically
//               computed; call clear_bounds() if you would like to
//               return the bounding volume to its default behavior.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
59
inline void Geom::set_bounds(BoundingVolume const *volume);

2249 12 clear_bounds 0 4 3077 18 Geom::clear_bounds 0 1 719 614
////////////////////////////////////////////////////////////////////
//     Function: Geom::clear_bounds
//       Access: Published
//  Description: Reverses the effect of a previous call to
//               set_bounds(), and allows the bounding volume to be
//               automatically computed once more based on the
//               vertices.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
37
inline void Geom::clear_bounds(void);

2250 6 output 0 6 3077 12 Geom::output 0 1 720 220
////////////////////////////////////////////////////////////////////
//     Function: Geom::output
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
46
virtual void Geom::output(ostream &out) const;

2251 5 write 0 6 3077 11 Geom::write 0 1 721 219
////////////////////////////////////////////////////////////////////
//     Function: Geom::write
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
67
virtual void Geom::write(ostream &out, int indent_level = 0) const;

2252 11 clear_cache 0 4 3077 17 Geom::clear_cache 0 1 722 546
////////////////////////////////////////////////////////////////////
//     Function: Geom::clear_cache
//       Access: Published
//  Description: Removes all of the previously-cached results of
//               munge_geom().
//
//               This blows away the entire cache, upstream and
//               downstream the pipeline.  Use clear_cache_stage()
//               instead if you only want to blow away the cache at
//               the current stage and upstream.
////////////////////////////////////////////////////////////////////
29
void Geom::clear_cache(void);

2253 17 clear_cache_stage 0 4 3077 23 Geom::clear_cache_stage 0 1 723 598
////////////////////////////////////////////////////////////////////
//     Function: Geom::clear_cache_stage
//       Access: Published
//  Description: Removes all of the previously-cached results of
//               munge_geom(), at the current pipeline stage and
//               upstream.  Does not affect the downstream cache.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
////////////////////////////////////////////////////////////////////
53
void Geom::clear_cache_stage(Thread *current_thread);

2254 7 prepare 0 4 3077 13 Geom::prepare 0 1 724 640
////////////////////////////////////////////////////////////////////
//     Function: Geom::prepare
//       Access: Published
//  Description: Indicates that the geom should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.  This will ensure the
//               geom is already loaded into geom memory if it
//               is expected to be rendered soon.
//
//               Use this function instead of prepare_now() to preload
//               geoms from a user interface standpoint.
////////////////////////////////////////////////////////////////////
62
void Geom::prepare(PreparedGraphicsObjects *prepared_objects);

2255 11 is_prepared 0 4 3077 17 Geom::is_prepared 0 1 725 368
////////////////////////////////////////////////////////////////////
//     Function: Geom::is_prepared
//       Access: Published
//  Description: Returns true if the geom has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
////////////////////////////////////////////////////////////////////
72
bool Geom::is_prepared(PreparedGraphicsObjects *prepared_objects) const;

2256 7 release 0 4 3077 13 Geom::release 0 1 726 388
////////////////////////////////////////////////////////////////////
//     Function: Geom::release
//       Access: Published
//  Description: Frees the geom context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
////////////////////////////////////////////////////////////////////
62
bool Geom::release(PreparedGraphicsObjects *prepared_objects);

2257 11 release_all 0 4 3077 17 Geom::release_all 0 1 727 386
////////////////////////////////////////////////////////////////////
//     Function: Geom::release_all
//       Access: Published
//  Description: Frees the context allocated on all objects for which
//               the geom has been declared.  Returns the number of
//               contexts which have been freed.
////////////////////////////////////////////////////////////////////
28
int Geom::release_all(void);

2258 11 prepare_now 0 4 3077 17 Geom::prepare_now 0 1 728 871
////////////////////////////////////////////////////////////////////
//     Function: Geom::prepare_now
//       Access: Public
//  Description: Creates a context for the geom on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) GeomContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               geoms.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a geom does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
////////////////////////////////////////////////////////////////////
106
GeomContext *Geom::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg);

2259 14 get_class_type 0 4 3077 20 Geom::get_class_type 0 1 729 0
45
static TypeHandle Geom::get_class_type(void);

2260 8 get_geom 0 4 3078 21 GeomContext::get_geom 0 1 734 220
////////////////////////////////////////////////////////////////////
//     Function: GeomContext::get_geom
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
47
inline Geom *GeomContext::get_geom(void) const;

2261 14 get_class_type 0 4 3078 27 GeomContext::get_class_type 0 1 735 0
52
static TypeHandle GeomContext::get_class_type(void);

2262 12 ~GeomContext 0 4 3078 25 GeomContext::~GeomContext 0 0 0
32
GeomContext::~GeomContext(void);

2263 9 GeomLines 0 4 3079 20 GeomLines::GeomLines 0 2 736 737 451
////////////////////////////////////////////////////////////////////
//     Function: GeomLines::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomLines::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
99
GeomLines::GeomLines(GeomEnums::UsageHint usage_hint);
GeomLines::GeomLines(GeomLines const &copy);

2264 12 operator new 0 4 3079 23 GeomLines::operator new 0 1 738 0
112
inline void *GeomLines::operator new(size_t size);
inline void *GeomLines::operator new(size_t size, void *ptr);

2265 15 operator delete 0 4 3079 26 GeomLines::operator delete 0 0 0
106
inline void GeomLines::operator delete(void *ptr);
inline void GeomLines::operator delete(void *, void *);

2266 12 validate_ptr 0 4 3079 23 GeomLines::validate_ptr 0 0 0
60
static inline bool GeomLines::validate_ptr(void const *ptr);

2267 14 get_class_type 0 4 3079 25 GeomLines::get_class_type 0 1 739 0
50
static TypeHandle GeomLines::get_class_type(void);

2268 14 GeomLinestrips 0 4 3080 30 GeomLinestrips::GeomLinestrips 0 2 740 741 461
////////////////////////////////////////////////////////////////////
//     Function: GeomLinestrips::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomLinestrips::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
124
GeomLinestrips::GeomLinestrips(GeomEnums::UsageHint usage_hint);
GeomLinestrips::GeomLinestrips(GeomLinestrips const &copy);

2269 12 operator new 0 4 3080 28 GeomLinestrips::operator new 0 1 742 0
122
inline void *GeomLinestrips::operator new(size_t size);
inline void *GeomLinestrips::operator new(size_t size, void *ptr);

2270 15 operator delete 0 4 3080 31 GeomLinestrips::operator delete 0 0 0
116
inline void GeomLinestrips::operator delete(void *ptr);
inline void GeomLinestrips::operator delete(void *, void *);

2271 12 validate_ptr 0 4 3080 28 GeomLinestrips::validate_ptr 0 0 0
65
static inline bool GeomLinestrips::validate_ptr(void const *ptr);

2272 14 get_class_type 0 4 3080 30 GeomLinestrips::get_class_type 0 1 743 0
55
static TypeHandle GeomLinestrips::get_class_type(void);

2273 11 GeomPatches 0 4 3081 24 GeomPatches::GeomPatches 0 2 744 745 743
////////////////////////////////////////////////////////////////////
//     Function: GeomPatches::Constructor
//       Access: Published
//  Description: The number of vertices per patch must be specified to
//               the GeomPatches constructor, and it may not be
//               changed during the lifetime of the GeomPatches
//               object.  Create a new GeomPatches if you need to have
//               a different value.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomPatches::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
137
GeomPatches::GeomPatches(int num_vertices_per_patch, GeomEnums::UsageHint usage_hint);
GeomPatches::GeomPatches(GeomPatches const &copy);

2274 12 operator new 0 4 3081 25 GeomPatches::operator new 0 1 746 0
116
inline void *GeomPatches::operator new(size_t size);
inline void *GeomPatches::operator new(size_t size, void *ptr);

2275 15 operator delete 0 4 3081 28 GeomPatches::operator delete 0 0 0
110
inline void GeomPatches::operator delete(void *ptr);
inline void GeomPatches::operator delete(void *, void *);

2276 12 validate_ptr 0 4 3081 25 GeomPatches::validate_ptr 0 0 0
62
static inline bool GeomPatches::validate_ptr(void const *ptr);

2277 14 get_class_type 0 4 3081 27 GeomPatches::get_class_type 0 1 747 0
52
static TypeHandle GeomPatches::get_class_type(void);

2278 10 GeomPoints 0 4 3082 22 GeomPoints::GeomPoints 0 2 748 749 453
////////////////////////////////////////////////////////////////////
//     Function: GeomPoints::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomPoints::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
104
GeomPoints::GeomPoints(GeomEnums::UsageHint usage_hint);
GeomPoints::GeomPoints(GeomPoints const &copy);

2279 12 operator new 0 4 3082 24 GeomPoints::operator new 0 1 750 0
114
inline void *GeomPoints::operator new(size_t size);
inline void *GeomPoints::operator new(size_t size, void *ptr);

2280 15 operator delete 0 4 3082 27 GeomPoints::operator delete 0 0 0
108
inline void GeomPoints::operator delete(void *ptr);
inline void GeomPoints::operator delete(void *, void *);

2281 12 validate_ptr 0 4 3082 24 GeomPoints::validate_ptr 0 0 0
61
static inline bool GeomPoints::validate_ptr(void const *ptr);

2282 14 get_class_type 0 4 3082 26 GeomPoints::get_class_type 0 1 751 0
51
static TypeHandle GeomPoints::get_class_type(void);

2283 13 GeomTriangles 0 4 3083 28 GeomTriangles::GeomTriangles 0 2 752 753 459
////////////////////////////////////////////////////////////////////
//     Function: GeomTriangles::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomTriangles::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
119
GeomTriangles::GeomTriangles(GeomEnums::UsageHint usage_hint);
GeomTriangles::GeomTriangles(GeomTriangles const &copy);

2284 12 operator new 0 4 3083 27 GeomTriangles::operator new 0 1 754 0
120
inline void *GeomTriangles::operator new(size_t size);
inline void *GeomTriangles::operator new(size_t size, void *ptr);

2285 15 operator delete 0 4 3083 30 GeomTriangles::operator delete 0 0 0
114
inline void GeomTriangles::operator delete(void *ptr);
inline void GeomTriangles::operator delete(void *, void *);

2286 12 validate_ptr 0 4 3083 27 GeomTriangles::validate_ptr 0 0 0
64
static inline bool GeomTriangles::validate_ptr(void const *ptr);

2287 14 get_class_type 0 4 3083 29 GeomTriangles::get_class_type 0 1 755 0
54
static TypeHandle GeomTriangles::get_class_type(void);

2288 11 GeomTrifans 0 4 3084 24 GeomTrifans::GeomTrifans 0 2 756 757 455
////////////////////////////////////////////////////////////////////
//     Function: GeomTrifans::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomTrifans::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
109
GeomTrifans::GeomTrifans(GeomEnums::UsageHint usage_hint);
GeomTrifans::GeomTrifans(GeomTrifans const &copy);

2289 12 operator new 0 4 3084 25 GeomTrifans::operator new 0 1 758 0
116
inline void *GeomTrifans::operator new(size_t size);
inline void *GeomTrifans::operator new(size_t size, void *ptr);

2290 15 operator delete 0 4 3084 28 GeomTrifans::operator delete 0 0 0
110
inline void GeomTrifans::operator delete(void *ptr);
inline void GeomTrifans::operator delete(void *, void *);

2291 12 validate_ptr 0 4 3084 25 GeomTrifans::validate_ptr 0 0 0
62
static inline bool GeomTrifans::validate_ptr(void const *ptr);

2292 14 get_class_type 0 4 3084 27 GeomTrifans::get_class_type 0 1 759 0
52
static TypeHandle GeomTrifans::get_class_type(void);

2293 13 GeomTristrips 0 4 3085 28 GeomTristrips::GeomTristrips 0 2 760 761 459
////////////////////////////////////////////////////////////////////
//     Function: GeomTristrips::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomTristrips::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
119
GeomTristrips::GeomTristrips(GeomEnums::UsageHint usage_hint);
GeomTristrips::GeomTristrips(GeomTristrips const &copy);

2294 12 operator new 0 4 3085 27 GeomTristrips::operator new 0 1 762 0
120
inline void *GeomTristrips::operator new(size_t size);
inline void *GeomTristrips::operator new(size_t size, void *ptr);

2295 15 operator delete 0 4 3085 30 GeomTristrips::operator delete 0 0 0
114
inline void GeomTristrips::operator delete(void *ptr);
inline void GeomTristrips::operator delete(void *, void *);

2296 12 validate_ptr 0 4 3085 27 GeomTristrips::validate_ptr 0 0 0
64
static inline bool GeomTristrips::validate_ptr(void const *ptr);

2297 14 get_class_type 0 4 3085 29 GeomTristrips::get_class_type 0 1 763 0
54
static TypeHandle GeomTristrips::get_class_type(void);

2298 16 GeomVertexReader 0 4 3086 34 GeomVertexReader::GeomVertexReader 0 6 764 765 766 767 768 769 2482
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Default Constructor
//       Access: Published
//  Description: Constructs an invalid GeomVertexReader.  You must use
//               the assignment operator to assign a valid
//               GeomVertexReader to this object before you can use
//               it.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Constructor
//       Access: Published
//  Description: Constructs a new reader to process the vertices of
//               the indicated data object.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Constructor
//       Access: Published
//  Description: Constructs a new reader to process the vertices of
//               the indicated data object.  This flavor creates the
//               reader specifically to process the named data type.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Constructor
//       Access: Published
//  Description: Constructs a new reader to process the vertices of
//               the indicated array only.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Constructor
//       Access: Published
//  Description: Constructs a new reader to process the vertices of
//               the indicated array only.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Constructor
//       Access: Public
//  Description: Constructs a new reader to process the vertices of
//               the indicated data object.  This flavor creates the
//               reader specifically to process the named data type.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
715
inline GeomVertexReader::GeomVertexReader(Thread *current_thread = (get_current_thread()));
inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, Thread *current_thread = (get_current_thread()));
inline GeomVertexReader::GeomVertexReader(GeomVertexData const *vertex_data, CPT_InternalName name, Thread *current_thread = (get_current_thread()));
inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, Thread *current_thread = (get_current_thread()));
inline GeomVertexReader::GeomVertexReader(GeomVertexArrayData const *array_data, int column, Thread *current_thread = (get_current_thread()));
inline GeomVertexReader::GeomVertexReader(GeomVertexReader const &copy);

2299 10 operator = 0 4 3086 28 GeomVertexReader::operator = 0 1 770 0
71
inline void GeomVertexReader::operator =(GeomVertexReader const &copy);

2300 17 ~GeomVertexReader 0 4 3086 35 GeomVertexReader::~GeomVertexReader 0 0 228
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
49
inline GeomVertexReader::~GeomVertexReader(void);

2301 15 get_vertex_data 0 4 3086 33 GeomVertexReader::get_vertex_data 0 1 771 408
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_vertex_data
//       Access: Published
//  Description: Returns the vertex data object that the
//               reader is processing.  This may return NULL if the
//               reader was constructed with just an array pointer.
////////////////////////////////////////////////////////////////////
75
inline GeomVertexData const *GeomVertexReader::get_vertex_data(void) const;

2302 14 get_array_data 0 4 3086 32 GeomVertexReader::get_array_data 0 1 772 325
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_array_data
//       Access: Published
//  Description: Returns the particular array object that the
//               reader is currently processing.
////////////////////////////////////////////////////////////////////
79
inline GeomVertexArrayData const *GeomVertexReader::get_array_data(void) const;

2303 16 get_array_handle 0 4 3086 34 GeomVertexReader::get_array_handle 0 1 773 400
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_array_handle
//       Access: Published
//  Description: Returns the read handle to the array object that the
//               read is currently processing.  This low-level call
//               should be used with caution.
////////////////////////////////////////////////////////////////////
87
inline GeomVertexArrayDataHandle const *GeomVertexReader::get_array_handle(void) const;

2304 10 get_stride 0 4 3086 28 GeomVertexReader::get_stride 0 1 774 459
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_stride
//       Access: Published
//  Description: Returns the per-row stride (bytes between consecutive
//               rows) of the underlying vertex array.  This low-level
//               information is normally not needed to use the
//               GeomVertexReader directly.
////////////////////////////////////////////////////////////////////
55
inline size_t GeomVertexReader::get_stride(void) const;

2305 18 get_current_thread 0 4 3086 36 GeomVertexReader::get_current_thread 0 1 775 359
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_current_thread
//       Access: Published
//  Description: Returns the Thread pointer of the currently-executing
//               thread, as passed to the constructor of this object.
////////////////////////////////////////////////////////////////////
64
inline Thread *GeomVertexReader::get_current_thread(void) const;

2306 9 set_force 0 4 3086 27 GeomVertexReader::set_force 0 1 776 928
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_force
//       Access: Published
//  Description: Sets the value of the force flag.  When this is true
//               (the default), vertex data will be paged in from disk
//               if necessary.  When this is false, the GeomVertexData
//               will simply return a failure code when attempting to
//               read vertex data that is not resident (but will put
//               it on the queue to become resident later).
//
//               Normally, vertex data is always resident, so this
//               will not be an issue.  It is only possible for vertex
//               data to be nonresident if you have enabled vertex
//               paging via the GeomVertexArrayData and VertexDataPage
//               interfaces.
////////////////////////////////////////////////////////////////////
52
inline void GeomVertexReader::set_force(bool force);

2307 9 get_force 0 4 3086 27 GeomVertexReader::get_force 0 1 777 298
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_force
//       Access: Published
//  Description: Returns the value of the force flag.  See
//               set_force().
////////////////////////////////////////////////////////////////////
52
inline bool GeomVertexReader::get_force(void) const;

2308 10 set_column 0 4 3086 28 GeomVertexReader::set_column 0 3 778 779 780 1896
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_column
//       Access: Published
//  Description: Sets up the reader to use the nth data type of the
//               GeomVertexFormat, numbering from 0.
//
//               This also resets the read row number to the start row
//               (the same value passed to a previous call to
//               set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_column
//       Access: Published
//  Description: Sets up the reader to use the data type with the
//               indicated name.
//
//               This also resets the read row number to the start row
//               (the same value passed to a previous call to
//               set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_column
//       Access: Published
//  Description: Sets up the reader to use the indicated column
//               description on the given array.
//
//               This also resets the current read row number to the
//               start row (the same value passed to a previous call
//               to set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
////////////////////////////////////////////////////////////////////
196
inline bool GeomVertexReader::set_column(int column);
inline bool GeomVertexReader::set_column(CPT_InternalName name);
bool GeomVertexReader::set_column(int array, GeomVertexColumn const *column);

2309 5 clear 0 4 3086 23 GeomVertexReader::clear 0 1 781 272
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::clear
//       Access: Published
//  Description: Resets the GeomVertexReader to the initial state.
////////////////////////////////////////////////////////////////////
42
inline void GeomVertexReader::clear(void);

2310 10 has_column 0 4 3086 28 GeomVertexReader::has_column 0 1 782 445
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::has_column
//       Access: Published
//  Description: Returns true if a valid data type has been
//               successfully set, or false if the data type does not
//               exist (or if get_force() is false and the vertex data
//               is nonresident).
////////////////////////////////////////////////////////////////////
53
inline bool GeomVertexReader::has_column(void) const;

2311 9 get_array 0 4 3086 27 GeomVertexReader::get_array 0 1 783 323
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_array
//       Access: Published
//  Description: Returns the array index containing the data type that
//               the reader is working on.
////////////////////////////////////////////////////////////////////
51
inline int GeomVertexReader::get_array(void) const;

2312 10 get_column 0 4 3086 28 GeomVertexReader::get_column 0 1 784 316
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_column
//       Access: Published
//  Description: Returns the description of the data type that the
//               reader is working on.
////////////////////////////////////////////////////////////////////
72
inline GeomVertexColumn const *GeomVertexReader::get_column(void) const;

2313 14 set_row_unsafe 0 4 3086 32 GeomVertexReader::set_row_unsafe 0 1 785 655
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_row_unsafe
//       Access: Published
//  Description: Sets the start row to the indicated value, without
//               internal checks.  This is the same as set_row(), but
//               it does not check for the possibility that the array
//               has been reallocated internally for some reason; use
//               only when you are confident that the array is
//               unchanged and you really need every bit of available
//               performance.
////////////////////////////////////////////////////////////////////
54
inline void GeomVertexReader::set_row_unsafe(int row);

2314 7 set_row 0 4 3086 25 GeomVertexReader::set_row 0 1 786 533
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_row
//       Access: Published
//  Description: Sets the start row to the indicated value.  The
//               reader will begin reading from the indicated row;
//               each subsequent get_data*() call will return the data
//               from the subsequent row.  If set_column() is called,
//               the reader will return to this row.
////////////////////////////////////////////////////////////////////
47
inline void GeomVertexReader::set_row(int row);

2315 13 get_start_row 0 4 3086 31 GeomVertexReader::get_start_row 0 1 787 375
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_start_row
//       Access: Published
//  Description: Returns the row index at which the reader started.
//               It will return to this row if you reset the current
//               column.
////////////////////////////////////////////////////////////////////
55
inline int GeomVertexReader::get_start_row(void) const;

2316 12 get_read_row 0 4 3086 30 GeomVertexReader::get_read_row 0 1 788 339
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_read_row
//       Access: Published
//  Description: Returns the row index from which the data will be
//               retrieved by the next call to get_data*().
////////////////////////////////////////////////////////////////////
54
inline int GeomVertexReader::get_read_row(void) const;

2317 9 is_at_end 0 4 3086 27 GeomVertexReader::is_at_end 0 1 789 440
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::is_at_end
//       Access: Published
//  Description: Returns true if the reader is currently at the end of
//               the list of vertices, false otherwise.  If this is
//               true, another call to get_data*() will result in a
//               crash.
////////////////////////////////////////////////////////////////////
52
inline bool GeomVertexReader::is_at_end(void) const;

2318 10 get_data1f 0 4 3086 28 GeomVertexReader::get_data1f 0 1 790 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data1f
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 1-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
48
inline float GeomVertexReader::get_data1f(void);

2319 10 get_data2f 0 4 3086 28 GeomVertexReader::get_data2f 0 1 791 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data2f
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 2-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
60
inline LVecBase2f const &GeomVertexReader::get_data2f(void);

2320 10 get_data3f 0 4 3086 28 GeomVertexReader::get_data3f 0 1 792 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data3f
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 3-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
60
inline LVecBase3f const &GeomVertexReader::get_data3f(void);

2321 10 get_data4f 0 4 3086 28 GeomVertexReader::get_data4f 0 1 793 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data4f
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 4-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
60
inline LVecBase4f const &GeomVertexReader::get_data4f(void);

2322 12 get_matrix3f 0 4 3086 30 GeomVertexReader::get_matrix3f 0 1 794 474
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix3f
//       Access: Published
//  Description: Returns the 3-by-3 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
////////////////////////////////////////////////////////////////////
54
inline LMatrix3f GeomVertexReader::get_matrix3f(void);

2323 12 get_matrix4f 0 4 3086 30 GeomVertexReader::get_matrix4f 0 1 795 474
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix4f
//       Access: Published
//  Description: Returns the 4-by-4 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
////////////////////////////////////////////////////////////////////
54
inline LMatrix4f GeomVertexReader::get_matrix4f(void);

2324 10 get_data1d 0 4 3086 28 GeomVertexReader::get_data1d 0 1 796 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data1d
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 1-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
49
inline double GeomVertexReader::get_data1d(void);

2325 10 get_data2d 0 4 3086 28 GeomVertexReader::get_data2d 0 1 797 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data2d
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 2-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
60
inline LVecBase2d const &GeomVertexReader::get_data2d(void);

2326 10 get_data3d 0 4 3086 28 GeomVertexReader::get_data3d 0 1 798 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data3d
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 3-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
60
inline LVecBase3d const &GeomVertexReader::get_data3d(void);

2327 10 get_data4d 0 4 3086 28 GeomVertexReader::get_data4d 0 1 799 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data4d
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 4-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
60
inline LVecBase4d const &GeomVertexReader::get_data4d(void);

2328 12 get_matrix3d 0 4 3086 30 GeomVertexReader::get_matrix3d 0 1 800 474
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix3d
//       Access: Published
//  Description: Returns the 3-by-3 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
////////////////////////////////////////////////////////////////////
54
inline LMatrix3d GeomVertexReader::get_matrix3d(void);

2329 12 get_matrix4d 0 4 3086 30 GeomVertexReader::get_matrix4d 0 1 801 474
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix4d
//       Access: Published
//  Description: Returns the 4-by-4 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
////////////////////////////////////////////////////////////////////
54
inline LMatrix4d GeomVertexReader::get_matrix4d(void);

2330 9 get_data1 0 4 3086 27 GeomVertexReader::get_data1 0 1 802 368
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data1
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 1-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
53
inline PN_stdfloat GeomVertexReader::get_data1(void);

2331 9 get_data2 0 4 3086 27 GeomVertexReader::get_data2 0 1 803 368
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data2
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 2-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
58
inline LVecBase2 const &GeomVertexReader::get_data2(void);

2332 9 get_data3 0 4 3086 27 GeomVertexReader::get_data3 0 1 804 368
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data3
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 3-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
58
inline LVecBase3 const &GeomVertexReader::get_data3(void);

2333 9 get_data4 0 4 3086 27 GeomVertexReader::get_data4 0 1 805 368
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data4
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 4-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
58
inline LVecBase4 const &GeomVertexReader::get_data4(void);

2334 11 get_matrix3 0 4 3086 29 GeomVertexReader::get_matrix3 0 1 806 473
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix3
//       Access: Published
//  Description: Returns the 3-by-3 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
////////////////////////////////////////////////////////////////////
52
inline LMatrix3 GeomVertexReader::get_matrix3(void);

2335 11 get_matrix4 0 4 3086 29 GeomVertexReader::get_matrix4 0 1 807 473
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix4
//       Access: Published
//  Description: Returns the 4-by-4 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
////////////////////////////////////////////////////////////////////
52
inline LMatrix4 GeomVertexReader::get_matrix4(void);

2336 10 get_data1i 0 4 3086 28 GeomVertexReader::get_data1i 0 1 808 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data1i
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 1-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
46
inline int GeomVertexReader::get_data1i(void);

2337 10 get_data2i 0 4 3086 28 GeomVertexReader::get_data2i 0 1 809 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data2i
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 2-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
60
inline LVecBase2i const &GeomVertexReader::get_data2i(void);

2338 10 get_data3i 0 4 3086 28 GeomVertexReader::get_data3i 0 1 810 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data3i
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 3-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
60
inline LVecBase3i const &GeomVertexReader::get_data3i(void);

2339 10 get_data4i 0 4 3086 28 GeomVertexReader::get_data4i 0 1 811 369
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data4i
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 4-component value, and advances the
//               read row.
////////////////////////////////////////////////////////////////////
60
inline LVecBase4i const &GeomVertexReader::get_data4i(void);

2340 6 output 0 4 3086 24 GeomVertexReader::output 0 1 812 224
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
50
void GeomVertexReader::output(ostream &out) const;

2341 16 GeomVertexWriter 0 4 3087 34 GeomVertexWriter::GeomVertexWriter 0 6 813 814 815 816 817 818 2481
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Default Constructor
//       Access: Published
//  Description: Constructs an invalid GeomVertexWriter.  You must use
//               the assignment operator to assign a valid
//               GeomVertexWriter to this object before you can use
//               it.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Constructor
//       Access: Published
//  Description: Constructs a new writer to process the vertices of
//               the indicated data object.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Constructor
//       Access: Published
//  Description: Constructs a new writer to process the vertices of
//               the indicated data object.  This flavor creates the
//               writer specifically to process the named data type.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Constructor
//       Access: Published
//  Description: Constructs a new writer to process the vertices of
//               the indicated array only.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Constructor
//       Access: Published
//  Description: Constructs a new writer to process the vertices of
//               the indicated array only.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Constructor
//       Access: Public
//  Description: Constructs a new writer to process the vertices of
//               the indicated data object.  This flavor creates the
//               writer specifically to process the named data type.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
691
inline GeomVertexWriter::GeomVertexWriter(Thread *current_thread = (get_current_thread()));
inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, Thread *current_thread = (get_current_thread()));
inline GeomVertexWriter::GeomVertexWriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = (get_current_thread()));
inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, Thread *current_thread = (get_current_thread()));
inline GeomVertexWriter::GeomVertexWriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = (get_current_thread()));
inline GeomVertexWriter::GeomVertexWriter(GeomVertexWriter const &copy);

2342 10 operator = 0 4 3087 28 GeomVertexWriter::operator = 0 1 819 0
71
inline void GeomVertexWriter::operator =(GeomVertexWriter const &copy);

2343 17 ~GeomVertexWriter 0 4 3087 35 GeomVertexWriter::~GeomVertexWriter 0 0 227
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
49
inline GeomVertexWriter::~GeomVertexWriter(void);

2344 15 get_vertex_data 0 4 3087 33 GeomVertexWriter::get_vertex_data 0 1 820 408
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_vertex_data
//       Access: Published
//  Description: Returns the vertex data object that the
//               writer is processing.  This may return NULL if the
//               writer was constructed with just an array pointer.
////////////////////////////////////////////////////////////////////
69
inline GeomVertexData *GeomVertexWriter::get_vertex_data(void) const;

2345 14 get_array_data 0 4 3087 32 GeomVertexWriter::get_array_data 0 1 821 325
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_array_data
//       Access: Published
//  Description: Returns the particular array object that the
//               writer is currently processing.
////////////////////////////////////////////////////////////////////
73
inline GeomVertexArrayData *GeomVertexWriter::get_array_data(void) const;

2346 16 get_array_handle 0 4 3087 34 GeomVertexWriter::get_array_handle 0 1 822 523
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_array_handle
//       Access: Published
//  Description: Returns the write handle to the array object that the
//               writer is currently processing.  This low-level call
//               should be used with caution; be careful with
//               modifying the data in the handle out from under the
//               GeomVertexWriter.
////////////////////////////////////////////////////////////////////
81
inline GeomVertexArrayDataHandle *GeomVertexWriter::get_array_handle(void) const;

2347 10 get_stride 0 4 3087 28 GeomVertexWriter::get_stride 0 1 823 459
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_stride
//       Access: Published
//  Description: Returns the per-row stride (bytes between consecutive
//               rows) of the underlying vertex array.  This low-level
//               information is normally not needed to use the
//               GeomVertexWriter directly.
////////////////////////////////////////////////////////////////////
55
inline size_t GeomVertexWriter::get_stride(void) const;

2348 18 get_current_thread 0 4 3087 36 GeomVertexWriter::get_current_thread 0 1 824 359
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_current_thread
//       Access: Published
//  Description: Returns the Thread pointer of the currently-executing
//               thread, as passed to the constructor of this object.
////////////////////////////////////////////////////////////////////
64
inline Thread *GeomVertexWriter::get_current_thread(void) const;

2349 10 set_column 0 4 3087 28 GeomVertexWriter::set_column 0 3 825 826 827 1895
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_column
//       Access: Published
//  Description: Sets up the writer to use the nth data type of the
//               GeomVertexFormat, numbering from 0.
//
//               This also resets the write row number to the start
//               row (the same value passed to a previous call to
//               set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_column
//       Access: Published
//  Description: Sets up the writer to use the data type with the
//               indicated name.
//
//               This also resets the write number to the start row
//               (the same value passed to a previous call to
//               set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_column
//       Access: Published
//  Description: Sets up the writer to use the indicated column
//               description on the given array.
//
//               This also resets the current write row number to the
//               start row (the same value passed to a previous call
//               to set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
////////////////////////////////////////////////////////////////////
196
inline bool GeomVertexWriter::set_column(int column);
inline bool GeomVertexWriter::set_column(CPT_InternalName name);
bool GeomVertexWriter::set_column(int array, GeomVertexColumn const *column);

2350 5 clear 0 4 3087 23 GeomVertexWriter::clear 0 1 828 272
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::clear
//       Access: Published
//  Description: Resets the GeomVertexWriter to the initial state.
////////////////////////////////////////////////////////////////////
42
inline void GeomVertexWriter::clear(void);

2351 16 reserve_num_rows 0 4 3087 34 GeomVertexWriter::reserve_num_rows 0 1 829 597
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::reserve_num_rows
//       Access: Published
//  Description: This ensures that enough memory space for num_rows is
//               allocated, so that you may add up to num_rows rows
//               without causing a new memory allocation.  This is a
//               performance optimization only; it is especially
//               useful when you know the number of rows you will be
//               adding ahead of time.
////////////////////////////////////////////////////////////////////
54
bool GeomVertexWriter::reserve_num_rows(int num_rows);

2352 10 has_column 0 4 3087 28 GeomVertexWriter::has_column 0 1 830 364
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::has_column
//       Access: Published
//  Description: Returns true if a valid data type has been
//               successfully set, or false if the data type does not
//               exist.
////////////////////////////////////////////////////////////////////
53
inline bool GeomVertexWriter::has_column(void) const;

2353 9 get_array 0 4 3087 27 GeomVertexWriter::get_array 0 1 831 323
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_array
//       Access: Published
//  Description: Returns the array index containing the data type that
//               the writer is working on.
////////////////////////////////////////////////////////////////////
51
inline int GeomVertexWriter::get_array(void) const;

2354 10 get_column 0 4 3087 28 GeomVertexWriter::get_column 0 1 832 316
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_column
//       Access: Published
//  Description: Returns the description of the data type that the
//               writer is working on.
////////////////////////////////////////////////////////////////////
72
inline GeomVertexColumn const *GeomVertexWriter::get_column(void) const;

2355 14 set_row_unsafe 0 4 3087 32 GeomVertexWriter::set_row_unsafe 0 1 833 655
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_row_unsafe
//       Access: Published
//  Description: Sets the start row to the indicated value, without
//               internal checks.  This is the same as set_row(), but
//               it does not check for the possibility that the array
//               has been reallocated internally for some reason; use
//               only when you are confident that the array is
//               unchanged and you really need every bit of available
//               performance.
////////////////////////////////////////////////////////////////////
54
inline void GeomVertexWriter::set_row_unsafe(int row);

2356 7 set_row 0 4 3087 25 GeomVertexWriter::set_row 0 1 834 530
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_row
//       Access: Published
//  Description: Sets the start row to the indicated value.  The
//               writer will begin writing to the indicated row;
//               each subsequent set_data*() call will store the data
//               into the subsequent row.  If set_column() is called,
//               the writer will return to this row.
////////////////////////////////////////////////////////////////////
47
inline void GeomVertexWriter::set_row(int row);

2357 13 get_start_row 0 4 3087 31 GeomVertexWriter::get_start_row 0 1 835 376
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_start_row
//       Access: Published
//  Description: Returns the row index at which the writer
//               started.  It will return to this row if you reset
//               the current column.
////////////////////////////////////////////////////////////////////
55
inline int GeomVertexWriter::get_start_row(void) const;

2358 13 get_write_row 0 4 3087 31 GeomVertexWriter::get_write_row 0 1 836 368
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_write_row
//       Access: Published
//  Description: Returns the row index to which the data will be
//               written at the next call to set_data*() or
//               add_data*().
////////////////////////////////////////////////////////////////////
55
inline int GeomVertexWriter::get_write_row(void) const;

2359 9 is_at_end 0 4 3087 27 GeomVertexWriter::is_at_end 0 1 837 509
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::is_at_end
//       Access: Published
//  Description: Returns true if the writer is currently at the end of
//               the list of vertices, false otherwise.  If this is
//               true, another call to set_data*() will result in a
//               crash, but another call to add_data*() will add a new
//               row.
////////////////////////////////////////////////////////////////////
52
inline bool GeomVertexWriter::is_at_end(void) const;

2360 10 set_data1f 0 4 3087 28 GeomVertexWriter::set_data1f 0 1 838 429
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data1f
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
53
inline void GeomVertexWriter::set_data1f(float data);

2361 10 set_data2f 0 4 3087 28 GeomVertexWriter::set_data2f 0 2 839 840 860
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2f
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2f
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
125
inline void GeomVertexWriter::set_data2f(float x, float y);
inline void GeomVertexWriter::set_data2f(LVecBase2f const &data);

2362 10 set_data3f 0 4 3087 28 GeomVertexWriter::set_data3f 0 2 841 842 860
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3f
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3f
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
134
inline void GeomVertexWriter::set_data3f(float x, float y, float z);
inline void GeomVertexWriter::set_data3f(LVecBase3f const &data);

2363 10 set_data4f 0 4 3087 28 GeomVertexWriter::set_data4f 0 2 843 844 860
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4f
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4f
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
143
inline void GeomVertexWriter::set_data4f(float x, float y, float z, float w);
inline void GeomVertexWriter::set_data4f(LVecBase4f const &data);

2364 12 set_matrix3f 0 4 3087 30 GeomVertexWriter::set_matrix3f 0 1 845 500
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix3f
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
65
inline void GeomVertexWriter::set_matrix3f(LMatrix3f const &mat);

2365 12 set_matrix4f 0 4 3087 30 GeomVertexWriter::set_matrix4f 0 1 846 500
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix4f
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
65
inline void GeomVertexWriter::set_matrix4f(LMatrix4f const &mat);

2366 10 set_data1d 0 4 3087 28 GeomVertexWriter::set_data1d 0 1 847 429
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data1d
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
54
inline void GeomVertexWriter::set_data1d(double data);

2367 10 set_data2d 0 4 3087 28 GeomVertexWriter::set_data2d 0 2 848 849 860
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2d
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2d
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
127
inline void GeomVertexWriter::set_data2d(double x, double y);
inline void GeomVertexWriter::set_data2d(LVecBase2d const &data);

2368 10 set_data3d 0 4 3087 28 GeomVertexWriter::set_data3d 0 2 850 851 860
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3d
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3d
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
137
inline void GeomVertexWriter::set_data3d(double x, double y, double z);
inline void GeomVertexWriter::set_data3d(LVecBase3d const &data);

2369 10 set_data4d 0 4 3087 28 GeomVertexWriter::set_data4d 0 2 852 853 860
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4d
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4d
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
147
inline void GeomVertexWriter::set_data4d(double x, double y, double z, double w);
inline void GeomVertexWriter::set_data4d(LVecBase4d const &data);

2370 12 set_matrix3d 0 4 3087 30 GeomVertexWriter::set_matrix3d 0 1 854 500
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix3d
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
65
inline void GeomVertexWriter::set_matrix3d(LMatrix3d const &mat);

2371 12 set_matrix4d 0 4 3087 30 GeomVertexWriter::set_matrix4d 0 1 855 500
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix4d
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
65
inline void GeomVertexWriter::set_matrix4d(LMatrix4d const &mat);

2372 9 set_data1 0 4 3087 27 GeomVertexWriter::set_data1 0 1 856 428
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data1
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
58
inline void GeomVertexWriter::set_data1(PN_stdfloat data);

2373 9 set_data2 0 4 3087 27 GeomVertexWriter::set_data2 0 2 857 858 858
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
134
inline void GeomVertexWriter::set_data2(PN_stdfloat x, PN_stdfloat y);
inline void GeomVertexWriter::set_data2(LVecBase2 const &data);

2374 9 set_data3 0 4 3087 27 GeomVertexWriter::set_data3 0 2 859 860 858
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
149
inline void GeomVertexWriter::set_data3(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline void GeomVertexWriter::set_data3(LVecBase3 const &data);

2375 9 set_data4 0 4 3087 27 GeomVertexWriter::set_data4 0 2 861 862 858
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
164
inline void GeomVertexWriter::set_data4(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat w);
inline void GeomVertexWriter::set_data4(LVecBase4 const &data);

2376 11 set_matrix3 0 4 3087 29 GeomVertexWriter::set_matrix3 0 1 863 499
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix3
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
63
inline void GeomVertexWriter::set_matrix3(LMatrix3 const &mat);

2377 11 set_matrix4 0 4 3087 29 GeomVertexWriter::set_matrix4 0 1 864 499
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix4
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
63
inline void GeomVertexWriter::set_matrix4(LMatrix4 const &mat);

2378 10 set_data1i 0 4 3087 28 GeomVertexWriter::set_data1i 0 1 865 429
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data1i
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
51
inline void GeomVertexWriter::set_data1i(int data);

2379 10 set_data2i 0 4 3087 28 GeomVertexWriter::set_data2i 0 2 866 867 860
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2i
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2i
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
121
inline void GeomVertexWriter::set_data2i(int a, int b);
inline void GeomVertexWriter::set_data2i(LVecBase2i const &data);

2380 10 set_data3i 0 4 3087 28 GeomVertexWriter::set_data3i 0 2 868 869 860
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3i
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3i
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
128
inline void GeomVertexWriter::set_data3i(int a, int b, int c);
inline void GeomVertexWriter::set_data3i(LVecBase3i const &data);

2381 10 set_data4i 0 4 3087 28 GeomVertexWriter::set_data4i 0 2 870 871 860
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4i
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4i
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
////////////////////////////////////////////////////////////////////
135
inline void GeomVertexWriter::set_data4i(int a, int b, int c, int d);
inline void GeomVertexWriter::set_data4i(LVecBase4i const &data);

2382 10 add_data1f 0 4 3087 28 GeomVertexWriter::add_data1f 0 1 872 450
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data1f
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
53
inline void GeomVertexWriter::add_data1f(float data);

2383 10 add_data2f 0 4 3087 28 GeomVertexWriter::add_data2f 0 2 873 874 902
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2f
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2f
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
125
inline void GeomVertexWriter::add_data2f(float x, float y);
inline void GeomVertexWriter::add_data2f(LVecBase2f const &data);

2384 10 add_data3f 0 4 3087 28 GeomVertexWriter::add_data3f 0 2 875 876 902
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3f
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3f
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
134
inline void GeomVertexWriter::add_data3f(float x, float y, float z);
inline void GeomVertexWriter::add_data3f(LVecBase3f const &data);

2385 10 add_data4f 0 4 3087 28 GeomVertexWriter::add_data4f 0 2 877 878 902
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4f
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4f
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
143
inline void GeomVertexWriter::add_data4f(float x, float y, float z, float w);
inline void GeomVertexWriter::add_data4f(LVecBase4f const &data);

2386 12 add_matrix3f 0 4 3087 30 GeomVertexWriter::add_matrix3f 0 1 879 521
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix3f
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
65
inline void GeomVertexWriter::add_matrix3f(LMatrix3f const &mat);

2387 12 add_matrix4f 0 4 3087 30 GeomVertexWriter::add_matrix4f 0 1 880 521
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix4f
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
65
inline void GeomVertexWriter::add_matrix4f(LMatrix4f const &mat);

2388 10 add_data1d 0 4 3087 28 GeomVertexWriter::add_data1d 0 1 881 450
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data1d
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
54
inline void GeomVertexWriter::add_data1d(double data);

2389 10 add_data2d 0 4 3087 28 GeomVertexWriter::add_data2d 0 2 882 883 902
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2d
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2d
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
127
inline void GeomVertexWriter::add_data2d(double x, double y);
inline void GeomVertexWriter::add_data2d(LVecBase2d const &data);

2390 10 add_data3d 0 4 3087 28 GeomVertexWriter::add_data3d 0 2 884 885 902
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3d
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3d
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
137
inline void GeomVertexWriter::add_data3d(double x, double y, double z);
inline void GeomVertexWriter::add_data3d(LVecBase3d const &data);

2391 10 add_data4d 0 4 3087 28 GeomVertexWriter::add_data4d 0 2 886 887 902
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4d
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4d
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
147
inline void GeomVertexWriter::add_data4d(double x, double y, double z, double w);
inline void GeomVertexWriter::add_data4d(LVecBase4d const &data);

2392 12 add_matrix3d 0 4 3087 30 GeomVertexWriter::add_matrix3d 0 1 888 521
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix3d
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
65
inline void GeomVertexWriter::add_matrix3d(LMatrix3d const &mat);

2393 12 add_matrix4d 0 4 3087 30 GeomVertexWriter::add_matrix4d 0 1 889 521
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix4d
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
65
inline void GeomVertexWriter::add_matrix4d(LMatrix4d const &mat);

2394 9 add_data1 0 4 3087 27 GeomVertexWriter::add_data1 0 1 890 449
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data1
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
58
inline void GeomVertexWriter::add_data1(PN_stdfloat data);

2395 9 add_data2 0 4 3087 27 GeomVertexWriter::add_data2 0 2 891 892 900
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
134
inline void GeomVertexWriter::add_data2(PN_stdfloat x, PN_stdfloat y);
inline void GeomVertexWriter::add_data2(LVecBase2 const &data);

2396 9 add_data3 0 4 3087 27 GeomVertexWriter::add_data3 0 2 893 894 900
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
149
inline void GeomVertexWriter::add_data3(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline void GeomVertexWriter::add_data3(LVecBase3 const &data);

2397 9 add_data4 0 4 3087 27 GeomVertexWriter::add_data4 0 2 895 896 900
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
164
inline void GeomVertexWriter::add_data4(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat w);
inline void GeomVertexWriter::add_data4(LVecBase4 const &data);

2398 11 add_matrix3 0 4 3087 29 GeomVertexWriter::add_matrix3 0 1 897 520
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix3
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
63
inline void GeomVertexWriter::add_matrix3(LMatrix3 const &mat);

2399 11 add_matrix4 0 4 3087 29 GeomVertexWriter::add_matrix4 0 1 898 520
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix4
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
63
inline void GeomVertexWriter::add_matrix4(LMatrix4 const &mat);

2400 10 add_data1i 0 4 3087 28 GeomVertexWriter::add_data1i 0 1 899 450
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data1i
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
51
inline void GeomVertexWriter::add_data1i(int data);

2401 10 add_data2i 0 4 3087 28 GeomVertexWriter::add_data2i 0 2 900 901 902
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2i
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2i
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
121
inline void GeomVertexWriter::add_data2i(int a, int b);
inline void GeomVertexWriter::add_data2i(LVecBase2i const &data);

2402 10 add_data3i 0 4 3087 28 GeomVertexWriter::add_data3i 0 2 902 903 902
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3i
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3i
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
128
inline void GeomVertexWriter::add_data3i(int a, int b, int c);
inline void GeomVertexWriter::add_data3i(LVecBase3i const &data);

2403 10 add_data4i 0 4 3087 28 GeomVertexWriter::add_data4i 0 2 904 905 902
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4i
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4i
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
////////////////////////////////////////////////////////////////////
135
inline void GeomVertexWriter::add_data4i(int a, int b, int c, int d);
inline void GeomVertexWriter::add_data4i(LVecBase4i const &data);

2404 6 output 0 4 3087 24 GeomVertexWriter::output 0 1 906 224
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
50
void GeomVertexWriter::output(ostream &out) const;

2405 26 upcast_to_GeomVertexWriter 0 12 3088 46 GeomVertexRewriter::upcast_to_GeomVertexWriter 0 1 931 50
upcast from GeomVertexRewriter to GeomVertexWriter
71
GeomVertexWriter *GeomVertexRewriter::upcast_to_GeomVertexWriter(void);

2406 30 downcast_to_GeomVertexRewriter 0 12 3087 48 GeomVertexWriter::downcast_to_GeomVertexRewriter 0 1 932 52
downcast from GeomVertexWriter to GeomVertexRewriter
75
GeomVertexRewriter *GeomVertexWriter::downcast_to_GeomVertexRewriter(void);

2407 26 upcast_to_GeomVertexReader 0 12 3088 46 GeomVertexRewriter::upcast_to_GeomVertexReader 0 1 933 50
upcast from GeomVertexRewriter to GeomVertexReader
71
GeomVertexReader *GeomVertexRewriter::upcast_to_GeomVertexReader(void);

2408 30 downcast_to_GeomVertexRewriter 0 12 3086 48 GeomVertexReader::downcast_to_GeomVertexRewriter 0 1 934 52
downcast from GeomVertexReader to GeomVertexRewriter
75
GeomVertexRewriter *GeomVertexReader::downcast_to_GeomVertexRewriter(void);

2409 18 GeomVertexRewriter 0 4 3088 38 GeomVertexRewriter::GeomVertexRewriter 0 6 907 908 909 910 911 912 2092
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Default Constructor
//       Access: Published
//  Description: Constructs an invalid GeomVertexRewriter.  You must use
//               the assignment operator to assign a valid
//               GeomVertexRewriter to this object before you can use
//               it.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Constructor
//       Access: Published
//  Description: Constructs a new rewriter to process the vertices of
//               the indicated data object.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Constructor
//       Access: Published
//  Description: Constructs a new rewriter to process the vertices of
//               the indicated data object.  This flavor creates the
//               rewriter specifically to process the named data type.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Constructor
//       Access: Published
//  Description: Constructs a new rewriter to process the vertices of
//               the indicated array only.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Constructor
//       Access: Published
//  Description: Constructs a new rewriter to process the vertices of
//               the indicated array only.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Copy Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
717
inline GeomVertexRewriter::GeomVertexRewriter(Thread *current_thread = (get_current_thread()));
inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, Thread *current_thread = (get_current_thread()));
inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexData *vertex_data, CPT_InternalName name, Thread *current_thread = (get_current_thread()));
inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, Thread *current_thread = (get_current_thread()));
inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexArrayData *array_data, int column, Thread *current_thread = (get_current_thread()));
inline GeomVertexRewriter::GeomVertexRewriter(GeomVertexRewriter const &copy);

2410 10 operator = 0 4 3088 30 GeomVertexRewriter::operator = 0 1 913 0
75
inline void GeomVertexRewriter::operator =(GeomVertexRewriter const &copy);

2411 19 ~GeomVertexRewriter 0 4 3088 39 GeomVertexRewriter::~GeomVertexRewriter 0 0 230
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Destructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
53
inline GeomVertexRewriter::~GeomVertexRewriter(void);

2412 15 get_vertex_data 0 4 3088 35 GeomVertexRewriter::get_vertex_data 0 1 914 315
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_vertex_data
//       Access: Published
//  Description: Returns the vertex data object that the
//               rewriter is processing.
////////////////////////////////////////////////////////////////////
71
inline GeomVertexData *GeomVertexRewriter::get_vertex_data(void) const;

2413 14 get_array_data 0 4 3088 34 GeomVertexRewriter::get_array_data 0 1 915 329
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_array_data
//       Access: Published
//  Description: Returns the particular array object that the
//               rewriter is currently processing.
////////////////////////////////////////////////////////////////////
75
inline GeomVertexArrayData *GeomVertexRewriter::get_array_data(void) const;

2414 16 get_array_handle 0 4 3088 36 GeomVertexRewriter::get_array_handle 0 1 916 529
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_array_handle
//       Access: Published
//  Description: Returns the write handle to the array object that the
//               rewriter is currently processing.  This low-level call
//               should be used with caution; be careful with
//               modifying the data in the handle out from under the
//               GeomVertexRewriter.
////////////////////////////////////////////////////////////////////
83
inline GeomVertexArrayDataHandle *GeomVertexRewriter::get_array_handle(void) const;

2415 10 get_stride 0 4 3088 30 GeomVertexRewriter::get_stride 0 1 917 463
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_stride
//       Access: Published
//  Description: Returns the per-row stride (bytes between consecutive
//               rows) of the underlying vertex array.  This low-level
//               information is normally not needed to use the
//               GeomVertexRewriter directly.
////////////////////////////////////////////////////////////////////
57
inline size_t GeomVertexRewriter::get_stride(void) const;

2416 18 get_current_thread 0 4 3088 38 GeomVertexRewriter::get_current_thread 0 1 918 361
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_current_thread
//       Access: Published
//  Description: Returns the Thread pointer of the currently-executing
//               thread, as passed to the constructor of this object.
////////////////////////////////////////////////////////////////////
66
inline Thread *GeomVertexRewriter::get_current_thread(void) const;

2417 10 set_column 0 4 3088 30 GeomVertexRewriter::set_column 0 3 919 920 921 1999
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_column
//       Access: Published
//  Description: Sets up the rewriter to use the nth data type of the
//               GeomVertexFormat, numbering from 0.
//
//               This also resets both the read and write row
//               numbers to the start row (the same value passed to
//               a previous call to set_row(), or 0 if set_row()
//               was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_column
//       Access: Published
//  Description: Sets up the rewriter to use the data type with the
//               indicated name.
//
//               This also resets both the read and write row
//               numbers to the start row (the same value passed to
//               a previous call to set_row(), or 0 if set_row()
//               was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_column
//       Access: Published
//  Description: Sets up the rewriter to use the indicated column
//               description on the given array.
//
//               This also resets both the read and write row
//               numbers to the start row (the same value passed to
//               a previous call to set_row(), or 0 if set_row()
//               was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
////////////////////////////////////////////////////////////////////
209
inline bool GeomVertexRewriter::set_column(int column);
inline bool GeomVertexRewriter::set_column(CPT_InternalName name);
inline bool GeomVertexRewriter::set_column(int array, GeomVertexColumn const *column);

2418 5 clear 0 4 3088 25 GeomVertexRewriter::clear 0 1 922 276
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::clear
//       Access: Published
//  Description: Resets the GeomVertexRewriter to the initial state.
////////////////////////////////////////////////////////////////////
44
inline void GeomVertexRewriter::clear(void);

2419 10 has_column 0 4 3088 30 GeomVertexRewriter::has_column 0 1 923 366
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::has_column
//       Access: Published
//  Description: Returns true if a valid data type has been
//               successfully set, or false if the data type does not
//               exist.
////////////////////////////////////////////////////////////////////
55
inline bool GeomVertexRewriter::has_column(void) const;

2420 9 get_array 0 4 3088 29 GeomVertexRewriter::get_array 0 1 924 327
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_array
//       Access: Published
//  Description: Returns the array index containing the data type that
//               the rewriter is working on.
////////////////////////////////////////////////////////////////////
53
inline int GeomVertexRewriter::get_array(void) const;

2421 10 get_column 0 4 3088 30 GeomVertexRewriter::get_column 0 1 925 320
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_column
//       Access: Published
//  Description: Returns the description of the data type that the
//               rewriter is working on.
////////////////////////////////////////////////////////////////////
74
inline GeomVertexColumn const *GeomVertexRewriter::get_column(void) const;

2422 14 set_row_unsafe 0 4 3088 34 GeomVertexRewriter::set_row_unsafe 0 1 926 657
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_row_unsafe
//       Access: Published
//  Description: Sets the start row to the indicated value, without
//               internal checks.  This is the same as set_row(), but
//               it does not check for the possibility that the array
//               has been reallocated internally for some reason; use
//               only when you are confident that the array is
//               unchanged and you really need every bit of available
//               performance.
////////////////////////////////////////////////////////////////////
56
inline void GeomVertexRewriter::set_row_unsafe(int row);

2423 7 set_row 0 4 3088 27 GeomVertexRewriter::set_row 0 1 927 379
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_row
//       Access: Published
//  Description: Sets the start, write, and write index to the
//               indicated value.  The rewriter will begin traversing
//               from the given row.
////////////////////////////////////////////////////////////////////
49
inline void GeomVertexRewriter::set_row(int row);

2424 13 get_start_row 0 4 3088 33 GeomVertexRewriter::get_start_row 0 1 928 380
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_start_row
//       Access: Published
//  Description: Returns the row index at which the rewriter
//               started.  It will return to this row if you reset
//               the current column.
////////////////////////////////////////////////////////////////////
57
inline int GeomVertexRewriter::get_start_row(void) const;

2425 9 is_at_end 0 4 3088 29 GeomVertexRewriter::is_at_end 0 1 929 348
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::is_at_end
//       Access: Published
//  Description: Returns true if the reader or writer is currently at
//               the end of the list of vertices, false otherwise.
////////////////////////////////////////////////////////////////////
54
inline bool GeomVertexRewriter::is_at_end(void) const;

2426 6 output 0 4 3088 26 GeomVertexRewriter::output 0 1 930 226
////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::output
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
52
void GeomVertexRewriter::output(ostream &out) const;

2427 12 SamplerState 0 4 3089 26 SamplerState::SamplerState 0 1 935 303
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::Constructor
//       Access: Published
//  Description: Creates a new SamplerState initialized to the
//               default values.
////////////////////////////////////////////////////////////////////
40
inline SamplerState::SamplerState(void);

2428 11 get_default 0 4 3089 25 SamplerState::get_default 0 1 936 322
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_default
//       Access: Published, Static
//  Description: Returns a reference to the global default immutable
//               SamplerState object.
////////////////////////////////////////////////////////////////////
66
static inline SamplerState const &SamplerState::get_default(void);

2429 10 set_wrap_u 0 4 3089 24 SamplerState::set_wrap_u 0 1 937 479
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_wrap_u
//       Access: Published
//  Description: This setting determines what happens when the
//               SamplerState is sampled with a U value outside the range
//               0.0-1.0.  The default is WM_repeat, which indicates
//               that the SamplerState should repeat indefinitely.
////////////////////////////////////////////////////////////////////
66
inline void SamplerState::set_wrap_u(SamplerState::WrapMode wrap);

2430 10 set_wrap_v 0 4 3089 24 SamplerState::set_wrap_v 0 1 938 479
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_wrap_v
//       Access: Published
//  Description: This setting determines what happens when the
//               SamplerState is sampled with a V value outside the range
//               0.0-1.0.  The default is WM_repeat, which indicates
//               that the SamplerState should repeat indefinitely.
////////////////////////////////////////////////////////////////////
66
inline void SamplerState::set_wrap_v(SamplerState::WrapMode wrap);

2431 10 set_wrap_w 0 4 3089 24 SamplerState::set_wrap_w 0 1 939 280
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_wrap_w
//       Access: Published
//  Description: The W wrap direction is only used for 3-d SamplerStates.
////////////////////////////////////////////////////////////////////
66
inline void SamplerState::set_wrap_w(SamplerState::WrapMode wrap);

2432 13 set_minfilter 0 4 3089 27 SamplerState::set_minfilter 0 1 940 336
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_minfilter
//       Access: Published
//  Description: Sets the filtering method that should be used when
//               viewing the SamplerState from a distance.
////////////////////////////////////////////////////////////////////
73
inline void SamplerState::set_minfilter(SamplerState::FilterType filter);

2433 13 set_magfilter 0 4 3089 27 SamplerState::set_magfilter 0 1 941 329
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_magfilter
//       Access: Published
//  Description: Sets the filtering method that should be used when
//               viewing the SamplerState up close.
////////////////////////////////////////////////////////////////////
73
inline void SamplerState::set_magfilter(SamplerState::FilterType filter);

2434 22 set_anisotropic_degree 0 4 3089 36 SamplerState::set_anisotropic_degree 0 1 942 748
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_anisotropic_degree
//       Access: Published
//  Description: Specifies the level of anisotropic filtering to apply
//               to the SamplerState.  Set this 0 to indicate the default
//               value, which is specified in the
//               SamplerState-anisotropic-degree config variable.
//
//               To explicitly disable anisotropic filtering, set this
//               value to 1.  To explicitly enable anisotropic
//               filtering, set it to a value higher than 1; larger
//               numbers indicate greater degrees of filtering.
////////////////////////////////////////////////////////////////////
73
inline void SamplerState::set_anisotropic_degree(int anisotropic_degree);

2435 16 set_border_color 0 4 3089 30 SamplerState::set_border_color 0 1 943 461
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_border_color
//       Access: Published
//  Description: Specifies the solid color of the SamplerState's border.
//               Some OpenGL implementations use a border for tiling
//               SamplerStates; in Panda, it is only used for specifying
//               the clamp color.
////////////////////////////////////////////////////////////////////
64
inline void SamplerState::set_border_color(LColor const &color);

2436 11 set_min_lod 0 4 3089 25 SamplerState::set_min_lod 0 1 944 368
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_min_lod
//       Access: Published
//  Description: Sets the minimum level of detail that will be used
//               when sampling this texture.  This may be a negative
//               value.
////////////////////////////////////////////////////////////////////
59
inline void SamplerState::set_min_lod(PN_stdfloat min_lod);

2437 11 set_max_lod 0 4 3089 25 SamplerState::set_max_lod 0 1 945 404
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_max_lod
//       Access: Published
//  Description: Sets the maximum level of detail that will be used
//               when sampling this texture.  This may exceed the
//               number of mipmap levels that the texture has.
////////////////////////////////////////////////////////////////////
59
inline void SamplerState::set_max_lod(PN_stdfloat max_lod);

2438 12 set_lod_bias 0 4 3089 26 SamplerState::set_lod_bias 0 1 946 471
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_lod_bias
//       Access: Published
//  Description: Sets the value that will be added to the level of
//               detail when sampling the texture.  This may be a
//               negative value, although some graphics hardware may
//               not support the use of negative LOD values.
////////////////////////////////////////////////////////////////////
61
inline void SamplerState::set_lod_bias(PN_stdfloat lod_bias);

2439 10 get_wrap_u 0 4 3089 24 SamplerState::get_wrap_u 0 1 947 297
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_wrap_u
//       Access: Published
//  Description: Returns the wrap mode of the texture in the U
//               direction.
////////////////////////////////////////////////////////////////////
67
inline SamplerState::WrapMode SamplerState::get_wrap_u(void) const;

2440 10 get_wrap_v 0 4 3089 24 SamplerState::get_wrap_v 0 1 948 297
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_wrap_v
//       Access: Published
//  Description: Returns the wrap mode of the texture in the V
//               direction.
////////////////////////////////////////////////////////////////////
67
inline SamplerState::WrapMode SamplerState::get_wrap_v(void) const;

2441 10 get_wrap_w 0 4 3089 24 SamplerState::get_wrap_w 0 1 949 360
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_wrap_w
//       Access: Published
//  Description: Returns the wrap mode of the texture in the W
//               direction.  This is the depth direction of 3-d
//               textures.
////////////////////////////////////////////////////////////////////
67
inline SamplerState::WrapMode SamplerState::get_wrap_w(void) const;

2442 13 get_minfilter 0 4 3089 27 SamplerState::get_minfilter 0 1 950 492
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_minfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               minification.  If this is one of the mipmap
//               constants, then the texture requires mipmaps.  This
//               may return FT_default; see also
//               get_effective_minfilter().
////////////////////////////////////////////////////////////////////
72
inline SamplerState::FilterType SamplerState::get_minfilter(void) const;

2443 13 get_magfilter 0 4 3089 27 SamplerState::get_magfilter 0 1 951 440
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_magfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               magnification.  The mipmap constants are invalid
//               here.  This may return FT_default; see also
//               get_effective_minfilter().
////////////////////////////////////////////////////////////////////
72
inline SamplerState::FilterType SamplerState::get_magfilter(void) const;

2444 23 get_effective_minfilter 0 4 3089 37 SamplerState::get_effective_minfilter 0 1 952 470
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_effective_minfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               minification, with special treatment for FT_default.
//               This will normally not return FT_default, unless
//               there is an error in the config file.
////////////////////////////////////////////////////////////////////
75
SamplerState::FilterType SamplerState::get_effective_minfilter(void) const;

2445 23 get_effective_magfilter 0 4 3089 37 SamplerState::get_effective_magfilter 0 1 953 471
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_effective_magfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               magnification, with special treatment for FT_default.
//               This will normally not return FT_default, unless
//               there is an error in the config file.
////////////////////////////////////////////////////////////////////
75
SamplerState::FilterType SamplerState::get_effective_magfilter(void) const;

2446 22 get_anisotropic_degree 0 4 3089 36 SamplerState::get_anisotropic_degree 0 1 954 468
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_anisotropic_degree
//       Access: Published
//  Description: Returns the degree of anisotropic filtering that
//               should be applied to the texture.  This value may
//               return 0, indicating the default value; see also
//               get_effective_anisotropic_degree.
////////////////////////////////////////////////////////////////////
60
inline int SamplerState::get_anisotropic_degree(void) const;

2447 32 get_effective_anisotropic_degree 0 4 3089 46 SamplerState::get_effective_anisotropic_degree 0 1 955 464
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_effective_anisotropic_degree
//       Access: Published
//  Description: Returns the degree of anisotropic filtering that
//               should be applied to the texture.  This value will
//               normally not return 0, unless there is an error in
//               the config file.
////////////////////////////////////////////////////////////////////
70
inline int SamplerState::get_effective_anisotropic_degree(void) const;

2448 16 get_border_color 0 4 3089 30 SamplerState::get_border_color 0 1 956 449
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_border_color
//       Access: Published
//  Description: Returns the solid color of the texture's border.
//               Some OpenGL implementations use a border for tiling
//               textures; in Panda, it is only used for specifying
//               the clamp color.
////////////////////////////////////////////////////////////////////
64
inline LColor const &SamplerState::get_border_color(void) const;

2449 11 get_min_lod 0 4 3089 25 SamplerState::get_min_lod 0 1 957 327
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_min_lod
//       Access: Published
//  Description: Returns the minimum level of detail that will be
//               observed when sampling this texture.
////////////////////////////////////////////////////////////////////
57
inline PN_stdfloat SamplerState::get_min_lod(void) const;

2450 11 get_max_lod 0 4 3089 25 SamplerState::get_max_lod 0 1 958 327
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_max_lod
//       Access: Published
//  Description: Returns the maximum level of detail that will be
//               observed when sampling this texture.
////////////////////////////////////////////////////////////////////
57
inline PN_stdfloat SamplerState::get_max_lod(void) const;

2451 12 get_lod_bias 0 4 3089 26 SamplerState::get_lod_bias 0 1 959 337
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_lod_bias
//       Access: Published
//  Description: Returns the bias that will be added to the texture
//               level of detail when sampling this texture.
////////////////////////////////////////////////////////////////////
58
inline PN_stdfloat SamplerState::get_lod_bias(void) const;

2452 12 uses_mipmaps 0 4 3089 26 SamplerState::uses_mipmaps 0 1 960 360
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::uses_mipmaps
//       Access: Public
//  Description: Returns true if the minfilter settings on this
//               sampler indicate the use of mipmapping, false
//               otherwise.
////////////////////////////////////////////////////////////////////
51
inline bool SamplerState::uses_mipmaps(void) const;

2453 9 is_mipmap 0 4 3089 23 SamplerState::is_mipmap 0 1 961 343
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::is_mipmap
//       Access: Published, Static
//  Description: Returns true if the indicated filter type requires
//               the use of mipmaps, or false if it does not.
////////////////////////////////////////////////////////////////////
74
static inline bool SamplerState::is_mipmap(SamplerState::FilterType type);

2454 18 format_filter_type 0 4 3089 32 SamplerState::format_filter_type 0 1 962 317
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::format_filter_type
//       Access: Published, Static
//  Description: Returns the indicated FilterType converted to a
//               string word.
////////////////////////////////////////////////////////////////////
76
static string SamplerState::format_filter_type(SamplerState::FilterType ft);

2455 18 string_filter_type 0 4 3089 32 SamplerState::string_filter_type 0 1 963 411
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::string_filter_type
//       Access: Public
//  Description: Returns the FilterType value associated with the given
//               string representation, or FT_invalid if the string
//               does not match any known FilterType value.
////////////////////////////////////////////////////////////////////
84
static SamplerState::FilterType SamplerState::string_filter_type(string const &str);

2456 16 format_wrap_mode 0 4 3089 30 SamplerState::format_wrap_mode 0 1 964 313
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::format_wrap_mode
//       Access: Published, Static
//  Description: Returns the indicated WrapMode converted to a
//               string word.
////////////////////////////////////////////////////////////////////
72
static string SamplerState::format_wrap_mode(SamplerState::WrapMode wm);

2457 16 string_wrap_mode 0 4 3089 30 SamplerState::string_wrap_mode 0 1 965 405
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::string_wrap_mode
//       Access: Public
//  Description: Returns the WrapMode value associated with the given
//               string representation, or WM_invalid if the string
//               does not match any known WrapMode value.
////////////////////////////////////////////////////////////////////
80
static SamplerState::WrapMode SamplerState::string_wrap_mode(string const &str);

2458 11 operator == 0 4 3089 25 SamplerState::operator == 0 1 966 0
71
inline bool SamplerState::operator ==(SamplerState const &other) const;

2459 11 operator != 0 4 3089 25 SamplerState::operator != 0 1 967 0
71
inline bool SamplerState::operator !=(SamplerState const &other) const;

2460 10 operator < 0 4 3089 24 SamplerState::operator < 0 1 968 0
70
inline bool SamplerState::operator <(SamplerState const &other) const;

2461 7 prepare 0 4 3089 21 SamplerState::prepare 0 1 969 519
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::prepare
//       Access: Published
//  Description: Indicates that the sampler should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.
//
//               Use this function instead of prepare_now() to preload
//               samplers from a user interface standpoint.
////////////////////////////////////////////////////////////////////
76
void SamplerState::prepare(PreparedGraphicsObjects *prepared_objects) const;

2462 11 is_prepared 0 4 3089 25 SamplerState::is_prepared 0 1 970 379
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::is_prepared
//       Access: Published
//  Description: Returns true if the sampler has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
////////////////////////////////////////////////////////////////////
80
bool SamplerState::is_prepared(PreparedGraphicsObjects *prepared_objects) const;

2463 7 release 0 4 3089 21 SamplerState::release 0 1 971 399
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::release
//       Access: Published
//  Description: Frees the texture context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
////////////////////////////////////////////////////////////////////
76
void SamplerState::release(PreparedGraphicsObjects *prepared_objects) const;

2464 11 prepare_now 0 4 3089 25 SamplerState::prepare_now 0 1 972 894
////////////////////////////////////////////////////////////////////
//     Function: SamplerState::prepare_now
//       Access: Published
//  Description: Creates a context for the sampler on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) SamplerContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               textures.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a sampler does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
////////////////////////////////////////////////////////////////////
123
SamplerContext *SamplerState::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg) const;

2465 14 get_class_type 0 4 3089 28 SamplerState::get_class_type 0 1 973 0
53
static TypeHandle SamplerState::get_class_type(void);

2466 13 ~SamplerState 0 4 3089 27 SamplerState::~SamplerState 0 0 0
34
SamplerState::~SamplerState(void);

2467 37 upcast_to_TypedWritableReferenceCount 0 12 3092 46 Texture::upcast_to_TypedWritableReferenceCount 0 1 1192 50
upcast from Texture to TypedWritableReferenceCount
82
TypedWritableReferenceCount *Texture::upcast_to_TypedWritableReferenceCount(void);

2468 19 downcast_to_Texture 0 12 3039 48 TypedWritableReferenceCount::downcast_to_Texture 0 1 1193 52
downcast from TypedWritableReferenceCount to Texture
64
Texture *TypedWritableReferenceCount::downcast_to_Texture(void);

2469 17 upcast_to_Namable 0 12 3092 26 Texture::upcast_to_Namable 0 1 1194 30
upcast from Texture to Namable
42
Namable *Texture::upcast_to_Namable(void);

2470 19 downcast_to_Texture 0 12 3025 28 Namable::downcast_to_Texture 0 1 1195 32
downcast from Namable to Texture
44
Texture *Namable::downcast_to_Texture(void);

2471 7 Texture 0 4 3092 16 Texture::Texture 0 1 974 763
////////////////////////////////////////////////////////////////////
//     Function: Texture::Constructor
//       Access: Published
//  Description: Constructs an empty texture.  The default is to set
//               up the texture as an empty 2-d texture; follow up
//               with one of the variants of setup_texture() if this
//               is not what you want.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::Copy Constructor
//       Access: Protected
//  Description: Use Texture::make_copy() to make a duplicate copy of
//               an existing Texture.
////////////////////////////////////////////////////////////////////
57
explicit Texture::Texture(string const &name = string());

2472 8 ~Texture 0 6 3092 17 Texture::~Texture 0 0 227
////////////////////////////////////////////////////////////////////
//     Function: Texture::Destructor
//       Access: Published, Virtual
//  Description:
////////////////////////////////////////////////////////////////////
32
virtual Texture::~Texture(void);

2473 9 make_copy 0 4 3092 18 Texture::make_copy 0 1 975 680
////////////////////////////////////////////////////////////////////
//     Function: Texture::make_copy
//       Access: Published
//  Description: Returns a new copy of the same Texture.  This copy,
//               if applied to geometry, will be copied into texture
//               as a separate texture from the original, so it will
//               be duplicated in texture memory (and may be
//               independently modified if desired).
//
//               If the Texture is a VideoTexture, the resulting
//               duplicate may be animated independently of the
//               original.
////////////////////////////////////////////////////////////////////
59
inline PointerTo< Texture > Texture::make_copy(void) const;

2474 5 clear 0 4 3092 14 Texture::clear 0 1 976 316
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear
//       Access: Published, Virtual
//  Description: Reinitializes the texture to its default, empty
//               state (except for the name).
////////////////////////////////////////////////////////////////////
33
inline void Texture::clear(void);

2475 13 setup_texture 0 4 3092 22 Texture::setup_texture 0 1 977 513
////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_texture
//       Access: Published
//  Description: Sets the texture to the indicated type and
//               dimensions, presumably in preparation for calling
//               read() or load(), or set_ram_image() or
//               modify_ram_image(), or use set_clear_color to let
//               the texture be cleared to a solid color.
////////////////////////////////////////////////////////////////////
169
inline void Texture::setup_texture(Texture::TextureType texture_type, int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format);

2476 16 setup_1d_texture 0 4 3092 25 Texture::setup_1d_texture 0 2 978 979 1034
////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_1d_texture
//       Access: Published
//  Description: Sets the texture as an empty 1-d texture with no
//               dimensions.  Follow up with read() or load() to fill
//               the texture properties and image data, or use
//               set_clear_color to let the texture be cleared to a
//               solid color.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_1d_texture
//       Access: Published
//  Description: Sets the texture as an empty 1-d texture with the
//               specified dimensions and properties.  Follow up with
//               set_ram_image() or modify_ram_image() to fill the
//               image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
////////////////////////////////////////////////////////////////////
158
inline void Texture::setup_1d_texture(void);
inline void Texture::setup_1d_texture(int x_size, Texture::ComponentType component_type, Texture::Format format);

2477 16 setup_2d_texture 0 4 3092 25 Texture::setup_2d_texture 0 2 980 981 1034
////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_2d_texture
//       Access: Published
//  Description: Sets the texture as an empty 2-d texture with no
//               dimensions.  Follow up with read() or load() to fill
//               the texture properties and image data, or use
//               set_clear_color to let the texture be cleared to a
//               solid color.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_2d_texture
//       Access: Published
//  Description: Sets the texture as an empty 2-d texture with the
//               specified dimensions and properties.  Follow up with
//               set_ram_image() or modify_ram_image() to fill the
//               image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
////////////////////////////////////////////////////////////////////
170
inline void Texture::setup_2d_texture(void);
inline void Texture::setup_2d_texture(int x_size, int y_size, Texture::ComponentType component_type, Texture::Format format);

2478 16 setup_3d_texture 0 4 3092 25 Texture::setup_3d_texture 0 2 982 983 1045
////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_3d_texture
//       Access: Published
//  Description: Sets the texture as an empty 3-d texture with no
//               dimensions (though if you know the depth ahead
//               of time, it saves a bit of reallocation later).
//               Follow up with read() or load() to fill the texture
//               properties and image data, or use set_clear_color
//               to let the texture be cleared to a solid color.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_3d_texture
//       Access: Published
//  Description: Sets the texture as an empty 3-d texture with the
//               specified dimensions and properties.  Follow up with
//               set_ram_image() or modify_ram_image() to fill the
//               image data.
////////////////////////////////////////////////////////////////////
192
inline void Texture::setup_3d_texture(int z_size = 1);
inline void Texture::setup_3d_texture(int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format);

2479 14 setup_cube_map 0 4 3092 23 Texture::setup_cube_map 0 2 984 985 1222
////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_cube_map
//       Access: Published
//  Description: Sets the texture as an empty cube map texture with no
//               dimensions.  Follow up with read() or load() to fill
//               the texture properties and image data, or use
//               set_clear_color to let the texture be cleared to a
//               solid color.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_cube_map
//       Access: Published
//  Description: Sets the texture as an empty cube map texture with
//               the specified dimensions and properties.  Follow up
//               with set_ram_image() or modify_ram_image() to fill
//               the image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
//
//               Note that a cube map should always consist of six
//               square images, so x_size and y_size will be the same,
//               and z_size is always 6.
////////////////////////////////////////////////////////////////////
152
inline void Texture::setup_cube_map(void);
inline void Texture::setup_cube_map(int size, Texture::ComponentType component_type, Texture::Format format);

2480 22 setup_2d_texture_array 0 4 3092 31 Texture::setup_2d_texture_array 0 2 986 987 1156
////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_2d_texture_array
//       Access: Published
//  Description: Sets the texture as an empty 2-d texture array with
//               no dimensions (though if you know the depth ahead
//               of time, it saves a bit of reallocation later).
//               Follow up with read() or load() to fill the texture
//               properties and image data, or use set_clear_color
//               to let the texture be cleared to a solid color.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_2d_texture_array
//       Access: Published
//  Description: Sets the texture as an empty 2-d texture array with the
//               specified dimensions and properties. Follow up with
//               set_ram_image() or modify_ram_image() to fill the
//               image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
////////////////////////////////////////////////////////////////////
204
inline void Texture::setup_2d_texture_array(int z_size = 1);
inline void Texture::setup_2d_texture_array(int x_size, int y_size, int z_size, Texture::ComponentType component_type, Texture::Format format);

2481 20 setup_buffer_texture 0 4 3092 29 Texture::setup_buffer_texture 0 1 988 637
////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_buffer_texture
//       Access: Published
//  Description: Sets the texture as an empty buffer texture with
//               the specified size and properties.  Follow up
//               with set_ram_image() or modify_ram_image() to fill
//               the image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
//
//               Note that a buffer texture's format needs to match
//               the component type.
////////////////////////////////////////////////////////////////////
143
inline void Texture::setup_buffer_texture(int size, Texture::ComponentType component_type, Texture::Format format, GeomEnums::UsageHint usage);

2482 31 generate_normalization_cube_map 0 4 3092 40 Texture::generate_normalization_cube_map 0 1 989 601
////////////////////////////////////////////////////////////////////
//     Function: Texture::generate_normalization_cube_map
//       Access: Published
//  Description: Generates a special cube map image in the texture
//               that can be used to apply bump mapping effects: for
//               each texel in the cube map that is indexed by the 3-d
//               texture coordinates (x, y, z), the resulting value is
//               the normalized vector (x, y, z) (compressed from
//               -1..1 into 0..1).
////////////////////////////////////////////////////////////////////
56
void Texture::generate_normalization_cube_map(int size);

2483 24 generate_alpha_scale_map 0 4 3092 33 Texture::generate_alpha_scale_map 0 1 990 534
////////////////////////////////////////////////////////////////////
//     Function: Texture::generate_alpha_scale_map
//       Access: Published
//  Description: Generates a special 256x1 1-d texture that can be
//               used to apply an arbitrary alpha scale to objects by
//               judicious use of texture matrix.  The texture is a
//               gradient, with an alpha of 0 on the left (U = 0), and
//               255 on the right (U = 1).
////////////////////////////////////////////////////////////////////
45
void Texture::generate_alpha_scale_map(void);

2484 11 clear_image 0 4 3092 20 Texture::clear_image 0 1 991 772
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_image
//       Access: Published
//  Description: Clears the texture data without changing its format
//               or resolution.  The texture is cleared on both the
//               graphics hardware and from RAM, unlike clear_ram_image,
//               which only removes the data from RAM.
//
//               If a clear color has been specified using
//               set_clear_color, the texture will be cleared using
//               a solid color.
//
//               The texture data will be cleared the first time in
//               which the texture is used after this method is called.
////////////////////////////////////////////////////////////////////
39
inline void Texture::clear_image(void);

2485 15 has_clear_color 0 4 3092 24 Texture::has_clear_color 0 1 992 306
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_clear_color
//       Access: Published
//  Description: Returns true if a color was previously set using
//               set_clear_color.
////////////////////////////////////////////////////////////////////
49
inline bool Texture::has_clear_color(void) const;

2486 15 get_clear_color 0 4 3092 24 Texture::get_clear_color 0 1 993 305
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_clear_color
//       Access: Published
//  Description: Returns the color that was previously set using
//               set_clear_color.
////////////////////////////////////////////////////////////////////
51
inline LColor Texture::get_clear_color(void) const;

2487 15 set_clear_color 0 4 3092 24 Texture::set_clear_color 0 1 994 659
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_clear_color
//       Access: Published
//  Description: Sets the color that will be used to fill the
//               texture image in absence of any image data.  It is
//               used when any of the setup_texture functions or
//               clear_image is called and image data is not
//               provided using read() or modify_ram_image().
//
//               This does not affect a texture that has already
//               been cleared; call clear_image to clear it again.
////////////////////////////////////////////////////////////////////
58
inline void Texture::set_clear_color(LColor const &color);

2488 14 get_clear_data 0 4 3092 23 Texture::get_clear_data 0 1 995 320
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_clear_data
//       Access: Published
//  Description: Returns the raw image data for a single pixel if
//               it were set to the clear color.
////////////////////////////////////////////////////////////////////
50
inline string Texture::get_clear_data(void) const;

2489 4 read 0 4 3092 13 Texture::read 0 4 996 997 998 999 5206
////////////////////////////////////////////////////////////////////
//     Function: Texture::read
//       Access: Published
//  Description: Reads the named filename into the texture.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::read
//       Access: Published
//  Description: Combine a 3-component image with a grayscale image
//               to get a 4-component image.
//
//               See the description of the full-parameter read()
//               method for the meaning of the
//               primary_file_num_channels and alpha_file_channel
//               parameters.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::read
//       Access: Published
//  Description: Reads a single file into a single page or mipmap
//               level, or automatically reads a series of files into
//               a series of pages and/or mipmap levels.
//
//               See the description of the full-parameter read()
//               method for the meaning of the various parameters.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::read
//       Access: Published
//  Description: Reads the texture from the indicated filename.  If
//               primary_file_num_channels is not 0, it specifies the
//               number of components to downgrade the image to if it
//               is greater than this number.
//
//               If the filename has the extension .txo, this
//               implicitly reads a texture object instead of a
//               filename (which replaces all of the texture
//               properties).  In this case, all the rest of the
//               parameters are ignored, and the filename should not
//               contain any hash marks; just the one named file will
//               be read, since a single .txo file can contain all
//               pages and mipmaps necessary to define a texture.
//
//               If alpha_fullpath is not empty, it specifies the name
//               of a file from which to retrieve the alpha.  In this
//               case, alpha_file_channel represents the numeric
//               channel of this image file to use as the resulting
//               texture's alpha channel; usually, this is 0 to
//               indicate the grayscale combination of r, g, b; or it
//               may be a one-based channel number, e.g. 1 for the red
//               channel, 2 for the green channel, and so on.
//
//               If read pages is false, then z indicates the page
//               number into which this image will be assigned.
//               Normally this is 0 for the first (or only) page of
//               the texture.  3-D textures have one page for each
//               level of depth, and cube map textures always have six
//               pages.
//
//               If read_pages is true, multiple images will be read
//               at once, one for each page of a cube map or a 3-D
//               texture.  In this case, the filename should contain a
//               sequence of one or more hash marks ("#") which will
//               be filled in with the z value of each page,
//               zero-based.  In this case, the z parameter indicates
//               the maximum z value that will be loaded, or 0 to load
//               all filenames that exist.
//
//               If read_mipmaps is false, then n indicates the mipmap
//               level to which this image will be assigned.  Normally
//               this is 0 for the base texture image, but it is
//               possible to load custom mipmap levels into the later
//               images.  After the base texture image is loaded (thus
//               defining the size of the texture), you can call
//               get_expected_num_mipmap_levels() to determine the
//               maximum sensible value for n.
//
//               If read_mipmaps is true, multiple images will be read
//               as above, but this time the images represent the
//               different mipmap levels of the texture image.  In
//               this case, the n parameter indicates the maximum n
//               value that will be loaded, or 0 to load all filenames
//               that exist (up to the expected number of mipmap
//               levels).
//
//               If both read_pages and read_mipmaps is true, then
//               both sequences will be read; the filename should
//               contain two sequences of hash marks, separated by
//               some character such as a hyphen, underscore, or dot.
//               The first hash mark sequence will be filled in with
//               the mipmap level, while the second hash mark sequence
//               will be the page index.
//
//               This method implicitly sets keep_ram_image to false.
////////////////////////////////////////////////////////////////////
677
bool Texture::read(Filename const &fullpath, LoaderOptions const &options = LoaderOptions());
bool Texture::read(Filename const &fullpath, Filename const &alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, LoaderOptions const &options = LoaderOptions());
bool Texture::read(Filename const &fullpath, int z, int n, bool read_pages, bool read_mipmaps, LoaderOptions const &options = LoaderOptions());
bool Texture::read(Filename const &fullpath, Filename const &alpha_fullpath, int primary_file_num_channels, int alpha_file_channel, int z, int n, bool read_pages, bool read_mipmaps, BamCacheRecord *record = 0, LoaderOptions const &options = LoaderOptions());

2490 5 write 0 4 3092 14 Texture::write 0 3 1000 1001 1002 3708
////////////////////////////////////////////////////////////////////
//     Function: Texture::write
//       Access: Published
//  Description: Writes the texture to the named filename.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::write
//       Access: Published
//  Description: Writes a single page or mipmap level to a single
//               file, or automatically writes a series of pages
//               and/or mipmap levels to a numbered series of files.
//
//               If the filename ends in the extension .txo, this
//               implicitly writes a Panda texture object (.txo)
//               instead of an image file.  In this case, the
//               remaining parameters are ignored, and only one file
//               is written, which will contain all of the pages and
//               resident mipmap levels in the texture.
//
//               If write_pages is false, then z indicates the page
//               number to write.  3-D textures have one page number
//               for each level of depth; cube maps have six pages
//               number 0 through 5.  Other kinds of textures have
//               only one page, numbered 0.  If there are multiple
//               views, the range of z is increased; the total range
//               is [0, get_num_pages()).
//
//               If write_pages is true, then all pages of the texture
//               will be written.  In this case z is ignored, and the
//               filename should contain a sequence of hash marks
//               ("#") which will be filled in with the page index
//               number.
//
//               If write_mipmaps is false, then n indicates the
//               mipmap level number to write.  Normally, this is 0,
//               for the base texture image.  Normally, the mipmap
//               levels of a texture are not available in RAM (they
//               are generated automatically by the graphics card).
//               However, if you have the mipmap levels available, for
//               instance because you called
//               generate_ram_mipmap_images() to generate them
//               internally, or you called
//               GraphicsEngine::extract_texture_data() to retrieve
//               them from the graphics card, then you may write out
//               each mipmap level with this parameter.
//
//               If write_mipmaps is true, then all mipmap levels of
//               the texture will be written.  In this case n is
//               ignored, and the filename should contain a sequence
//               of hash marks ("#") which will be filled in with the
//               mipmap level number.
//
//               If both write_pages and write_mipmaps is true, then
//               all pages and all mipmap levels will be written.  In
//               this case, the filename should contain two different
//               sequences of hash marks, separated by a character
//               such as a hyphen, underscore, or dot.  The first hash
//               mark sequence will be filled in with the mipmap
//               level, while the second hash mark sequence will be
//               the page index.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::write
//       Access: Published
//  Description: Not to be confused with write(Filename), this method
//               simply describes the texture properties.
////////////////////////////////////////////////////////////////////
218
inline bool Texture::write(Filename const &fullpath);
inline bool Texture::write(Filename const &fullpath, int z, int n, bool write_pages, bool write_mipmaps);
void Texture::write(ostream &out, int indent_level) const;

2491 8 read_txo 0 4 3092 17 Texture::read_txo 0 1 1003 692
////////////////////////////////////////////////////////////////////
//     Function: Texture::read_txo
//       Access: Published
//  Description: Reads the texture from a Panda texture object.  This
//               defines the complete Texture specification, including
//               the image data as well as all texture properties.
//               This only works if the txo file contains a static
//               Texture image, as opposed to a subclass of Texture
//               such as a movie texture.
//
//               Pass a real filename if it is available, or empty
//               string if it is not.
////////////////////////////////////////////////////////////////////
65
bool Texture::read_txo(istream &in, string const &filename = "");

2492 13 make_from_txo 0 4 3092 22 Texture::make_from_txo 0 1 1004 621
////////////////////////////////////////////////////////////////////
//     Function: Texture::make_from_txo
//       Access: Published, Static
//  Description: Constructs a new Texture object from the txo file.
//               This is similar to Texture::read_txo(), but it
//               constructs and returns a new object, which allows it
//               to return a subclass of Texture (for instance, a
//               movie texture).
//
//               Pass a real filename if it is available, or empty
//               string if it is not.
////////////////////////////////////////////////////////////////////
93
static PointerTo< Texture > Texture::make_from_txo(istream &in, string const &filename = "");

2493 9 write_txo 0 4 3092 18 Texture::write_txo 0 1 1005 463
////////////////////////////////////////////////////////////////////
//     Function: Texture::write_txo
//       Access: Published
//  Description: Writes the texture to a Panda texture object.  This
//               defines the complete Texture specification, including
//               the image data as well as all texture properties.
//
//               The filename is just for reference.
////////////////////////////////////////////////////////////////////
73
bool Texture::write_txo(ostream &out, string const &filename = "") const;

2494 8 read_dds 0 4 3092 17 Texture::read_dds 0 1 1006 674
////////////////////////////////////////////////////////////////////
//     Function: Texture::read_dds
//       Access: Published
//  Description: Reads the texture from a DDS file object.  This is a
//               Microsoft-defined file format; it is similar in
//               principle to a txo object, in that it is designed to
//               contain the texture image in a form as similar as
//               possible to its runtime image, and it can contain
//               mipmaps, pre-compressed textures, and so on.
//
//               As with read_txo, the filename is just for reference.
////////////////////////////////////////////////////////////////////
87
bool Texture::read_dds(istream &in, string const &filename = "", bool header_only = 0);

2495 4 load 0 4 3092 13 Texture::load 0 4 1007 1008 1009 1010 1134
////////////////////////////////////////////////////////////////////
//     Function: Texture::load
//       Access: Published
//  Description: Replaces the texture with the indicated image.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::load
//       Access: Published
//  Description: Stores the indicated image in the given page and
//               mipmap level.  See read().
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::load
//       Access: Published
//  Description: Replaces the texture with the indicated image.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::load
//       Access: Published
//  Description: Stores the indicated image in the given page and
//               mipmap level.  See read().
////////////////////////////////////////////////////////////////////
419
inline bool Texture::load(PNMImage const &pnmimage, LoaderOptions const &options = LoaderOptions());
inline bool Texture::load(PNMImage const &pnmimage, int z, int n, LoaderOptions const &options = LoaderOptions());
inline bool Texture::load(PfmFile const &pfm, LoaderOptions const &options = LoaderOptions());
inline bool Texture::load(PfmFile const &pfm, int z, int n, LoaderOptions const &options = LoaderOptions());

2496 14 load_sub_image 0 4 3092 23 Texture::load_sub_image 0 1 1011 628
////////////////////////////////////////////////////////////////////
//     Function: Texture::load_sub_image
//       Access: Published
//  Description: Stores the indicated image in a region of the
//               texture.  The texture properties remain unchanged.
//               This can be more efficient than updating an entire
//               texture, but has a few restrictions: for one, you
//               must ensure that the texture is still in RAM (eg.
//               using set_keep_ram_image) and it may not be
//               compressed.
////////////////////////////////////////////////////////////////////
98
inline bool Texture::load_sub_image(PNMImage const &pnmimage, int x, int y, int z = 0, int n = 0);

2497 5 store 0 4 3092 14 Texture::store 0 4 1012 1013 1014 1015 1224
////////////////////////////////////////////////////////////////////
//     Function: Texture::store
//       Access: Published
//  Description: Saves the texture to the indicated PNMImage, but does
//               not write it to disk.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::store
//       Access: Published
//  Description: Saves the indicated page and mipmap level of the
//               texture to the PNMImage.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::store
//       Access: Published
//  Description: Saves the texture to the indicated PfmFile, but does
//               not write it to disk.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::store
//       Access: Published
//  Description: Saves the indicated page and mipmap level of the
//               texture to the PfmFile.
////////////////////////////////////////////////////////////////////
231
inline bool Texture::store(PNMImage &pnmimage) const;
inline bool Texture::store(PNMImage &pnmimage, int z, int n) const;
inline bool Texture::store(PfmFile &pfm) const;
inline bool Texture::store(PfmFile &pfm, int z, int n) const;

2498 6 reload 0 4 3092 15 Texture::reload 0 1 1016 532
////////////////////////////////////////////////////////////////////
//     Function: Texture::reload
//       Access: Published
//  Description: Re-reads the Texture from its disk file.  Useful when
//               you know the image on disk has recently changed, and
//               you want to update the Texture image.
//
//               Returns true on success, false on failure (in which
//               case, the Texture may or may not still be valid).
////////////////////////////////////////////////////////////////////
34
inline bool Texture::reload(void);

2499 12 load_related 0 4 3092 21 Texture::load_related 0 1 1017 444
////////////////////////////////////////////////////////////////////
//     Function: Texture::load_related
//       Access: Published
//  Description: Loads a texture whose filename is derived by
//               concatenating a suffix to the filename of this
//               texture.  May return NULL, for example, if this
//               texture doesn't have a filename.
////////////////////////////////////////////////////////////////////
65
Texture *Texture::load_related(InternalName const *suffix) const;

2500 12 has_filename 0 4 3092 21 Texture::has_filename 0 1 1018 318
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_filename
//       Access: Published
//  Description: Returns true if the filename has been set and
//               is available.  See set_filename().
////////////////////////////////////////////////////////////////////
46
inline bool Texture::has_filename(void) const;

2501 12 get_filename 0 4 3092 21 Texture::get_filename 0 1 1019 371
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_filename
//       Access: Published
//  Description: Returns the filename that has been set.  This is the
//               name of the file as it was requested.  Also see
//               get_fullpath().
////////////////////////////////////////////////////////////////////
57
inline Filename const &Texture::get_filename(void) const;

2502 18 has_alpha_filename 0 4 3092 27 Texture::has_alpha_filename 0 1 1020 336
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_alpha_filename
//       Access: Published
//  Description: Returns true if the alpha_filename has been set and
//               is available.  See set_alpha_filename().
////////////////////////////////////////////////////////////////////
52
inline bool Texture::has_alpha_filename(void) const;

2503 18 get_alpha_filename 0 4 3092 27 Texture::get_alpha_filename 0 1 1021 475
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_alpha_filename
//       Access: Published
//  Description: Returns the alpha_filename that has been set.  If
//               this is set, it represents the name of the alpha
//               component, which is stored in a separate file.  See
//               also get_filename(), and get_alpha_fullpath().
////////////////////////////////////////////////////////////////////
63
inline Filename const &Texture::get_alpha_filename(void) const;

2504 12 has_fullpath 0 4 3092 21 Texture::has_fullpath 0 1 1022 318
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_fullpath
//       Access: Published
//  Description: Returns true if the fullpath has been set and
//               is available.  See set_fullpath().
////////////////////////////////////////////////////////////////////
46
inline bool Texture::has_fullpath(void) const;

2505 12 get_fullpath 0 4 3092 21 Texture::get_fullpath 0 1 1023 376
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_fullpath
//       Access: Published
//  Description: Returns the fullpath that has been set.  This is the
//               full path to the file as it was found along the
//               texture search path.
////////////////////////////////////////////////////////////////////
57
inline Filename const &Texture::get_fullpath(void) const;

2506 18 has_alpha_fullpath 0 4 3092 27 Texture::has_alpha_fullpath 0 1 1024 336
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_alpha_fullpath
//       Access: Published
//  Description: Returns true if the alpha_fullpath has been set and
//               is available.  See set_alpha_fullpath().
////////////////////////////////////////////////////////////////////
52
inline bool Texture::has_alpha_fullpath(void) const;

2507 18 get_alpha_fullpath 0 4 3092 27 Texture::get_alpha_fullpath 0 1 1025 429
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_alpha_fullpath
//       Access: Published
//  Description:
//               Returns the alpha_fullpath that has been set.  This
//               is the full path to the alpha part of the image file
//               as it was found along the texture search path.
////////////////////////////////////////////////////////////////////
63
inline Filename const &Texture::get_alpha_fullpath(void) const;

2508 10 get_x_size 0 4 3092 19 Texture::get_x_size 0 1 1026 268
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_x_size
//       Access: Published
//  Description: Returns the width of the texture image in texels.
////////////////////////////////////////////////////////////////////
43
inline int Texture::get_x_size(void) const;

2509 10 get_y_size 0 4 3092 19 Texture::get_y_size 0 1 1027 321
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_y_size
//       Access: Published
//  Description: Returns the height of the texture image in texels.
//               For a 1-d texture, this will be 1.
////////////////////////////////////////////////////////////////////
43
inline int Texture::get_y_size(void) const;

2510 10 get_z_size 0 4 3092 19 Texture::get_z_size 0 1 1028 392
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_z_size
//       Access: Published
//  Description: Returns the depth of the texture image in texels.
//               For a 1-d texture or 2-d texture, this will be 1.
//               For a cube map texture, this will be 6.
////////////////////////////////////////////////////////////////////
43
inline int Texture::get_z_size(void) const;

2511 13 get_num_views 0 4 3092 22 Texture::get_num_views 0 1 1029 758
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_views
//       Access: Published
//  Description: Returns the number of "views" in the texture.  A view
//               is a completely separate image stored within the
//               Texture object.  Most textures have only one view,
//               but a stereo texture, for instance, may have two
//               views, a left and a right image.  Other uses for
//               multiple views are not yet defined.
//
//               If this value is greater than one, the additional
//               views are accessed as additional pages beyond
//               get_z_size().
////////////////////////////////////////////////////////////////////
46
inline int Texture::get_num_views(void) const;

2512 13 get_num_pages 0 4 3092 22 Texture::get_num_pages 0 1 1030 602
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_pages
//       Access: Published
//  Description: Returns the total number of pages in the texture.
//               Each "page" is a 2-d texture image within the larger
//               image--a face of a cube map, or a level of a 3-d
//               texture.  Normally, get_num_pages() is the same as
//               get_z_size().  However, in a multiview texture, this
//               returns get_z_size() * get_num_views().
////////////////////////////////////////////////////////////////////
46
inline int Texture::get_num_pages(void) const;

2513 18 get_num_components 0 4 3092 27 Texture::get_num_components 0 1 1031 456
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_components
//       Access: Published
//  Description: Returns the number of color components for each texel
//               of the texture image.  This is 3 for an rgb texture
//               or 4 for an rgba texture; it may also be 1 or 2 for a
//               grayscale texture.
////////////////////////////////////////////////////////////////////
51
inline int Texture::get_num_components(void) const;

2514 19 get_component_width 0 4 3092 28 Texture::get_component_width 0 1 1032 390
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_component_width
//       Access: Published
//  Description: Returns the number of bytes stored for each color
//               component of a texel.  Typically this is 1, but it
//               may be 2 for 16-bit texels.
////////////////////////////////////////////////////////////////////
52
inline int Texture::get_component_width(void) const;

2515 16 get_texture_type 0 4 3092 25 Texture::get_texture_type 0 1 1033 275
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_texture_type
//       Access: Published
//  Description: Returns the overall interpretation of the texture.
////////////////////////////////////////////////////////////////////
66
inline Texture::TextureType Texture::get_texture_type(void) const;

2516 10 get_format 0 4 3092 19 Texture::get_format 0 1 1034 392
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_format
//       Access: Published
//  Description: Returns the format of the texture, which represents
//               both the semantic meaning of the texels and, to some
//               extent, their storage information.
////////////////////////////////////////////////////////////////////
55
inline Texture::Format Texture::get_format(void) const;

2517 18 get_component_type 0 4 3092 27 Texture::get_component_type 0 1 1035 312
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_component_type
//       Access: Published
//  Description: Returns the numeric interpretation of each component
//               of the texture.
////////////////////////////////////////////////////////////////////
70
inline Texture::ComponentType Texture::get_component_type(void) const;

2518 14 get_usage_hint 0 4 3092 23 Texture::get_usage_hint 0 1 1036 340
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_usage_hint
//       Access: Published
//  Description: Returns the usage hint specified for buffer textures,
//               or UH_unspecified for all other texture types.
////////////////////////////////////////////////////////////////////
64
inline GeomEnums::UsageHint Texture::get_usage_hint(void) const;

2519 10 set_wrap_u 0 4 3092 19 Texture::set_wrap_u 0 1 1037 647
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_wrap_u
//       Access: Published
//  Description: This setting determines what happens when the
//               texture is sampled with a U value outside the range
//               0.0-1.0.  The default is WM_repeat, which indicates
//               that the texture should repeat indefinitely.
//
//               This sets the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
56
inline void Texture::set_wrap_u(Texture::WrapMode wrap);

2520 10 set_wrap_v 0 4 3092 19 Texture::set_wrap_v 0 1 1038 647
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_wrap_v
//       Access: Published
//  Description: This setting determines what happens when the
//               texture is sampled with a V value outside the range
//               0.0-1.0.  The default is WM_repeat, which indicates
//               that the texture should repeat indefinitely.
//
//               This sets the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
56
inline void Texture::set_wrap_v(Texture::WrapMode wrap);

2521 10 set_wrap_w 0 4 3092 19 Texture::set_wrap_w 0 1 1039 453
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_wrap_w
//       Access: Published
//  Description: The W wrap direction is only used for 3-d textures.
//
//               This sets the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
56
inline void Texture::set_wrap_w(Texture::WrapMode wrap);

2522 13 set_minfilter 0 4 3092 22 Texture::set_minfilter 0 1 1040 509
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_minfilter
//       Access: Published
//  Description: Sets the filtering method that should be used when
//               viewing the texture from a distance.
//
//               This sets the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
63
inline void Texture::set_minfilter(Texture::FilterType filter);

2523 13 set_magfilter 0 4 3092 22 Texture::set_magfilter 0 1 1041 502
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_magfilter
//       Access: Published
//  Description: Sets the filtering method that should be used when
//               viewing the texture up close.
//
//               This sets the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
63
inline void Texture::set_magfilter(Texture::FilterType filter);

2524 22 set_anisotropic_degree 0 4 3092 31 Texture::set_anisotropic_degree 0 1 1042 916
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_anisotropic_degree
//       Access: Published
//  Description: Specifies the level of anisotropic filtering to apply
//               to the texture.  Set this 0 to indicate the default
//               value, which is specified in the
//               texture-anisotropic-degree config variable.
//
//               To explicitly disable anisotropic filtering, set this
//               value to 1.  To explicitly enable anisotropic
//               filtering, set it to a value higher than 1; larger
//               numbers indicate greater degrees of filtering.
//
//               This sets the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
68
inline void Texture::set_anisotropic_degree(int anisotropic_degree);

2525 16 set_border_color 0 4 3092 25 Texture::set_border_color 0 1 1043 629
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_border_color
//       Access: Published
//  Description: Specifies the solid color of the texture's border.
//               Some OpenGL implementations use a border for tiling
//               textures; in Panda, it is only used for specifying
//               the clamp color.
//
//               This sets the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
59
inline void Texture::set_border_color(LColor const &color);

2526 15 set_compression 0 4 3092 24 Texture::set_compression 0 1 1044 1035
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_compression
//       Access: Published
//  Description: Requests that this particular Texture be compressed
//               when it is loaded into texture memory.
//
//               This refers to the internal compression of the
//               texture image within texture memory; it is not
//               related to jpeg or png compression, which are disk
//               file compression formats.  The actual disk file that
//               generated this texture may be stored in a compressed
//               or uncompressed format supported by Panda; it will be
//               decompressed on load, and then recompressed by the
//               graphics API if this parameter is not CM_off.
//
//               If the GSG does not support this texture compression
//               mode, the texture will silently be loaded
//               uncompressed.
////////////////////////////////////////////////////////////////////
75
inline void Texture::set_compression(Texture::CompressionMode compression);

2527 21 set_render_to_texture 0 4 3092 30 Texture::set_render_to_texture 0 1 1045 905
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_render_to_texture
//       Access: Published
//  Description: Sets a flag on the texture that indicates whether the
//               texture is intended to be used as a direct-render
//               target, by binding a framebuffer to a texture and
//               rendering directly into the texture.
//
//               This controls some low-level choices made about the
//               texture object itself.  For instance, compressed
//               textures are disallowed when this flag is set true.
//
//               Normally, a user should not need to set this flag
//               directly; it is set automatically by the low-level
//               display code when a texture is bound to a
//               framebuffer.
////////////////////////////////////////////////////////////////////
67
inline void Texture::set_render_to_texture(bool render_to_texture);

2528 19 get_default_sampler 0 4 3092 28 Texture::get_default_sampler 0 1 1046 501
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_default_sampler
//       Access: Published
//  Description: This returns the default sampler state for this
//               texture, containing the wrap and filter properties
//               specified on the texture level; it may still be
//               overridden by a sampler state specified at a higher
//               level.
////////////////////////////////////////////////////////////////////
68
inline SamplerState const &Texture::get_default_sampler(void) const;

2529 19 set_default_sampler 0 4 3092 28 Texture::set_default_sampler 0 1 1047 851
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_default_sampler
//       Access: Published
//  Description: This sets the default sampler state for this
//               texture, containing the wrap and filter properties
//               specified on the texture level; it may still be
//               overridden by a sampler state specified at a higher
//               level.  This encompasses the settings for get_wrap_u,
//               get_minfilter, get_anisotropic_degree, etc.
//
//               This makes a copy of the SamplerState object, so
//               future modifications of the same SamplerState will
//               have no effect on this texture unless you call
//               set_default_sampler again.
////////////////////////////////////////////////////////////////////
70
inline void Texture::set_default_sampler(SamplerState const &sampler);

2530 10 get_wrap_u 0 4 3092 19 Texture::get_wrap_u 0 1 1048 478
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_wrap_u
//       Access: Published
//  Description: Returns the wrap mode of the texture in the U
//               direction.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
62
inline SamplerState::WrapMode Texture::get_wrap_u(void) const;

2531 10 get_wrap_v 0 4 3092 19 Texture::get_wrap_v 0 1 1049 478
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_wrap_v
//       Access: Published
//  Description: Returns the wrap mode of the texture in the V
//               direction.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
62
inline SamplerState::WrapMode Texture::get_wrap_v(void) const;

2532 10 get_wrap_w 0 4 3092 19 Texture::get_wrap_w 0 1 1050 541
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_wrap_w
//       Access: Published
//  Description: Returns the wrap mode of the texture in the W
//               direction.  This is the depth direction of 3-d
//               textures.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
62
inline SamplerState::WrapMode Texture::get_wrap_w(void) const;

2533 13 get_minfilter 0 4 3092 22 Texture::get_minfilter 0 1 1051 673
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_minfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               minification.  If this is one of the mipmap
//               constants, then the texture requires mipmaps.  This
//               may return FT_default; see also
//               get_effective_minfilter().
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
67
inline SamplerState::FilterType Texture::get_minfilter(void) const;

2534 13 get_magfilter 0 4 3092 22 Texture::get_magfilter 0 1 1052 621
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_magfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               magnification.  The mipmap constants are invalid
//               here.  This may return FT_default; see also
//               get_effective_minfilter().
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
67
inline SamplerState::FilterType Texture::get_magfilter(void) const;

2535 23 get_effective_minfilter 0 4 3092 32 Texture::get_effective_minfilter 0 1 1053 651
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_effective_minfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               minification, with special treatment for FT_default.
//               This will normally not return FT_default, unless
//               there is an error in the config file.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
77
inline SamplerState::FilterType Texture::get_effective_minfilter(void) const;

2536 23 get_effective_magfilter 0 4 3092 32 Texture::get_effective_magfilter 0 1 1054 652
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_effective_magfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               magnification, with special treatment for FT_default.
//               This will normally not return FT_default, unless
//               there is an error in the config file.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
77
inline SamplerState::FilterType Texture::get_effective_magfilter(void) const;

2537 22 get_anisotropic_degree 0 4 3092 31 Texture::get_anisotropic_degree 0 1 1055 649
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_anisotropic_degree
//       Access: Published
//  Description: Returns the degree of anisotropic filtering that
//               should be applied to the texture.  This value may
//               return 0, indicating the default value; see also
//               get_effective_anisotropic_degree.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
55
inline int Texture::get_anisotropic_degree(void) const;

2538 32 get_effective_anisotropic_degree 0 4 3092 41 Texture::get_effective_anisotropic_degree 0 1 1056 645
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_effective_anisotropic_degree
//       Access: Published
//  Description: Returns the degree of anisotropic filtering that
//               should be applied to the texture.  This value will
//               normally not return 0, unless there is an error in
//               the config file.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
65
inline int Texture::get_effective_anisotropic_degree(void) const;

2539 16 get_border_color 0 4 3092 25 Texture::get_border_color 0 1 1057 630
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_border_color
//       Access: Published
//  Description: Returns the solid color of the texture's border.
//               Some OpenGL implementations use a border for tiling
//               textures; in Panda, it is only used for specifying
//               the clamp color.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
////////////////////////////////////////////////////////////////////
52
inline LColor Texture::get_border_color(void) const;

2540 15 get_compression 0 4 3092 24 Texture::get_compression 0 1 1058 765
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_compression
//       Access: Published
//  Description: Returns the compression mode requested for this
//               particular texture, or CM_off if the texture is not
//               to be compressed.
//
//               If a value other than CM_off is returned, this is
//               not a guarantee that the texture is actually
//               successfully compressed on the GSG.  It may be that
//               the GSG does not support the requested compression
//               mode, in which case the texture may actually be
//               stored uncompressed in texture memory.
////////////////////////////////////////////////////////////////////
69
inline Texture::CompressionMode Texture::get_compression(void) const;

2541 15 has_compression 0 4 3092 24 Texture::has_compression 0 1 1059 764
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_compression
//       Access: Published
//  Description: Returns true if the texture indicates it wants to be
//               compressed, either with CM_on or higher, or
//               CM_default and compressed-textures is true.
//
//               If true returned, this is not a guarantee that the
//               texture is actually successfully compressed on the
//               GSG.  It may be that the GSG does not support the
//               requested compression mode, in which case the texture
//               may actually be stored uncompressed in texture
//               memory.
////////////////////////////////////////////////////////////////////
49
inline bool Texture::has_compression(void) const;

2542 21 get_render_to_texture 0 4 3092 30 Texture::get_render_to_texture 0 1 1060 701
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_render_to_texture
//       Access: Published
//  Description: Returns a flag on the texture that indicates whether the
//               texture is intended to be used as a direct-render
//               target, by binding a framebuffer to a texture and
//               rendering directly into the texture.
//
//               Normally, a user should not need to set this flag
//               directly; it is set automatically by the low-level
//               display code when a texture is bound to a
//               framebuffer.
////////////////////////////////////////////////////////////////////
55
inline bool Texture::get_render_to_texture(void) const;

2543 12 uses_mipmaps 0 4 3092 21 Texture::uses_mipmaps 0 1 1061 355
////////////////////////////////////////////////////////////////////
//     Function: Texture::uses_mipmaps
//       Access: Public
//  Description: Returns true if the minfilter settings on this
//               texture indicate the use of mipmapping, false
//               otherwise.
////////////////////////////////////////////////////////////////////
46
inline bool Texture::uses_mipmaps(void) const;

2544 17 set_quality_level 0 4 3092 26 Texture::set_quality_level 0 1 1062 535
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_quality_level
//       Access: Public
//  Description: Sets a hint to the renderer about the desired
//               performance / quality tradeoff for this particular
//               texture.  This is most useful for the tinydisplay
//               software renderer; for normal, hardware-accelerated
//               renderers, this may have little or no effect.
////////////////////////////////////////////////////////////////////
76
inline void Texture::set_quality_level(Texture::QualityLevel quality_level);

2545 17 get_quality_level 0 4 3092 26 Texture::get_quality_level 0 1 1063 392
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_quality_level
//       Access: Public
//  Description: Returns the current quality_level hint.  See
//               set_quality_level().  This value may return
//               QL_default; see get_effective_quality_level().
////////////////////////////////////////////////////////////////////
68
inline Texture::QualityLevel Texture::get_quality_level(void) const;

2546 27 get_effective_quality_level 0 4 3092 36 Texture::get_effective_quality_level 0 1 1064 519
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_effective_quality_level
//       Access: Public
//  Description: Returns the current quality_level hint, or the global
//               default quality_level if this texture doesn't specify
//               a quality level.  This value will not normally return
//               QL_default (unless there is an error in the config
//               file)
////////////////////////////////////////////////////////////////////
78
inline Texture::QualityLevel Texture::get_effective_quality_level(void) const;

2547 30 get_expected_num_mipmap_levels 0 4 3092 39 Texture::get_expected_num_mipmap_levels 0 1 1065 536
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_num_mipmap_levels
//       Access: Published
//  Description: Returns the number of mipmap levels that should be
//               defined for this texture, given the texture's size.
//
//               Note that this returns a number appropriate for
//               mipmapping, even if the texture does not currently
//               have mipmapping enabled.
////////////////////////////////////////////////////////////////////
63
inline int Texture::get_expected_num_mipmap_levels(void) const;

2548 26 get_expected_mipmap_x_size 0 4 3092 35 Texture::get_expected_mipmap_x_size 0 1 1066 338
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_mipmap_x_size
//       Access: Published
//  Description: Returns the x_size that the nth mipmap level should
//               have, based on the texture's size.
////////////////////////////////////////////////////////////////////
60
inline int Texture::get_expected_mipmap_x_size(int n) const;

2549 26 get_expected_mipmap_y_size 0 4 3092 35 Texture::get_expected_mipmap_y_size 0 1 1067 338
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_mipmap_y_size
//       Access: Published
//  Description: Returns the y_size that the nth mipmap level should
//               have, based on the texture's size.
////////////////////////////////////////////////////////////////////
60
inline int Texture::get_expected_mipmap_y_size(int n) const;

2550 26 get_expected_mipmap_z_size 0 4 3092 35 Texture::get_expected_mipmap_z_size 0 1 1068 338
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_mipmap_z_size
//       Access: Published
//  Description: Returns the z_size that the nth mipmap level should
//               have, based on the texture's size.
////////////////////////////////////////////////////////////////////
60
inline int Texture::get_expected_mipmap_z_size(int n) const;

2551 29 get_expected_mipmap_num_pages 0 4 3092 38 Texture::get_expected_mipmap_num_pages 0 1 1069 566
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_mipmap_num_pages
//       Access: Published
//  Description: Returns the total number of pages that the nth mipmap
//               level should have, based on the texture's size.  This
//               is usually the same as get_expected_mipmap_z_size(),
//               except for a multiview texture, in which case it is
//               get_expected_mipmap_z_size() * get_num_views().
////////////////////////////////////////////////////////////////////
63
inline int Texture::get_expected_mipmap_num_pages(int n) const;

2552 13 has_ram_image 0 4 3092 22 Texture::has_ram_image 0 1 1070 1616
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_ram_image
//       Access: Published
//  Description: Returns true if the Texture has its image contents
//               available in main RAM, false if it exists only in
//               texture memory or in the prepared GSG context.
//
//               Note that this has nothing to do with whether
//               get_ram_image() will fail or not.  Even if
//               has_ram_image() returns false, get_ram_image() may
//               still return a valid RAM image, because
//               get_ram_image() will automatically load the texture
//               from disk if necessary.  The only thing
//               has_ram_image() tells you is whether the texture is
//               available right now without hitting the disk first.
//
//               Note also that if an application uses only one GSG,
//               it may appear that has_ram_image() returns true if
//               the texture has not yet been loaded by the GSG, but
//               this correlation is not true in general and should
//               not be depended on.  Specifically, if an application
//               ever uses multiple GSG's in its lifetime (for
//               instance, by opening more than one window, or by
//               closing its window and opening another one later),
//               then has_ram_image() may well return false on
//               textures that have never been loaded on the current
//               GSG.
////////////////////////////////////////////////////////////////////
47
inline bool Texture::has_ram_image(void) const;

2553 26 has_uncompressed_ram_image 0 4 3092 35 Texture::has_uncompressed_ram_image 0 1 1071 401
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_uncompressed_ram_image
//       Access: Published
//  Description: Returns true if the Texture has its image contents
//               available in main RAM and is uncompressed, false
//               otherwise.  See has_ram_image().
////////////////////////////////////////////////////////////////////
60
inline bool Texture::has_uncompressed_ram_image(void) const;

2554 20 might_have_ram_image 0 4 3092 29 Texture::might_have_ram_image 0 1 1072 578
////////////////////////////////////////////////////////////////////
//     Function: Texture::might_have_ram_image
//       Access: Published
//  Description: Returns true if the texture's image contents are
//               currently available in main RAM, or there is reason
//               to believe it can be loaded on demand.  That is, this
//               function returns a "best guess" as to whether
//               get_ram_image() will succeed without actually calling
//               it first.
////////////////////////////////////////////////////////////////////
54
inline bool Texture::might_have_ram_image(void) const;

2555 18 get_ram_image_size 0 4 3092 27 Texture::get_ram_image_size 0 1 1073 388
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_image_size
//       Access: Published
//  Description: Returns the total number of bytes used by the
//               in-memory image, across all pages and views, or 0 if
//               there is no in-memory image.
////////////////////////////////////////////////////////////////////
54
inline size_t Texture::get_ram_image_size(void) const;

2556 17 get_ram_view_size 0 4 3092 26 Texture::get_ram_view_size 0 1 1074 467
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_view_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image per view, or 0 if there is no in-memory image.
//               Since each view is a stack of z_size pages, this is
//               get_z_size() * get_ram_page_size().
////////////////////////////////////////////////////////////////////
53
inline size_t Texture::get_ram_view_size(void) const;

2557 17 get_ram_page_size 0 4 3092 26 Texture::get_ram_page_size 0 1 1075 647
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_page_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image per page, or 0 if there is no in-memory image.
//
//               For a non-compressed texture, this is the same as
//               get_expected_ram_page_size().  For a compressed
//               texture, this may be a smaller value.  (We do assume
//               that all pages will be the same size on a compressed
//               texture).
////////////////////////////////////////////////////////////////////
53
inline size_t Texture::get_ram_page_size(void) const;

2558 27 get_expected_ram_image_size 0 4 3092 36 Texture::get_expected_ram_image_size 0 1 1076 378
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_image_size
//       Access: Published
//  Description: Returns the number of bytes that *ought* to be used
//               by the in-memory image, based on the texture
//               parameters.
////////////////////////////////////////////////////////////////////
63
inline size_t Texture::get_expected_ram_image_size(void) const;

2559 26 get_expected_ram_page_size 0 4 3092 35 Texture::get_expected_ram_page_size 0 1 1077 447
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_page_size
//       Access: Published
//  Description: Returns the number of bytes that should be used per
//               each Z page of the 3-d texture.  For a 2-d or 1-d
//               texture, this is the same as
//               get_expected_ram_image_size().
////////////////////////////////////////////////////////////////////
62
inline size_t Texture::get_expected_ram_page_size(void) const;

2560 13 get_ram_image 0 4 3092 22 Texture::get_ram_image 0 1 1078 1676
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_image
//       Access: Published
//  Description: Returns the system-RAM image data associated with the
//               texture.  If the texture does not currently have an
//               associated RAM image, and the texture was generated
//               by loading an image from a disk file (the most common
//               case), this forces the reload of the same texture.
//               This can happen if keep_texture_ram is configured to
//               false, and we have previously prepared this texture
//               with a GSG.
//
//               Note that it is not correct to call has_ram_image()
//               first to test whether this function will fail.  A
//               false return value from has_ram_image() indicates
//               only that get_ram_image() may need to reload the
//               texture from disk, which it will do automatically.
//               However, you can call might_have_ram_image(), which
//               will return true if the ram image exists, or there is
//               a reasonable reason to believe it can be loaded.
//
//               On the other hand, it is possible that the texture
//               cannot be found on disk or is otherwise unavailable.
//               If that happens, this function will return NULL.
//               There is no way to predict with 100% accuracy whether
//               get_ram_image() will return NULL without calling it
//               first; might_have_ram_image() is the closest.
////////////////////////////////////////////////////////////////////
47
inline CPTA_uchar Texture::get_ram_image(void);

2561 25 get_ram_image_compression 0 4 3092 34 Texture::get_ram_image_compression 0 1 1079 633
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_image_compression
//       Access: Published
//  Description: Returns the compression mode in which the ram image
//               is already stored pre-compressed.  If this is other
//               than CM_off, you cannot rely on the contents of the
//               ram image to be anything predicatable (it will not be
//               an array of x by y pixels, and it probably won't have
//               the same length as get_expected_ram_image_size()).
////////////////////////////////////////////////////////////////////
79
inline Texture::CompressionMode Texture::get_ram_image_compression(void) const;

2562 26 get_uncompressed_ram_image 0 4 3092 35 Texture::get_uncompressed_ram_image 0 1 1080 973
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_uncompressed_ram_image
//       Access: Published
//  Description: Returns the system-RAM image associated with the
//               texture, in an uncompressed form if at all possible.
//
//               If get_ram_image_compression() is CM_off, then the
//               system-RAM image is already uncompressed, and this
//               returns the same thing as get_ram_image().
//
//               If get_ram_image_compression() is anything else, then
//               the system-RAM image is compressed.  In this case,
//               the image will be reloaded from the *original* file
//               (not from the cache), in the hopes that an
//               uncompressed image will be found there.
//
//               If an uncompressed image cannot be found, returns
//               NULL.
////////////////////////////////////////////////////////////////////
60
inline CPTA_uchar Texture::get_uncompressed_ram_image(void);

2563 16 get_ram_image_as 0 4 3092 25 Texture::get_ram_image_as 0 1 1081 1762
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_image_as
//       Access: Published
//  Description: Returns the uncompressed system-RAM image data
//               associated with the texture. Rather than
//               just returning a pointer to the data, like
//               get_uncompressed_ram_image, this function first
//               processes the data and reorders the components
//               using the specified format string, and places these
//               into a new char array. The 'format' argument should
//               specify in which order the components of the texture
//               must be. For example, valid format strings are
//               "RGBA", "GA", "ABRG" or "AAA". A component can
//               also be written as "0" or "1", which means an
//               empty/black or a full/white channel, respectively.
//               This function is particularly useful to
//               copy an image in-memory to a different library
//               (for example, PIL or wxWidgets) that require
//               a different component order than Panda's internal
//               format, BGRA. Note, however, that this conversion
//               can still be too slow if you want to do it every
//               frame, and should thus be avoided for that purpose.
//               The only requirement for the reordering is that
//               an uncompressed image must be available. If the
//               RAM image is compressed, it will attempt to re-load
//               the texture from disk, if it doesn't find an
//               uncompressed image there, it will return NULL.
////////////////////////////////////////////////////////////////////
69
CPTA_uchar Texture::get_ram_image_as(string const &requested_format);

2564 16 modify_ram_image 0 4 3092 25 Texture::modify_ram_image 0 1 1082 517
////////////////////////////////////////////////////////////////////
//     Function: Texture::modify_ram_image
//       Access: Published
//  Description: Returns a modifiable pointer to the system-RAM image.
//               This assumes the RAM image should be uncompressed.
//               If the RAM image has been dumped, or is stored
//               compressed, creates a new one.
//
//               This does *not* affect keep_ram_image.
////////////////////////////////////////////////////////////////////
49
inline PTA_uchar Texture::modify_ram_image(void);

2565 14 make_ram_image 0 4 3092 23 Texture::make_ram_image 0 1 1083 455
////////////////////////////////////////////////////////////////////
//     Function: Texture::make_ram_image
//       Access: Published
//  Description: Discards the current system-RAM image for the
//               texture, if any, and allocates a new buffer of the
//               appropriate size.  Returns the new buffer.
//
//               This does *not* affect keep_ram_image.
////////////////////////////////////////////////////////////////////
47
inline PTA_uchar Texture::make_ram_image(void);

2566 13 set_ram_image 0 4 3092 22 Texture::set_ram_image 0 1 1084 501
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_ram_image
//       Access: Published
//  Description: Replaces the current system-RAM image with the new
//               data.  If compression is not CM_off, it indicates
//               that the new data is already pre-compressed in the
//               indicated format.
//
//               This does *not* affect keep_ram_image.
////////////////////////////////////////////////////////////////////
133
inline void Texture::set_ram_image(CPTA_uchar image, Texture::CompressionMode compression = ::Texture::CM_off, size_t page_size = 0);

2567 16 set_ram_image_as 0 4 3092 25 Texture::set_ram_image_as 0 1 1085 597
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_ram_image_as
//       Access: Published
//  Description: Replaces the current system-RAM image with the new
//               data, converting it first if necessary from the
//               indicated component-order format.  See
//               get_ram_image_as() for specifications about the
//               format.  This method cannot support compressed image
//               data or sub-pages; use set_ram_image() for that.
////////////////////////////////////////////////////////////////////
80
void Texture::set_ram_image_as(CPTA_uchar image, string const &provided_format);

2568 15 clear_ram_image 0 4 3092 24 Texture::clear_ram_image 0 1 1086 262
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_ram_image
//       Access: Published
//  Description: Discards the current system-RAM image.
////////////////////////////////////////////////////////////////////
43
inline void Texture::clear_ram_image(void);

2569 18 set_keep_ram_image 0 4 3092 27 Texture::set_keep_ram_image 0 1 1087 827
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_keep_ram_image
//       Access: Published
//  Description: Sets the flag that indicates whether this Texture is
//               eligible to have its main RAM copy of the texture
//               memory dumped when the texture is prepared for
//               rendering.
//
//               This will be false for most textures, which can
//               reload their images if needed by rereading the input
//               file.  However, textures that were generated
//               dynamically and cannot be easily reloaded will want
//               to set this flag to true, so that the texture will
//               always keep its image copy around.
////////////////////////////////////////////////////////////////////
61
inline void Texture::set_keep_ram_image(bool keep_ram_image);

2570 18 get_keep_ram_image 0 6 3092 27 Texture::get_keep_ram_image 0 1 1088 477
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_keep_ram_image
//       Access: Published, Virtual
//  Description: Returns the flag that indicates whether this Texture
//               is eligible to have its main RAM copy of the texture
//               memory dumped when the texture is prepared for
//               rendering.  See set_keep_ram_image().
////////////////////////////////////////////////////////////////////
53
virtual bool Texture::get_keep_ram_image(void) const;

2571 12 is_cacheable 0 6 3092 21 Texture::is_cacheable 0 1 1089 464
////////////////////////////////////////////////////////////////////
//     Function: Texture::is_cacheable
//       Access: Published, Virtual
//  Description: Returns true if there is enough information in this
//               Texture object to write it to the bam cache
//               successfully, false otherwise.  For most textures,
//               this is the same as has_ram_image().
////////////////////////////////////////////////////////////////////
47
virtual bool Texture::is_cacheable(void) const;

2572 18 compress_ram_image 0 4 3092 27 Texture::compress_ram_image 0 1 1090 1257
////////////////////////////////////////////////////////////////////
//     Function: Texture::compress_ram_image
//       Access: Published
//  Description: Attempts to compress the texture's RAM image
//               internally, to a format supported by the indicated
//               GSG.  In order for this to work, the squish library
//               must have been compiled into Panda.
//
//               If compression is CM_on, then an appropriate
//               compression method that is supported by the indicated
//               GSG is automatically chosen.  If the GSG pointer is
//               NULL, any of the standard DXT1/3/5 compression
//               methods will be used, regardless of whether it is
//               supported.
//
//               If compression is any specific compression method,
//               that method is used regardless of whether the GSG
//               supports it.
//
//               quality_level determines the speed/quality tradeoff
//               of the compression.  If it is QL_default, the
//               texture's own quality_level parameter is used.
//
//               Returns true if successful, false otherwise.
////////////////////////////////////////////////////////////////////
194
inline bool Texture::compress_ram_image(Texture::CompressionMode compression = ::Texture::CM_on, Texture::QualityLevel quality_level = ::Texture::QL_default, GraphicsStateGuardianBase *gsg = 0);

2573 20 uncompress_ram_image 0 4 3092 29 Texture::uncompress_ram_image 0 1 1091 573
////////////////////////////////////////////////////////////////////
//     Function: Texture::uncompress_ram_image
//       Access: Published
//  Description: Attempts to uncompress the texture's RAM image
//               internally.  In order for this to work, the squish
//               library must have been compiled into Panda, and the
//               ram image must be compressed in a format supported by
//               squish.
//
//               Returns true if successful, false otherwise.
////////////////////////////////////////////////////////////////////
48
inline bool Texture::uncompress_ram_image(void);

2574 25 get_num_ram_mipmap_images 0 4 3092 34 Texture::get_num_ram_mipmap_images 0 1 1092 584
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_ram_mipmap_images
//       Access: Published
//  Description: Returns the maximum number of mipmap level images
//               available in system memory.  The actual number may be
//               less than this (that is, there might be gaps in the
//               sequence); use has_ram_mipmap_image() to verify each
//               level.
//
//               Also see get_num_loadable_ram_mipmap_images().
////////////////////////////////////////////////////////////////////
58
inline int Texture::get_num_ram_mipmap_images(void) const;

2575 20 has_ram_mipmap_image 0 4 3092 29 Texture::has_ram_mipmap_image 0 1 1093 608
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_ram_mipmap_image
//       Access: Published
//  Description: Returns true if the Texture has the nth mipmap level
//               available in system memory, false otherwise.  If the
//               texture's minfilter mode requires mipmapping (see
//               uses_mipmaps()), and all the texture's mipmap levels
//               are not available when the texture is rendered, they
//               will be generated automatically.
////////////////////////////////////////////////////////////////////
55
inline bool Texture::has_ram_mipmap_image(int n) const;

2576 34 get_num_loadable_ram_mipmap_images 0 4 3092 43 Texture::get_num_loadable_ram_mipmap_images 0 1 1094 955
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_loadable_ram_mipmap_images
//       Access: Published
//  Description: Returns the number of contiguous mipmap levels that
//               exist in RAM, up until the first gap in the sequence.
//               It is guaranteed that at least mipmap levels [0,
//               get_num_ram_mipmap_images()) exist.
//
//               The number returned will never exceed the number of
//               required mipmap images based on the size of the
//               texture and its filter mode.
//
//               This method is different from
//               get_num_ram_mipmap_images() in that it returns only
//               the number of mipmap levels that can actually be
//               usefully loaded, regardless of the actual number that
//               may be stored.
////////////////////////////////////////////////////////////////////
60
int Texture::get_num_loadable_ram_mipmap_images(void) const;

2577 25 has_all_ram_mipmap_images 0 4 3092 34 Texture::has_all_ram_mipmap_images 0 1 1095 403
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_all_ram_mipmap_images
//       Access: Published
//  Description: Returns true if all expected mipmap levels have been
//               defined and exist in the system RAM, or false if even
//               one mipmap level is missing.
////////////////////////////////////////////////////////////////////
59
inline bool Texture::has_all_ram_mipmap_images(void) const;

2578 25 get_ram_mipmap_image_size 0 4 3092 34 Texture::get_ram_mipmap_image_size 0 1 1096 402
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_image_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image for mipmap level n, or 0 if there is no
//               in-memory image for this mipmap level.
////////////////////////////////////////////////////////////////////
62
inline size_t Texture::get_ram_mipmap_image_size(int n) const;

2579 24 get_ram_mipmap_view_size 0 4 3092 33 Texture::get_ram_mipmap_view_size 0 1 1097 913
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_view_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image per view for mipmap level n, or 0 if there is
//               no in-memory image for this mipmap level.
//
//               A "view" is a collection of z_size pages for each
//               mipmap level.  Most textures have only one view,
//               except for multiview or stereo textures.
//
//               For a non-compressed texture, this is the same as
//               get_expected_ram_mipmap_view_size().  For a compressed
//               texture, this may be a smaller value.  (We do assume
//               that all pages will be the same size on a compressed
//               texture).
////////////////////////////////////////////////////////////////////
61
inline size_t Texture::get_ram_mipmap_view_size(int n) const;

2580 24 get_ram_mipmap_page_size 0 4 3092 33 Texture::get_ram_mipmap_page_size 0 1 1098 719
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_page_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image per page for mipmap level n, or 0 if there is
//               no in-memory image for this mipmap level.
//
//               For a non-compressed texture, this is the same as
//               get_expected_ram_mipmap_page_size().  For a compressed
//               texture, this may be a smaller value.  (We do assume
//               that all pages will be the same size on a compressed
//               texture).
////////////////////////////////////////////////////////////////////
61
inline size_t Texture::get_ram_mipmap_page_size(int n) const;

2581 34 get_expected_ram_mipmap_image_size 0 4 3092 43 Texture::get_expected_ram_mipmap_image_size 0 1 1099 404
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_mipmap_image_size
//       Access: Published
//  Description: Returns the number of bytes that *ought* to be used
//               by the in-memory image for mipmap level n, based on
//               the texture parameters.
////////////////////////////////////////////////////////////////////
71
inline size_t Texture::get_expected_ram_mipmap_image_size(int n) const;

2582 33 get_expected_ram_mipmap_view_size 0 4 3092 42 Texture::get_expected_ram_mipmap_view_size 0 1 1100 547
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_mipmap_view_size
//       Access: Published
//  Description: Returns the number of bytes that *ought* to be used
//               by each view of the in-memory image for mipmap level
//               n, based on the texture parameters.  For a normal,
//               non-multiview texture, this is the same as
//               get_expected_ram_mipmap_image_size(n).
////////////////////////////////////////////////////////////////////
70
inline size_t Texture::get_expected_ram_mipmap_view_size(int n) const;

2583 33 get_expected_ram_mipmap_page_size 0 4 3092 42 Texture::get_expected_ram_mipmap_page_size 0 1 1101 480
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_mipmap_page_size
//       Access: Published
//  Description: Returns the number of bytes that should be used per
//               each Z page of the 3-d texture, for mipmap level n.
//               For a 2-d or 1-d texture, this is the same as
//               get_expected_ram_mipmap_view_size(n).
////////////////////////////////////////////////////////////////////
70
inline size_t Texture::get_expected_ram_mipmap_page_size(int n) const;

2584 20 get_ram_mipmap_image 0 4 3092 29 Texture::get_ram_mipmap_image 0 1 1102 400
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_image
//       Access: Published
//  Description: Returns the system-RAM image data associated with the
//               nth mipmap level, if present.  Returns NULL if the
//               nth mipmap level is not present.
////////////////////////////////////////////////////////////////////
54
CPTA_uchar Texture::get_ram_mipmap_image(int n) const;

2585 22 get_ram_mipmap_pointer 0 4 3092 31 Texture::get_ram_mipmap_pointer 0 1 1103 447
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_pointer
//       Access: Published
//  Description: Similiar to get_ram_mipmap_image(), however, in this
//               case the void pointer for the given ram image is
//               returned.  This will be NULL unless it has been
//               explicitly set.
////////////////////////////////////////////////////////////////////
51
void *Texture::get_ram_mipmap_pointer(int n) const;

2586 23 modify_ram_mipmap_image 0 4 3092 32 Texture::modify_ram_mipmap_image 0 1 1104 511
////////////////////////////////////////////////////////////////////
//     Function: Texture::modify_ram_mipmap_image
//       Access: Published
//  Description: Returns a modifiable pointer to the system-RAM image
//               for the nth mipmap level.  This assumes the RAM image
//               is uncompressed; if this is not the case, raises an
//               assertion.
//
//               This does *not* affect keep_ram_image.
////////////////////////////////////////////////////////////////////
57
inline PTA_uchar Texture::modify_ram_mipmap_image(int n);

2587 21 make_ram_mipmap_image 0 4 3092 30 Texture::make_ram_mipmap_image 0 1 1105 471
////////////////////////////////////////////////////////////////////
//     Function: Texture::make_ram_mipmap_image
//       Access: Published
//  Description: Discards the current system-RAM image for the
//               nth mipmap level, if any, and allocates a new buffer
//               of the appropriate size.  Returns the new buffer.
//
//               This does *not* affect keep_ram_image.
////////////////////////////////////////////////////////////////////
55
inline PTA_uchar Texture::make_ram_mipmap_image(int n);

2588 22 set_ram_mipmap_pointer 0 4 3092 31 Texture::set_ram_mipmap_pointer 0 0 827
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_ram_mipmap_pointer
//       Access: Published
//  Description: Sets an explicit void pointer as the texture's mipmap
//               image for the indicated level.  This is a special
//               call to direct a texture to reference some external
//               image location, for instance from a webcam input.
//
//               The texture will henceforth reference this pointer
//               directly, instead of its own internal storage; the
//               user is responsible for ensuring the data at this
//               address remains allocated and valid, and in the
//               correct format, during the lifetime of the texture.
////////////////////////////////////////////////////////////////////
79
void Texture::set_ram_mipmap_pointer(int n, void *image, size_t page_size = 0);

2589 31 set_ram_mipmap_pointer_from_int 0 4 3092 40 Texture::set_ram_mipmap_pointer_from_int 0 1 1106 592
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_ram_mipmap_pointer_from_int
//       Access: Published
//  Description: Accepts a raw pointer cast as an int, which is then
//               passed to set_ram_mipmap_pointer(); see the
//               documentation for that method.
//
//               This variant is particularly useful to set an
//               external pointer from a language like Python, which
//               doesn't support void pointers directly.
////////////////////////////////////////////////////////////////////
91
void Texture::set_ram_mipmap_pointer_from_int(long long int pointer, int n, int page_size);

2590 20 set_ram_mipmap_image 0 4 3092 29 Texture::set_ram_mipmap_image 0 1 1107 556
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_ram_mipmap_image
//       Access: Published
//  Description: Replaces the current system-RAM image for the
//               indicated mipmap level with the new data.  If
//               compression is not CM_off, it indicates that the new
//               data is already pre-compressed in the indicated
//               format.
//
//               This does *not* affect keep_ram_image.
////////////////////////////////////////////////////////////////////
89
inline void Texture::set_ram_mipmap_image(int n, CPTA_uchar image, size_t page_size = 0);

2591 22 clear_ram_mipmap_image 0 4 3092 31 Texture::clear_ram_mipmap_image 0 1 1108 311
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_ram_mipmap_image
//       Access: Published
//  Description: Discards the current system-RAM image for the nth
//               mipmap level.
////////////////////////////////////////////////////////////////////
44
void Texture::clear_ram_mipmap_image(int n);

2592 23 clear_ram_mipmap_images 0 4 3092 32 Texture::clear_ram_mipmap_images 0 1 1109 342
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_ram_mipmap_images
//       Access: Published
//  Description: Discards the current system-RAM image for all
//               mipmap levels, except level 0 (the base image).
////////////////////////////////////////////////////////////////////
51
inline void Texture::clear_ram_mipmap_images(void);

2593 26 generate_ram_mipmap_images 0 4 3092 35 Texture::generate_ram_mipmap_images 0 1 1110 794
////////////////////////////////////////////////////////////////////
//     Function: Texture::generate_ram_mipmap_images
//       Access: Published
//  Description: Automatically fills in the n mipmap levels of the
//               Texture, based on the texture's source image.  This
//               requires the texture's uncompressed ram image to be
//               available in system memory.  If it is not already, it
//               will be fetched if possible.
//
//               This call is not normally necessary, since the mipmap
//               levels will be generated automatically if needed.
//               But there may be certain cases in which you would
//               like to call this explicitly.
////////////////////////////////////////////////////////////////////
54
inline void Texture::generate_ram_mipmap_images(void);

2594 17 get_simple_x_size 0 4 3092 26 Texture::get_simple_x_size 0 1 1111 276
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_x_size
//       Access: Published
//  Description: Returns the width of the "simple" image in texels.
////////////////////////////////////////////////////////////////////
50
inline int Texture::get_simple_x_size(void) const;

2595 17 get_simple_y_size 0 4 3092 26 Texture::get_simple_y_size 0 1 1112 277
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_y_size
//       Access: Published
//  Description: Returns the height of the "simple" image in texels.
////////////////////////////////////////////////////////////////////
50
inline int Texture::get_simple_y_size(void) const;

2596 20 has_simple_ram_image 0 4 3092 29 Texture::has_simple_ram_image 0 1 1113 326
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_simple_ram_image
//       Access: Published, Virtual
//  Description: Returns true if the Texture has a "simple" image
//               available in main RAM.
////////////////////////////////////////////////////////////////////
54
inline bool Texture::has_simple_ram_image(void) const;

2597 25 get_simple_ram_image_size 0 4 3092 34 Texture::get_simple_ram_image_size 0 1 1114 340
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_ram_image_size
//       Access: Published
//  Description: Returns the number of bytes used by the "simple"
//               image, or 0 if there is no simple image.
////////////////////////////////////////////////////////////////////
61
inline size_t Texture::get_simple_ram_image_size(void) const;

2598 20 get_simple_ram_image 0 4 3092 29 Texture::get_simple_ram_image 0 1 1115 879
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_ram_image
//       Access: Published
//  Description: Returns the image data associated with the "simple"
//               texture image.  This is provided for some textures as
//               an option to display while the main texture image is
//               being loaded from disk.
//
//               Unlike get_ram_image(), this function will always
//               return immediately.  Either the simple image is
//               available, or it is not.
//
//               The "simple" image is always 4 components, 1 byte
//               each, regardless of the parameters of the full
//               texture.  The simple image is only supported for
//               ordinary 2-d textures.
////////////////////////////////////////////////////////////////////
60
inline CPTA_uchar Texture::get_simple_ram_image(void) const;

2599 20 set_simple_ram_image 0 4 3092 29 Texture::set_simple_ram_image 0 1 1116 1051
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_simple_ram_image
//       Access: Published
//  Description: Replaces the internal "simple" texture image.  This
//               can be used as an option to display while the main
//               texture image is being loaded from disk.  It is
//               normally a very small image, 16x16 or smaller (and
//               maybe even 1x1), that is designed to give just enough
//               sense of color to serve as a placeholder until the
//               full texture is available.
//
//               The "simple" image is always 4 components, 1 byte
//               each, regardless of the parameters of the full
//               texture.  The simple image is only supported for
//               ordinary 2-d textures.
//
//               Also see generate_simple_ram_image(),
//               modify_simple_ram_image(), and
//               new_simple_ram_image().
////////////////////////////////////////////////////////////////////
84
inline void Texture::set_simple_ram_image(CPTA_uchar image, int x_size, int y_size);

2600 23 modify_simple_ram_image 0 4 3092 32 Texture::modify_simple_ram_image 0 1 1117 346
////////////////////////////////////////////////////////////////////
//     Function: Texture::modify_simple_ram_image
//       Access: Published
//  Description: Returns a modifiable pointer to the internal "simple"
//               texture image.  See set_simple_ram_image().
////////////////////////////////////////////////////////////////////
49
PTA_uchar Texture::modify_simple_ram_image(void);

2601 20 new_simple_ram_image 0 4 3092 29 Texture::new_simple_ram_image 0 1 1118 413
////////////////////////////////////////////////////////////////////
//     Function: Texture::new_simple_ram_image
//       Access: Published
//  Description: Creates an empty array for the simple ram image of
//               the indicated size, and returns a modifiable pointer
//               to the new array.  See set_simple_ram_image().
////////////////////////////////////////////////////////////////////
64
PTA_uchar Texture::new_simple_ram_image(int x_size, int y_size);

2602 25 generate_simple_ram_image 0 4 3092 34 Texture::generate_simple_ram_image 0 1 1119 453
////////////////////////////////////////////////////////////////////
//     Function: Texture::generate_simple_ram_image
//       Access: Published
//  Description: Computes the "simple" ram image by loading the main
//               RAM image, if it is not already available, and
//               reducing it to 16x16 or smaller.  This may be an
//               expensive operation.
////////////////////////////////////////////////////////////////////
46
void Texture::generate_simple_ram_image(void);

2603 22 clear_simple_ram_image 0 4 3092 31 Texture::clear_simple_ram_image 0 1 1120 267
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_simple_ram_image
//       Access: Published
//  Description: Discards the current "simple" image.
////////////////////////////////////////////////////////////////////
50
inline void Texture::clear_simple_ram_image(void);

2604 4 peek 0 4 3092 13 Texture::peek 0 1 1121 826
////////////////////////////////////////////////////////////////////
//     Function: Texture::peek
//       Access: Published
//  Description: Returns a TexturePeeker object that can be used to
//               examine the individual texels stored within this
//               Texture by (u, v) coordinate.
//
//               If the texture has a ram image resident, that image
//               is used.  If it does not have a full ram image but
//               does have a simple_ram_image resident, that image is
//               used instead.  If neither image is resident the full
//               image is reloaded.
//
//               Returns NULL if the texture cannot find an image to
//               load, or the texture format is incompatible.
////////////////////////////////////////////////////////////////////
47
PointerTo< TexturePeeker > Texture::peek(void);

2605 23 get_properties_modified 0 4 3092 32 Texture::get_properties_modified 0 1 1122 403
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_properties_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture properties
//               (unrelated to the image) are modified.
////////////////////////////////////////////////////////////////////
62
inline UpdateSeq Texture::get_properties_modified(void) const;

2606 18 get_image_modified 0 4 3092 27 Texture::get_image_modified 0 1 1123 399
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_image_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture image data
//               (including mipmap levels) are modified.
////////////////////////////////////////////////////////////////////
57
inline UpdateSeq Texture::get_image_modified(void) const;

2607 25 get_simple_image_modified 0 4 3092 34 Texture::get_simple_image_modified 0 1 1124 390
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_image_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture's "simple"
//               image data is modified.
////////////////////////////////////////////////////////////////////
64
inline UpdateSeq Texture::get_simple_image_modified(void) const;

2608 22 set_auto_texture_scale 0 4 3092 31 Texture::set_auto_texture_scale 0 1 1125 421
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_auto_texture_scale
//       Access: Published
//  Description: Specifies the power-of-2 texture-scaling mode that
//               will be applied to this particular texture when it is
//               next loaded from disk.  See set_textures_power_2().
////////////////////////////////////////////////////////////////////
68
inline void Texture::set_auto_texture_scale(AutoTextureScale scale);

2609 22 get_auto_texture_scale 0 4 3092 31 Texture::get_auto_texture_scale 0 1 1126 419
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_auto_texture_scale
//       Access: Published
//  Description: Returns the power-of-2 texture-scaling mode that will
//               be applied to this particular texture when it is next
//               loaded from disk.  See set_textures_power_2().
////////////////////////////////////////////////////////////////////
68
inline AutoTextureScale Texture::get_auto_texture_scale(void) const;

2610 22 has_auto_texture_scale 0 4 3092 31 Texture::has_auto_texture_scale 0 1 1127 387
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_auto_texture_scale
//       Access: Published
//  Description: Returns true if set_auto_texture_scale() has been set
//               to something other than ATS_unspecified for this
//               particular texture.
////////////////////////////////////////////////////////////////////
56
inline bool Texture::has_auto_texture_scale(void) const;

2611 7 prepare 0 4 3092 16 Texture::prepare 0 1 1128 655
////////////////////////////////////////////////////////////////////
//     Function: Texture::prepare
//       Access: Published
//  Description: Indicates that the texture should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.  This will ensure the
//               texture is already loaded into texture memory if it
//               is expected to be rendered soon.
//
//               Use this function instead of prepare_now() to preload
//               textures from a user interface standpoint.
////////////////////////////////////////////////////////////////////
65
void Texture::prepare(PreparedGraphicsObjects *prepared_objects);

2612 11 is_prepared 0 4 3092 20 Texture::is_prepared 0 1 1129 374
////////////////////////////////////////////////////////////////////
//     Function: Texture::is_prepared
//       Access: Published
//  Description: Returns true if the texture has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
////////////////////////////////////////////////////////////////////
75
bool Texture::is_prepared(PreparedGraphicsObjects *prepared_objects) const;

2613 18 was_image_modified 0 4 3092 27 Texture::was_image_modified 0 1 1130 437
////////////////////////////////////////////////////////////////////
//     Function: Texture::was_image_modified
//       Access: Published
//  Description: Returns true if the texture needs to be re-loaded
//               onto the indicated GSG, either because its image data
//               is out-of-date, or because it's not fully prepared
//               now.
////////////////////////////////////////////////////////////////////
82
bool Texture::was_image_modified(PreparedGraphicsObjects *prepared_objects) const;

2614 19 get_data_size_bytes 0 4 3092 28 Texture::get_data_size_bytes 0 1 1131 639
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_data_size_bytes
//       Access: Public
//  Description: Returns the number of bytes which the texture is
//               reported to consume within graphics memory, for the
//               indicated GSG.  This may return a nonzero value even
//               if the texture is not currently resident; you should
//               also check get_resident() if you want to know how
//               much space the texture is actually consuming right
//               now.
////////////////////////////////////////////////////////////////////
85
size_t Texture::get_data_size_bytes(PreparedGraphicsObjects *prepared_objects) const;

2615 10 get_active 0 4 3092 19 Texture::get_active 0 1 1132 325
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_active
//       Access: Public
//  Description: Returns true if this Texture was rendered in the most
//               recent frame within the indicated GSG.
////////////////////////////////////////////////////////////////////
74
bool Texture::get_active(PreparedGraphicsObjects *prepared_objects) const;

2616 12 get_resident 0 4 3092 21 Texture::get_resident 0 1 1133 353
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_resident
//       Access: Public
//  Description: Returns true if this Texture is reported to be
//               resident within graphics memory for the indicated
//               GSG.
////////////////////////////////////////////////////////////////////
76
bool Texture::get_resident(PreparedGraphicsObjects *prepared_objects) const;

2617 7 release 0 4 3092 16 Texture::release 0 1 1134 394
////////////////////////////////////////////////////////////////////
//     Function: Texture::release
//       Access: Published
//  Description: Frees the texture context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
////////////////////////////////////////////////////////////////////
65
bool Texture::release(PreparedGraphicsObjects *prepared_objects);

2618 11 release_all 0 4 3092 20 Texture::release_all 0 1 1135 392
////////////////////////////////////////////////////////////////////
//     Function: Texture::release_all
//       Access: Published
//  Description: Frees the context allocated on all objects for which
//               the texture has been declared.  Returns the number of
//               contexts which have been freed.
////////////////////////////////////////////////////////////////////
31
int Texture::release_all(void);

2619 23 estimate_texture_memory 0 4 3092 32 Texture::estimate_texture_memory 0 1 1136 775
////////////////////////////////////////////////////////////////////
//     Function: Texture::estimate_texture_memory
//       Access: Published
//  Description: Estimates the amount of texture memory that will be
//               consumed by loading this texture.  This returns a
//               value that is not specific to any particular graphics
//               card or driver; it tries to make a reasonable
//               assumption about how a driver will load the texture.
//               It does not account for texture compression or
//               anything fancy.  This is mainly useful for debugging
//               and reporting purposes.
//
//               Returns a value in bytes.
////////////////////////////////////////////////////////////////////
52
size_t Texture::estimate_texture_memory(void) const;

2620 12 set_aux_data 0 4 3092 21 Texture::set_aux_data 0 1 1137 523
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_aux_data
//       Access: Published
//  Description: Records an arbitrary object in the Texture,
//               associated with a specified key.  The object may
//               later be retrieved by calling get_aux_data() with the
//               same key.
//
//               These data objects are not recorded to a bam or txo
//               file.
////////////////////////////////////////////////////////////////////
77
void Texture::set_aux_data(string const &key, TypedReferenceCount *aux_data);

2621 14 clear_aux_data 0 4 3092 23 Texture::clear_aux_data 0 1 1138 296
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_aux_data
//       Access: Published
//  Description: Removes a record previously recorded via
//               set_aux_data().
////////////////////////////////////////////////////////////////////
48
void Texture::clear_aux_data(string const &key);

2622 12 get_aux_data 0 4 3092 21 Texture::get_aux_data 0 1 1139 383
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_aux_data
//       Access: Published
//  Description: Returns a record previously recorded via
//               set_aux_data().  Returns NULL if there was no record
//               associated with the indicated key.
////////////////////////////////////////////////////////////////////
68
TypedReferenceCount *Texture::get_aux_data(string const &key) const;

2623 20 set_textures_power_2 0 4 3092 29 Texture::set_textures_power_2 0 1 1140 520
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_textures_power_2
//       Access: Published, Static
//  Description: Set this flag to ATS_none, ATS_up, ATS_down, or
//               ATS_pad to control the scaling of textures in
//               general, if a particular texture does not override
//               this.  See also set_auto_texture_scale() for the
//               per-texture override.
////////////////////////////////////////////////////////////////////
73
static inline void Texture::set_textures_power_2(AutoTextureScale scale);

2624 20 get_textures_power_2 0 4 3092 29 Texture::get_textures_power_2 0 1 1141 536
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_textures_power_2
//       Access: Published, Static
//  Description: This flag returns ATS_none, ATS_up, or ATS_down
//               and controls the scaling of textures in general.  It
//               is initialized from the config variable of the same
//               name, but it can be subsequently adjusted.  See also
//               get_auto_texture_scale().
////////////////////////////////////////////////////////////////////
67
static inline AutoTextureScale Texture::get_textures_power_2(void);

2625 20 has_textures_power_2 0 4 3092 29 Texture::has_textures_power_2 0 1 1142 452
////////////////////////////////////////////////////////////////////
//     Function: Texture::has_textures_power_2
//       Access: Published, Static
//  Description: If true, then get_textures_power_2 has been
//               set using set_textures_power_2.
//               If false, then get_textures_power_2 simply
//               returns the config variable of the same name.
////////////////////////////////////////////////////////////////////
55
static inline bool Texture::has_textures_power_2(void);

2626 12 set_filename 0 4 3092 21 Texture::set_filename 0 1 1143 834
// These are published, but in general, you shouldn't be mucking
// with these values; they are set automatically when a texture is
// loaded.

////////////////////////////////////////////////////////////////////
//     Function: Texture::set_filename
//       Access: Published
//  Description: Sets the name of the file that contains the image's
//               contents.  Normally, this is set automatically when
//               the image is loaded, for instance via
//               Texture::read().
//
//               The Texture's get_name() function used to return
//               the filename, but now returns just the basename
//               (without the extension), which is a more useful name
//               for identifying an image in show code.
////////////////////////////////////////////////////////////////////
60
inline void Texture::set_filename(Filename const &filename);

2627 14 clear_filename 0 4 3092 23 Texture::clear_filename 0 1 1144 313
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_filename
//       Access: Published
//  Description: Removes the alpha filename, if it was previously set.
//               See set_filename().
////////////////////////////////////////////////////////////////////
42
inline void Texture::clear_filename(void);

2628 18 set_alpha_filename 0 4 3092 27 Texture::set_alpha_filename 0 1 1145 915
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_alpha_filename
//       Access: Published
//  Description: Sets the name of the file that contains the image's
//               alpha channel contents.  Normally, this is set
//               automatically when the image is loaded, for instance
//               via Texture::read().
//
//               The Texture's get_filename() function returns the
//               name of the image file that was loaded into the
//               buffer.  In the case where a texture specified two
//               separate files to load, a 1- or 3-channel color image
//               and a 1-channel alpha image, this Filename is update
//               to contain the name of the image file that was loaded
//               into the buffer's alpha channel.
////////////////////////////////////////////////////////////////////
72
inline void Texture::set_alpha_filename(Filename const &alpha_filename);

2629 20 clear_alpha_filename 0 4 3092 29 Texture::clear_alpha_filename 0 1 1146 325
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_alpha_filename
//       Access: Published
//  Description: Removes the alpha filename, if it was previously set.
//               See set_alpha_filename().
////////////////////////////////////////////////////////////////////
48
inline void Texture::clear_alpha_filename(void);

2630 12 set_fullpath 0 4 3092 21 Texture::set_fullpath 0 1 1147 470
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_fullpath
//       Access: Published
//  Description: Sets the full pathname to the file that contains the
//               image's contents, as found along the search path.
//               Normally, this is set automatically when the image is
//               loaded, for instance via Texture::read().
////////////////////////////////////////////////////////////////////
60
inline void Texture::set_fullpath(Filename const &fullpath);

2631 14 clear_fullpath 0 4 3092 23 Texture::clear_fullpath 0 1 1148 313
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_fullpath
//       Access: Published
//  Description: Removes the alpha fullpath, if it was previously set.
//               See set_fullpath().
////////////////////////////////////////////////////////////////////
42
inline void Texture::clear_fullpath(void);

2632 18 set_alpha_fullpath 0 4 3092 27 Texture::set_alpha_fullpath 0 1 1149 508
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_alpha_fullpath
//       Access: Published
//  Description: Sets the full pathname to the file that contains the
//               image's alpha channel contents, as found along the
//               search path.  Normally, this is set automatically
//               when the image is loaded, for instance via
//               Texture::read().
////////////////////////////////////////////////////////////////////
72
inline void Texture::set_alpha_fullpath(Filename const &alpha_fullpath);

2633 20 clear_alpha_fullpath 0 4 3092 29 Texture::clear_alpha_fullpath 0 1 1150 325
////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_alpha_fullpath
//       Access: Published
//  Description: Removes the alpha fullpath, if it was previously set.
//               See set_alpha_fullpath().
////////////////////////////////////////////////////////////////////
48
inline void Texture::clear_alpha_fullpath(void);

2634 10 set_x_size 0 4 3092 19 Texture::set_x_size 0 1 1151 371
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_x_size
//       Access: Published
//  Description: Changes the x size indicated for the texture.  This
//               also implicitly unloads the texture if it has already
//               been loaded.
////////////////////////////////////////////////////////////////////
44
inline void Texture::set_x_size(int x_size);

2635 10 set_y_size 0 4 3092 19 Texture::set_y_size 0 1 1152 371
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_y_size
//       Access: Published
//  Description: Changes the y size indicated for the texture.  This
//               also implicitly unloads the texture if it has already
//               been loaded.
////////////////////////////////////////////////////////////////////
44
inline void Texture::set_y_size(int y_size);

2636 10 set_z_size 0 4 3092 19 Texture::set_z_size 0 1 1153 371
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_z_size
//       Access: Published
//  Description: Changes the z size indicated for the texture.  This
//               also implicitly unloads the texture if it has already
//               been loaded.
////////////////////////////////////////////////////////////////////
44
inline void Texture::set_z_size(int z_size);

2637 13 set_num_views 0 4 3092 22 Texture::set_num_views 0 1 1154 866
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_num_views
//       Access: Published
//  Description: Sets the number of "views" within a texture.  A view
//               is a completely separate image stored within the
//               Texture object.  Most textures have only one view,
//               but a stereo texture, for instance, may have two
//               views, a left and a right image.  Other uses for
//               multiple views are not yet defined.
//
//               If this value is greater than one, the additional
//               views are accessed as additional pages beyond
//               get_z_size().
//
//               This also implicitly unloads the texture if it has
//               already been loaded.
////////////////////////////////////////////////////////////////////
50
inline void Texture::set_num_views(int num_views);

2638 14 get_pad_x_size 0 4 3092 23 Texture::get_pad_x_size 0 1 1155 273
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_pad_x_size
//       Access: Published
//  Description: Returns size of the pad region.  See set_pad_size.
////////////////////////////////////////////////////////////////////
47
inline int Texture::get_pad_x_size(void) const;

2639 14 get_pad_y_size 0 4 3092 23 Texture::get_pad_y_size 0 1 1156 273
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_pad_y_size
//       Access: Published
//  Description: Returns size of the pad region.  See set_pad_size.
////////////////////////////////////////////////////////////////////
47
inline int Texture::get_pad_y_size(void) const;

2640 14 get_pad_z_size 0 4 3092 23 Texture::get_pad_z_size 0 1 1157 273
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_pad_z_size
//       Access: Published
//  Description: Returns size of the pad region.  See set_pad_size.
////////////////////////////////////////////////////////////////////
47
inline int Texture::get_pad_z_size(void) const;

2641 13 get_tex_scale 0 4 3092 22 Texture::get_tex_scale 0 1 1158 866
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_tex_scale
//       Access: Published
//  Description: Returns a scale pair that is suitable for applying to
//               geometry via NodePath::set_tex_scale(), which will
//               convert texture coordinates on the geometry from the
//               range 0..1 into the appropriate range to render the
//               video part of the texture.
//
//               This is necessary only if a padding size has been set
//               via set_pad_size() (or implicitly via something like
//               "textures-power-2 pad" in the config.prc file).  In
//               this case, this is a convenient way to generate UV's
//               that reflect the built-in padding size.
////////////////////////////////////////////////////////////////////
52
inline LVecBase2 Texture::get_tex_scale(void) const;

2642 12 set_pad_size 0 4 3092 21 Texture::set_pad_size 0 1 1159 813
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_pad_size
//       Access: Published
//  Description: Sets the size of the pad region.
//
//               Sometimes, when a video card demands power-of-two
//               textures, it is necessary to create a big texture
//               and then only use a portion of it.  The pad region
//               indicates which portion of the texture is not
//               really in use.  All operations use the texture
//               as a whole, including the pad region, unless they
//               explicitly state that they use only the non-pad
//               region.
//
//               Changing the texture's size clears the pad region.
////////////////////////////////////////////////////////////////////
67
inline void Texture::set_pad_size(int x = 0, int y = 0, int z = 0);

2643 15 set_size_padded 0 4 3092 24 Texture::set_size_padded 0 1 1160 348
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_size_padded
//       Access: Published
//  Description: Changes the size of the texture, padding
//               if necessary, and setting the pad region
//               as well.
////////////////////////////////////////////////////////////////////
63
void Texture::set_size_padded(int x = 1, int y = 1, int z = 1);

2644 20 get_orig_file_x_size 0 4 3092 29 Texture::get_orig_file_x_size 0 1 1161 414
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_orig_file_x_size
//       Access: Published
//  Description: Returns the X size of the original disk image that
//               this Texture was loaded from (if it came from a disk
//               file), before any automatic rescaling by Panda.
////////////////////////////////////////////////////////////////////
53
inline int Texture::get_orig_file_x_size(void) const;

2645 20 get_orig_file_y_size 0 4 3092 29 Texture::get_orig_file_y_size 0 1 1162 414
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_orig_file_y_size
//       Access: Published
//  Description: Returns the Y size of the original disk image that
//               this Texture was loaded from (if it came from a disk
//               file), before any automatic rescaling by Panda.
////////////////////////////////////////////////////////////////////
53
inline int Texture::get_orig_file_y_size(void) const;

2646 20 get_orig_file_z_size 0 4 3092 29 Texture::get_orig_file_z_size 0 1 1163 414
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_orig_file_z_size
//       Access: Published
//  Description: Returns the Z size of the original disk image that
//               this Texture was loaded from (if it came from a disk
//               file), before any automatic rescaling by Panda.
////////////////////////////////////////////////////////////////////
53
inline int Texture::get_orig_file_z_size(void) const;

2647 18 set_orig_file_size 0 4 3092 27 Texture::set_orig_file_size 0 1 1164 343
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_orig_file_size
//       Access: Published
//  Description: Specifies the size of the texture as it exists in its
//               original disk file, before any Panda scaling.
////////////////////////////////////////////////////////////////////
58
void Texture::set_orig_file_size(int x, int y, int z = 1);

2648 10 set_format 0 4 3092 19 Texture::set_format 0 1 1165 333
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_format
//       Access: Published
//  Description: Changes the format value for the texture components.
//               This implicitly sets num_components as well.
////////////////////////////////////////////////////////////////////
56
inline void Texture::set_format(Texture::Format format);

2649 18 set_component_type 0 4 3092 27 Texture::set_component_type 0 1 1166 340
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_component_type
//       Access: Published
//  Description: Changes the data value for the texture components.
//               This implicitly sets component_width as well.
////////////////////////////////////////////////////////////////////
79
inline void Texture::set_component_type(Texture::ComponentType component_type);

2650 21 set_loaded_from_image 0 4 3092 30 Texture::set_loaded_from_image 0 1 1167 553
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_loaded_from_image
//       Access: Published
//  Description: Sets the flag that indicates the texture has been
//               loaded from a disk file or PNMImage.  You should also
//               ensure the filename has been set correctly.  When
//               this flag is true, the texture may be automatically
//               reloaded when its ram image needs to be replaced.
////////////////////////////////////////////////////////////////////
49
inline void Texture::set_loaded_from_image(void);

2651 21 get_loaded_from_image 0 4 3092 30 Texture::get_loaded_from_image 0 1 1168 383
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_loaded_from_image
//       Access: Published
//  Description: Returns the flag that indicates the texture has been
//               loaded from a disk file or PNMImage.  See
//               set_loaded_from_image().
////////////////////////////////////////////////////////////////////
55
inline bool Texture::get_loaded_from_image(void) const;

2652 19 set_loaded_from_txo 0 4 3092 28 Texture::set_loaded_from_txo 0 1 1169 452
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_loaded_from_txo
//       Access: Published
//  Description: Sets the flag that indicates the texture has been
//               loaded from a txo file.  You probably shouldn't be
//               setting this directly; it is set automatically when a
//               Texture is loaded.
////////////////////////////////////////////////////////////////////
47
inline void Texture::set_loaded_from_txo(void);

2653 19 get_loaded_from_txo 0 4 3092 28 Texture::get_loaded_from_txo 0 1 1170 321
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_loaded_from_txo
//       Access: Published
//  Description: Returns the flag that indicates the texture has been
//               loaded from a txo file.
////////////////////////////////////////////////////////////////////
53
inline bool Texture::get_loaded_from_txo(void) const;

2654 28 get_match_framebuffer_format 0 4 3092 37 Texture::get_match_framebuffer_format 0 1 1171 588
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_match_framebuffer_format
//       Access: Public
//  Description: Returns true if the special flag was set that
//               indicates to the GSG that the Texture's format should
//               be chosen to exactly match the framebuffer's format,
//               presumably because the application intends to copy
//               image data from the framebuffer into the Texture (or
//               vice-versa).
////////////////////////////////////////////////////////////////////
62
inline bool Texture::get_match_framebuffer_format(void) const;

2655 28 set_match_framebuffer_format 0 4 3092 37 Texture::set_match_framebuffer_format 0 1 1172 743
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_match_framebuffer_format
//       Access: Public
//  Description: Sets the special flag that, if true, indicates to the
//               GSG that the Texture's format should be chosen to
//               exactly match the framebuffer's format, presumably
//               because the application intends to copy image data
//               from the framebuffer into the Texture (or
//               vice-versa).
//
//               This sets only the graphics card's idea of the
//               texture format; it is not related to the
//               system-memory format.
////////////////////////////////////////////////////////////////////
61
inline void Texture::set_match_framebuffer_format(bool flag);

2656 25 get_post_load_store_cache 0 4 3092 34 Texture::get_post_load_store_cache 0 1 1173 336
////////////////////////////////////////////////////////////////////
//     Function: Texture::get_post_load_store_cache
//       Access: Public
//  Description: Returns the setting of the post_load_store_cache
//               flag.  See set_post_load_store_cache().
////////////////////////////////////////////////////////////////////
59
inline bool Texture::get_post_load_store_cache(void) const;

2657 25 set_post_load_store_cache 0 4 3092 34 Texture::set_post_load_store_cache 0 1 1174 742
////////////////////////////////////////////////////////////////////
//     Function: Texture::set_post_load_store_cache
//       Access: Public
//  Description: Sets the post_load_store_cache flag.  When this is
//               set, the next time the texture is loaded on a GSG, it
//               will automatically extract its RAM image from the GSG
//               and save it to the global BamCache.
//
//               This is used to store compressed RAM images in the
//               BamCache.  This flag should not be set explicitly; it
//               is set automatically by the TexturePool when
//               model-cache-compressed-textures is set true.
////////////////////////////////////////////////////////////////////
58
inline void Texture::set_post_load_store_cache(bool flag);

2658 11 prepare_now 0 4 3092 20 Texture::prepare_now 0 1 1175 889
////////////////////////////////////////////////////////////////////
//     Function: Texture::prepare_now
//       Access: Published
//  Description: Creates a context for the texture on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) TextureContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               textures.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a texture does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
////////////////////////////////////////////////////////////////////
122
TextureContext *Texture::prepare_now(int view, PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg);

2659 13 up_to_power_2 0 4 3092 22 Texture::up_to_power_2 0 1 1176 310
////////////////////////////////////////////////////////////////////
//     Function: Texture::up_to_power_2
//       Access: Published, Static
//  Description: Returns the smallest power of 2 greater than or equal
//               to value.
////////////////////////////////////////////////////////////////////
45
static int Texture::up_to_power_2(int value);

2660 15 down_to_power_2 0 4 3092 24 Texture::down_to_power_2 0 1 1177 308
////////////////////////////////////////////////////////////////////
//     Function: Texture::down_to_power_2
//       Access: Published, Static
//  Description: Returns the largest power of 2 less than or equal
//               to value.
////////////////////////////////////////////////////////////////////
47
static int Texture::down_to_power_2(int value);

2661 16 consider_rescale 0 4 3092 25 Texture::consider_rescale 0 2 1178 1179 1574
////////////////////////////////////////////////////////////////////
//     Function: Texture::consider_rescale
//       Access: Published
//  Description: Asks the PNMImage to change its scale when it reads
//               the image, according to the whims of the Config.prc
//               file.
//
//               For most efficient results, this method should be
//               called after pnmimage.read_header() has been called,
//               but before pnmimage.read().  This method may also be
//               called after pnmimage.read(), i.e. when the pnmimage
//               is already loaded; in this case it will rescale the
//               image on the spot.  Also see rescale_texture().
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Texture::consider_rescale
//       Access: Published, Static
//  Description: Asks the PNMImage to change its scale when it reads
//               the image, according to the whims of the Config.prc
//               file.
//
//               For most efficient results, this method should be
//               called after pnmimage.read_header() has been called,
//               but before pnmimage.read().  This method may also be
//               called after pnmimage.read(), i.e. when the pnmimage
//               is already loaded; in this case it will rescale the
//               image on the spot.  Also see rescale_texture().
////////////////////////////////////////////////////////////////////
187
void Texture::consider_rescale(PNMImage &pnmimage);
static void Texture::consider_rescale(PNMImage &pnmimage, string const &name, AutoTextureScale auto_texture_scale = ::ATS_unspecified);

2662 15 rescale_texture 0 4 3092 24 Texture::rescale_texture 0 1 1180 711
////////////////////////////////////////////////////////////////////
//     Function: Texture::rescale_texture
//       Access: Published
//  Description: This method is similar to consider_rescale(), but
//               instead of scaling a separate PNMImage, it will ask
//               the Texture to rescale its own internal image to a
//               power of 2, according to the config file
//               requirements.  This may be useful after loading a
//               Texture image by hand, instead of reading it from a
//               disk file.  Returns true if the texture is changed,
//               false if it was not.
////////////////////////////////////////////////////////////////////
43
inline bool Texture::rescale_texture(void);

2663 19 format_texture_type 0 4 3092 28 Texture::format_texture_type 0 1 1181 314
////////////////////////////////////////////////////////////////////
//     Function: Texture::format_texture_type
//       Access: Published, Static
//  Description: Returns the indicated TextureType converted to a
//               string word.
////////////////////////////////////////////////////////////////////
68
static string Texture::format_texture_type(Texture::TextureType tt);

2664 19 string_texture_type 0 4 3092 28 Texture::string_texture_type 0 1 1182 320
////////////////////////////////////////////////////////////////////
//     Function: Texture::string_texture_type
//       Access: Published, Static
//  Description: Returns the TextureType corresponding to the
//               indicated string word.
////////////////////////////////////////////////////////////////////
76
static Texture::TextureType Texture::string_texture_type(string const &str);

2665 21 format_component_type 0 4 3092 30 Texture::format_component_type 0 1 1183 318
////////////////////////////////////////////////////////////////////
//     Function: Texture::format_component_type
//       Access: Published, Static
//  Description: Returns the indicated ComponentType converted to a
//               string word.
////////////////////////////////////////////////////////////////////
72
static string Texture::format_component_type(Texture::ComponentType ct);

2666 21 string_component_type 0 4 3092 30 Texture::string_component_type 0 1 1184 324
////////////////////////////////////////////////////////////////////
//     Function: Texture::string_component_type
//       Access: Published, Static
//  Description: Returns the ComponentType corresponding to the
//               indicated string word.
////////////////////////////////////////////////////////////////////
80
static Texture::ComponentType Texture::string_component_type(string const &str);

2667 13 format_format 0 4 3092 22 Texture::format_format 0 1 1185 303
////////////////////////////////////////////////////////////////////
//     Function: Texture::format_format
//       Access: Published, Static
//  Description: Returns the indicated Format converted to a
//               string word.
////////////////////////////////////////////////////////////////////
56
static string Texture::format_format(Texture::Format f);

2668 13 string_format 0 4 3092 22 Texture::string_format 0 1 1186 309
////////////////////////////////////////////////////////////////////
//     Function: Texture::string_format
//       Access: Published, Static
//  Description: Returns the Format corresponding to the
//               indicated string word.
////////////////////////////////////////////////////////////////////
65
static Texture::Format Texture::string_format(string const &str);

2669 23 format_compression_mode 0 4 3092 32 Texture::format_compression_mode 0 1 1187 322
////////////////////////////////////////////////////////////////////
//     Function: Texture::format_compression_mode
//       Access: Published, Static
//  Description: Returns the indicated CompressionMode converted to a
//               string word.
////////////////////////////////////////////////////////////////////
76
static string Texture::format_compression_mode(Texture::CompressionMode cm);

2670 23 string_compression_mode 0 4 3092 32 Texture::string_compression_mode 0 1 1188 328
////////////////////////////////////////////////////////////////////
//     Function: Texture::string_compression_mode
//       Access: Public
//  Description: Returns the CompressionMode value associated with the
//               given string representation.
////////////////////////////////////////////////////////////////////
84
static Texture::CompressionMode Texture::string_compression_mode(string const &str);

2671 20 format_quality_level 0 4 3092 29 Texture::format_quality_level 0 1 1189 316
////////////////////////////////////////////////////////////////////
//     Function: Texture::format_quality_level
//       Access: Published, Static
//  Description: Returns the indicated QualityLevel converted to a
//               string word.
////////////////////////////////////////////////////////////////////
71
static string Texture::format_quality_level(Texture::QualityLevel tql);

2672 20 string_quality_level 0 4 3092 29 Texture::string_quality_level 0 1 1190 322
////////////////////////////////////////////////////////////////////
//     Function: Texture::string_quality_level
//       Access: Public
//  Description: Returns the QualityLevel value associated with the
//               given string representation.
////////////////////////////////////////////////////////////////////
78
static Texture::QualityLevel Texture::string_quality_level(string const &str);

2673 14 get_class_type 0 4 3092 23 Texture::get_class_type 0 1 1191 0
48
static TypeHandle Texture::get_class_type(void);

2674 4 load 0 4 3100 12 Shader::load 0 2 1196 1197 566
////////////////////////////////////////////////////////////////////
//     Function: Shader::load
//       Access: Published, Static
//  Description: Loads the shader with the given filename.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Shader::load
//       Access: Published, Static
//  Description: This variant of Shader::load loads all shader
//               programs separately.
////////////////////////////////////////////////////////////////////
335
static PointerTo< Shader > Shader::load(Filename const &file, Shader::ShaderLanguage lang = ::Shader::SL_none);
static PointerTo< Shader > Shader::load(Shader::ShaderLanguage lang, Filename const &vertex, Filename const &fragment, Filename const &geometry = "", Filename const &tess_control = "", Filename const &tess_evaluation = "");

2675 4 make 0 4 3100 12 Shader::make 0 2 1198 1199 553
//////////////////////////////////////////////////////////////////////
//     Function: Shader::make
//       Access: Published, Static
//  Description: Loads the shader, using the string as shader body.
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//     Function: Shader::make
//       Access: Published, Static
//  Description: Loads the shader, using the strings as shader bodies.
//////////////////////////////////////////////////////////////////////
323
static PointerTo< Shader > Shader::make(string const &body, Shader::ShaderLanguage lang = ::Shader::SL_none);
static PointerTo< Shader > Shader::make(Shader::ShaderLanguage lang, string const &vertex, string const &fragment, string const &geometry = "", string const &tess_control = "", string const &tess_evaluation = "");

2676 12 load_compute 0 4 3100 20 Shader::load_compute 0 1 1200 251
////////////////////////////////////////////////////////////////////
//     Function: Shader::load_compute
//       Access: Published, Static
//  Description: Loads a compute shader.
////////////////////////////////////////////////////////////////////
97
static PointerTo< Shader > Shader::load_compute(Shader::ShaderLanguage lang, Filename const &fn);

2677 12 make_compute 0 4 3100 20 Shader::make_compute 0 1 1201 279
//////////////////////////////////////////////////////////////////////
//     Function: Shader::make_compute
//       Access: Published, Static
//  Description: Loads the compute shader from the given string.
//////////////////////////////////////////////////////////////////////
97
static PointerTo< Shader > Shader::make_compute(Shader::ShaderLanguage lang, string const &body);

2678 12 get_filename 0 4 3100 20 Shader::get_filename 0 1 1202 292
////////////////////////////////////////////////////////////////////
//     Function: Shader::get_filename
//       Access: Published
//  Description: Return the Shader's filename for the given shader
//               type.
////////////////////////////////////////////////////////////////////
95
inline Filename Shader::get_filename(Shader::ShaderType const &type = ::Shader::ST_none) const;

2679 8 get_text 0 4 3100 16 Shader::get_text 0 1 1203 267
////////////////////////////////////////////////////////////////////
//     Function: Shader::get_text
//       Access: Published
//  Description: Return the Shader's text for the given shader type.
////////////////////////////////////////////////////////////////////
96
inline string const &Shader::get_text(Shader::ShaderType const &type = ::Shader::ST_none) const;

2680 14 get_error_flag 0 4 3100 22 Shader::get_error_flag 0 1 1204 399
////////////////////////////////////////////////////////////////////
//     Function: Shader::get_error_flag
//       Access: Public
//  Description: Returns true if the shader contains a compile-time
//               error.  This doesn't tell you whether or not the
//               shader is supported on the current video card.
////////////////////////////////////////////////////////////////////
47
inline bool Shader::get_error_flag(void) const;

2681 12 get_language 0 4 3100 20 Shader::get_language 0 1 1205 298
////////////////////////////////////////////////////////////////////
//     Function: Shader::get_language
//       Access: Published
//  Description: Returns the shader language in which this shader
//               was written.
////////////////////////////////////////////////////////////////////
63
inline Shader::ShaderLanguage Shader::get_language(void) const;

2682 22 get_shader_utilization 0 4 3100 30 Shader::get_shader_utilization 0 1 1206 509
////////////////////////////////////////////////////////////////////
//     Function: Shader::get_shader_utilization
//       Access: Published, Static
//  Description: This flag returns SUT_none, SUT_basic, or
//               SUT_advanced and controls the automatic generation
//               of shaders.  It is initialized from the config
//               variable of the same name, but it can be
//               subsequently adjusted.
////////////////////////////////////////////////////////////////////
69
static inline ShaderUtilization Shader::get_shader_utilization(void);

2683 22 set_shader_utilization 0 4 3100 30 Shader::set_shader_utilization 0 1 1207 382
////////////////////////////////////////////////////////////////////
//     Function: Shader::set_shader_utilization
//       Access: Published, Static
//  Description: Set this flag to SUT_none, SUT_basic, or
//               SUT_advanced to limit panda's automatic shader
//               generation facilities.
////////////////////////////////////////////////////////////////////
73
static inline void Shader::set_shader_utilization(ShaderUtilization utl);

2684 23 have_shader_utilization 0 4 3100 31 Shader::have_shader_utilization 0 1 1208 460
////////////////////////////////////////////////////////////////////
//     Function: Shader::have_shader_utilization
//       Access: Published, Static
//  Description: If true, then get_shader_utilization has been
//               set using set_shader_utilization.
//               If false, then get_shader_utilization simply
//               returns the config variable of the same name.
////////////////////////////////////////////////////////////////////
57
static inline bool Shader::have_shader_utilization(void);

2685 7 prepare 0 4 3100 15 Shader::prepare 0 1 1209 653
////////////////////////////////////////////////////////////////////
//     Function: Shader::prepare
//       Access: Published
//  Description: Indicates that the shader should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.  This will ensure the
//               texture is already loaded into texture memory if it
//               is expected to be rendered soon.
//
//               Use this function instead of prepare_now() to preload
//               textures from a user interface standpoint.
////////////////////////////////////////////////////////////////////
64
void Shader::prepare(PreparedGraphicsObjects *prepared_objects);

2686 11 is_prepared 0 4 3100 19 Shader::is_prepared 0 1 1210 372
////////////////////////////////////////////////////////////////////
//     Function: Shader::is_prepared
//       Access: Published
//  Description: Returns true if the shader has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
////////////////////////////////////////////////////////////////////
74
bool Shader::is_prepared(PreparedGraphicsObjects *prepared_objects) const;

2687 7 release 0 4 3100 15 Shader::release 0 1 1211 393
////////////////////////////////////////////////////////////////////
//     Function: Shader::release
//       Access: Published
//  Description: Frees the texture context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
////////////////////////////////////////////////////////////////////
64
bool Shader::release(PreparedGraphicsObjects *prepared_objects);

2688 11 release_all 0 4 3100 19 Shader::release_all 0 1 1212 391
////////////////////////////////////////////////////////////////////
//     Function: Shader::release_all
//       Access: Published
//  Description: Frees the context allocated on all objects for which
//               the texture has been declared.  Returns the number of
//               contexts which have been freed.
////////////////////////////////////////////////////////////////////
30
int Shader::release_all(void);

2689 11 prepare_now 0 4 3100 19 Shader::prepare_now 0 1 1213 885
////////////////////////////////////////////////////////////////////
//     Function: Shader::prepare_now
//       Access: Published
//  Description: Creates a context for the shader on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) ShaderContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               textures.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a shader does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
////////////////////////////////////////////////////////////////////
110
ShaderContext *Shader::prepare_now(PreparedGraphicsObjects *prepared_objects, GraphicsStateGuardianBase *gsg);

2690 14 get_class_type 0 4 3100 22 Shader::get_class_type 0 1 1214 0
47
static TypeHandle Shader::get_class_type(void);

2691 8 get_name 0 4 3105 33 PreparedGraphicsObjects::get_name 0 1 1215 414
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_name
//       Access: Public
//  Description: Returns the name of the PreparedGraphicsObjects
//               structure.  This is an arbitrary name that serves
//               mainly to uniquify the context for PStats reporting.
////////////////////////////////////////////////////////////////////
67
inline string const &PreparedGraphicsObjects::get_name(void) const;

2692 25 set_graphics_memory_limit 0 4 3105 50 PreparedGraphicsObjects::set_graphics_memory_limit 0 1 1216 873
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::set_graphics_memory_limit
//       Access: Public
//  Description: Sets an artificial cap on graphics memory that
//               will be imposed on this GSG.
//
//               This limits the total amount of graphics memory,
//               including texture memory and vertex buffer memory,
//               that will be consumed by the GSG, regardless of
//               whether the hardware claims to provide more graphics
//               memory than this. It is useful to put a ceiling on
//               graphics memory consumed, since some drivers seem to
//               allow the application to consume more memory than the
//               hardware can realistically support.
////////////////////////////////////////////////////////////////////
70
void PreparedGraphicsObjects::set_graphics_memory_limit(size_t limit);

2693 25 get_graphics_memory_limit 0 4 3105 50 PreparedGraphicsObjects::get_graphics_memory_limit 0 1 1217 394
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_graphics_memory_limit
//       Access: Public
//  Description: Returns the artificial cap on graphics memory that
//               will be imposed on this GSG.  See
//               set_graphics_memory_limit().
////////////////////////////////////////////////////////////////////
77
inline size_t PreparedGraphicsObjects::get_graphics_memory_limit(void) const;

2694 24 show_graphics_memory_lru 0 4 3105 49 PreparedGraphicsObjects::show_graphics_memory_lru 0 1 1218 393
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::show_graphics_memory_lru
//       Access: Public
//  Description: Writes to the indicated ostream a report of how the
//               various textures and vertex buffers are allocated in
//               the LRU.
////////////////////////////////////////////////////////////////////
75
void PreparedGraphicsObjects::show_graphics_memory_lru(ostream &out) const;

2695 23 show_residency_trackers 0 4 3105 48 PreparedGraphicsObjects::show_residency_trackers 0 1 1219 392
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::show_residency_trackers
//       Access: Public
//  Description: Writes to the indicated ostream a report of how the
//               various textures and vertex buffers are allocated in
//               the LRU.
////////////////////////////////////////////////////////////////////
74
void PreparedGraphicsObjects::show_residency_trackers(ostream &out) const;

2696 11 release_all 0 4 3105 36 PreparedGraphicsObjects::release_all 0 1 1220 284
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all
//       Access: Public
//  Description: Releases all prepared objects of all kinds at once.
////////////////////////////////////////////////////////////////////
55
inline void PreparedGraphicsObjects::release_all(void);

2697 14 get_num_queued 0 4 3105 39 PreparedGraphicsObjects::get_num_queued 0 1 1221 346
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued
//       Access: Public
//  Description: Returns the number of objects of any kind that have
//               been enqueued to be prepared on this GSG.
////////////////////////////////////////////////////////////////////
63
inline int PreparedGraphicsObjects::get_num_queued(void) const;

2698 16 get_num_prepared 0 4 3105 41 PreparedGraphicsObjects::get_num_prepared 0 1 1222 341
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared
//       Access: Public
//  Description: Returns the number of objects of any kind that have
//               already been prepared on this GSG.
////////////////////////////////////////////////////////////////////
65
inline int PreparedGraphicsObjects::get_num_prepared(void) const;

2699 15 enqueue_texture 0 4 3105 40 PreparedGraphicsObjects::enqueue_texture 0 1 1223 413
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_texture
//       Access: Public
//  Description: Indicates that a texture would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
////////////////////////////////////////////////////////////////////
60
void PreparedGraphicsObjects::enqueue_texture(Texture *tex);

2700 17 is_texture_queued 0 4 3105 42 PreparedGraphicsObjects::is_texture_queued 0 1 1224 329
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_texture_queued
//       Access: Public
//  Description: Returns true if the texture has been queued on this
//               GSG, false otherwise.
////////////////////////////////////////////////////////////////////
74
bool PreparedGraphicsObjects::is_texture_queued(Texture const *tex) const;

2701 15 dequeue_texture 0 4 3105 40 PreparedGraphicsObjects::dequeue_texture 0 1 1225 733
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_texture
//       Access: Public
//  Description: Removes a texture from the queued list of textures to
//               be prepared.  Normally it is not necessary to call
//               this, unless you change your mind about preparing it
//               at the last minute, since the texture will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the texture is
//               successfully dequeued, false if it had not been
//               queued.
////////////////////////////////////////////////////////////////////
60
bool PreparedGraphicsObjects::dequeue_texture(Texture *tex);

2702 19 is_texture_prepared 0 4 3105 44 PreparedGraphicsObjects::is_texture_prepared 0 1 1226 333
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_texture_prepared
//       Access: Public
//  Description: Returns true if the texture has been prepared on
//               this GSG, false otherwise.
////////////////////////////////////////////////////////////////////
76
bool PreparedGraphicsObjects::is_texture_prepared(Texture const *tex) const;

2703 15 release_texture 0 4 3105 40 PreparedGraphicsObjects::release_texture 0 2 1227 1228 1171
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_texture
//       Access: Public
//  Description: Indicates that a texture context, created by a
//               previous call to prepare_texture(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release textures--this
//               prevents conflicts from threading or multiple GSG's
//               sharing textures (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_texture is called).
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_texture
//       Access: Public
//  Description: Releases a texture if it has already been prepared,
//               or removes it from the preparation queue.
////////////////////////////////////////////////////////////////////
127
void PreparedGraphicsObjects::release_texture(TextureContext *tc);
void PreparedGraphicsObjects::release_texture(Texture *tex);

2704 20 release_all_textures 0 4 3105 45 PreparedGraphicsObjects::release_all_textures 0 1 1229 460
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_textures
//       Access: Public
//  Description: Releases all textures at once.  This will force them
//               to be reloaded into texture memory for all GSG's that
//               share this object.  Returns the number of textures
//               released.
////////////////////////////////////////////////////////////////////
56
int PreparedGraphicsObjects::release_all_textures(void);

2705 23 get_num_queued_textures 0 4 3105 48 PreparedGraphicsObjects::get_num_queued_textures 0 1 1230 344
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_textures
//       Access: Public
//  Description: Returns the number of textures that have been
//               enqueued to be prepared on this GSG.
////////////////////////////////////////////////////////////////////
65
int PreparedGraphicsObjects::get_num_queued_textures(void) const;

2706 25 get_num_prepared_textures 0 4 3105 50 PreparedGraphicsObjects::get_num_prepared_textures 0 1 1231 339
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_textures
//       Access: Public
//  Description: Returns the number of textures that have already been
//               prepared on this GSG.
////////////////////////////////////////////////////////////////////
67
int PreparedGraphicsObjects::get_num_prepared_textures(void) const;

2707 19 prepare_texture_now 0 4 3105 44 PreparedGraphicsObjects::prepare_texture_now 0 1 1232 1165
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_texture_now
//       Access: Public
//  Description: Immediately creates a new TextureContext for the
//               indicated texture and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               textures.  If this is not necessarily the case, you
//               should use enqueue_texture() instead.
//
//               Normally, this function is not called directly.  Call
//               Texture::prepare_now() instead.
//
//               The TextureContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular texture, and will exist as long as the
//               texture is ready to be rendered.
//
//               When either the Texture or the
//               PreparedGraphicsObjects object destructs, the
//               TextureContext will be deleted.
////////////////////////////////////////////////////////////////////
117
TextureContext *PreparedGraphicsObjects::prepare_texture_now(Texture *tex, int view, GraphicsStateGuardianBase *gsg);

2708 15 enqueue_sampler 0 4 3105 40 PreparedGraphicsObjects::enqueue_sampler 0 1 1233 413
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_sampler
//       Access: Public
//  Description: Indicates that a sampler would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
////////////////////////////////////////////////////////////////////
75
void PreparedGraphicsObjects::enqueue_sampler(SamplerState const &sampler);

2709 17 is_sampler_queued 0 4 3105 42 PreparedGraphicsObjects::is_sampler_queued 0 1 1234 329
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_sampler_queued
//       Access: Public
//  Description: Returns true if the sampler has been queued on this
//               GSG, false otherwise.
////////////////////////////////////////////////////////////////////
83
bool PreparedGraphicsObjects::is_sampler_queued(SamplerState const &sampler) const;

2710 15 dequeue_sampler 0 4 3105 40 PreparedGraphicsObjects::dequeue_sampler 0 1 1235 733
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_sampler
//       Access: Public
//  Description: Removes a sampler from the queued list of samplers to
//               be prepared.  Normally it is not necessary to call
//               this, unless you change your mind about preparing it
//               at the last minute, since the sampler will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the sampler is
//               successfully dequeued, false if it had not been
//               queued.
////////////////////////////////////////////////////////////////////
75
bool PreparedGraphicsObjects::dequeue_sampler(SamplerState const &sampler);

2711 19 is_sampler_prepared 0 4 3105 44 PreparedGraphicsObjects::is_sampler_prepared 0 1 1236 333
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_sampler_prepared
//       Access: Public
//  Description: Returns true if the sampler has been prepared on
//               this GSG, false otherwise.
////////////////////////////////////////////////////////////////////
85
bool PreparedGraphicsObjects::is_sampler_prepared(SamplerState const &sampler) const;

2712 15 release_sampler 0 4 3105 40 PreparedGraphicsObjects::release_sampler 0 2 1237 1238 895
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_sampler
//       Access: Public
//  Description: Indicates that a sampler context, created by a
//               previous call to prepare_sampler(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release samplers.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_sampler
//       Access: Public
//  Description: Releases a sampler if it has already been prepared,
//               or removes it from the preparation queue.
////////////////////////////////////////////////////////////////////
142
void PreparedGraphicsObjects::release_sampler(SamplerContext *sc);
void PreparedGraphicsObjects::release_sampler(SamplerState const &sampler);

2713 20 release_all_samplers 0 4 3105 45 PreparedGraphicsObjects::release_all_samplers 0 1 1239 422
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_samplers
//       Access: Public
//  Description: Releases all samplers at once.  This will force them
//               to be reloaded for all GSG's that share this object.
//               Returns the number of samplers released.
////////////////////////////////////////////////////////////////////
56
int PreparedGraphicsObjects::release_all_samplers(void);

2714 23 get_num_queued_samplers 0 4 3105 48 PreparedGraphicsObjects::get_num_queued_samplers 0 1 1240 344
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_samplers
//       Access: Public
//  Description: Returns the number of samplers that have been
//               enqueued to be prepared on this GSG.
////////////////////////////////////////////////////////////////////
65
int PreparedGraphicsObjects::get_num_queued_samplers(void) const;

2715 25 get_num_prepared_samplers 0 4 3105 50 PreparedGraphicsObjects::get_num_prepared_samplers 0 1 1241 339
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_samplers
//       Access: Public
//  Description: Returns the number of samplers that have already been
//               prepared on this GSG.
////////////////////////////////////////////////////////////////////
67
int PreparedGraphicsObjects::get_num_prepared_samplers(void) const;

2716 19 prepare_sampler_now 0 4 3105 44 PreparedGraphicsObjects::prepare_sampler_now 0 1 1242 1164
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_sampler_now
//       Access: Public
//  Description: Immediately creates a new SamplerContext for the
//               indicated sampler and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               samplers.  If this is not necessarily the case, you
//               should use enqueue_sampler() instead.
//
//               Normally, this function is not called directly.
//               Call Sampler::prepare_now() instead.
//
//               The SamplerContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular sampler, and will exist as long as the
//               sampler is ready to be rendered.
//
//               When either the Sampler or the
//               PreparedGraphicsObjects object destructs, the
//               SamplerContext will be deleted.
////////////////////////////////////////////////////////////////////
122
SamplerContext *PreparedGraphicsObjects::prepare_sampler_now(SamplerState const &sampler, GraphicsStateGuardianBase *gsg);

2717 12 enqueue_geom 0 4 3105 37 PreparedGraphicsObjects::enqueue_geom 0 1 1243 407
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_geom
//       Access: Public
//  Description: Indicates that a geom would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
////////////////////////////////////////////////////////////////////
55
void PreparedGraphicsObjects::enqueue_geom(Geom *geom);

2718 14 is_geom_queued 0 4 3105 39 PreparedGraphicsObjects::is_geom_queued 0 1 1244 323
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_geom_queued
//       Access: Public
//  Description: Returns true if the geom has been queued on this
//               GSG, false otherwise.
////////////////////////////////////////////////////////////////////
69
bool PreparedGraphicsObjects::is_geom_queued(Geom const *geom) const;

2719 12 dequeue_geom 0 4 3105 37 PreparedGraphicsObjects::dequeue_geom 0 1 1245 718
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_geom
//       Access: Public
//  Description: Removes a geom from the queued list of geoms to
//               be prepared.  Normally it is not necessary to call
//               this, unless you change your mind about preparing it
//               at the last minute, since the geom will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the geom is
//               successfully dequeued, false if it had not been
//               queued.
////////////////////////////////////////////////////////////////////
55
bool PreparedGraphicsObjects::dequeue_geom(Geom *geom);

2720 16 is_geom_prepared 0 4 3105 41 PreparedGraphicsObjects::is_geom_prepared 0 1 1246 336
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_geom_prepared
//       Access: Public
//  Description: Returns true if the vertex buffer has been prepared on
//               this GSG, false otherwise.
////////////////////////////////////////////////////////////////////
71
bool PreparedGraphicsObjects::is_geom_prepared(Geom const *geom) const;

2721 12 release_geom 0 4 3105 37 PreparedGraphicsObjects::release_geom 0 1 1247 804
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_geom
//       Access: Public
//  Description: Indicates that a geom context, created by a
//               previous call to prepare_geom(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release geoms--this
//               prevents conflicts from threading or multiple GSG's
//               sharing geoms (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_geom is called).
////////////////////////////////////////////////////////////////////
60
void PreparedGraphicsObjects::release_geom(GeomContext *gc);

2722 17 release_all_geoms 0 4 3105 42 PreparedGraphicsObjects::release_all_geoms 0 1 1248 448
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_geoms
//       Access: Public
//  Description: Releases all geoms at once.  This will force them
//               to be reloaded into geom memory for all GSG's that
//               share this object.  Returns the number of geoms
//               released.
////////////////////////////////////////////////////////////////////
53
int PreparedGraphicsObjects::release_all_geoms(void);

2723 20 get_num_queued_geoms 0 4 3105 45 PreparedGraphicsObjects::get_num_queued_geoms 0 1 1249 338
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_geoms
//       Access: Public
//  Description: Returns the number of geoms that have been
//               enqueued to be prepared on this GSG.
////////////////////////////////////////////////////////////////////
62
int PreparedGraphicsObjects::get_num_queued_geoms(void) const;

2724 22 get_num_prepared_geoms 0 4 3105 47 PreparedGraphicsObjects::get_num_prepared_geoms 0 1 1250 333
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_geoms
//       Access: Public
//  Description: Returns the number of geoms that have already been
//               prepared on this GSG.
////////////////////////////////////////////////////////////////////
64
int PreparedGraphicsObjects::get_num_prepared_geoms(void) const;

2725 16 prepare_geom_now 0 4 3105 41 PreparedGraphicsObjects::prepare_geom_now 0 1 1251 1132
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_geom_now
//       Access: Public
//  Description: Immediately creates a new GeomContext for the
//               indicated geom and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               geoms.  If this is not necessarily the case, you
//               should use enqueue_geom() instead.
//
//               Normally, this function is not called directly.  Call
//               Geom::prepare_now() instead.
//
//               The GeomContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular geom, and will exist as long as the
//               geom is ready to be rendered.
//
//               When either the Geom or the
//               PreparedGraphicsObjects object destructs, the
//               GeomContext will be deleted.
////////////////////////////////////////////////////////////////////
99
GeomContext *PreparedGraphicsObjects::prepare_geom_now(Geom *geom, GraphicsStateGuardianBase *gsg);

2726 14 enqueue_shader 0 4 3105 39 PreparedGraphicsObjects::enqueue_shader 0 1 1252 411
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_shader
//       Access: Public
//  Description: Indicates that a shader would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
////////////////////////////////////////////////////////////////////
61
void PreparedGraphicsObjects::enqueue_shader(Shader *shader);

2727 16 is_shader_queued 0 4 3105 41 PreparedGraphicsObjects::is_shader_queued 0 1 1253 327
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_shader_queued
//       Access: Public
//  Description: Returns true if the shader has been queued on this
//               GSG, false otherwise.
////////////////////////////////////////////////////////////////////
75
bool PreparedGraphicsObjects::is_shader_queued(Shader const *shader) const;

2728 14 dequeue_shader 0 4 3105 39 PreparedGraphicsObjects::dequeue_shader 0 1 1254 728
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_shader
//       Access: Public
//  Description: Removes a shader from the queued list of shaders to
//               be prepared.  Normally it is not necessary to call
//               this, unless you change your mind about preparing it
//               at the last minute, since the shader will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the shader is
//               successfully dequeued, false if it had not been
//               queued.
////////////////////////////////////////////////////////////////////
61
bool PreparedGraphicsObjects::dequeue_shader(Shader *shader);

2729 18 is_shader_prepared 0 4 3105 43 PreparedGraphicsObjects::is_shader_prepared 0 1 1255 331
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_shader_prepared
//       Access: Public
//  Description: Returns true if the shader has been prepared on
//               this GSG, false otherwise.
////////////////////////////////////////////////////////////////////
77
bool PreparedGraphicsObjects::is_shader_prepared(Shader const *shader) const;

2730 14 release_shader 0 4 3105 39 PreparedGraphicsObjects::release_shader 0 1 1256 816
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_shader
//       Access: Public
//  Description: Indicates that a shader context, created by a
//               previous call to prepare_shader(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release shaders--this
//               prevents conflicts from threading or multiple GSG's
//               sharing shaders (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_shader is called).
////////////////////////////////////////////////////////////////////
64
void PreparedGraphicsObjects::release_shader(ShaderContext *sc);

2731 19 release_all_shaders 0 4 3105 44 PreparedGraphicsObjects::release_all_shaders 0 1 1257 456
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_shaders
//       Access: Public
//  Description: Releases all shaders at once.  This will force them
//               to be reloaded into shader memory for all GSG's that
//               share this object.  Returns the number of shaders
//               released.
////////////////////////////////////////////////////////////////////
55
int PreparedGraphicsObjects::release_all_shaders(void);

2732 22 get_num_queued_shaders 0 4 3105 47 PreparedGraphicsObjects::get_num_queued_shaders 0 1 1258 342
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_shaders
//       Access: Public
//  Description: Returns the number of shaders that have been
//               enqueued to be prepared on this GSG.
////////////////////////////////////////////////////////////////////
64
int PreparedGraphicsObjects::get_num_queued_shaders(void) const;

2733 24 get_num_prepared_shaders 0 4 3105 49 PreparedGraphicsObjects::get_num_prepared_shaders 0 1 1259 337
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_shaders
//       Access: Public
//  Description: Returns the number of shaders that have already been
//               prepared on this GSG.
////////////////////////////////////////////////////////////////////
66
int PreparedGraphicsObjects::get_num_prepared_shaders(void) const;

2734 18 prepare_shader_now 0 4 3105 43 PreparedGraphicsObjects::prepare_shader_now 0 1 1260 1154
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_shader_now
//       Access: Public
//  Description: Immediately creates a new ShaderContext for the
//               indicated shader and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               shaders.  If this is not necessarily the case, you
//               should use enqueue_shader() instead.
//
//               Normally, this function is not called directly.  Call
//               Shader::prepare_now() instead.
//
//               The ShaderContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular shader, and will exist as long as the
//               shader is ready to be rendered.
//
//               When either the Shader or the
//               PreparedGraphicsObjects object destructs, the
//               ShaderContext will be deleted.
////////////////////////////////////////////////////////////////////
107
ShaderContext *PreparedGraphicsObjects::prepare_shader_now(Shader *shader, GraphicsStateGuardianBase *gsg);

2735 21 enqueue_vertex_buffer 0 4 3105 46 PreparedGraphicsObjects::enqueue_vertex_buffer 0 1 1261 418
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_vertex_buffer
//       Access: Public
//  Description: Indicates that a buffer would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
////////////////////////////////////////////////////////////////////
79
void PreparedGraphicsObjects::enqueue_vertex_buffer(GeomVertexArrayData *data);

2736 23 is_vertex_buffer_queued 0 4 3105 48 PreparedGraphicsObjects::is_vertex_buffer_queued 0 1 1262 341
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_vertex_buffer_queued
//       Access: Public
//  Description: Returns true if the vertex buffer has been queued on
//               this GSG, false otherwise.
////////////////////////////////////////////////////////////////////
93
bool PreparedGraphicsObjects::is_vertex_buffer_queued(GeomVertexArrayData const *data) const;

2737 21 dequeue_vertex_buffer 0 4 3105 46 PreparedGraphicsObjects::dequeue_vertex_buffer 0 1 1263 737
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_vertex_buffer
//       Access: Public
//  Description: Removes a buffer from the queued list of data
//               arrays to be prepared.  Normally it is not necessary
//               to call this, unless you change your mind about
//               preparing it at the last minute, since the data will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the buffer is
//               successfully dequeued, false if it had not been
//               queued.
////////////////////////////////////////////////////////////////////
79
bool PreparedGraphicsObjects::dequeue_vertex_buffer(GeomVertexArrayData *data);

2738 25 is_vertex_buffer_prepared 0 4 3105 50 PreparedGraphicsObjects::is_vertex_buffer_prepared 0 1 1264 345
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_vertex_buffer_prepared
//       Access: Public
//  Description: Returns true if the vertex buffer has been prepared on
//               this GSG, false otherwise.
////////////////////////////////////////////////////////////////////
95
bool PreparedGraphicsObjects::is_vertex_buffer_prepared(GeomVertexArrayData const *data) const;

2739 21 release_vertex_buffer 0 4 3105 46 PreparedGraphicsObjects::release_vertex_buffer 0 1 1265 831
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_vertex_buffer
//       Access: Public
//  Description: Indicates that a data context, created by a
//               previous call to prepare_vertex_buffer(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release datas--this
//               prevents conflicts from threading or multiple GSG's
//               sharing datas (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_vertex_buffer is called).
////////////////////////////////////////////////////////////////////
78
void PreparedGraphicsObjects::release_vertex_buffer(VertexBufferContext *vbc);

2740 26 release_all_vertex_buffers 0 4 3105 51 PreparedGraphicsObjects::release_all_vertex_buffers 0 1 1266 457
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_vertex_buffers
//       Access: Public
//  Description: Releases all datas at once.  This will force them
//               to be reloaded into data memory for all GSG's that
//               share this object.  Returns the number of datas
//               released.
////////////////////////////////////////////////////////////////////
62
int PreparedGraphicsObjects::release_all_vertex_buffers(void);

2741 29 get_num_queued_vertex_buffers 0 4 3105 54 PreparedGraphicsObjects::get_num_queued_vertex_buffers 0 1 1267 356
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_vertex_buffers
//       Access: Public
//  Description: Returns the number of vertex buffers that have been
//               enqueued to be prepared on this GSG.
////////////////////////////////////////////////////////////////////
71
int PreparedGraphicsObjects::get_num_queued_vertex_buffers(void) const;

2742 31 get_num_prepared_vertex_buffers 0 4 3105 56 PreparedGraphicsObjects::get_num_prepared_vertex_buffers 0 1 1268 351
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_vertex_buffers
//       Access: Public
//  Description: Returns the number of vertex buffers that have
//               already been prepared on this GSG.
////////////////////////////////////////////////////////////////////
73
int PreparedGraphicsObjects::get_num_prepared_vertex_buffers(void) const;

2743 25 prepare_vertex_buffer_now 0 4 3105 50 PreparedGraphicsObjects::prepare_vertex_buffer_now 0 1 1269 1174
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_vertex_buffer_now
//       Access: Public
//  Description: Immediately creates a new VertexBufferContext for the
//               indicated data and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               datas.  If this is not necessarily the case, you
//               should use enqueue_vertex_buffer() instead.
//
//               Normally, this function is not called directly.  Call
//               Data::prepare_now() instead.
//
//               The VertexBufferContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular data, and will exist as long as the
//               data is ready to be rendered.
//
//               When either the Data or the
//               PreparedGraphicsObjects object destructs, the
//               VertexBufferContext will be deleted.
////////////////////////////////////////////////////////////////////
131
VertexBufferContext *PreparedGraphicsObjects::prepare_vertex_buffer_now(GeomVertexArrayData *data, GraphicsStateGuardianBase *gsg);

2744 20 enqueue_index_buffer 0 4 3105 45 PreparedGraphicsObjects::enqueue_index_buffer 0 1 1270 417
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_index_buffer
//       Access: Public
//  Description: Indicates that a buffer would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
////////////////////////////////////////////////////////////////////
72
void PreparedGraphicsObjects::enqueue_index_buffer(GeomPrimitive *data);

2745 22 is_index_buffer_queued 0 4 3105 47 PreparedGraphicsObjects::is_index_buffer_queued 0 1 1271 339
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_index_buffer_queued
//       Access: Public
//  Description: Returns true if the index buffer has been queued on
//               this GSG, false otherwise.
////////////////////////////////////////////////////////////////////
86
bool PreparedGraphicsObjects::is_index_buffer_queued(GeomPrimitive const *data) const;

2746 20 dequeue_index_buffer 0 4 3105 45 PreparedGraphicsObjects::dequeue_index_buffer 0 1 1272 736
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_index_buffer
//       Access: Public
//  Description: Removes a buffer from the queued list of data
//               arrays to be prepared.  Normally it is not necessary
//               to call this, unless you change your mind about
//               preparing it at the last minute, since the data will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the buffer is
//               successfully dequeued, false if it had not been
//               queued.
////////////////////////////////////////////////////////////////////
72
bool PreparedGraphicsObjects::dequeue_index_buffer(GeomPrimitive *data);

2747 24 is_index_buffer_prepared 0 4 3105 49 PreparedGraphicsObjects::is_index_buffer_prepared 0 1 1273 343
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_index_buffer_prepared
//       Access: Public
//  Description: Returns true if the index buffer has been prepared on
//               this GSG, false otherwise.
////////////////////////////////////////////////////////////////////
88
bool PreparedGraphicsObjects::is_index_buffer_prepared(GeomPrimitive const *data) const;

2748 20 release_index_buffer 0 4 3105 45 PreparedGraphicsObjects::release_index_buffer 0 1 1274 828
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_index_buffer
//       Access: Public
//  Description: Indicates that a data context, created by a
//               previous call to prepare_index_buffer(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release datas--this
//               prevents conflicts from threading or multiple GSG's
//               sharing datas (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_index_buffer is called).
////////////////////////////////////////////////////////////////////
76
void PreparedGraphicsObjects::release_index_buffer(IndexBufferContext *ibc);

2749 25 release_all_index_buffers 0 4 3105 50 PreparedGraphicsObjects::release_all_index_buffers 0 1 1275 456
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_index_buffers
//       Access: Public
//  Description: Releases all datas at once.  This will force them
//               to be reloaded into data memory for all GSG's that
//               share this object.  Returns the number of datas
//               released.
////////////////////////////////////////////////////////////////////
61
int PreparedGraphicsObjects::release_all_index_buffers(void);

2750 28 get_num_queued_index_buffers 0 4 3105 53 PreparedGraphicsObjects::get_num_queued_index_buffers 0 1 1276 354
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_index_buffers
//       Access: Public
//  Description: Returns the number of index buffers that have been
//               enqueued to be prepared on this GSG.
////////////////////////////////////////////////////////////////////
70
int PreparedGraphicsObjects::get_num_queued_index_buffers(void) const;

2751 30 get_num_prepared_index_buffers 0 4 3105 55 PreparedGraphicsObjects::get_num_prepared_index_buffers 0 1 1277 349
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_index_buffers
//       Access: Public
//  Description: Returns the number of index buffers that have
//               already been prepared on this GSG.
////////////////////////////////////////////////////////////////////
72
int PreparedGraphicsObjects::get_num_prepared_index_buffers(void) const;

2752 24 prepare_index_buffer_now 0 4 3105 49 PreparedGraphicsObjects::prepare_index_buffer_now 0 1 1278 1169
////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_index_buffer_now
//       Access: Public
//  Description: Immediately creates a new IndexBufferContext for the
//               indicated data and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               datas.  If this is not necessarily the case, you
//               should use enqueue_index_buffer() instead.
//
//               Normally, this function is not called directly.  Call
//               Data::prepare_now() instead.
//
//               The IndexBufferContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular data, and will exist as long as the
//               data is ready to be rendered.
//
//               When either the Data or the
//               PreparedGraphicsObjects object destructs, the
//               IndexBufferContext will be deleted.
////////////////////////////////////////////////////////////////////
123
IndexBufferContext *PreparedGraphicsObjects::prepare_index_buffer_now(GeomPrimitive *data, GraphicsStateGuardianBase *gsg);

2753 23 upcast_to_BufferContext 0 12 3106 43 IndexBufferContext::upcast_to_BufferContext 0 1 1284 47
upcast from IndexBufferContext to BufferContext
65
BufferContext *IndexBufferContext::upcast_to_BufferContext(void);

2754 30 downcast_to_IndexBufferContext 0 12 3070 45 BufferContext::downcast_to_IndexBufferContext 0 1 1285 49
downcast from BufferContext to IndexBufferContext
72
IndexBufferContext *BufferContext::downcast_to_IndexBufferContext(void);

2755 25 upcast_to_AdaptiveLruPage 0 12 3106 45 IndexBufferContext::upcast_to_AdaptiveLruPage 0 1 1286 49
upcast from IndexBufferContext to AdaptiveLruPage
69
AdaptiveLruPage *IndexBufferContext::upcast_to_AdaptiveLruPage(void);

2756 30 downcast_to_IndexBufferContext 0 12 3026 47 AdaptiveLruPage::downcast_to_IndexBufferContext 0 1 1287 51
downcast from AdaptiveLruPage to IndexBufferContext
74
IndexBufferContext *AdaptiveLruPage::downcast_to_IndexBufferContext(void);

2757 8 get_data 0 4 3106 28 IndexBufferContext::get_data 0 1 1279 299
////////////////////////////////////////////////////////////////////
//     Function: IndexBufferContext::get_data
//       Access: Public
//  Description: Returns the pointer to the client-side array data
//               object.
////////////////////////////////////////////////////////////////////
63
inline GeomPrimitive *IndexBufferContext::get_data(void) const;

2758 12 changed_size 0 4 3106 32 IndexBufferContext::changed_size 0 1 1280 333
////////////////////////////////////////////////////////////////////
//     Function: IndexBufferContext::changed_size
//       Access: Public
//  Description: Returns true if the data has changed size since the
//               last time mark_loaded() was called.
////////////////////////////////////////////////////////////////////
94
inline bool IndexBufferContext::changed_size(GeomPrimitivePipelineReader const *reader) const;

2759 18 changed_usage_hint 0 4 3106 38 IndexBufferContext::changed_usage_hint 0 1 1281 349
////////////////////////////////////////////////////////////////////
//     Function: IndexBufferContext::changed_usage_hint
//       Access: Public
//  Description: Returns true if the data has changed its usage hint
//               since the last time mark_loaded() was called.
////////////////////////////////////////////////////////////////////
100
inline bool IndexBufferContext::changed_usage_hint(GeomPrimitivePipelineReader const *reader) const;

2760 12 was_modified 0 4 3106 32 IndexBufferContext::was_modified 0 1 1282 334
////////////////////////////////////////////////////////////////////
//     Function: IndexBufferContext::was_modified
//       Access: Public
//  Description: Returns true if the data has been modified since the
//               last time mark_loaded() was called.
////////////////////////////////////////////////////////////////////
94
inline bool IndexBufferContext::was_modified(GeomPrimitivePipelineReader const *reader) const;

2761 14 get_class_type 0 4 3106 34 IndexBufferContext::get_class_type 0 1 1283 0
59
static TypeHandle IndexBufferContext::get_class_type(void);

2762 19 ~IndexBufferContext 0 4 3106 39 IndexBufferContext::~IndexBufferContext 0 0 0
46
IndexBufferContext::~IndexBufferContext(void);

2763 9 make_copy 0 6 3107 15 Lens::make_copy 0 1 1288 0
58
virtual PointerTo< Lens > Lens::make_copy(void) const = 0;

2764 7 extrude 0 4 3107 13 Lens::extrude 0 2 1289 1290 1640
////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude
//       Access: Published
//  Description: Given a 2-d point in the range (-1,1) in both
//               dimensions, where (0,0) is the center of the
//               lens and (-1,-1) is the lower-left corner,
//               compute the corresponding vector in space that maps
//               to this point, if such a vector can be determined.
//               The vector is returned by indicating the points on
//               the near plane and far plane that both map to the
//               indicated 2-d point.
//
//               Returns true if the vector is defined, or false
//               otherwise.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude
//       Access: Published
//  Description: Given a 2-d point in the range (-1,1) in both
//               dimensions, where (0,0) is the center of the
//               lens and (-1,-1) is the lower-left corner,
//               compute the corresponding vector in space that maps
//               to this point, if such a vector can be determined.
//               The vector is returned by indicating the points on
//               the near plane and far plane that both map to the
//               indicated 2-d point.
//
//               The z coordinate of the 2-d point is ignored.
//
//               Returns true if the vector is defined, or false
//               otherwise.
////////////////////////////////////////////////////////////////////
195
inline bool Lens::extrude(LPoint2 const &point2d, LPoint3 &near_point, LPoint3 &far_point) const;
inline bool Lens::extrude(LPoint3 const &point2d, LPoint3 &near_point, LPoint3 &far_point) const;

2765 13 extrude_depth 0 4 3107 19 Lens::extrude_depth 0 1 1291 528
////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude_depth
//       Access: Published
//  Description: Uses the depth component of the 3-d result from
//               project() to compute the original point in 3-d space
//               corresponding to a particular point on the lens.
//               This exactly reverses project(), assuming the point
//               does fall legitimately within the lens.
////////////////////////////////////////////////////////////////////
80
inline bool Lens::extrude_depth(LPoint3 const &point2d, LPoint3 &point3d) const;

2766 11 extrude_vec 0 4 3107 17 Lens::extrude_vec 0 2 1292 1293 1838
////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude_vec
//       Access: Published
//  Description: Given a 2-d point in the range (-1,1) in both
//               dimensions, where (0,0) is the center of the
//               lens and (-1,-1) is the lower-left corner,
//               compute the vector that corresponds to the view
//               direction.  This will be parallel to the normal on
//               the surface (the far plane) corresponding to the lens
//               shape at this point.
//
//               See the comment block on Lens::extrude_vec_impl() for
//               a more in-depth comment on the meaning of this
//               vector.
//
//               Returns true if the vector is defined, or false
//               otherwise.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude_vec
//       Access: Published
//  Description: Given a 2-d point in the range (-1,1) in both
//               dimensions, where (0,0) is the center of the
//               lens and (-1,-1) is the lower-left corner,
//               compute the vector that corresponds to the view
//               direction.  This will be parallel to the normal on
//               the surface (the far plane) corresponding to the lens
//               shape at this point.
//
//               See the comment block on Lens::extrude_vec_impl() for
//               a more in-depth comment on the meaning of this
//               vector.
//
//               The z coordinate of the 2-d point is ignored.
//
//               Returns true if the vector is defined, or false
//               otherwise.
////////////////////////////////////////////////////////////////////
155
inline bool Lens::extrude_vec(LPoint2 const &point2d, LVector3 &vec3d) const;
inline bool Lens::extrude_vec(LPoint3 const &point2d, LVector3 &vec3d) const;

2767 7 project 0 4 3107 13 Lens::project 0 2 1294 1295 1751
////////////////////////////////////////////////////////////////////
//     Function: Lens::project
//       Access: Published
//  Description: Given a 3-d point in space, determine the 2-d point
//               this maps to, in the range (-1,1) in both dimensions,
//               where (0,0) is the center of the lens and
//               (-1,-1) is the lower-left corner.
//
//               Returns true if the 3-d point is in front of the lens
//               and within the viewing frustum (in which case point2d
//               is filled in), or false otherwise (in which case
//               point2d will be filled in with something, which may
//               or may not be meaningful).
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::project
//       Access: Published
//  Description: Given a 3-d point in space, determine the 2-d point
//               this maps to, in the range (-1,1) in both dimensions,
//               where (0,0) is the center of the lens and
//               (-1,-1) is the lower-left corner.
//
//               The z coordinate will also be set to a value in the
//               range (-1, 1), where 1 represents a point on the near
//               plane, and -1 represents a point on the far plane.
//
//               Returns true if the 3-d point is in front of the lens
//               and within the viewing frustum (in which case point2d
//               is filled in), or false otherwise (in which case
//               point2d will be filled in with something, which may
//               or may not be meaningful).
////////////////////////////////////////////////////////////////////
149
inline bool Lens::project(LPoint3 const &point3d, LPoint3 &point2d) const;
inline bool Lens::project(LPoint3 const &point3d, LPoint2 &point2d) const;

2768 16 set_change_event 0 4 3107 22 Lens::set_change_event 0 1 1296 643
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_change_event
//       Access: Published
//  Description: Sets the name of the event that will be generated
//               whenever any properties of the Lens have
//               changed.  If this is not set for a particular lens,
//               no event will be generated.
//
//               The event is thrown with one parameter, the lens
//               itself.  This can be used to automatically track
//               changes to camera fov, etc. in the application.
////////////////////////////////////////////////////////////////////
56
inline void Lens::set_change_event(string const &event);

2769 16 get_change_event 0 4 3107 22 Lens::get_change_event 0 1 1297 370
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_change_event
//       Access: Published
//  Description: Returns the name of the event that will be generated
//               whenever any properties of this particular Lens have
//               changed.
////////////////////////////////////////////////////////////////////
56
inline string const &Lens::get_change_event(void) const;

2770 21 set_coordinate_system 0 4 3107 27 Lens::set_coordinate_system 0 1 1298 385
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_coordinate_system
//       Access: Published
//  Description: Specifies the coordinate system that all 3-d
//               computations are performed within for this
//               Lens.  Normally, this is CS_default.
////////////////////////////////////////////////////////////////////
54
void Lens::set_coordinate_system(CoordinateSystem cs);

2771 21 get_coordinate_system 0 4 3107 27 Lens::get_coordinate_system 0 1 1299 383
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_coordinate_system
//       Access: Published
//  Description: Returns the coordinate system that all 3-d
//               computations are performed within for this
//               Lens.  Normally, this is CS_default.
////////////////////////////////////////////////////////////////////
64
inline CoordinateSystem Lens::get_coordinate_system(void) const;

2772 5 clear 0 4 3107 11 Lens::clear 0 1 1300 289
////////////////////////////////////////////////////////////////////
//     Function: Lens::clear
//       Access: Published
//  Description: Resets all lens parameters to their initial default
//               settings.
////////////////////////////////////////////////////////////////////
23
void Lens::clear(void);

2773 13 set_film_size 0 4 3107 19 Lens::set_film_size 0 3 1301 1302 1303 2825
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_size
//       Access: Published
//  Description: Sets the horizontal size of the film without changing
//               its shape.  The aspect ratio remains unchanged; this
//               computes the vertical size of the film to
//               automatically maintain the aspect ratio.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_size
//       Access: Published
//  Description: Sets the size and shape of the "film" within the
//               lens.  This both establishes the units used by
//               calls like set_focal_length(), and establishes the
//               aspect ratio of the frame.
//
//               In a physical camera, the field of view of a lens is
//               determined by the lens' focal length and by the size
//               of the film area exposed by the lens.  For instance,
//               a 35mm camera exposes a rectangle on the film about
//               24mm x 36mm, which means a 50mm lens gives about a
//               40-degree horizontal field of view.
//
//               In the virtual camera, you may set the film size to
//               any units here, and specify a focal length in the
//               same units to simulate the same effect.  Or, you may
//               ignore this parameter, and specify the field of view
//               and aspect ratio of the lens directly.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_size
//       Access: Published
//  Description: Sets the size and shape of the "film" within the
//               lens.  This both establishes the units used by
//               calls like set_focal_length(), and establishes the
//               aspect ratio of the frame.
//
//               In a physical camera, the field of view of a lens is
//               determined by the lens' focal length and by the size
//               of the film area exposed by the lens.  For instance,
//               a 35mm camera exposes a rectangle on the film about
//               24mm x 36mm, which means a 50mm lens gives about a
//               40-degree horizontal field of view.
//
//               In the virtual camera, you may set the film size to
//               any units here, and specify a focal length in the
//               same units to simulate the same effect.  Or, you may
//               ignore this parameter, and specify the field of view
//               and aspect ratio of the lens directly.
////////////////////////////////////////////////////////////////////
184
inline void Lens::set_film_size(PN_stdfloat width);
inline void Lens::set_film_size(PN_stdfloat width, PN_stdfloat height);
inline void Lens::set_film_size(LVecBase2 const &film_size);

2774 13 get_film_size 0 4 3107 19 Lens::get_film_size 0 1 1304 324
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_film_size
//       Access: Published
//  Description: Returns the horizontal and vertical film size of
//               the virtual film.  See set_film_size().
////////////////////////////////////////////////////////////////////
56
inline LVecBase2 const &Lens::get_film_size(void) const;

2775 15 set_film_offset 0 4 3107 21 Lens::set_film_offset 0 2 1305 1306 898
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_offset
//       Access: Published
//  Description: Sets the horizontal and vertical offset amounts of
//               this Lens.  These are both in the same units
//               specified in set_film_size().
//
//               This can be used to establish an off-axis lens.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_offset
//       Access: Published
//  Description: Sets the horizontal and vertical offset amounts of
//               this Lens.  These are both in the same units
//               specified in set_film_size().
//
//               This can be used to establish an off-axis lens.
////////////////////////////////////////////////////////////////////
129
inline void Lens::set_film_offset(PN_stdfloat x, PN_stdfloat y);
inline void Lens::set_film_offset(LVecBase2 const &film_offset);

2776 15 get_film_offset 0 4 3107 21 Lens::get_film_offset 0 1 1307 326
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_film_offset
//       Access: Published
//  Description: Returns the horizontal and vertical offset amounts of
//               this Lens.  See set_film_offset().
////////////////////////////////////////////////////////////////////
57
inline LVector2 const &Lens::get_film_offset(void) const;

2777 16 set_focal_length 0 4 3107 22 Lens::set_focal_length 0 1 1308 515
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_focal_length
//       Access: Published
//  Description: Sets the focal length of the lens.  This may adjust
//               the field-of-view correspondingly, and is an
//               alternate way to specify field of view.
//
//               For certain kinds of lenses (e.g. OrthographicLens),
//               the focal length has no meaning.
////////////////////////////////////////////////////////////////////
61
inline void Lens::set_focal_length(PN_stdfloat focal_length);

2778 16 get_focal_length 0 4 3107 22 Lens::get_focal_length 0 1 1309 527
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_focal_length
//       Access: Published
//  Description: Returns the focal length of the lens.  This may have
//               been set explicitly by a previous call to
//               set_focal_length(), or it may be computed based on
//               the lens' fov and film_size.  For certain kinds of
//               lenses, the focal length has no meaning.
////////////////////////////////////////////////////////////////////
54
inline PN_stdfloat Lens::get_focal_length(void) const;

2779 11 set_min_fov 0 4 3107 17 Lens::set_min_fov 0 1 1310 836
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_min_fov
//       Access: Published
//  Description: Sets the field of view of the smallest dimension of
//               the window.  If the window is wider than it is tall,
//               this specifies the vertical field of view; if it is
//               taller than it is wide, this specifies the horizontal
//               field of view.
//
//               In many cases, this is preferable to setting either
//               the horizontal or vertical field of view explicitly.
//               Setting this parameter means that pulling the window
//               wider will widen the field of view, which is usually
//               what you expect to happen.
////////////////////////////////////////////////////////////////////
44
void Lens::set_min_fov(PN_stdfloat min_fov);

2780 7 set_fov 0 4 3107 13 Lens::set_fov 0 3 1311 1312 1313 1651
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_fov
//       Access: Published
//  Description: Sets the horizontal field of view of the lens without
//               changing the aspect ratio.  The vertical field of
//               view is adjusted to maintain the same aspect ratio.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::set_fov
//       Access: Published
//  Description: Sets the field of view of the lens in both
//               dimensions.  This establishes both the field of view
//               and the aspect ratio of the lens.  This is one way to
//               specify the field of view of a lens;
//               set_focal_length() is another way.
//
//               For certain kinds of lenses (like OrthoLens),
//               the field of view has no meaning.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::set_fov
//       Access: Published
//  Description: Sets the field of view of the lens in both
//               dimensions.  This establishes both the field of view
//               and the aspect ratio of the lens.  This is one way to
//               specify the field of view of a lens;
//               set_focal_length() is another way.
//
//               For certain kinds of lenses (like OrthographicLens),
//               the field of view has no meaning.
////////////////////////////////////////////////////////////////////
155
inline void Lens::set_fov(PN_stdfloat fov);
inline void Lens::set_fov(PN_stdfloat hfov, PN_stdfloat vfov);
inline void Lens::set_fov(LVecBase2 const &fov);

2781 7 get_fov 0 4 3107 13 Lens::get_fov 0 1 1314 312
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_fov
//       Access: Published
//  Description: Returns the horizontal and vertical film size of
//               the virtual film.  See set_fov().
////////////////////////////////////////////////////////////////////
50
inline LVecBase2 const &Lens::get_fov(void) const;

2782 8 get_hfov 0 4 3107 14 Lens::get_hfov 0 1 1315 292
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_hfov
//       Access: Published
//  Description: Returns the horizontal component of fov only.  See
//               get_fov().
////////////////////////////////////////////////////////////////////
46
inline PN_stdfloat Lens::get_hfov(void) const;

2783 8 get_vfov 0 4 3107 14 Lens::get_vfov 0 1 1316 290
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_vfov
//       Access: Published
//  Description: Returns the vertical component of fov only.  See
//               get_fov().
////////////////////////////////////////////////////////////////////
46
inline PN_stdfloat Lens::get_vfov(void) const;

2784 11 get_min_fov 0 4 3107 17 Lens::get_min_fov 0 1 1317 321
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_min_fov
//       Access: Published
//  Description: Returns the field of view of the narrowest dimension
//               of the window.  See set_min_fov().
////////////////////////////////////////////////////////////////////
42
PN_stdfloat Lens::get_min_fov(void) const;

2785 16 set_aspect_ratio 0 4 3107 22 Lens::set_aspect_ratio 0 1 1318 444
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_aspect_ratio
//       Access: Published
//  Description: Sets the aspect ratio of the lens.  This is the ratio
//               of the height to the width of the generated image.
//               Setting this overrides the two-parameter fov or film
//               size setting.
////////////////////////////////////////////////////////////////////
61
inline void Lens::set_aspect_ratio(PN_stdfloat aspect_ratio);

2786 16 get_aspect_ratio 0 4 3107 22 Lens::get_aspect_ratio 0 1 1319 368
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_aspect_ratio
//       Access: Published
//  Description: Returns the aspect ratio of the Lens.  This is
//               determined based on the indicated film size; see
//               set_film_size().
////////////////////////////////////////////////////////////////////
54
inline PN_stdfloat Lens::get_aspect_ratio(void) const;

2787 8 set_near 0 4 3107 14 Lens::set_near 0 1 1320 377
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_near
//       Access: Published
//  Description: Defines the position of the near plane (or cylinder,
//               sphere, whatever).  Points closer to the lens than
//               this may not be rendered.
////////////////////////////////////////////////////////////////////
54
inline void Lens::set_near(PN_stdfloat near_distance);

2788 8 get_near 0 4 3107 14 Lens::get_near 0 1 1321 302
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_near
//       Access: Published
//  Description: Returns the position of the near plane (or cylinder,
//               sphere, whatever).
////////////////////////////////////////////////////////////////////
46
inline PN_stdfloat Lens::get_near(void) const;

2789 7 set_far 0 4 3107 13 Lens::set_far 0 1 1322 378
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_far
//       Access: Published
//  Description: Defines the position of the far plane (or cylinder,
//               sphere, whatever).  Points farther from the lens than
//               this may not be rendered.
////////////////////////////////////////////////////////////////////
52
inline void Lens::set_far(PN_stdfloat far_distance);

2790 7 get_far 0 4 3107 13 Lens::get_far 0 1 1323 300
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_far
//       Access: Published
//  Description: Returns the position of the far plane (or cylinder,
//               sphere, whatever).
////////////////////////////////////////////////////////////////////
45
inline PN_stdfloat Lens::get_far(void) const;

2791 12 set_near_far 0 4 3107 18 Lens::set_near_far 0 1 1324 265
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_near_far
//       Access: Published
//  Description: Simultaneously changes the near and far planes.
////////////////////////////////////////////////////////////////////
84
inline void Lens::set_near_far(PN_stdfloat near_distance, PN_stdfloat far_distance);

2792 16 get_default_near 0 4 3107 22 Lens::get_default_near 0 1 1325 391
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_default_near
//       Access: Published, Static
//  Description: Returns the default near plane distance that will be
//               assigned to each newly-created lens.  This is read
//               from the Configrc file.
////////////////////////////////////////////////////////////////////
48
static PN_stdfloat Lens::get_default_near(void);

2793 15 get_default_far 0 4 3107 21 Lens::get_default_far 0 1 1326 389
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_default_far
//       Access: Published, Static
//  Description: Returns the default far plane distance that will be
//               assigned to each newly-created lens.  This is read
//               from the Configrc file.
////////////////////////////////////////////////////////////////////
47
static PN_stdfloat Lens::get_default_far(void);

2794 12 set_view_hpr 0 4 3107 18 Lens::set_view_hpr 0 2 1327 1328 1188
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_hpr
//       Access: Published
//  Description: Sets the direction in which the lens is facing.
//               Normally, this is down the forward axis (usually the
//               Y axis), but it may be rotated.  This is only one way
//               of specifying the rotation; you may also specify an
//               explicit vector in which to look, or you may give a
//               complete transformation matrix.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_hpr
//       Access: Published
//  Description: Sets the direction in which the lens is facing.
//               Normally, this is down the forward axis (usually the
//               Y axis), but it may be rotated.  This is only one way
//               of specifying the rotation; you may also specify an
//               explicit vector in which to look, or you may give a
//               complete transformation matrix.
////////////////////////////////////////////////////////////////////
128
inline void Lens::set_view_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);
void Lens::set_view_hpr(LVecBase3 const &view_hpr);

2795 12 get_view_hpr 0 4 3107 18 Lens::get_view_hpr 0 1 1329 268
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_view_hpr
//       Access: Published
//  Description: Returns the direction in which the lens is facing.
////////////////////////////////////////////////////////////////////
48
LVecBase3 const &Lens::get_view_hpr(void) const;

2796 15 set_view_vector 0 4 3107 21 Lens::set_view_vector 0 2 1330 1331 882
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_vector
//       Access: Published
//  Description: Specifies the direction in which the lens is facing
//               by giving an axis to look along, and a perpendicular
//               (or at least non-parallel) up axis.
//
//               See also set_view_hpr().
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_vector
//       Access: Published
//  Description: Specifies the direction in which the lens is facing
//               by giving an axis to look along, and a perpendicular
//               (or at least non-parallel) up axis.
//
//               See also set_view_hpr().
////////////////////////////////////////////////////////////////////
208
inline void Lens::set_view_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat i, PN_stdfloat j, PN_stdfloat k);
void Lens::set_view_vector(LVector3 const &view_vector, LVector3 const &up_vector);

2797 15 get_view_vector 0 4 3107 21 Lens::get_view_vector 0 1 1332 269
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_view_vector
//       Access: Published
//  Description: Returns the axis along which the lens is facing.
////////////////////////////////////////////////////////////////////
50
LVector3 const &Lens::get_view_vector(void) const;

2798 13 get_up_vector 0 4 3107 19 Lens::get_up_vector 0 1 1333 329
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_up_vector
//       Access: Published
//  Description: Returns the axis perpendicular to the camera's view
//               vector that indicates the "up" direction.
////////////////////////////////////////////////////////////////////
48
LVector3 const &Lens::get_up_vector(void) const;

2799 15 get_nodal_point 0 4 3107 21 Lens::get_nodal_point 0 1 1334 317
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_nodal_point
//       Access: Published
//  Description: Returns the center point of the lens: the point from
//               which the lens is viewing.
////////////////////////////////////////////////////////////////////
42
LPoint3 Lens::get_nodal_point(void) const;

2800 24 set_interocular_distance 0 4 3107 30 Lens::set_interocular_distance 0 1 1335 796
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_interocular_distance
//       Access: Published
//  Description: Sets the distance between the left and right eyes of
//               a stereo camera.  This distance is used to apply a
//               stereo effect when the lens is rendered on a stereo
//               display region.  It only has an effect on a
//               PerspectiveLens.
//
//               The left eye and the right eye are each offset along
//               the X axis by half of this distance, so that this
//               parameter specifies the total distance between them.
//
//               Also see set_convergence_distance(), which relates.
////////////////////////////////////////////////////////////////////
77
inline void Lens::set_interocular_distance(PN_stdfloat interocular_distance);

2801 24 get_interocular_distance 0 4 3107 30 Lens::get_interocular_distance 0 1 1336 261
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_interocular_distance
//       Access: Published
//  Description: See set_interocular_distance().
////////////////////////////////////////////////////////////////////
62
inline PN_stdfloat Lens::get_interocular_distance(void) const;

2802 24 set_convergence_distance 0 4 3107 30 Lens::set_convergence_distance 0 1 1337 1921
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_convergence_distance
//       Access: Published
//  Description: Sets the distance between between the camera plane
//               and the point in the distance that the left and right
//               eyes are both looking at.  This distance is used to
//               apply a stereo effect when the lens is rendered on a
//               stereo display region.  It only has an effect on a
//               PerspectiveLens.
//
//               This parameter must be greater than 0, but may be as
//               large as you like.  It controls the distance at
//               which the two stereo images will appear to converge,
//               which is a normal property of stereo vision.  Normally
//               this should be set to the distance from the camera to
//               the area of interest in your scene.  Anything beyond
//               this distance will appear to go into the screen, and
//               anything closer will appear to come out of the screen.
//               If you want to simulate parallel stereo, set this
//               to infinity.
//
//               Note that this creates an off-axis frustum, which
//               means that the lenses are still pointing in the
//               same direction, which is usually more desirable
//               than the more naive toe-in approach, where the
//               two lenses are simply tilted toward each other.
//
//               Prior to Panda3D 1.9.0, the convergence was being
//               calculated incorrectly.  It has since been corrected.
//               To restore the legacy behavior you can set the
//               stereo-lens-old-convergence variable to true.
//
//               Also see set_interocular_distance(), which relates.
////////////////////////////////////////////////////////////////////
77
inline void Lens::set_convergence_distance(PN_stdfloat convergence_distance);

2803 24 get_convergence_distance 0 4 3107 30 Lens::get_convergence_distance 0 1 1338 261
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_convergence_distance
//       Access: Published
//  Description: See set_convergence_distance().
////////////////////////////////////////////////////////////////////
62
inline PN_stdfloat Lens::get_convergence_distance(void) const;

2804 12 set_view_mat 0 4 3107 18 Lens::set_view_mat 0 1 1339 831
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_mat
//       Access: Published
//  Description: Sets an arbitrary transformation on the lens.  This
//               replaces the individual transformation components
//               like set_view_hpr().
//
//               Setting a transformation here will have a slightly
//               different effect than putting one on the LensNode
//               that contains this lens.  In particular, lighting and
//               other effects computations will still be performed on
//               the lens in its untransformed (facing forward)
//               position, but the actual projection matrix will be
//               transformed by this matrix.
////////////////////////////////////////////////////////////////////
57
inline void Lens::set_view_mat(LMatrix4 const &view_mat);

2805 12 get_view_mat 0 4 3107 18 Lens::get_view_mat 0 1 1340 268
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_view_mat
//       Access: Published
//  Description: Returns the direction in which the lens is facing.
////////////////////////////////////////////////////////////////////
54
inline LMatrix4 const &Lens::get_view_mat(void) const;

2806 14 clear_view_mat 0 4 3107 20 Lens::clear_view_mat 0 1 1341 258
////////////////////////////////////////////////////////////////////
//     Function: Lens::clear_view_mat
//       Access: Published
//  Description: Resets the lens transform to identity.
////////////////////////////////////////////////////////////////////
32
void Lens::clear_view_mat(void);

2807 12 set_keystone 0 4 3107 18 Lens::set_keystone 0 1 1342 989
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_keystone
//       Access: Published
//  Description: Indicates the ratio of keystone correction to perform
//               on the lens, in each of three axes.  This will build
//               a special non-affine scale factor into the projection
//               matrix that will compensate for keystoning of a
//               projected image; this can be used to compensate for a
//               projector that for physical reasons cannot be aimed
//               directly at its screen.  
//
//               The default value is taken from the default-keystone
//               Config variable.  0, 0 indicates no keystone
//               correction; specify a small value (usually in the
//               range -1 .. 1) in either the x or y position to
//               generate a keystone correction in that axis.
////////////////////////////////////////////////////////////////////
51
void Lens::set_keystone(LVecBase2 const &keystone);

2808 12 get_keystone 0 4 3107 18 Lens::get_keystone 0 1 1343 290
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_keystone
//       Access: Published
//  Description: Returns the keystone correction specified for the
//               lens.
////////////////////////////////////////////////////////////////////
55
inline LVecBase2 const &Lens::get_keystone(void) const;

2809 14 clear_keystone 0 4 3107 20 Lens::clear_keystone 0 1 1344 258
////////////////////////////////////////////////////////////////////
//     Function: Lens::clear_keystone
//       Access: Published
//  Description: Disables the lens keystone correction.
////////////////////////////////////////////////////////////////////
32
void Lens::clear_keystone(void);

2810 19 set_custom_film_mat 0 4 3107 25 Lens::set_custom_film_mat 0 1 1345 743
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_custom_film_mat
//       Access: Published
//  Description: Specifies a custom matrix to transform the points on
//               the film after they have been converted into nominal
//               film space (-1 .. 1 in U and V).  This can be used to
//               introduce arbitrary scales, rotations, or other
//               linear transforms to the media plane.  This is
//               normally a 2-d matrix, but a full 4x4 matrix may be
//               specified.  This is applied on top of any film size,
//               lens shift, and/or keystone correction.
////////////////////////////////////////////////////////////////////
64
void Lens::set_custom_film_mat(LMatrix4 const &custom_film_mat);

2811 19 get_custom_film_mat 0 4 3107 25 Lens::get_custom_film_mat 0 1 1346 293
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_custom_film_mat
//       Access: Published
//  Description: Returns the custom_film_mat specified for the
//               lens.
////////////////////////////////////////////////////////////////////
61
inline LMatrix4 const &Lens::get_custom_film_mat(void) const;

2812 21 clear_custom_film_mat 0 4 3107 27 Lens::clear_custom_film_mat 0 1 1347 272
////////////////////////////////////////////////////////////////////
//     Function: Lens::clear_custom_film_mat
//       Access: Published
//  Description: Disables the lens custom_film_mat correction.
////////////////////////////////////////////////////////////////////
39
void Lens::clear_custom_film_mat(void);

2813 24 set_frustum_from_corners 0 4 3107 30 Lens::set_frustum_from_corners 0 1 1348 3080
////////////////////////////////////////////////////////////////////
//     Function: Lens::set_frustum_from_corners
//       Access: Published
//  Description: Sets up the lens to use the frustum defined by the
//               four indicated points.  This is most useful for a
//               PerspectiveLens, but it may be called for other kinds
//               of lenses as well.
//
//               The frustum will be rooted at the origin (or by
//               whatever translation might have been specified in a
//               previous call to set_view_mat).
//
//               It is legal for the four points not to be arranged in
//               a rectangle; if this is the case, the frustum will be
//               fitted as tightly as possible to cover all four
//               points.
//
//               The flags parameter contains the union of one or more
//               of the following bits to control the behavior of this
//               function:
//
//               FC_roll - If this is included, the camera may be
//               rotated so that its up vector is perpendicular to the
//               top line.  Otherwise, the standard up vector is used.
//
//               FC_camera_plane - This allows the camera plane to be
//               adjusted to be as nearly perpendicular to the center
//               of the frustum as possible.  Without this bit, the
//               orientation camera plane is defined by position of
//               the four points (which should all be coplanar).  With
//               this bit, the camera plane is arbitarary, and may be
//               chosen so that the four points do not themselves lie
//               in the camera plane (but the points will still be
//               within the frustum).
//
//               FC_off_axis - This allows the resulting frustum to be
//               off-axis to get the tightest possible fit.  Without
//               this bit, the viewing axis will be centered within
//               the frustum, but there may be more wasted space along
//               the edges.
//
//               FC_aspect_ratio - This allows the frustum to be
//               scaled non-proportionately in the vertical and
//               horizontal dimensions, if necessary, to get a tighter
//               fit.  Without this bit, the current aspect ratio will
//               be preserved.
//
//               FC_shear - This allows the frustum to be sheared, if
//               necessary, to get the tightest possible fit.  This
//               may result in a parallelogram-based frustum, which
//               will give a slanted appearance to the rendered image.
//               Without this bit, the frustum will be
//               rectangle-based.
//
//               In general, if 0 is passed in as the value for flags,
//               the generated frustum will be a loose fit but sane;
//               if -1 is passed in, it will be a tighter fit and
//               possibly screwy.
////////////////////////////////////////////////////////////////////
131
void Lens::set_frustum_from_corners(LVecBase3 const &ul, LVecBase3 const &ur, LVecBase3 const &ll, LVecBase3 const &lr, int flags);

2814 13 recompute_all 0 4 3107 19 Lens::recompute_all 0 1 1349 405
////////////////////////////////////////////////////////////////////
//     Function: Lens::recompute_all
//       Access: Published
//  Description: Forces all internal parameters of the Lens to be
//               recomputed.  Normally, this should never need to be
//               called; it is provided only to assist in debugging.
////////////////////////////////////////////////////////////////////
31
void Lens::recompute_all(void);

2815 9 is_linear 0 6 3107 15 Lens::is_linear 0 1 1350 464
////////////////////////////////////////////////////////////////////
//     Function: Lens::is_linear
//       Access: Published, Virtual
//  Description: Returns true if the lens represents a linear
//               projection (e.g. PerspectiveLens, OrthographicLens),
//               and therefore there is a valid matrix returned by
//               get_projection_mat(), or false otherwise.
////////////////////////////////////////////////////////////////////
41
virtual bool Lens::is_linear(void) const;

2816 14 is_perspective 0 6 3107 20 Lens::is_perspective 0 1 1351 372
////////////////////////////////////////////////////////////////////
//     Function: Lens::is_perspective
//       Access: Published, Virtual
//  Description: Returns true if the lens represents a perspective
//               projection (i.e. it is a PerspectiveLens), false
//               otherwise.
////////////////////////////////////////////////////////////////////
46
virtual bool Lens::is_perspective(void) const;

2817 15 is_orthographic 0 6 3107 21 Lens::is_orthographic 0 1 1352 375
////////////////////////////////////////////////////////////////////
//     Function: Lens::is_orthographic
//       Access: Published, Virtual
//  Description: Returns true if the lens represents a orthographic
//               projection (i.e. it is a OrthographicLens), false
//               otherwise.
////////////////////////////////////////////////////////////////////
47
virtual bool Lens::is_orthographic(void) const;

2818 13 make_geometry 0 6 3107 19 Lens::make_geometry 0 1 1353 515
////////////////////////////////////////////////////////////////////
//     Function: Lens::make_geometry
//       Access: Published, Virtual
//  Description: Allocates and returns a new Geom that can be rendered
//               to show a visible representation of the frustum used
//               for this kind of lens, if it makes sense to do
//               so.  If a visible representation cannot be created,
//               returns NULL.
////////////////////////////////////////////////////////////////////
52
virtual PointerTo< Geom > Lens::make_geometry(void);

2819 11 make_bounds 0 6 3107 17 Lens::make_bounds 0 1 1354 450
////////////////////////////////////////////////////////////////////
//     Function: Lens::make_bounds
//       Access: Published, Virtual
//  Description: Allocates and returns a new BoundingVolume that
//               encloses the frustum used for this kind of
//               lens, if possible.  If a suitable bounding
//               volume cannot be created, returns NULL.
////////////////////////////////////////////////////////////////////
66
virtual PointerTo< BoundingVolume > Lens::make_bounds(void) const;

2820 18 get_projection_mat 0 4 3107 24 Lens::get_projection_mat 0 1 1355 441
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_projection_mat
//       Access: Published
//  Description: Returns the complete transformation matrix from a 3-d
//               point in space to a point on the film, if such a
//               matrix exists, or the identity matrix if the lens is
//               nonlinear.
////////////////////////////////////////////////////////////////////
101
inline LMatrix4 const &Lens::get_projection_mat(Lens::StereoChannel channel = ::Lens::SC_mono) const;

2821 22 get_projection_mat_inv 0 4 3107 28 Lens::get_projection_mat_inv 0 1 1356 376
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_projection_mat_inv
//       Access: Published
//  Description: Returns the matrix that transforms from a 2-d point
//               on the film to a 3-d vector in space, if such a
//               matrix exists.
////////////////////////////////////////////////////////////////////
105
inline LMatrix4 const &Lens::get_projection_mat_inv(Lens::StereoChannel channel = ::Lens::SC_mono) const;

2822 12 get_film_mat 0 4 3107 18 Lens::get_film_mat 0 1 1357 322
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_film_mat
//       Access: Published
//  Description: Returns the matrix that transforms from a point
//               behind the lens to a point on the film.
////////////////////////////////////////////////////////////////////
54
inline LMatrix4 const &Lens::get_film_mat(void) const;

2823 16 get_film_mat_inv 0 4 3107 22 Lens::get_film_mat_inv 0 1 1358 326
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_film_mat_inv
//       Access: Published
//  Description: Returns the matrix that transforms from a point on
//               the film to a point behind the lens.
////////////////////////////////////////////////////////////////////
58
inline LMatrix4 const &Lens::get_film_mat_inv(void) const;

2824 12 get_lens_mat 0 4 3107 18 Lens::get_lens_mat 0 1 1359 324
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_lens_mat
//       Access: Published
//  Description: Returns the matrix that transforms from a point
//               in front of the lens to a point in space.
////////////////////////////////////////////////////////////////////
54
inline LMatrix4 const &Lens::get_lens_mat(void) const;

2825 16 get_lens_mat_inv 0 4 3107 22 Lens::get_lens_mat_inv 0 1 1360 328
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_lens_mat_inv
//       Access: Published
//  Description: Returns the matrix that transforms from a point in
//               space to a point in front of the lens.
////////////////////////////////////////////////////////////////////
58
inline LMatrix4 const &Lens::get_lens_mat_inv(void) const;

2826 6 output 0 6 3107 12 Lens::output 0 1 1361 221
////////////////////////////////////////////////////////////////////
//     Function: Lens::output
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
46
virtual void Lens::output(ostream &out) const;

2827 5 write 0 6 3107 11 Lens::write 0 1 1362 220
////////////////////////////////////////////////////////////////////
//     Function: Lens::write
//       Access: Published, Virtual
//  Description: 
////////////////////////////////////////////////////////////////////
67
virtual void Lens::write(ostream &out, int indent_level = 0) const;

2828 15 get_last_change 0 4 3107 21 Lens::get_last_change 0 1 1363 447
////////////////////////////////////////////////////////////////////
//     Function: Lens::get_last_change
//       Access: Published
//  Description: Returns the UpdateSeq that is incremented whenever
//               the lens properties are changed.  As long as this
//               number remains the same, you may assume the lens
//               properties are unchanged.
////////////////////////////////////////////////////////////////////
51
inline UpdateSeq Lens::get_last_change(void) const;

2829 14 get_class_type 0 4 3107 20 Lens::get_class_type 0 1 1364 0
45
static TypeHandle Lens::get_class_type(void);

2830 5 ~Lens 0 4 3107 11 Lens::~Lens 0 0 0
18
Lens::~Lens(void);

2831 37 upcast_to_TypedWritableReferenceCount 0 12 3110 47 Material::upcast_to_TypedWritableReferenceCount 0 1 1400 51
upcast from Material to TypedWritableReferenceCount
83
TypedWritableReferenceCount *Material::upcast_to_TypedWritableReferenceCount(void);

2832 20 downcast_to_Material 0 12 3039 49 TypedWritableReferenceCount::downcast_to_Material 0 1 1401 53
downcast from TypedWritableReferenceCount to Material
66
Material *TypedWritableReferenceCount::downcast_to_Material(void);

2833 17 upcast_to_Namable 0 12 3110 27 Material::upcast_to_Namable 0 1 1402 31
upcast from Material to Namable
43
Namable *Material::upcast_to_Namable(void);

2834 20 downcast_to_Material 0 12 3025 29 Namable::downcast_to_Material 0 1 1403 33
downcast from Namable to Material
46
Material *Namable::downcast_to_Material(void);

2835 8 Material 0 4 3110 18 Material::Material 0 2 1365 1366 447
////////////////////////////////////////////////////////////////////
//     Function: Material::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: Material::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
109
inline explicit Material::Material(string const &name = "");
inline Material::Material(Material const &copy);

2836 10 operator = 0 4 3110 20 Material::operator = 0 1 1367 0
48
void Material::operator =(Material const &copy);

2837 9 ~Material 0 6 3110 19 Material::~Material 0 0 219
////////////////////////////////////////////////////////////////////
//     Function: Material::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
41
virtual inline Material::~Material(void);

2838 11 get_default 0 4 3110 21 Material::get_default 0 1 1368 258
////////////////////////////////////////////////////////////////////
//     Function: Material::get_default
//       Access: Published, Static
//  Description: Returns the default material.
////////////////////////////////////////////////////////////////////
52
static inline Material *Material::get_default(void);

2839 11 has_ambient 0 4 3110 21 Material::has_ambient 0 1 1369 331
////////////////////////////////////////////////////////////////////
//     Function: Material::has_ambient
//       Access: Published
//  Description: Returns true if the ambient color has been explicitly
//               set for this material, false otherwise.
////////////////////////////////////////////////////////////////////
46
inline bool Material::has_ambient(void) const;

2840 11 get_ambient 0 4 3110 21 Material::get_ambient 0 1 1370 367
////////////////////////////////////////////////////////////////////
//     Function: Material::get_ambient
//       Access: Published
//  Description: Returns the ambient color setting, if it has been
//               set.  Returns (0,0,0,0) if the ambient color has not
//               been set.
////////////////////////////////////////////////////////////////////
55
inline LColor const &Material::get_ambient(void) const;

2841 11 set_ambient 0 4 3110 21 Material::set_ambient 0 1 1371 592
////////////////////////////////////////////////////////////////////
//     Function: Material::set_ambient
//       Access: Published
//  Description: Specifies the ambient color setting of the material.
//               This will be the multiplied by any ambient lights in
//               effect on the material to set its base color.
//
//               This is the color of the object as it appears in the
//               absence of direct light.
//
//               If this is not set, the object color will be used.
////////////////////////////////////////////////////////////////////
48
void Material::set_ambient(LColor const &color);

2842 13 clear_ambient 0 4 3110 23 Material::clear_ambient 0 1 1372 276
////////////////////////////////////////////////////////////////////
//     Function: Material::clear_ambient
//       Access: Published
//  Description: Removes the explicit ambient color from the material.
////////////////////////////////////////////////////////////////////
42
inline void Material::clear_ambient(void);

2843 11 has_diffuse 0 4 3110 21 Material::has_diffuse 0 1 1373 331
////////////////////////////////////////////////////////////////////
//     Function: Material::has_diffuse
//       Access: Published
//  Description: Returns true if the diffuse color has been explicitly
//               set for this material, false otherwise.
////////////////////////////////////////////////////////////////////
46
inline bool Material::has_diffuse(void) const;

2844 11 get_diffuse 0 4 3110 21 Material::get_diffuse 0 1 1374 367
////////////////////////////////////////////////////////////////////
//     Function: Material::get_diffuse
//       Access: Published
//  Description: Returns the diffuse color setting, if it has been
//               set.  Returns (1,1,1,1) if the diffuse color has not
//               been set.
////////////////////////////////////////////////////////////////////
55
inline LColor const &Material::get_diffuse(void) const;

2845 11 set_diffuse 0 4 3110 21 Material::set_diffuse 0 1 1375 709
////////////////////////////////////////////////////////////////////
//     Function: Material::set_diffuse
//       Access: Published
//  Description: Specifies the diffuse color setting of the material.
//               This will be multiplied by any lights in effect on
//               the material to get the color in the parts of the
//               object illuminated by the lights.
//
//               This is the primary color of an object; the color of
//               the object as it appears in direct light, in the
//               absence of highlights.
//
//               If this is not set, the object color will be used.
////////////////////////////////////////////////////////////////////
48
void Material::set_diffuse(LColor const &color);

2846 13 clear_diffuse 0 4 3110 23 Material::clear_diffuse 0 1 1376 276
////////////////////////////////////////////////////////////////////
//     Function: Material::clear_diffuse
//       Access: Published
//  Description: Removes the explicit diffuse color from the material.
////////////////////////////////////////////////////////////////////
42
inline void Material::clear_diffuse(void);

2847 12 has_specular 0 4 3110 22 Material::has_specular 0 1 1377 333
////////////////////////////////////////////////////////////////////
//     Function: Material::has_specular
//       Access: Published
//  Description: Returns true if the specular color has been explicitly
//               set for this material, false otherwise.
////////////////////////////////////////////////////////////////////
47
inline bool Material::has_specular(void) const;

2848 12 get_specular 0 4 3110 22 Material::get_specular 0 1 1378 370
////////////////////////////////////////////////////////////////////
//     Function: Material::get_specular
//       Access: Published
//  Description: Returns the specular color setting, if it has been
//               set.  Returns (0,0,0,0) if the specular color has not
//               been set.
////////////////////////////////////////////////////////////////////
56
inline LColor const &Material::get_specular(void) const;

2849 12 set_specular 0 4 3110 22 Material::set_specular 0 1 1379 637
////////////////////////////////////////////////////////////////////
//     Function: Material::set_specular
//       Access: Published
//  Description: Specifies the diffuse color setting of the material.
//               This will be multiplied by any lights in effect on
//               the material to compute the color of specular
//               highlights on the object.
//
//               This is the highlight color of an object: the color
//               of small highlight reflections.
//
//               If this is not set, highlights will not appear.
////////////////////////////////////////////////////////////////////
49
void Material::set_specular(LColor const &color);

2850 14 clear_specular 0 4 3110 24 Material::clear_specular 0 1 1380 278
////////////////////////////////////////////////////////////////////
//     Function: Material::clear_specular
//       Access: Published
//  Description: Removes the explicit specular color from the material.
////////////////////////////////////////////////////////////////////
43
inline void Material::clear_specular(void);

2851 12 has_emission 0 4 3110 22 Material::has_emission 0 1 1381 333
////////////////////////////////////////////////////////////////////
//     Function: Material::has_emission
//       Access: Published
//  Description: Returns true if the emission color has been explicitly
//               set for this material, false otherwise.
////////////////////////////////////////////////////////////////////
47
inline bool Material::has_emission(void) const;

2852 12 get_emission 0 4 3110 22 Material::get_emission 0 1 1382 370
////////////////////////////////////////////////////////////////////
//     Function: Material::get_emission
//       Access: Published
//  Description: Returns the emission color setting, if it has been
//               set.  Returns (0,0,0,0) if the emission color has not
//               been set.
////////////////////////////////////////////////////////////////////
56
inline LColor const &Material::get_emission(void) const;

2853 12 set_emission 0 4 3110 22 Material::set_emission 0 1 1383 768
////////////////////////////////////////////////////////////////////
//     Function: Material::set_emission
//       Access: Published
//  Description: Specifies the emission color setting of the material.
//               This is the color of the object as it appears in the
//               absence of any light whatsover, including ambient
//               light.  It is as if the object is glowing by this
//               color (although of course it will not illuminate
//               neighboring objects).
//
//               If this is not set, the object will not glow by its
//               own light and will only appear visible in the
//               presence of one or more lights.
////////////////////////////////////////////////////////////////////
49
void Material::set_emission(LColor const &color);

2854 14 clear_emission 0 4 3110 24 Material::clear_emission 0 1 1384 278
////////////////////////////////////////////////////////////////////
//     Function: Material::clear_emission
//       Access: Published
//  Description: Removes the explicit emission color from the material.
////////////////////////////////////////////////////////////////////
43
inline void Material::clear_emission(void);

2855 13 get_shininess 0 4 3110 23 Material::get_shininess 0 1 1385 270
////////////////////////////////////////////////////////////////////
//     Function: Material::get_shininess
//       Access: Published
//  Description: Returns the shininess exponent of the material.
////////////////////////////////////////////////////////////////////
55
inline PN_stdfloat Material::get_shininess(void) const;

2856 13 set_shininess 0 4 3110 23 Material::set_shininess 0 1 1386 598
////////////////////////////////////////////////////////////////////
//     Function: Material::set_shininess
//       Access: Published
//  Description: Sets the shininess exponent of the material.  This
//               controls the size of the specular highlight spot.  In
//               general, larger number produce a smaller specular
//               highlight, which makes the object appear shinier.
//               Smaller numbers produce a larger highlight, which
//               makes the object appear less shiny.
////////////////////////////////////////////////////////////////////
59
inline void Material::set_shininess(PN_stdfloat shininess);

2857 9 get_local 0 4 3110 19 Material::get_local 0 1 1387 267
////////////////////////////////////////////////////////////////////
//     Function: Material::get_local
//       Access: Published
//  Description: Returns the local viewer flag.  Set set_local().
////////////////////////////////////////////////////////////////////
44
inline bool Material::get_local(void) const;

2858 9 set_local 0 4 3110 19 Material::set_local 0 1 1388 519
////////////////////////////////////////////////////////////////////
//     Function: Material::set_local
//       Access: Published
//  Description: Sets the local viewer flag.  Set this true to enable
//               camera-relative specular highlights, or false to use
//               orthogonal specular highlights.  The default value is
//               true.  Applications that use orthogonal projection
//               should specify false.
////////////////////////////////////////////////////////////////////
44
inline void Material::set_local(bool local);

2859 11 get_twoside 0 4 3110 21 Material::get_twoside 0 1 1389 306
////////////////////////////////////////////////////////////////////
//     Function: Material::get_twoside
//       Access: Published
//  Description: Returns the state of the two-sided lighting flag.
//               See set_twoside().
////////////////////////////////////////////////////////////////////
46
inline bool Material::get_twoside(void) const;

2860 11 set_twoside 0 4 3110 21 Material::set_twoside 0 1 1390 513
////////////////////////////////////////////////////////////////////
//     Function: Material::set_twoside
//       Access: Published
//  Description: Set this true to enable two-sided lighting.  When
//               two-sided lighting is on, both sides of a polygon
//               will be lit by this material.  The default is for
//               two-sided lighting to be off, in which case only the
//               front surface is lit.
////////////////////////////////////////////////////////////////////
48
inline void Material::set_twoside(bool twoside);

2861 11 operator == 0 4 3110 21 Material::operator == 0 1 1391 0
63
inline bool Material::operator ==(Material const &other) const;

2862 11 operator != 0 4 3110 21 Material::operator != 0 1 1392 0
63
inline bool Material::operator !=(Material const &other) const;

2863 10 operator < 0 4 3110 20 Material::operator < 0 1 1393 0
62
inline bool Material::operator <(Material const &other) const;

2864 10 compare_to 0 4 3110 20 Material::compare_to 0 1 1394 535
////////////////////////////////////////////////////////////////////
//     Function: Material::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this material
//               sorts before the other one, greater than zero if it
//               sorts after, or zero if they are equivalent.  The
//               sorting order is arbitrary and largely meaningless,
//               except to differentiate different materials.
////////////////////////////////////////////////////////////////////
54
int Material::compare_to(Material const &other) const;

2865 6 output 0 4 3110 16 Material::output 0 1 1395 215
////////////////////////////////////////////////////////////////////
//     Function: Material::output
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
42
void Material::output(ostream &out) const;

2866 5 write 0 4 3110 15 Material::write 0 1 1396 214
////////////////////////////////////////////////////////////////////
//     Function: Material::write
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
53
void Material::write(ostream &out, int indent) const;

2867 16 is_attrib_locked 0 4 3110 26 Material::is_attrib_locked 0 1 1397 225
////////////////////////////////////////////////////////////////////
//     Function: Material::is_attrib_locked
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
51
inline bool Material::is_attrib_locked(void) const;

2868 15 set_attrib_lock 0 4 3110 25 Material::set_attrib_lock 0 1 1398 224
////////////////////////////////////////////////////////////////////
//     Function: Material::set_attrib_lock
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
44
inline void Material::set_attrib_lock(void);

2869 14 get_class_type 0 4 3110 24 Material::get_class_type 0 1 1399 0
49
static TypeHandle Material::get_class_type(void);

2870 12 get_material 0 4 3111 26 MaterialPool::get_material 0 1 1404 1050
////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::get_material
//       Access: Public, Static
//  Description: Returns a Material pointer that represents the
//               same material described by temp, except that it is a
//               shared pointer.
//
//               Each call to get_material() passing an equivalent
//               Material pointer will return the same shared pointer.
//
//               If you modify the shared pointer, it will
//               automatically disassociate it from the pool.
//
//               Also, the return value may be a different pointer
//               than that passed in, or it may be the same pointer.
//               In either case, the passed in pointer has now been
//               sacrificed to the greater good and should not be used
//               again (like any other PointerTo, it will be freed
//               when the last reference count is removed).
////////////////////////////////////////////////////////////////////
67
static inline Material *MaterialPool::get_material(Material *temp);

2871 16 release_material 0 4 3111 30 MaterialPool::release_material 0 1 1405 283
////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::release_material
//       Access: Published, Static
//  Description: Removes the indicated material from the pool.
////////////////////////////////////////////////////////////////////
66
static inline void MaterialPool::release_material(Material *temp);

2872 21 release_all_materials 0 4 3111 35 MaterialPool::release_all_materials 0 1 1406 336
////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::release_all_materials
//       Access: Published, Static
//  Description: Releases all materials in the pool and restores the
//               pool to the empty state.
////////////////////////////////////////////////////////////////////
61
static inline void MaterialPool::release_all_materials(void);

2873 15 garbage_collect 0 4 3111 29 MaterialPool::garbage_collect 0 1 1407 481
////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::garbage_collect
//       Access: Public, Static
//  Description: Releases only those materials in the pool that have a
//               reference count of exactly 1; i.e. only those
//               materials that are not being used outside of the pool.
//               Returns the number of materials released.
////////////////////////////////////////////////////////////////////
54
static inline int MaterialPool::garbage_collect(void);

2874 13 list_contents 0 4 3111 27 MaterialPool::list_contents 0 1 1408 320
////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::list_contents
//       Access: Public, Static
//  Description: Lists the contents of the material pool to the
//               indicated output stream.
////////////////////////////////////////////////////////////////////
61
static inline void MaterialPool::list_contents(ostream &out);

2875 5 write 0 4 3111 19 MaterialPool::write 0 1 1409 315
////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::write
//       Access: Published, Static
//  Description: Lists the contents of the material pool to the
//               indicated output stream.
////////////////////////////////////////////////////////////////////
46
static void MaterialPool::write(ostream &out);

2876 13 ~MaterialPool 0 4 3111 27 MaterialPool::~MaterialPool 0 0 0
34
MaterialPool::~MaterialPool(void);

2877 10 MatrixLens 0 4 3112 22 MatrixLens::MatrixLens 0 1 1410 445
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::Copy Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
36
inline MatrixLens::MatrixLens(void);

2878 12 set_user_mat 0 4 3112 24 MatrixLens::set_user_mat 0 1 1411 938
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::set_user_mat
//       Access: Published
//  Description: Explicitly specifies the projection matrix.  This
//               matrix should convert X and Y to the range
//               [-film_size/2, film_size/2], where (-fs/2,-fs/2) is
//               the lower left corner of the screen and (fs/2, fs/2)
//               is the upper right.  Z should go to the range [-1,
//               1], where -1 is the far plane and 1 is the near
//               plane.  Note that this is a left-handed Y-up
//               coordinate system.
//
//               The default film_size for a MatrixLens is 2, so the
//               default range is [-1, 1] for both X and Y.  This is
//               consistent with the GL conventions for projection
//               matrices.
////////////////////////////////////////////////////////////////////
63
inline void MatrixLens::set_user_mat(LMatrix4 const &user_mat);

2879 12 get_user_mat 0 4 3112 24 MatrixLens::get_user_mat 0 1 1412 404
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::get_user_mat
//       Access: Published
//  Description: Returns the explicit projection matrix as set by the
//               user.  This does not include transforms on the lens
//               or film (e.g. a film offset or view hpr).
////////////////////////////////////////////////////////////////////
60
inline LMatrix4 const &MatrixLens::get_user_mat(void) const;

2880 16 set_left_eye_mat 0 4 3112 28 MatrixLens::set_left_eye_mat 0 1 1413 761
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::set_left_eye_mat
//       Access: Published
//  Description: Sets a custom projection matrix for the left eye.
//               This is only used if the lens is attached to a stereo
//               camera, in which case the left eye matrix will be
//               used to draw the scene in the left eye (but the
//               center matrix--the user_mat--will still be used to
//               cull the scene).
//
//               This matrix should not be too different from the
//               center matrix (set by set_user_mat()) or culling
//               errors may become obvious.
////////////////////////////////////////////////////////////////////
67
inline void MatrixLens::set_left_eye_mat(LMatrix4 const &user_mat);

2881 18 clear_left_eye_mat 0 4 3112 30 MatrixLens::clear_left_eye_mat 0 1 1414 380
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::clear_left_eye_mat
//       Access: Published
//  Description: Removes the custom projection matrix set for the left
//               eye, and uses the center matrix (set by set_user_mat)
//               instead.
////////////////////////////////////////////////////////////////////
49
inline void MatrixLens::clear_left_eye_mat(void);

2882 16 has_left_eye_mat 0 4 3112 28 MatrixLens::has_left_eye_mat 0 1 1415 441
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::has_left_eye_mat
//       Access: Published
//  Description: Returns true if the camera has a custom projection
//               matrix set for the left eye, or false if the center
//               matrix (set by set_user_mat) will be used for the
//               left eye.
////////////////////////////////////////////////////////////////////
53
inline bool MatrixLens::has_left_eye_mat(void) const;

2883 16 get_left_eye_mat 0 4 3112 28 MatrixLens::get_left_eye_mat 0 1 1416 396
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::get_left_eye_mat
//       Access: Published
//  Description: Returns the custom projection matrix for the left
//               eye, if any, or the center matrix if there is no
//               custom matrix set for the left eye.
////////////////////////////////////////////////////////////////////
64
inline LMatrix4 const &MatrixLens::get_left_eye_mat(void) const;

2884 17 set_right_eye_mat 0 4 3112 29 MatrixLens::set_right_eye_mat 0 1 1417 765
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::set_right_eye_mat
//       Access: Published
//  Description: Sets a custom projection matrix for the right eye.
//               This is only used if the lens is attached to a stereo
//               camera, in which case the right eye matrix will be
//               used to draw the scene in the right eye (but the
//               center matrix--the user_mat--will still be used to
//               cull the scene).
//
//               This matrix should not be too different from the
//               center matrix (set by set_user_mat()) or culling
//               errors may become obvious.
////////////////////////////////////////////////////////////////////
68
inline void MatrixLens::set_right_eye_mat(LMatrix4 const &user_mat);

2885 19 clear_right_eye_mat 0 4 3112 31 MatrixLens::clear_right_eye_mat 0 1 1418 382
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::clear_right_eye_mat
//       Access: Published
//  Description: Removes the custom projection matrix set for the right
//               eye, and uses the center matrix (set by set_user_mat)
//               instead.
////////////////////////////////////////////////////////////////////
50
inline void MatrixLens::clear_right_eye_mat(void);

2886 17 has_right_eye_mat 0 4 3112 29 MatrixLens::has_right_eye_mat 0 1 1419 444
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::has_right_eye_mat
//       Access: Published
//  Description: Returns true if the camera has a custom projection
//               matrix set for the right eye, or false if the center
//               matrix (set by set_user_mat) will be used for the
//               right eye.
////////////////////////////////////////////////////////////////////
54
inline bool MatrixLens::has_right_eye_mat(void) const;

2887 17 get_right_eye_mat 0 4 3112 29 MatrixLens::get_right_eye_mat 0 1 1420 399
////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::get_right_eye_mat
//       Access: Published
//  Description: Returns the custom projection matrix for the right
//               eye, if any, or the center matrix if there is no
//               custom matrix set for the right eye.
////////////////////////////////////////////////////////////////////
65
inline LMatrix4 const &MatrixLens::get_right_eye_mat(void) const;

2888 14 get_class_type 0 4 3112 26 MatrixLens::get_class_type 0 1 1421 0
51
static TypeHandle MatrixLens::get_class_type(void);

2889 11 ~MatrixLens 0 4 3112 23 MatrixLens::~MatrixLens 0 0 0
30
MatrixLens::~MatrixLens(void);

2890 16 OrthographicLens 0 4 3113 34 OrthographicLens::OrthographicLens 0 1 1422 457
////////////////////////////////////////////////////////////////////
//     Function: OrthographicLens::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: OrthographicLens::Copy Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
48
inline OrthographicLens::OrthographicLens(void);

2891 14 get_class_type 0 4 3113 32 OrthographicLens::get_class_type 0 1 1423 0
57
static TypeHandle OrthographicLens::get_class_type(void);

2892 17 ~OrthographicLens 0 4 3113 35 OrthographicLens::~OrthographicLens 0 0 0
42
OrthographicLens::~OrthographicLens(void);

2893 19 ParamTextureSampler 0 4 3114 40 ParamTextureSampler::ParamTextureSampler 0 1 1424 329
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureSampler::Constructor
//       Access: Published
//  Description: Creates a new ParamTextureSampler storing the given
//               texture and sampler objects.
////////////////////////////////////////////////////////////////////
91
inline ParamTextureSampler::ParamTextureSampler(Texture *tex, SamplerState const &sampler);

2894 11 get_texture 0 4 3114 32 ParamTextureSampler::get_texture 0 1 1425 278
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureSampler::get_texture
//       Access: Published
//  Description: Retrieves the texture stored in the parameter.
////////////////////////////////////////////////////////////////////
61
inline Texture *ParamTextureSampler::get_texture(void) const;

2895 11 get_sampler 0 4 3114 32 ParamTextureSampler::get_sampler 0 1 1426 284
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureSampler::get_sampler
//       Access: Published
//  Description: Retrieves the sampler state stored in the parameter.
////////////////////////////////////////////////////////////////////
72
inline SamplerState const &ParamTextureSampler::get_sampler(void) const;

2896 14 get_class_type 0 4 3114 35 ParamTextureSampler::get_class_type 0 1 1427 0
60
static TypeHandle ParamTextureSampler::get_class_type(void);

2897 20 ~ParamTextureSampler 0 4 3114 41 ParamTextureSampler::~ParamTextureSampler 0 0 0
48
ParamTextureSampler::~ParamTextureSampler(void);

2898 17 ParamTextureImage 0 4 3116 36 ParamTextureImage::ParamTextureImage 0 1 1428 334
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::Constructor
//       Access: Published
//  Description: Creates a new ParamTextureImage storing the given
//               texture and image binding parameters.
////////////////////////////////////////////////////////////////////
104
inline ParamTextureImage::ParamTextureImage(Texture *tex, bool read, bool write, int z = -1, int n = 0);

2899 11 get_texture 0 4 3116 30 ParamTextureImage::get_texture 0 1 1429 276
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::get_texture
//       Access: Published
//  Description: Retrieves the texture stored in the parameter.
////////////////////////////////////////////////////////////////////
59
inline Texture *ParamTextureImage::get_texture(void) const;

2900 15 has_read_access 0 4 3116 34 ParamTextureImage::has_read_access 0 1 1430 319
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::has_read_access
//       Access: Published
//  Description: Returns true if this image should be bound with
//               read access enabled.
////////////////////////////////////////////////////////////////////
59
inline bool ParamTextureImage::has_read_access(void) const;

2901 16 has_write_access 0 4 3116 35 ParamTextureImage::has_write_access 0 1 1431 321
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::has_write_access
//       Access: Published
//  Description: Returns true if this image should be bound with
//               write access enabled.
////////////////////////////////////////////////////////////////////
60
inline bool ParamTextureImage::has_write_access(void) const;

2902 16 get_bind_layered 0 4 3116 35 ParamTextureImage::get_bind_layered 0 1 1432 324
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::get_bind_layered
//       Access: Published
//  Description: Returns true if all layers of this image should be
//               bound simultaneously.
////////////////////////////////////////////////////////////////////
60
inline bool ParamTextureImage::get_bind_layered(void) const;

2903 14 get_bind_level 0 4 3116 33 ParamTextureImage::get_bind_level 0 1 1433 278
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::get_bind_level
//       Access: Published
//  Description: Returns the image level that should be bound.
////////////////////////////////////////////////////////////////////
57
inline int ParamTextureImage::get_bind_level(void) const;

2904 14 get_bind_layer 0 4 3116 33 ParamTextureImage::get_bind_layer 0 1 1434 351
////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::get_bind_layer
//       Access: Published
//  Description: Returns the image layer that should be bound.  This
//               is undefined if get_bind_layered() returns false.
////////////////////////////////////////////////////////////////////
57
inline int ParamTextureImage::get_bind_layer(void) const;

2905 14 get_class_type 0 4 3116 33 ParamTextureImage::get_class_type 0 1 1435 0
58
static TypeHandle ParamTextureImage::get_class_type(void);

2906 18 ~ParamTextureImage 0 4 3116 37 ParamTextureImage::~ParamTextureImage 0 0 0
44
ParamTextureImage::~ParamTextureImage(void);

2907 15 PerspectiveLens 0 4 3117 32 PerspectiveLens::PerspectiveLens 0 2 1436 1437 681
////////////////////////////////////////////////////////////////////
//     Function: PerspectiveLens::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: PerspectiveLens::Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: PerspectiveLens::Copy Constructor
//       Access: Public
//  Description:
////////////////////////////////////////////////////////////////////
123
inline PerspectiveLens::PerspectiveLens(void);
inline PerspectiveLens::PerspectiveLens(PN_stdfloat hfov, PN_stdfloat vfov);

2908 14 get_class_type 0 4 3117 31 PerspectiveLens::get_class_type 0 1 1438 0
56
static TypeHandle PerspectiveLens::get_class_type(void);

2909 16 ~PerspectiveLens 0 4 3117 33 PerspectiveLens::~PerspectiveLens 0 0 0
40
PerspectiveLens::~PerspectiveLens(void);

2910 20 TextureReloadRequest 0 4 3118 42 TextureReloadRequest::TextureReloadRequest 0 1 1439 358
////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::Constructor
//       Access: Published
//  Description: Create a new TextureReloadRequest, and add it to the loader
//               via load_async(), to begin an asynchronous load.
////////////////////////////////////////////////////////////////////
141
inline TextureReloadRequest::TextureReloadRequest(string const &name, PreparedGraphicsObjects *pgo, Texture *texture, bool allow_compressed);

2911 29 get_prepared_graphics_objects 0 4 3118 51 TextureReloadRequest::get_prepared_graphics_objects 0 1 1440 366
////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::get_prepared_graphics_objects
//       Access: Published
//  Description: Returns the PreparedGraphicsObjects object associated with
//               this asynchronous TextureReloadRequest.
////////////////////////////////////////////////////////////////////
96
inline PreparedGraphicsObjects *TextureReloadRequest::get_prepared_graphics_objects(void) const;

2912 11 get_texture 0 4 3118 33 TextureReloadRequest::get_texture 0 1 1441 332
////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::get_texture
//       Access: Published
//  Description: Returns the Texture object associated with
//               this asynchronous TextureReloadRequest.
////////////////////////////////////////////////////////////////////
62
inline Texture *TextureReloadRequest::get_texture(void) const;

2913 20 get_allow_compressed 0 4 3118 42 TextureReloadRequest::get_allow_compressed 0 1 1442 350
////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::get_allow_compressed
//       Access: Published
//  Description: Returns the "allow compressed" flag associated with
//               this asynchronous TextureReloadRequest.
////////////////////////////////////////////////////////////////////
67
inline bool TextureReloadRequest::get_allow_compressed(void) const;

2914 8 is_ready 0 4 3118 30 TextureReloadRequest::is_ready 0 1 1443 320
////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::is_ready
//       Access: Published
//  Description: Returns true if this request has completed, false if
//               it is still pending.
////////////////////////////////////////////////////////////////////
55
inline bool TextureReloadRequest::is_ready(void) const;

2915 14 get_class_type 0 4 3118 36 TextureReloadRequest::get_class_type 0 1 1444 0
61
static TypeHandle TextureReloadRequest::get_class_type(void);

2916 21 ~TextureReloadRequest 0 4 3118 43 TextureReloadRequest::~TextureReloadRequest 0 0 0
50
TextureReloadRequest::~TextureReloadRequest(void);

2917 23 upcast_to_BufferContext 0 12 3119 39 TextureContext::upcast_to_BufferContext 0 1 1455 43
upcast from TextureContext to BufferContext
61
BufferContext *TextureContext::upcast_to_BufferContext(void);

2918 26 downcast_to_TextureContext 0 12 3070 41 BufferContext::downcast_to_TextureContext 0 1 1456 45
downcast from BufferContext to TextureContext
64
TextureContext *BufferContext::downcast_to_TextureContext(void);

2919 25 upcast_to_AdaptiveLruPage 0 12 3119 41 TextureContext::upcast_to_AdaptiveLruPage 0 1 1457 45
upcast from TextureContext to AdaptiveLruPage
65
AdaptiveLruPage *TextureContext::upcast_to_AdaptiveLruPage(void);

2920 26 downcast_to_TextureContext 0 12 3026 43 AdaptiveLruPage::downcast_to_TextureContext 0 1 1458 47
downcast from AdaptiveLruPage to TextureContext
66
TextureContext *AdaptiveLruPage::downcast_to_TextureContext(void);

2921 11 get_texture 0 4 3119 27 TextureContext::get_texture 0 1 1445 294
////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_texture
//       Access: Public
//  Description: Returns the pointer to the associated Texture
//               object.
////////////////////////////////////////////////////////////////////
56
inline Texture *TextureContext::get_texture(void) const;

2922 8 get_view 0 4 3119 24 TextureContext::get_view 0 1 1446 394
////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_view
//       Access: Public
//  Description: Returns the specific view of a multiview texture this
//               context represents.  In the usual case, with a
//               non-multiview texture, this will be 0.
////////////////////////////////////////////////////////////////////
48
inline int TextureContext::get_view(void) const;

2923 12 was_modified 0 4 3119 28 TextureContext::was_modified 0 1 1447 371
////////////////////////////////////////////////////////////////////
//     Function: TextureContext::was_modified
//       Access: Public
//  Description: Returns true if the texture properties or image have
//               been modified since the last time mark_loaded() was
//               called.
////////////////////////////////////////////////////////////////////
53
inline bool TextureContext::was_modified(void) const;

2924 23 was_properties_modified 0 4 3119 39 TextureContext::was_properties_modified 0 1 1448 398
////////////////////////////////////////////////////////////////////
//     Function: TextureContext::was_properties_modified
//       Access: Public
//  Description: Returns true if the texture properties (unrelated to
//               the image) have been modified since the last time
//               mark_loaded() was called.
////////////////////////////////////////////////////////////////////
64
inline bool TextureContext::was_properties_modified(void) const;

2925 18 was_image_modified 0 4 3119 34 TextureContext::was_image_modified 0 1 1449 345
////////////////////////////////////////////////////////////////////
//     Function: TextureContext::was_image_modified
//       Access: Public
//  Description: Returns true if the texture image has been modified
//               since the last time mark_loaded() was called.
////////////////////////////////////////////////////////////////////
59
inline bool TextureContext::was_image_modified(void) const;

2926 25 was_simple_image_modified 0 4 3119 41 TextureContext::was_simple_image_modified 0 1 1450 387
////////////////////////////////////////////////////////////////////
//     Function: TextureContext::was_simple_image_modified
//       Access: Public
//  Description: Returns true if the texture's "simple" image has been
//               modified since the last time mark_simple_loaded() was
//               called.
////////////////////////////////////////////////////////////////////
66
inline bool TextureContext::was_simple_image_modified(void) const;

2927 23 get_properties_modified 0 4 3119 39 TextureContext::get_properties_modified 0 1 1451 410
////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_properties_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture properties
//               (unrelated to the image) are modified.
////////////////////////////////////////////////////////////////////
69
inline UpdateSeq TextureContext::get_properties_modified(void) const;

2928 18 get_image_modified 0 4 3119 34 TextureContext::get_image_modified 0 1 1452 406
////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_image_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture image data
//               (including mipmap levels) are modified.
////////////////////////////////////////////////////////////////////
64
inline UpdateSeq TextureContext::get_image_modified(void) const;

2929 25 get_simple_image_modified 0 4 3119 41 TextureContext::get_simple_image_modified 0 1 1453 397
////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_simple_image_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture's "simple"
//               image data is modified.
////////////////////////////////////////////////////////////////////
71
inline UpdateSeq TextureContext::get_simple_image_modified(void) const;

2930 14 get_class_type 0 4 3119 30 TextureContext::get_class_type 0 1 1454 0
55
static TypeHandle TextureContext::get_class_type(void);

2931 15 ~TextureContext 0 4 3119 31 TextureContext::~TextureContext 0 0 0
38
TextureContext::~TextureContext(void);

2932 10 get_shader 0 4 3120 25 ShaderContext::get_shader 0 1 1459 227
////////////////////////////////////////////////////////////////////
//     Function: ShaderContext::get_expansion
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
53
inline Shader *ShaderContext::get_shader(void) const;

2933 14 get_class_type 0 4 3120 29 ShaderContext::get_class_type 0 1 1460 0
54
static TypeHandle ShaderContext::get_class_type(void);

2934 14 ~ShaderContext 0 4 3120 29 ShaderContext::~ShaderContext 0 0 0
36
ShaderContext::~ShaderContext(void);

2935 16 UserVertexSlider 0 4 3121 34 UserVertexSlider::UserVertexSlider 0 2 1461 1462 460
////////////////////////////////////////////////////////////////////
//     Function: UserVertexSlider::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: UserVertexSlider::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
117
UserVertexSlider::UserVertexSlider(string const &name);
UserVertexSlider::UserVertexSlider(InternalName const *name);

2936 10 set_slider 0 4 3121 28 UserVertexSlider::set_slider 0 1 1463 262
////////////////////////////////////////////////////////////////////
//     Function: UserVertexSlider::set_slider
//       Access: Published
//  Description: Stores the indicated slider value.
////////////////////////////////////////////////////////////////////
61
inline void UserVertexSlider::set_slider(PN_stdfloat slider);

2937 14 get_class_type 0 4 3121 32 UserVertexSlider::get_class_type 0 1 1464 0
57
static TypeHandle UserVertexSlider::get_class_type(void);

2938 17 ~UserVertexSlider 0 4 3121 35 UserVertexSlider::~UserVertexSlider 0 0 0
42
UserVertexSlider::~UserVertexSlider(void);

2939 19 UserVertexTransform 0 4 3122 40 UserVertexTransform::UserVertexTransform 0 1 1465 232
////////////////////////////////////////////////////////////////////
//     Function: UserVertexTransform::Constructor
//       Access: Published
//  Description: 
////////////////////////////////////////////////////////////////////
61
UserVertexTransform::UserVertexTransform(string const &name);

2940 8 get_name 0 4 3122 29 UserVertexTransform::get_name 0 1 1466 311
////////////////////////////////////////////////////////////////////
//     Function: UserVertexTransform::get_name
//       Access: Published
//  Description: Returns the name passed to the constructor.
//               Completely arbitrary.
////////////////////////////////////////////////////////////////////
63
inline string const &UserVertexTransform::get_name(void) const;

2941 10 set_matrix 0 4 3122 31 UserVertexTransform::set_matrix 0 1 1467 259
////////////////////////////////////////////////////////////////////
//     Function: UserVertexTransform::set_matrix
//       Access: Published
//  Description: Stores the indicated matrix.
////////////////////////////////////////////////////////////////////
68
inline void UserVertexTransform::set_matrix(LMatrix4 const &matrix);

2942 14 get_class_type 0 4 3122 35 UserVertexTransform::get_class_type 0 1 1468 0
60
static TypeHandle UserVertexTransform::get_class_type(void);

2943 20 ~UserVertexTransform 0 4 3122 41 UserVertexTransform::~UserVertexTransform 0 0 0
48
UserVertexTransform::~UserVertexTransform(void);

2944 17 upcast_to_Texture 0 12 3123 31 VideoTexture::upcast_to_Texture 0 1 1473 35
upcast from VideoTexture to Texture
47
Texture *VideoTexture::upcast_to_Texture(void);

2945 24 downcast_to_VideoTexture 0 12 3092 33 Texture::downcast_to_VideoTexture 0 1 1474 37
downcast from Texture to VideoTexture
54
VideoTexture *Texture::downcast_to_VideoTexture(void);

2946 23 upcast_to_AnimInterface 0 12 3123 37 VideoTexture::upcast_to_AnimInterface 0 1 1475 41
upcast from VideoTexture to AnimInterface
59
AnimInterface *VideoTexture::upcast_to_AnimInterface(void);

2947 24 downcast_to_VideoTexture 0 12 3124 39 AnimInterface::downcast_to_VideoTexture 0 1 1476 43
downcast from AnimInterface to VideoTexture
60
VideoTexture *AnimInterface::downcast_to_VideoTexture(void);

2948 18 get_keep_ram_image 0 6 3123 32 VideoTexture::get_keep_ram_image 0 1 1469 482
////////////////////////////////////////////////////////////////////
//     Function: VideoTexture::get_keep_ram_image
//       Access: Published, Virtual
//  Description: Returns the flag that indicates whether this Texture
//               is eligible to have its main RAM copy of the texture
//               memory dumped when the texture is prepared for
//               rendering.  See set_keep_ram_image().
////////////////////////////////////////////////////////////////////
58
virtual bool VideoTexture::get_keep_ram_image(void) const;

2949 15 get_video_width 0 4 3123 29 VideoTexture::get_video_width 0 1 1470 463
////////////////////////////////////////////////////////////////////
//     Function: VideoTexture::get_video_width
//       Access: Published
//  Description: Returns the width in texels of the source video
//               stream.  This is not necessarily the width of the
//               actual texture, since the texture may have been
//               expanded to raise it to a power of 2.
////////////////////////////////////////////////////////////////////
53
inline int VideoTexture::get_video_width(void) const;

2950 16 get_video_height 0 4 3123 30 VideoTexture::get_video_height 0 1 1471 466
////////////////////////////////////////////////////////////////////
//     Function: VideoTexture::get_video_height
//       Access: Published
//  Description: Returns the height in texels of the source video
//               stream.  This is not necessarily the height of the
//               actual texture, since the texture may have been
//               expanded to raise it to a power of 2.
////////////////////////////////////////////////////////////////////
54
inline int VideoTexture::get_video_height(void) const;

2951 14 get_class_type 0 4 3123 28 VideoTexture::get_class_type 0 1 1472 0
53
static TypeHandle VideoTexture::get_class_type(void);

2952 13 ~VideoTexture 0 4 3123 27 VideoTexture::~VideoTexture 0 0 0
34
VideoTexture::~VideoTexture(void);

2953 23 upcast_to_BufferContext 0 12 3125 44 VertexBufferContext::upcast_to_BufferContext 0 1 1482 48
upcast from VertexBufferContext to BufferContext
66
BufferContext *VertexBufferContext::upcast_to_BufferContext(void);

2954 31 downcast_to_VertexBufferContext 0 12 3070 46 BufferContext::downcast_to_VertexBufferContext 0 1 1483 50
downcast from BufferContext to VertexBufferContext
74
VertexBufferContext *BufferContext::downcast_to_VertexBufferContext(void);

2955 25 upcast_to_AdaptiveLruPage 0 12 3125 46 VertexBufferContext::upcast_to_AdaptiveLruPage 0 1 1484 50
upcast from VertexBufferContext to AdaptiveLruPage
70
AdaptiveLruPage *VertexBufferContext::upcast_to_AdaptiveLruPage(void);

2956 31 downcast_to_VertexBufferContext 0 12 3026 48 AdaptiveLruPage::downcast_to_VertexBufferContext 0 1 1485 52
downcast from AdaptiveLruPage to VertexBufferContext
76
VertexBufferContext *AdaptiveLruPage::downcast_to_VertexBufferContext(void);

2957 8 get_data 0 4 3125 29 VertexBufferContext::get_data 0 1 1477 300
////////////////////////////////////////////////////////////////////
//     Function: VertexBufferContext::get_data
//       Access: Public
//  Description: Returns the pointer to the client-side array data
//               object.
////////////////////////////////////////////////////////////////////
70
inline GeomVertexArrayData *VertexBufferContext::get_data(void) const;

2958 12 changed_size 0 4 3125 33 VertexBufferContext::changed_size 0 1 1478 334
////////////////////////////////////////////////////////////////////
//     Function: VertexBufferContext::changed_size
//       Access: Public
//  Description: Returns true if the data has changed size since the
//               last time mark_loaded() was called.
////////////////////////////////////////////////////////////////////
93
inline bool VertexBufferContext::changed_size(GeomVertexArrayDataHandle const *reader) const;

2959 18 changed_usage_hint 0 4 3125 39 VertexBufferContext::changed_usage_hint 0 1 1479 350
////////////////////////////////////////////////////////////////////
//     Function: VertexBufferContext::changed_usage_hint
//       Access: Public
//  Description: Returns true if the data has changed its usage hint
//               since the last time mark_loaded() was called.
////////////////////////////////////////////////////////////////////
99
inline bool VertexBufferContext::changed_usage_hint(GeomVertexArrayDataHandle const *reader) const;

2960 12 was_modified 0 4 3125 33 VertexBufferContext::was_modified 0 1 1480 335
////////////////////////////////////////////////////////////////////
//     Function: VertexBufferContext::was_modified
//       Access: Public
//  Description: Returns true if the data has been modified since the
//               last time mark_loaded() was called.
////////////////////////////////////////////////////////////////////
93
inline bool VertexBufferContext::was_modified(GeomVertexArrayDataHandle const *reader) const;

2961 14 get_class_type 0 4 3125 35 VertexBufferContext::get_class_type 0 1 1481 0
60
static TypeHandle VertexBufferContext::get_class_type(void);

2962 20 ~VertexBufferContext 0 4 3125 41 VertexBufferContext::~VertexBufferContext 0 0 0
48
VertexBufferContext::~VertexBufferContext(void);

2963 17 TextureCollection 0 4 3126 36 TextureCollection::TextureCollection 0 3 1486 1487 1488 465
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::Copy Constructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
186
TextureCollection::TextureCollection(void);
TextureCollection::TextureCollection(TextureCollection const &copy);
TextureCollection::TextureCollection(PyObject *self, PyObject *sequence);

2964 10 operator = 0 4 3126 29 TextureCollection::operator = 0 1 1489 0
66
void TextureCollection::operator =(TextureCollection const &copy);

2965 18 ~TextureCollection 0 4 3126 37 TextureCollection::~TextureCollection 0 0 228
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::Destructor
//       Access: Published
//  Description:
////////////////////////////////////////////////////////////////////
51
inline TextureCollection::~TextureCollection(void);

2966 10 __reduce__ 0 4 3126 29 TextureCollection::__reduce__ 0 1 1490 0
62
PyObject *TextureCollection::__reduce__(PyObject *self) const;

2967 11 add_texture 0 4 3126 30 TextureCollection::add_texture 0 1 1491 267
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::add_texture
//       Access: Published
//  Description: Adds a new Texture to the collection.
////////////////////////////////////////////////////////////////////
54
void TextureCollection::add_texture(Texture *texture);

2968 14 remove_texture 0 4 3126 33 TextureCollection::remove_texture 0 1 1492 406
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::remove_texture
//       Access: Published
//  Description: Removes the indicated Texture from the collection.
//               Returns true if the texture was removed, false if it was
//               not a member of the collection.
////////////////////////////////////////////////////////////////////
57
bool TextureCollection::remove_texture(Texture *texture);

2969 17 add_textures_from 0 4 3126 36 TextureCollection::add_textures_from 0 1 1493 482
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::add_textures_from
//       Access: Published
//  Description: Adds all the Textures indicated in the other
//               collection to this texture.  The other textures are simply
//               appended to the end of the textures in this list;
//               duplicates are not automatically removed.
////////////////////////////////////////////////////////////////////
74
void TextureCollection::add_textures_from(TextureCollection const &other);

2970 20 remove_textures_from 0 4 3126 39 TextureCollection::remove_textures_from 0 1 1494 336
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::remove_textures_from
//       Access: Published
//  Description: Removes from this collection all of the Textures
//               listed in the other collection.
////////////////////////////////////////////////////////////////////
77
void TextureCollection::remove_textures_from(TextureCollection const &other);

2971 25 remove_duplicate_textures 0 4 3126 44 TextureCollection::remove_duplicate_textures 0 1 1495 473
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::remove_duplicate_textures
//       Access: Published
//  Description: Removes any duplicate entries of the same Textures
//               on this collection.  If a Texture appears multiple
//               times, the first appearance is retained; subsequent
//               appearances are removed.
////////////////////////////////////////////////////////////////////
56
void TextureCollection::remove_duplicate_textures(void);

2972 11 has_texture 0 4 3126 30 TextureCollection::has_texture 0 1 1496 329
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::has_texture
//       Access: Published
//  Description: Returns true if the indicated Texture appears in
//               this collection, false otherwise.
////////////////////////////////////////////////////////////////////
60
bool TextureCollection::has_texture(Texture *texture) const;

2973 5 clear 0 4 3126 24 TextureCollection::clear 0 1 1497 265
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::clear
//       Access: Published
//  Description: Removes all Textures from the collection.
////////////////////////////////////////////////////////////////////
36
void TextureCollection::clear(void);

2974 7 reserve 0 4 3126 26 TextureCollection::reserve 0 1 1498 403
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::reserve
//       Access: Published
//  Description: This is a hint to Panda to allocate enough memory
//               to hold the given number of NodePaths, if you know
//               ahead of time how many you will be adding.
////////////////////////////////////////////////////////////////////
44
void TextureCollection::reserve(size_t num);

2975 12 find_texture 0 4 3126 31 TextureCollection::find_texture 0 1 1499 372
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::find_texture
//       Access: Published
//  Description: Returns the texture in the collection with the
//               indicated name, if any, or NULL if no texture has
//               that name.
////////////////////////////////////////////////////////////////////
67
Texture *TextureCollection::find_texture(string const &name) const;

2976 16 get_num_textures 0 4 3126 35 TextureCollection::get_num_textures 0 1 1500 284
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::get_num_textures
//       Access: Published
//  Description: Returns the number of Textures in the collection.
////////////////////////////////////////////////////////////////////
52
int TextureCollection::get_num_textures(void) const;

2977 11 get_texture 0 4 3126 30 TextureCollection::get_texture 0 1 1501 272
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::get_texture
//       Access: Published
//  Description: Returns the nth Texture in the collection.
////////////////////////////////////////////////////////////////////
57
Texture *TextureCollection::get_texture(int index) const;

2978 11 operator [] 0 4 3126 30 TextureCollection::operator [] 0 1 1502 392
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::operator []
//       Access: Published
//  Description: Returns the nth Texture in the collection.  This is
//               the same as get_texture(), but it may be a more
//               convenient way to access it.
////////////////////////////////////////////////////////////////////
57
Texture *TextureCollection::operator [](int index) const;

2979 4 size 0 4 3126 23 TextureCollection::size 0 1 1503 336
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::size
//       Access: Published
//  Description: Returns the number of textures in the collection.  This
//               is the same thing as get_num_textures().
////////////////////////////////////////////////////////////////////
40
int TextureCollection::size(void) const;

2980 11 operator += 0 4 3126 30 TextureCollection::operator += 0 1 1504 0
75
inline void TextureCollection::operator +=(TextureCollection const &other);

2981 10 operator + 0 4 3126 29 TextureCollection::operator + 0 1 1505 0
93
inline TextureCollection TextureCollection::operator +(TextureCollection const &other) const;

2982 6 append 0 4 3126 25 TextureCollection::append 0 1 1506 450
// Method names to satisfy Python's conventions.

////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::append
//       Access: Published
//  Description: Adds a new Texture to the collection.  This method
//               duplicates the add_texture() method; it is provided to
//               satisfy Python's naming convention.
////////////////////////////////////////////////////////////////////
56
inline void TextureCollection::append(Texture *texture);

2983 6 extend 0 4 3126 25 TextureCollection::extend 0 1 1507 401
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::extend
//       Access: Published
//  Description: Appends the other list onto the end of this one.
//               This method duplicates the += operator; it is
//               provided to satisfy Python's naming convention.
////////////////////////////////////////////////////////////////////
70
inline void TextureCollection::extend(TextureCollection const &other);

2984 6 output 0 4 3126 25 TextureCollection::output 0 1 1508 334
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::output
//       Access: Published
//  Description: Writes a brief one-line description of the
//               TextureCollection to the indicated output stream.
////////////////////////////////////////////////////////////////////
51
void TextureCollection::output(ostream &out) const;

2985 5 write 0 4 3126 24 TextureCollection::write 0 1 1509 338
////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::write
//       Access: Published
//  Description: Writes a complete multi-line description of the
//               TextureCollection to the indicated output stream.
////////////////////////////////////////////////////////////////////
72
void TextureCollection::write(ostream &out, int indent_level = 0) const;

2986 11 has_texture 0 4 3127 24 TexturePool::has_texture 0 1 1510 315
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::has_texture
//       Access: Published, Static
//  Description: Returns true if the texture has ever been loaded,
//               false otherwise.
////////////////////////////////////////////////////////////////////
70
static inline bool TexturePool::has_texture(Filename const &filename);

2987 14 verify_texture 0 4 3127 27 TexturePool::verify_texture 0 1 1511 611
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::verify_texture
//       Access: Published, Static
//  Description: Loads the given filename up into a texture, if it has
//               not already been loaded, and returns true to indicate
//               success, or false to indicate failure.  If this
//               returns true, it is guaranteed that a subsequent call
//               to load_texture() with the same texture name will
//               return a valid Texture pointer.
////////////////////////////////////////////////////////////////////
73
static inline bool TexturePool::verify_texture(Filename const &filename);

2988 12 load_texture 0 4 3127 25 TexturePool::load_texture 0 2 1512 1513 1673
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_texture
//       Access: Published, Static
//  Description: Loads the given filename up into a texture, if it has
//               not already been loaded, and returns the new texture.
//               If a texture with the same filename was previously
//               loaded, returns that one instead.  If the texture
//               file cannot be found, returns NULL.
//
//               If read_mipmaps is true, the filename should contain
//               a hash mark ('#'), which will be filled in with the
//               mipmap level number; and the texture will be defined
//               with a series of images, one for each mipmap level.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_texture
//       Access: Published, Static
//  Description: Loads the given filename up into a texture, if it has
//               not already been loaded, and returns the new texture.
//               If a texture with the same filename was previously
//               loaded, returns that one instead.  If the texture
//               file cannot be found, returns NULL.
//
//               If read_mipmaps is true, both filenames should
//               contain a hash mark ('#'), which will be filled in
//               with the mipmap level number; and the texture will be
//               defined with a series of images, two for each mipmap
//               level.
////////////////////////////////////////////////////////////////////
423
static inline Texture *TexturePool::load_texture(Filename const &filename, int primary_file_num_channels = 0, bool read_mipmaps = 0, LoaderOptions const &options = LoaderOptions());
static inline Texture *TexturePool::load_texture(Filename const &filename, Filename const &alpha_filename, int primary_file_num_channels = 0, int alpha_file_channel = 0, bool read_mipmaps = 0, LoaderOptions const &options = LoaderOptions());

2989 15 load_3d_texture 0 4 3127 28 TexturePool::load_3d_texture 0 1 1514 833
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_3d_texture
//       Access: Published, Static
//  Description: Loads a 3-D texture that is specified with a series
//               of n pages, all numbered in sequence, and beginning
//               with index 0.  The filename should include a sequence
//               of one or more hash characters ("#") which will be
//               filled in with the index number of each level.
//
//               If read_mipmaps is true, the filename should contain
//               an additional hash mark.  The first hash mark will be
//               filled in with the mipmap level number, and the
//               second with the index number of each 3-d level.
////////////////////////////////////////////////////////////////////
157
static inline Texture *TexturePool::load_3d_texture(Filename const &filename_pattern, bool read_mipmaps = 0, LoaderOptions const &options = LoaderOptions());

2990 21 load_2d_texture_array 0 4 3127 34 TexturePool::load_2d_texture_array 0 1 1515 845
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_2d_texture_array
//       Access: Published, Static
//  Description: Loads a 2-D texture array that is specified with a series
//               of n pages, all numbered in sequence, and beginning
//               with index 0.  The filename should include a sequence
//               of one or more hash characters ("#") which will be
//               filled in with the index number of each level.
//
//               If read_mipmaps is true, the filename should contain
//               an additional hash mark.  The first hash mark will be
//               filled in with the mipmap level number, and the
//               second with the index number of each 2-d level.
////////////////////////////////////////////////////////////////////
163
static inline Texture *TexturePool::load_2d_texture_array(Filename const &filename_pattern, bool read_mipmaps = 0, LoaderOptions const &options = LoaderOptions());

2991 13 load_cube_map 0 4 3127 26 TexturePool::load_cube_map 0 1 1516 798
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_cube_map
//       Access: Published, Static
//  Description: Loads a cube map texture that is specified with a
//               series of 6 pages, numbered 0 through 5.  The
//               filename should include a sequence of one or more
//               hash characters ("#") which will be filled in with
//               the index number of each pagee.
//
//               If read_mipmaps is true, the filename should contain
//               an additional hash mark.  The first hash mark will be
//               filled in with the mipmap level number, and the
//               second with the face number, 0 through 5.
////////////////////////////////////////////////////////////////////
155
static inline Texture *TexturePool::load_cube_map(Filename const &filename_pattern, bool read_mipmaps = 0, LoaderOptions const &options = LoaderOptions());

2992 26 get_normalization_cube_map 0 4 3127 39 TexturePool::get_normalization_cube_map 0 1 1517 619
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::get_normalization_cube_map
//       Access: Published, Static
//  Description: Returns a standard Texture object that has been
//               created with
//               Texture::generate_normalization_cube_map().  This
//               Texture may be shared by any application code
//               requiring a normalization cube map.  It will be at
//               least as large as the specified size, though it may
//               be larger.
////////////////////////////////////////////////////////////////////
73
static inline Texture *TexturePool::get_normalization_cube_map(int size);

2993 19 get_alpha_scale_map 0 4 3127 32 TexturePool::get_alpha_scale_map 0 1 1518 598
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::get_alpha_scale_map
//       Access: Published, Static
//  Description: Returns a standard Texture object that has been
//               created with Texture::generate_alpha_scale_map().
//
//               This Texture object is used internally by Panda to
//               apply an alpha scale to an object (instead of munging
//               its vertices) when gsg->get_alpha_scale_via_texture()
//               returns true.
////////////////////////////////////////////////////////////////////
62
static inline Texture *TexturePool::get_alpha_scale_map(void);

2994 11 add_texture 0 4 3127 24 TexturePool::add_texture 0 1 1519 509
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::add_texture
//       Access: Published, Static
//  Description: Adds the indicated already-loaded texture to the
//               pool.  The texture must have a filename set for its
//               name.  The texture will always replace any
//               previously-loaded texture in the pool that had the
//               same filename.
////////////////////////////////////////////////////////////////////
62
static inline void TexturePool::add_texture(Texture *texture);

2995 15 release_texture 0 4 3127 28 TexturePool::release_texture 0 1 1520 733
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::release_texture
//       Access: Published, Static
//  Description: Removes the indicated texture from the pool,
//               indicating it will never be loaded again; the texture
//               may then be freed.  If this function is never called,
//               a reference count will be maintained on every texture
//               every loaded, and textures will never be freed.
//
//               The texture's name should not have been changed
//               during its lifetime, or this function may fail to
//               locate it in the pool.
////////////////////////////////////////////////////////////////////
66
static inline void TexturePool::release_texture(Texture *texture);

2996 20 release_all_textures 0 4 3127 33 TexturePool::release_all_textures 0 1 1521 333
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::release_all_textures
//       Access: Published, Static
//  Description: Releases all textures in the pool and restores the
//               pool to the empty state.
////////////////////////////////////////////////////////////////////
59
static inline void TexturePool::release_all_textures(void);

2997 6 rehash 0 4 3127 19 TexturePool::rehash 0 1 1522 378
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::rehash
//       Access: Published, Static
//  Description: Should be called when the model-path changes, to blow
//               away the cache of texture pathnames found along the
//               model-path.
////////////////////////////////////////////////////////////////////
45
static inline void TexturePool::rehash(void);

2998 15 garbage_collect 0 4 3127 28 TexturePool::garbage_collect 0 1 1523 480
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::garbage_collect
//       Access: Published, Static
//  Description: Releases only those textures in the pool that have a
//               reference count of exactly 1; i.e. only those
//               textures that are not being used outside of the pool.
//               Returns the number of textures released.
////////////////////////////////////////////////////////////////////
53
static inline int TexturePool::garbage_collect(void);

2999 13 list_contents 0 4 3127 26 TexturePool::list_contents 0 2 1524 1525 603
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::list_contents
//       Access: Published, Static
//  Description: Lists the contents of the texture pool to the
//               indicated output stream.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TexturePool::list_contents
//       Access: Published, Static
//  Description: Lists the contents of the texture pool to cout
////////////////////////////////////////////////////////////////////
113
static inline void TexturePool::list_contents(ostream &out);
static inline void TexturePool::list_contents(void);

3000 12 find_texture 0 4 3127 25 TexturePool::find_texture 0 1 1526 449
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::find_texture
//       Access: Published, Static
//  Description: Returns the first texture found in the pool that
//               matches the indicated name (which may contain
//               wildcards).  Returns the texture if it is found, or
//               NULL if it is not.
////////////////////////////////////////////////////////////////////
69
static inline Texture *TexturePool::find_texture(string const &name);

3001 17 find_all_textures 0 4 3127 30 TexturePool::find_all_textures 0 1 1527 382
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::find_all_textures
//       Access: Published, Static
//  Description: Returns the set of all textures found in the pool
//               that match the indicated name (which may contain
//               wildcards).
////////////////////////////////////////////////////////////////////
89
static inline TextureCollection TexturePool::find_all_textures(string const &name = "*");

3002 22 set_fake_texture_image 0 4 3127 35 TexturePool::set_fake_texture_image 0 1 1528 355
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::set_fake_texture_image
//       Access: Published, Static
//  Description: Sets a bogus filename that will be loaded in lieu of
//               any textures requested from this point on.
////////////////////////////////////////////////////////////////////
81
static inline void TexturePool::set_fake_texture_image(Filename const &filename);

3003 24 clear_fake_texture_image 0 4 3127 37 TexturePool::clear_fake_texture_image 0 1 1529 330
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::clear_fake_texture_image
//       Access: Published, Static
//  Description: Restores normal behavior of loading the textures
//               actually requested.
////////////////////////////////////////////////////////////////////
63
static inline void TexturePool::clear_fake_texture_image(void);

3004 22 has_fake_texture_image 0 4 3127 35 TexturePool::has_fake_texture_image 0 1 1530 353
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::has_fake_texture_image
//       Access: Published, Static
//  Description: Returns true if fake_texture_image mode has been
//               enabled, false if we are in the normal mode.
////////////////////////////////////////////////////////////////////
61
static inline bool TexturePool::has_fake_texture_image(void);

3005 22 get_fake_texture_image 0 4 3127 35 TexturePool::get_fake_texture_image 0 1 1531 349
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::get_fake_texture_image
//       Access: Published, Static
//  Description: Returns the filename that was specified with a
//               previous call to set_fake_texture_image().
////////////////////////////////////////////////////////////////////
72
static inline Filename const &TexturePool::get_fake_texture_image(void);

3006 12 make_texture 0 4 3127 25 TexturePool::make_texture 0 1 1532 452
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::make_texture
//       Access: Published, Static
//  Description: Creates a new Texture object of the appropriate type
//               for the indicated filename extension, according to
//               the types that have been registered via
//               register_texture_type().
////////////////////////////////////////////////////////////////////
86
static inline PointerTo< Texture > TexturePool::make_texture(string const &extension);

3007 5 write 0 4 3127 18 TexturePool::write 0 1 1533 345
////////////////////////////////////////////////////////////////////
//     Function: TexturePool::write
//       Access: Published, Static
//  Description: Lists the contents of the texture pool to the
//               indicated output stream.
//               For debugging.
////////////////////////////////////////////////////////////////////
45
static void TexturePool::write(ostream &out);

3008 12 ~TexturePool 0 4 3127 25 TexturePool::~TexturePool 0 0 0
32
TexturePool::~TexturePool(void);

3009 10 get_x_size 0 4 3128 25 TexturePeeker::get_x_size 0 1 1534 449
////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::get_x_size
//       Access: Published
//  Description: Returns the width of the texture image that is
//               contributing to the TexturePeeker's information.
//               This may be either the Texture's full width, or its
//               simple ram image's width.
////////////////////////////////////////////////////////////////////
49
inline int TexturePeeker::get_x_size(void) const;

3010 10 get_y_size 0 4 3128 25 TexturePeeker::get_y_size 0 1 1535 452
////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::get_y_size
//       Access: Published
//  Description: Returns the height of the texture image that is
//               contributing to the TexturePeeker's information.
//               This may be either the Texture's full height, or its
//               simple ram image's height.
////////////////////////////////////////////////////////////////////
49
inline int TexturePeeker::get_y_size(void) const;

3011 10 get_z_size 0 4 3128 25 TexturePeeker::get_z_size 0 1 1536 337
////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::get_z_size
//       Access: Published
//  Description: Returns the depth of the texture image that is
//               contributing to the TexturePeeker's information.
////////////////////////////////////////////////////////////////////
49
inline int TexturePeeker::get_z_size(void) const;

3012 6 lookup 0 4 3128 21 TexturePeeker::lookup 0 2 1537 1538 1223
////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::lookup
//       Access: Published
//  Description: Fills "color" with the RGBA color of the texel at
//               point (u, v).
//
//               The texel color is determined via nearest-point
//               sampling (no filtering of adjacent pixels),
//               regardless of the filter type associated with the
//               texture.  u, v, and w will wrap around regardless of
//               the texture's wrap mode.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::lookup
//       Access: Published
//  Description: Fills "color" with the RGBA color of the texel at
//               point (u, v, w).
//
//               The texel color is determined via nearest-point
//               sampling (no filtering of adjacent pixels),
//               regardless of the filter type associated with the
//               texture.  u, v, and w will wrap around regardless of
//               the texture's wrap mode.
////////////////////////////////////////////////////////////////////
172
void TexturePeeker::lookup(LColor &color, PN_stdfloat u, PN_stdfloat v) const;
void TexturePeeker::lookup(LColor &color, PN_stdfloat u, PN_stdfloat v, PN_stdfloat w) const;

3013 11 filter_rect 0 4 3128 26 TexturePeeker::filter_rect 0 2 1539 1540 1128
////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::filter_rect
//       Access: Published
//  Description: Fills "color" with the average RGBA color of the
//               texels within the rectangle defined by the specified
//               coordinate range.
//
//               The texel color is linearly filtered over the entire
//               region.  u, v, and w will wrap around regardless of
//               the texture's wrap mode.
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::filter_rect
//       Access: Published
//  Description: Fills "color" with the average RGBA color of the
//               texels within the rectangle defined by the specified
//               coordinate range.
//
//               The texel color is linearly filtered over the entire
//               region.  u, v, and w will wrap around regardless of
//               the texture's wrap mode.
////////////////////////////////////////////////////////////////////
297
void TexturePeeker::filter_rect(LColor &color, PN_stdfloat min_u, PN_stdfloat min_v, PN_stdfloat max_u, PN_stdfloat max_v) const;
void TexturePeeker::filter_rect(LColor &color, PN_stdfloat min_u, PN_stdfloat min_v, PN_stdfloat min_w, PN_stdfloat max_u, PN_stdfloat max_v, PN_stdfloat max_w) const;

3014 14 ~TexturePeeker 0 4 3128 29 TexturePeeker::~TexturePeeker 0 0 0
36
TexturePeeker::~TexturePeeker(void);

3015 9 get_stage 0 4 3129 27 TextureStagePool::get_stage 0 1 1541 1060
////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::get_stage
//       Access: Public, Static
//  Description: Returns a TextureStage pointer that represents the
//               same TextureStage described by temp, except that it is a
//               shared pointer.
//
//               Each call to get_stage() passing an equivalent
//               TextureStage pointer will return the same shared pointer.
//
//               If you modify the shared pointer, it will
//               automatically disassociate it from the pool.
//
//               Also, the return value may be a different pointer
//               than that passed in, or it may be the same pointer.
//               In either case, the passed in pointer has now been
//               sacrificed to the greater good and should not be used
//               again (like any other PointerTo, it will be freed
//               when the last reference count is removed).
////////////////////////////////////////////////////////////////////
76
static inline TextureStage *TextureStagePool::get_stage(TextureStage *temp);

3016 13 release_stage 0 4 3129 31 TextureStagePool::release_stage 0 1 1542 288
////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::release_stage
//       Access: Published, Static
//  Description: Removes the indicated TextureStage from the pool.
////////////////////////////////////////////////////////////////////
71
static inline void TextureStagePool::release_stage(TextureStage *temp);

3017 18 release_all_stages 0 4 3129 36 TextureStagePool::release_all_stages 0 1 1543 341
////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::release_all_stages
//       Access: Published, Static
//  Description: Releases all TextureStages in the pool and restores the
//               pool to the empty state.
////////////////////////////////////////////////////////////////////
62
static inline void TextureStagePool::release_all_stages(void);

3018 8 set_mode 0 4 3129 26 TextureStagePool::set_mode 0 1 1544 847
////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::set_mode
//       Access: Published, Static
//  Description: Specifies the fundamental operating mode of the
//               TextureStagePool.
//
//               If this is M_none, each call to get_stage() returns
//               the same TextureStage pointer that was passed in (the
//               pool is effectively disabled).  If this is M_name,
//               each call to get_stage() returns the last
//               TextureStage passed in with the same name, whether it
//               has different properties or not.  If this is
//               M_unique, then each call to get_stage() returns only
//               TextureStages with identical properties.
////////////////////////////////////////////////////////////////////
75
static inline void TextureStagePool::set_mode(TextureStagePool::Mode mode);

3019 8 get_mode 0 4 3129 26 TextureStagePool::get_mode 0 1 1545 331
////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::get_mode
//       Access: Published, Static
//  Description: Returns the fundamental operating mode of the
//               TextureStagePool.  See set_mode().
////////////////////////////////////////////////////////////////////
70
static inline TextureStagePool::Mode TextureStagePool::get_mode(void);

3020 15 garbage_collect 0 4 3129 33 TextureStagePool::garbage_collect 0 1 1546 497
////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::garbage_collect
//       Access: Public, Static
//  Description: Releases only those TextureStages in the pool that have a
//               reference count of exactly 1; i.e. only those
//               TextureStages that are not being used outside of the pool.
//               Returns the number of TextureStages released.
////////////////////////////////////////////////////////////////////
58
static inline int TextureStagePool::garbage_collect(void);

3021 13 list_contents 0 4 3129 31 TextureStagePool::list_contents 0 1 1547 328
////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::list_contents
//       Access: Public, Static
//  Description: Lists the contents of the TextureStage pool to the
//               indicated output stream.
////////////////////////////////////////////////////////////////////
65
static inline void TextureStagePool::list_contents(ostream &out);

3022 5 write 0 4 3129 23 TextureStagePool::write 0 1 1548 323
////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::write
//       Access: Published, Static
//  Description: Lists the contents of the TextureStage pool to the
//               indicated output stream.
////////////////////////////////////////////////////////////////////
50
static void TextureStagePool::write(ostream &out);

3023 17 ~TextureStagePool 0 4 3129 35 TextureStagePool::~TextureStagePool 0 0 0
42
TextureStagePool::~TextureStagePool(void);

1548
1 0 0 7 3 3134 1550 0 224 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 name 1 3131  8 max_size 1 3132  
2 0 0 6 5 3132 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::get_total_size
//       Access: Published
//  Description: Returns the total size of all objects currently
//               active on the LRU.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3135  
3 0 0 6 6 3132 0 0 319 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::get_max_size
//       Access: Published
//  Description: Returns the max size of all objects that are allowed
//               to be active on the LRU.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3135  
4 0 0 4 7 3137 0 0 385 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::set_max_size
//       Access: Published
//  Description: Changes the max size of all objects that are allowed
//               to be active on the LRU.
//
//               If the size is (size_t)-1, there is no limit.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3134  8 max_size 1 3132  
5 0 0 6 8 3132 0 0 339 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::count_active_size
//       Access: Published
//  Description: Returns the total size of the pages that were
//               enqueued since the last call to begin_epoch().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3135  
6 0 0 4 9 3137 0 0 277 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::consider_evict
//       Access: Published
//  Description: Evicts a sequence of objects if the queue is full.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3134  
7 0 0 4 10 3137 0 0 373 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::evict_to
//       Access: Published
//  Description: Evicts a sequence of objects until the queue fits
//               within the indicated target size, regardless of its
//               normal max size.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3134  11 target_size 1 3132  
8 0 0 4 11 3137 0 0 443 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::begin_epoch
//       Access: Published
//  Description: Marks the end of the previous epoch and the beginning
//               of the next one.  This will evict any objects that
//               are pending eviction, and also update any internal
//               bookkeeping.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3134  
9 0 0 6 12 3138 0 0 365 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::validate
//       Access: Published
//  Description: Checks that the LRU is internally self-consistent.
//               Returns true if successful, false if there is some
//               problem.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3134  
10 0 0 4 13 3137 0 0 219 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3135  3 out 1 3139  
11 0 0 4 14 3137 0 0 227 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3135  3 out 1 3139  12 indent_level 1 3141  
12 0 0 4 15 3137 0 0 314 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::set_weight
//       Access: Published
//  Description: Specifies the weight value used to compute the
//               exponential moving average.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3134  6 weight 1 3142  
13 0 0 6 16 3142 0 0 312 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::get_weight
//       Access: Published
//  Description: Returns the weight value used to compute the
//               exponential moving average.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3135  
14 0 0 4 17 3137 0 0 486 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::set_max_updates_per_frame
//       Access: Published
//  Description: Specifies the maximum number of pages the AdaptiveLru
//               will update each frame.  This is a performance
//               optimization: keeping this number low limits the
//               impact of the AdaptiveLru's adaptive algorithm.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3134  21 max_updates_per_frame 1 3141  
15 0 0 6 18 3141 0 0 330 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLru::get_max_updates_per_frame
//       Access: Published
//  Description: Returns the maximum number of pages the AdaptiveLru
//               will update each frame.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3135  
16 0 0 7 26 3146 1571 0 233 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::Copy Constructor
//       Access: Protected
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3144  
17 0 0 7 26 3146 1571 0 228 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::Constructor
//       Access: Protected
//  Description: 
//////////////////////////////////////////////////////////////////// 1 8 lru_size 1 3132  
18 0 0 6 27 3146 0 0 0 2 4 this 3 3146  4 copy 1 3144  
19 0 0 6 29 3134 0 0 335 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::enqueue_lru
//       Access: Published
//  Description: Returns the LRU that manages this page, or NULL if it
//               is not currently managed by any LRU.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3144  
20 0 0 4 30 3137 0 0 445 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::enqueue_lru
//       Access: Published
//  Description: Adds the page to the LRU for the first time, or marks
//               it recently-accessed if it has already been added.
//
//               If lru is NULL, it means to remove this page from its
//               LRU.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3146  3 lru 1 3134  
21 0 0 4 31 3137 0 0 266 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::dequeue_lru
//       Access: Published
//  Description: Removes the page from its AdaptiveLru.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3146  
22 0 0 4 32 3137 0 0 485 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::mark_used_lru
//       Access: Published
//  Description: To be called when the page is used; this will move it
//               to the tail of the AdaptiveLru queue it is already on.
//
//               This method is const because it's not technically
//               modifying the contents of the page itself.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3144  
23 0 0 4 32 3137 0 0 348 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::mark_used_lru
//       Access: Published
//  Description: To be called when the page is used; this will move it
//               to the tail of the specified AdaptiveLru queue.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3146  3 lru 1 3134  
24 0 0 6 33 3132 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::get_lru_size
//       Access: Published
//  Description: Returns the size of this page as reported to the LRU,
//               presumably in bytes.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3144  
25 0 0 4 34 3137 0 0 330 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::set_lru_size
//       Access: Published
//  Description: Specifies the size of this page, presumably in bytes,
//               although any unit is possible.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3146  8 lru_size 1 3132  
26 0 0 4 35 3137 0 0 814 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::evict_lru
//       Access: Published, Virtual
//  Description: Evicts the page from the LRU.  Called internally when
//               the LRU determines that it is full.  May also be
//               called externally when necessary to explicitly evict
//               the page.
//
//               It is legal for this method to either evict the page
//               as requested, do nothing (in which case the eviction
//               will be requested again at the next epoch), or
//               requeue itself on the tail of the queue (in which
//               case the eviction will be requested again much
//               later).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3146  
27 0 0 4 36 3137 0 0 232 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3144  3 out 1 3139  
28 0 0 4 37 3137 0 0 231 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3144  3 out 1 3139  12 indent_level 1 3141  
29 0 0 6 38 3147 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::get_num_frames
//       Access: Published
//  Description: Returns the number of frames since the page was first
//               added to its LRU.  Returns 0 if it does not have an
//               LRU.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3144  
30 0 0 6 39 3147 0 0 386 ////////////////////////////////////////////////////////////////////
//     Function: AdaptiveLruPage::get_num_inactive_frames
//       Access: Published
//  Description: Returns the number of frames since the page was last
//               accessed on its LRU.  Returns 0 if it does not have
//               an LRU.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3144  
31 0 0 7 50 3148 1593 0 236 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 0 
32 0 0 7 50 3148 1593 0 241 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 5 other 1 3149  
33 0 0 6 51 3148 0 0 0 2 4 this 3 3148  5 other 1 3149  
34 0 0 6 52 3036 0 0 315 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::get_animation_type
//       Access: Published
//  Description: Returns the type of animation represented by this
//               spec.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3149  
35 0 0 6 53 3141 0 0 479 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::get_num_transforms
//       Access: Published
//  Description: This is only meaningful for animation_type
//               AT_hardware.  It specifies the maximum number of
//               transforms that might be simultaneously applied to
//               any one vertex by the data in this format.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3149  
36 0 0 6 54 3138 0 0 529 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::get_indexed_transforms
//       Access: Published
//  Description: This is only meaningful for animation_type
//               AT_hardware.  If true, it indicates that the format
//               uses indexed animation tables.  It is false if each
//               vertex will reference the first _num_transforms
//               table entries only.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3149  
37 0 0 4 55 3137 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::set_none
//       Access: Published
//  Description: Specifies that no vertex animation is represented by
//               this spec.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3148  
38 0 0 4 56 3137 0 0 419 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::set_panda
//       Access: Published
//  Description: Specifies that vertex animation is to be performed by
//               Panda.  This is the most general setting and can
//               handle any kind of vertex animation represented.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3148  
39 0 0 4 57 3137 0 0 721 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::set_hardware
//       Access: Published
//  Description: Specifies that vertex animation is to be performed by
//               the graphics hardware (or at least by the graphics
//               backend API, which is actually still free to animate
//               the vertices on the CPU).
//
//               This is only legal if the graphics hardware can
//               support the specified limits on number of transforms
//               and/or indexed transforms.  Also, no current graphics
//               API's support morphing.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3148  14 num_transforms 1 3141  18 indexed_transforms 1 3138  
40 0 0 4 58 3137 0 0 231 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexAnimationSpec::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3149  3 out 1 3139  
41 0 0 7 62 3154 0 0 0 1 3 str 1 3151  
42 0 0 7 62 3154 0 0 301 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::make
//       Access: Published, Static
//  Description: Make using a string and an integer.  Concatenates
//               the two.
//////////////////////////////////////////////////////////////////// 2 4 name 1 3131  5 index 1 3141  
43 0 0 7 63 3154 0 0 475 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::append
//       Access: Published
//  Description: Constructs a new InternalName based on this name,
//               with the indicated string following it.  This is a
//               cheaper way to construct a hierarchical name than
//               InternalName::make(parent->get_name() + ".basename").
//////////////////////////////////////////////////////////////////// 2 4 this 3 3154  8 basename 1 3131  
44 0 0 7 64 3154 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_parent
//       Access: Published
//  Description: Return the parent of this InternalName.  All names
//               have a parent, except the root name.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3155  
45 0 0 6 65 3131 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_name
//       Access: Published
//  Description: Returns the complete name represented by the
//               InternalName and all of its parents.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3155  
46 0 0 6 66 3131 0 0 293 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::join
//       Access: Published
//  Description: Like get_name, but uses a custom separator instead
//               of ".".
//////////////////////////////////////////////////////////////////// 2 4 this 3 3155  3 sep 1 3131  
47 0 0 6 67 3131 0 0 404 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_basename
//       Access: Published
//  Description: Return the name represented by just this particular
//               InternalName object, ignoring its parents names.
//               This is everything after the rightmost dot.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3155  
48 0 0 6 68 3141 0 0 584 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::find_ancestor
//       Access: Published
//  Description: Returns the index of the ancestor with the indicated
//               basename, or -1 if no ancestor has that basename.
//               Returns 0 if this name has the basename.
//
//               This index value may be passed to get_ancestor() or
//               get_net_basename() to retrieve more information about
//               the indicated name.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3155  8 basename 1 3131  
49 0 0 7 69 3155 0 0 481 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_ancestor
//       Access: Published
//  Description: Returns the ancestor with the indicated index number.
//               0 is this name itself, 1 is the name's parent, 2 is
//               the parent's parent, and so on.  If there are not
//               enough ancestors, returns the root InternalName.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3155  1 n 1 3141  
50 0 0 7 70 3155 0 0 460 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_top
//       Access: Published
//  Description: Returns the oldest ancestor in the InternalName's
//               chain, not counting the root.  This will be the first
//               name in the string, e.g. "texcoord.foo.bar" will
//               return the InternalName "texcoord".
//////////////////////////////////////////////////////////////////// 1 4 this 3 3155  
51 0 0 6 71 3131 0 0 456 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_net_basename
//       Access: Published
//  Description: Returns the basename of this name prefixed by the
//               indicated number of ancestors.  0 is this name's
//               basename, 1 is parent.basename, 2 is
//               grandparent.parent.basename, and so on.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3155  1 n 1 3141  
52 0 0 4 72 3137 0 0 219 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 3155  3 out 1 3139  
53 0 0 7 73 3154 0 0 438 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_root
//       Access: Published, Static
//  Description: Returns the standard root InternalName.  This is the
//               root of all other InternalNames.  It has no name
//               itself, and it is the only InternalName with no
//               parent.
//////////////////////////////////////////////////////////////////// 0 
54 0 0 7 74 3154 0 0 273 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_error
//       Access: Published, Static
//  Description: Returns the standard InternalName "error".
//////////////////////////////////////////////////////////////////// 0 
55 0 0 7 75 3154 0 0 400 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_vertex
//       Access: Published, Static
//  Description: Returns the standard InternalName "vertex".  This is
//               the column header for the 3-d or 4-d vertex position
//               information for each vertex.
//////////////////////////////////////////////////////////////////// 0 
56 0 0 7 76 3154 0 0 381 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_normal
//       Access: Published, Static
//  Description: Returns the standard InternalName "normal".  This is
//               the column header for the 3-d lighting normal for
//               each vertex.
//////////////////////////////////////////////////////////////////// 0 
57 0 0 7 77 3154 0 0 593 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_tangent
//       Access: Published, Static
//  Description: Returns the standard InternalName "tangent".  This is
//               the column header for the tangent vector associated
//               with each vertex, which is a unit vector
//               usually perpendicular to the normal and in the
//               direction of the U texture coordinate change.  It is
//               used for deriving bump maps.
//////////////////////////////////////////////////////////////////// 0 
58 0 0 7 78 3154 0 0 457 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_tangent_name
//       Access: Published, Static
//  Description: Returns the InternalName "tangent.name", where name
//               is the supplied string.  This is the column header
//               for the tangent associated with the named texture
//               coordinate set.
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
59 0 0 7 79 3154 0 0 634 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_binormal
//       Access: Published, Static
//  Description: Returns the standard InternalName "binormal".  This is
//               the column header for the tangent vector associated
//               with each vertex, which is a unit vector
//               usually perpendicular to both the normal and the
//               tangent, and in the direction of the V texture
//               coordinate change.  It is used for deriving bump
//               maps.
//////////////////////////////////////////////////////////////////// 0 
60 0 0 7 80 3154 0 0 460 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_binormal_name
//       Access: Published, Static
//  Description: Returns the InternalName "binormal.name", where name
//               is the supplied string.  This is the column header
//               for the binormal associated with the named texture
//               coordinate set.
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
61 0 0 7 81 3154 0 0 517 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_texcoord
//       Access: Published, Static
//  Description: Returns the standard InternalName "texcoord".  This
//               is the column header for the default texture
//               coordinate set for each vertex.  It is also used for
//               identifying the default texture coordinate set in a
//               TextureStage.
//////////////////////////////////////////////////////////////////// 0 
62 0 0 7 82 3154 0 0 548 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_texcoord_name
//       Access: Published, Static
//  Description: Returns the InternalName "texcoord.name", where name
//               is the supplied string.  This is the column header
//               for the named texture coordinate set for each vertex.
//               It is also used for identifying the named texture
//               coordinate set in a TextureStage.
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
63 0 0 7 83 3154 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_color
//       Access: Published, Static
//  Description: Returns the standard InternalName "color".  This is
//               the column header for the 4-component color value for
//               each vertex.
//////////////////////////////////////////////////////////////////// 0 
64 0 0 7 84 3154 0 0 500 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_rotate
//       Access: Published, Static
//  Description: Returns the standard InternalName "rotate".  This is
//               the column header for the floating-point rotate
//               value, which represents a number of degrees
//               counter-clockwise to rotate each point or point
//               sprite.
//////////////////////////////////////////////////////////////////// 0 
65 0 0 7 85 3154 0 0 505 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_size
//       Access: Published, Static
//  Description: Returns the standard InternalName "size".  This is
//               the column header for the floating-point size value,
//               which overrides the thickness parameter of the
//               RenderModeAttrib on a per-vertex (e.g. per-point)
//               basis.
//////////////////////////////////////////////////////////////////// 0 
66 0 0 7 86 3154 0 0 535 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_aspect_ratio
//       Access: Published, Static
//  Description: Returns the standard InternalName "aspect_ratio".
//               This is the column header for the floating-point
//               aspect ratio value, which is used to define
//               non-square points.  This number is the ratio x / y,
//               where y is the point size (above).
//////////////////////////////////////////////////////////////////// 0 
67 0 0 7 87 3154 0 0 553 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_transform_blend
//       Access: Published, Static
//  Description: Returns the standard InternalName "transform_blend".
//               This is the column header for the integer
//               transform_blend index, which is used to define vertex
//               animation on the CPU by indexing to a particular
//               vertex weighting from the TransformBlendTable.
//////////////////////////////////////////////////////////////////// 0 
68 0 0 7 88 3154 0 0 823 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_transform_weight
//       Access: Published, Static
//  Description: Returns the standard InternalName "transform_weight".
//               This is the column header for the n-component
//               transform_weight value, which is used in conjuntion
//               with "transform_index" to define vertex animation on
//               the graphics card.  The transform_weight value
//               specifies the weight of the nth transform.  By
//               convention, there are 1 fewer weight values than
//               transforms, since the weights are assumed to sum to 1
//               (and the last value is therefore implicit).
//////////////////////////////////////////////////////////////////// 0 
69 0 0 7 89 3154 0 0 795 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_transform_index
//       Access: Published, Static
//  Description: Returns the standard InternalName "transform_index".
//               This is the column header for the n-component
//               transform_index value, which is used in conjuntion
//               with "transform_weight" to define vertex animation on
//               the graphics card.  The transform_index value
//               specifies the nth transform, by lookup in the
//               TransformTable.  The transform_index column may be
//               omitted, in which case the nth transform is the nth
//               entry in the table.
//////////////////////////////////////////////////////////////////// 0 
70 0 0 7 90 3154 0 0 655 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_morph
//       Access: Published, Static
//  Description: Returns an InternalName derived from the given base
//               column name and the given slider name, which is the
//               column header for the offset vector that should be
//               applied to the base column name when the named morph
//               slider is engaged.
//
//               Each morph slider requires a set of n morph columns,
//               one for each base column it applies to.
//////////////////////////////////////////////////////////////////// 2 6 column 1 3154  6 slider 1 3131  
71 0 0 7 91 3154 0 0 515 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_index
//       Access: Published, Static
//  Description: Returns the standard InternalName "index".  This is
//               the column header for the integer vertex index.  It
//               is not used in the vertex data itself, but is used in
//               the GeomPrimitive structure to index into the vertex
//               data.
//////////////////////////////////////////////////////////////////// 0 
72 0 0 7 92 3154 0 0 342 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_world
//       Access: Published, Static
//  Description: Returns the standard InternalName "world".  This is
//               used as a keyword in the shader subsystem.
//////////////////////////////////////////////////////////////////// 0 
73 0 0 7 93 3154 0 0 344 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_camera
//       Access: Published, Static
//  Description: Returns the standard InternalName "camera".  This is
//               used as a keyword in the shader subsystem.
//////////////////////////////////////////////////////////////////// 0 
74 0 0 7 94 3154 0 0 342 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_model
//       Access: Published, Static
//  Description: Returns the standard InternalName "model".  This is
//               used as a keyword in the shader subsystem.
//////////////////////////////////////////////////////////////////// 0 
75 0 0 7 95 3154 0 0 340 ////////////////////////////////////////////////////////////////////
//     Function: InternalName::get_view
//       Access: Published, Static
//  Description: Returns the standard InternalName "view".  This is
//               used as a keyword in the shader subsystem.
//////////////////////////////////////////////////////////////////// 0 
76 0 0 7 96 3158 0 0 0 0 
77 0 0 7 98 3159 1631 0 228 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 8 4 name 1 3155  14 num_components 1 3141  12 numeric_type 1 3034  8 contents 1 3035  5 start 1 3141  16 column_alignment 1 3141  12 num_elements 1 3141  14 element_stride 1 3141  
78 0 0 7 98 3159 1631 0 233 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3160  
79 0 0 6 99 3159 0 0 0 2 4 this 3 3159  4 copy 1 3160  
80 0 0 7 101 3155 0 0 541 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_name
//       Access: Published
//  Description: Returns the name of this particular data field,
//               e.g. "vertex" or "normal".  The name may be a
//               user-defined string, or it may be one of the standard
//               system-defined field types.  Only the system-defined
//               field types are used for the actual rendering.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
81 0 0 6 102 3141 0 0 464 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_num_components
//       Access: Published
//  Description: Returns the number of components of the column:
//               the number of instances of the NumericType in each
//               element.  This is usually, but not always, the same
//               thing as get_num_values().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
82 0 0 6 103 3141 0 0 648 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_num_values
//       Access: Published
//  Description: Returns the number of numeric values of the column:
//               the number of distinct numeric values that go into
//               each element.  This is usually, but not always, the
//               same thing as get_num_components(); the difference is
//               in the case of a composite numeric type like
//               NT_packed_dcba, which has four numeric values per
//               component.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
83 0 0 6 104 3141 0 0 343 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_num_elements
//       Access: Published
//  Description: Returns the number of times this column is repeated.
//               This is usually 1, except for matrices.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
84 0 0 6 105 3034 0 0 319 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_numeric_type
//       Access: Published
//  Description: Returns the token representing the numeric type of
//               the data storage.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
85 0 0 6 106 3035 0 0 319 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_contents
//       Access: Published
//  Description: Returns the token representing the semantic meaning of
//               the stored value.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
86 0 0 6 107 3141 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_start
//       Access: Published
//  Description: Returns the byte within the array record at which
//               this column starts.  This can be set to non-zero
//               to implement interleaved arrays.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
87 0 0 6 108 3141 0 0 601 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_column_alignment
//       Access: Published
//  Description: Returns the alignment requirements for this column.
//               If this is greater than 1, it restricts the column to
//               appear only on memory addresses that are integer
//               multiples of this value; this has implications for
//               this column's start value, as well as the stride of
//               the resulting array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
88 0 0 6 109 3141 0 0 388 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_element_stride
//       Access: Published
//  Description: This value is only relevant for matrix types.
//               Returns the number of bytes to add to access the
//               next row of the matrix.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
89 0 0 6 110 3141 0 0 351 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_component_bytes
//       Access: Published
//  Description: Returns the number of bytes used by each component
//               (that is, by one element of the numeric type).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
90 0 0 6 111 3141 0 0 347 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::get_total_bytes
//       Access: Published
//  Description: Returns the number of bytes used by each element of
//               the column: component_bytes * num_components.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
91 0 0 6 112 3138 0 0 727 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::has_homogeneous_coord
//       Access: Published
//  Description: Returns true if this Contents type is one that
//               includes a homogeneous coordinate in the fourth
//               component, or false otherwise.  If this is true,
//               correct operation on the vertex data may require
//               scaling by the homogeneous coordinate from time to
//               time (but in general this is handled automatically if
//               you use the 3-component or smaller forms of
//               get_data() and set_data()).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3160  
92 0 0 6 113 3138 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::overlaps_with
//       Access: Published
//  Description: Returns true if this column overlaps with any of
//               the bytes in the indicated range, false if it does
//               not.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3160  10 start_byte 1 3141  9 num_bytes 1 3141  
93 0 0 6 114 3138 0 0 419 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::is_bytewise_equivalent
//       Access: Published
//  Description: Returns true if the data store of this column is
//               exactly the same as that of the other, irrespective
//               of name or start position within the record.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3160  5 other 1 3160  
94 0 0 4 115 3137 0 0 393 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_name
//       Access: Published
//  Description: Replaces the name of an existing column.  This is
//               only legal on an unregistered format (i.e. when
//               constructing the format initially).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3159  4 name 1 3154  
95 0 0 4 116 3137 0 0 418 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_num_components
//       Access: Published
//  Description: Changes the number of components of an existing
//               column.  This is only legal on an unregistered format
//               (i.e. when constructing the format initially).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3159  14 num_components 1 3141  
96 0 0 4 117 3137 0 0 405 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_numeric_type
//       Access: Published
//  Description: Changes the numeric type an existing column.  This is
//               only legal on an unregistered format (i.e. when
//               constructing the format initially).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3159  12 numeric_type 1 3034  
97 0 0 4 118 3137 0 0 407 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_contents
//       Access: Published
//  Description: Changes the semantic meaning of an existing column.
//               This is only legal on an unregistered format
//               (i.e. when constructing the format initially).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3159  8 contents 1 3035  
98 0 0 4 119 3137 0 0 398 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_start
//       Access: Published
//  Description: Changes the start byte of an existing column.
//               This is only legal on an unregistered format
//               (i.e. when constructing the format initially).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3159  5 start 1 3141  
99 0 0 4 120 3137 0 0 415 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::set_column_alignment
//       Access: Published
//  Description: Changes the column alignment of an existing column.
//               This is only legal on an unregistered format
//               (i.e. when constructing the format initially).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3159  16 column_alignment 1 3141  
100 0 0 4 121 3137 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexColumn::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 3160  3 out 1 3139  
101 0 0 7 127 3162 1659 0 233 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
102 0 0 7 127 3162 1659 0 233 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 4 5 name0 1 3155  15 num_components0 1 3141  13 numeric_type0 1 3034  9 contents0 1 3035  
103 0 0 7 127 3162 1659 0 233 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 8 5 name0 1 3155  15 num_components0 1 3141  13 numeric_type0 1 3034  9 contents0 1 3035  5 name1 1 3155  15 num_components1 1 3141  13 numeric_type1 1 3034  9 contents1 1 3035  
104 0 0 7 127 3162 1659 0 233 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 12 5 name0 1 3155  15 num_components0 1 3141  13 numeric_type0 1 3034  9 contents0 1 3035  5 name1 1 3155  15 num_components1 1 3141  13 numeric_type1 1 3034  9 contents1 1 3035  5 name2 1 3155  15 num_components2 1 3141  13 numeric_type2 1 3034  9 contents2 1 3035  
105 0 0 7 127 3162 1659 0 233 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 16 5 name0 1 3155  15 num_components0 1 3141  13 numeric_type0 1 3034  9 contents0 1 3035  5 name1 1 3155  15 num_components1 1 3141  13 numeric_type1 1 3034  9 contents1 1 3035  5 name2 1 3155  15 num_components2 1 3141  13 numeric_type2 1 3034  9 contents2 1 3035  5 name3 1 3155  15 num_components3 1 3141  13 numeric_type3 1 3034  9 contents3 1 3035  
106 0 0 7 127 3162 1659 0 238 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3163  
107 0 0 7 128 3162 1659 0 0 2 4 this 3 3162  4 copy 1 3163  
108 0 0 6 130 3138 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::unref
//       Access: Published, Virtual
//  Description: This method overrides ReferenceCount::unref() to
//               unregister the object when its reference count goes
//               to zero.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3163  
109 0 0 6 131 3138 0 0 468 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::is_registered
//       Access: Published
//  Description: Returns true if this format has been registered,
//               false if it has not.  It may not be used for a Geom
//               until it has been registered, but once registered, it
//               may no longer be modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3163  
110 0 0 7 132 3163 0 0 774 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::register_format
//       Access: Published, Static
//  Description: Adds the indicated format to the registry, if there
//               is not an equivalent format already there; in either
//               case, returns the pointer to the equivalent format
//               now in the registry.
//
//               This is similar to
//               GeomVertexFormat::register_format(), except that you
//               generally need not call it explicitly.  Calling
//               GeomVertexFormat::register_format() automatically
//               registers all of the nested array formats.
//////////////////////////////////////////////////////////////////// 1 6 format 1 3163  
111 0 0 6 133 3141 0 0 322 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_stride
//       Access: Published
//  Description: Returns the total number of bytes reserved in the
//               array for each vertex.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3163  
112 0 0 4 134 3137 0 0 443 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::set_stride
//       Access: Published
//  Description: Changes the total number of bytes reserved in the
//               array for each vertex.  You may not reduce this below
//               get_total_bytes(), but you may increase it
//               arbitrarily.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3162  6 stride 1 3141  
113 0 0 6 135 3141 0 0 659 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_pad_to
//       Access: Published
//  Description: Returns the byte divisor to which the data record
//               must be padded to meet hardware limitations.  For
//               instance, if this is 4, the stride will be
//               automatically rounded up to the next multiple of 4
//               bytes.  This value is automatically increased as
//               needed to ensure the individual numeric components in
//               the array are word-aligned.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3163  
114 0 0 4 136 3137 0 0 666 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::set_pad_to
//       Access: Published
//  Description: Explicitly sets the byte divisor to which the data
//               record must be padded to meet hardware limitations.
//               See get_pad_to().  Normally it is not necessary to
//               call this unless you have some specific requirements
//               for row-to-row data alignment.  Note that this value
//               may be automatically increased at each subsequent
//               call to add_column().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3162  6 pad_to 1 3141  
115 0 0 6 137 3141 0 0 482 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_divisor
//       Access: Published
//  Description: Returns the divisor attribute for the data in this
//               array.  If 0, it contains per-vertex data.  If 1,
//               it contains per-instance data.  If higher than 1,
//               the read row is advanced for each n instances.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3163  
116 0 0 4 138 3137 0 0 474 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::set_divisor
//       Access: Published
//  Description: Set this to 0 to indicate that this array contains
//               per-vertex data, or to 1 to indicate that it
//               contains per-instance data.  If higher than 1,
//               the read row is advanced for each n instances.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3162  7 divisor 1 3141  
117 0 0 6 139 3141 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_total_bytes
//       Access: Published
//  Description: Returns the total number of bytes used by the data
//               types within the format, including gaps between
//               elements.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3163  
118 0 0 6 140 3141 0 0 631 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::add_column
//       Access: Published
//  Description: Adds a new column to the specification.  This is a
//               table of per-vertex floating-point numbers such as
//               "vertex" or "normal"; you must specify where in each
//               record the table starts, and how many components
//               (dimensions) exist per vertex.
//
//               The return value is the index number of the new data
//               type.
//////////////////////////////////////////////////////////////////// 7 4 this 3 3162  4 name 1 3155  14 num_components 1 3141  12 numeric_type 1 3034  8 contents 1 3035  5 start 1 3141  16 column_alignment 1 3141  
119 0 0 6 140 3141 0 0 828 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::add_column
//       Access: Published
//  Description: Adds a new column to the specification.  This is a
//               table of per-vertex floating-point numbers such as
//               "vertex" or "normal"; you must specify where in each
//               record the table starts, and how many components
//               (dimensions) exist per vertex.
//
//               Adding a column with the same name as a previous
//               type, or that overlaps with one or more previous
//               types, quietly removes the previous type(s).
//
//               The return value is the index number of the new data
//               type.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3162  6 column 1 3160  
120 0 0 4 141 3137 0 0 346 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::remove_column
//       Access: Published
//  Description: Removes the column with the indicated name, if
//               any.  This leaves a gap in the byte structure.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3162  4 name 1 3155  
121 0 0 4 142 3137 0 0 343 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::clear_columns
//       Access: Published
//  Description: Removes all columns previously added, sets the
//               stride to zero, and prepares to start over.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3162  
122 0 0 4 143 3137 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::pack_columns
//       Access: Published
//  Description: Removes wasted space between columns.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3162  
123 0 0 4 144 3137 0 0 648 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::align_columns_for_animation
//       Access: Published
//  Description: Reprocesses the columns in the format to align the
//               C_point and C_vector columns to 16-byte boundaries to
//               allow for the more efficient SSE2 operations
//               (assuming SSE2 is enabled in the build).
//
//               The caller is responsible for testing
//               vertex_animation_align_16 to decide whether to call
//               this method.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3162  
124 0 0 6 145 3141 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_num_columns
//       Access: Published
//  Description: Returns the number of different columns in the
//               array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3163  
125 0 0 6 146 3160 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_column
//       Access: Published
//  Description: Returns the specification with the indicated name, or
//               NULL if the name is not used.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3163  4 name 1 3155  
126 0 0 6 146 3160 0 0 269 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_column
//       Access: Published
//  Description: Returns the ith column of the array.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3163  1 i 1 3141  
127 0 0 6 146 3160 0 0 378 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_column
//       Access: Published
//  Description: Returns the first specification that overlaps with
//               any of the indicated bytes in the range, or NULL if
//               none do.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3163  10 start_byte 1 3141  9 num_bytes 1 3141  
128 0 0 6 147 3138 0 0 314 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::has_column
//       Access: Published
//  Description: Returns true if the array has the named column,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3163  4 name 1 3155  
129 0 0 6 148 3138 0 0 614 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::is_data_subset_of
//       Access: Published
//  Description: Returns true if all of the fields in this array
//               format are also present and equivalent in the other
//               array format, and in the same byte positions, and the
//               stride is the same.  That is, true if this format can
//               share the same data pointer as the other format (with
//               possibly some unused gaps).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3163  5 other 1 3163  
130 0 0 6 149 3141 0 0 330 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::count_unused_space
//       Access: Published
//  Description: Returns the number of bytes per row that are not
//               assigned to any column.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3163  
131 0 0 4 150 3137 0 0 228 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 3163  3 out 1 3139  
132 0 0 4 151 3137 0 0 227 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::write
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 3 4 this 3 3163  3 out 1 3139  12 indent_level 1 3141  
133 0 0 4 152 3137 0 0 237 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::write_with_data
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 4 4 this 3 3163  3 out 1 3139  12 indent_level 1 3141  10 array_data 1 3165  
134 0 0 6 153 3131 0 0 532 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayFormat::get_format_string
//       Access: Published
//  Description: Returns a string with format codes representing the
//               exact memory layout of the columns in memory, as
//               understood by Python's struct module.
//               If pad is true, extra padding bytes are added to
//               the end as 'x' characters as needed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3163  3 pad 1 3138  
135 0 0 7 154 3158 0 0 0 0 
136 0 0 7 123 3167 0 0 0 1 4 this 3 3162  
137 0 0 7 124 3162 1659 0 0 1 4 this 3 3167  
138 0 0 6 125 3168 0 0 0 1 4 this 3 3162  
139 0 0 7 126 3162 1659 0 0 1 4 this 3 3168  
140 0 0 7 160 3169 1691 0 228 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
141 0 0 7 160 3169 1691 0 228 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 12 array_format 1 3163  
142 0 0 7 160 3169 1691 0 233 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3170  
143 0 0 7 161 3169 1691 0 0 2 4 this 3 3169  4 copy 1 3170  
144 0 0 6 163 3138 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::unref
//       Access: Published, Virtual
//  Description: This method overrides ReferenceCount::unref() to
//               unregister the object when its reference count goes
//               to zero.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
145 0 0 6 164 3138 0 0 463 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::is_registered
//       Access: Published
//  Description: Returns true if this format has been registered,
//               false if it has not.  It may not be used for a Geom
//               until it has been registered, but once registered, it
//               may no longer be modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
146 0 0 7 165 3170 0 0 362 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::register_format
//       Access: Published, Static
//  Description: This flavor of register_format() implicitly creates a
//               one-array vertex format from the array definition.
//////////////////////////////////////////////////////////////////// 1 6 format 1 3163  
147 0 0 7 165 3170 0 0 849 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::register_format
//       Access: Published, Static
//  Description: Adds the indicated format to the registry, if there
//               is not an equivalent format already there; in either
//               case, returns the pointer to the equivalent format
//               now in the registry.
//
//               This must be called before a format may be used in a
//               Geom.  After this call, you should discard the
//               original pointer you passed in (which may or may not
//               now be invalid) and let its reference count decrement
//               normally; you should use only the returned value from
//               this point on.
//////////////////////////////////////////////////////////////////// 1 6 format 1 3170  
148 0 0 6 166 3149 0 0 351 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_animation
//       Access: Published
//  Description: Returns the GeomVertexAnimationSpec that indicates
//               how this format's vertices are set up for animation.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
149 0 0 4 167 3137 0 0 555 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::set_animation
//       Access: Published
//  Description: Resets the GeomVertexAnimationSpec that indicates
//               how this format's vertices are set up for animation.
//               You should also, of course, change the columns in the
//               tables accordingly.
//
//               This may not be called once the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3169  9 animation 1 3149  
150 0 0 7 168 3170 0 0 646 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_post_animated_format
//       Access: Published
//  Description: Returns a suitable vertex format for sending the
//               animated vertices to the graphics backend.  This is
//               the same format as the source format, with the
//               CPU-animation data elements removed.
//
//               This may only be called after the format has been
//               registered.  The return value will have been already
//               registered.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
151 0 0 7 169 3170 0 0 791 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_union_format
//       Access: Published
//  Description: Returns a new GeomVertexFormat that includes all of
//               the columns defined in either this GeomVertexFormat
//               or the other one.  If any column is defined in both
//               formats with different sizes (for instance, texcoord2
//               vs. texcoord3), the new format will include the
//               larger of the two definitions.
//
//               This may only be called after both source formats
//               have been registered.  The return value will also
//               have been already registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  5 other 1 3170  
152 0 0 6 170 3141 0 0 506 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_arrays
//       Access: Published
//  Description: Returns the number of individual arrays required by
//               the format.  If the array data is completely
//               interleaved, this will be 1; if it is completely
//               parallel, this will be the same as the number of data
//               types.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
153 0 0 7 171 3163 0 0 304 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_array
//       Access: Published
//  Description: Returns the description of the nth array used by the
//               format.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  5 array 1 3141  
154 0 0 7 172 3162 1659 0 470 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::modify_array
//       Access: Published
//  Description: Returns a modifiable pointer to the indicated array.
//               This means duplicating it if it is shared or
//               registered.
//
//               This may not be called once the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3169  5 array 1 3141  
155 0 0 4 173 3137 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::set_array
//       Access: Published
//  Description: Replaces the definition of the indicated array.
//
//               This may not be called once the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3169  5 array 1 3141  6 format 1 3163  
156 0 0 4 174 3137 0 0 365 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::remove_array
//       Access: Published
//  Description: Removes the nth array from the format.
//
//               This may not be called once the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3169  5 array 1 3141  
157 0 0 6 175 3141 0 0 534 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::add_array
//       Access: Published
//  Description: Adds the indicated array definition to the list of
//               arrays included within this vertex format definition.
//               The return value is the index number of the new
//               array.
//
//               This may not be called once the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3169  12 array_format 1 3163  
158 0 0 4 176 3137 0 0 570 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::insert_array
//       Access: Published
//  Description: Adds the indicated array definition to the list of
//               arrays at the indicated position.  This works just
//               like add_array(), except that you can specify which
//               array index the new array should have.
//
//               This may not be called once the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3169  5 array 1 3141  12 array_format 1 3163  
159 0 0 4 177 3137 0 0 413 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::clear_arrays
//       Access: Published
//  Description: Removes all of the array definitions from the format
//               and starts over.
//
//               This may not be called once the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3169  
160 0 0 4 178 3137 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::remove_empty_arrays
//       Access: Published
//  Description: Removes the arrays that define no columns.
//
//               This may not be called once the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3169  
161 0 0 6 179 3141 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_columns
//       Access: Published
//  Description: Returns the total number of different columns in
//               the specification, across all arrays.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
162 0 0 6 180 3141 0 0 766 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_array_with
//       Access: Published
//  Description: Returns the index number of the array with the
//               indicated column, or -1 if no arrays contained
//               that name.
//
//               The return value can be passed to get_array_format()
//               to get the format of the array.  It may also be
//               passed to GeomVertexData::get_array_data() or
//               get_data() or set_data() to manipulate the actual
//               array data.
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  4 name 1 3155  
163 0 0 6 180 3141 0 0 604 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_array_with
//       Access: Published
//  Description: Returns the index number of the array with the
//               ith column.
//
//               The return value can be passed to get_array_format()
//               to get the format of the array.  It may also be
//               passed to GeomVertexData::get_array_data() or
//               get_data() or set_data() to manipulate the actual
//               array data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  1 i 1 3141  
164 0 0 6 181 3160 0 0 441 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_column
//       Access: Published
//  Description: Returns the specification with the indicated name, or
//               NULL if the name is not used.  Use get_array_with()
//               to determine which array this column is associated
//               with.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  4 name 1 3155  
165 0 0 6 181 3160 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_column
//       Access: Published
//  Description: Returns the ith column of the specification,
//               across all arrays.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  1 i 1 3141  
166 0 0 6 182 3138 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::has_column
//       Access: Published
//  Description: Returns true if the format has the named column,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  4 name 1 3155  
167 0 0 4 183 3137 0 0 697 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::remove_column
//       Access: Published
//  Description: Removes the named column from the format, from
//               whichever array it exists in.  If there are other
//               columns remaining in the array, the array is left
//               with a gap where the column used to be; if this
//               was the only column in the array, the array is
//               removed (unless keep_empty_array is true).
//
//               This may not be called once the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3169  4 name 1 3155  16 keep_empty_array 1 3138  
168 0 0 4 184 3137 0 0 267 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::pack_columns
//       Access: Published
//  Description: Removes wasted space between columns.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3169  
169 0 0 4 185 3137 0 0 552 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::align_columns_for_animation
//       Access: Published
//  Description: Reprocesses the columns in the format to align the
//               C_point and C_vector columns to 16-byte boundaries to
//               allow for the more efficient SSE2 operations
//               (assuming SSE2 is enabled in the build).
//
//               Also see maybe_align_columns_for_animation().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3169  
170 0 0 4 186 3137 0 0 439 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::maybe_align_columns_for_animation
//       Access: Published
//  Description: Calls align_columns_for_animation() if this format's
//               AnimationSpec indicates that it contains animated
//               vertices, and if vertex-animation-align-16 is true.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3169  
171 0 0 6 187 3141 0 0 427 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_points
//       Access: Published
//  Description: Returns the number of columns within the format
//               that represent points in space.
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
172 0 0 7 188 3155 0 0 497 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_point
//       Access: Published
//  Description: Returns the name of the nth point column.  This
//               represents a point in space, which should be
//               transformed by any spatial transform matrix.
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  1 n 1 3141  
173 0 0 6 189 3141 0 0 432 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_vectors
//       Access: Published
//  Description: Returns the number of columns within the format
//               that represent directional vectors.
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
174 0 0 7 190 3155 0 0 532 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_vector
//       Access: Published
//  Description: Returns the name of the nth vector column.  This
//               represents a directional vector, which should be
//               transformed by any spatial transform matrix as a
//               vector.
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  1 n 1 3141  
175 0 0 6 191 3141 0 0 434 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_texcoords
//       Access: Published
//  Description: Returns the number of columns within the format
//               that represent texture coordinates.
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
176 0 0 7 192 3155 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_texcoord
//       Access: Published
//  Description: Returns the name of the nth texcoord column.  This
//               represents a texture coordinate.
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  1 n 1 3141  
177 0 0 6 193 3141 0 0 424 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_num_morphs
//       Access: Published
//  Description: Returns the number of columns within the format
//               that represent morph deltas.
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3170  
178 0 0 7 194 3155 0 0 587 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_morph_slider
//       Access: Published
//  Description: Returns the slider name associated with the nth morph
//               column.  This is the name of the slider that will
//               control the morph, and should be defined within the
//               SliderTable associated with the GeomVertexData.
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  1 n 1 3141  
179 0 0 7 195 3155 0 0 562 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_morph_base
//       Access: Published
//  Description: Returns the name of the base column that the nth
//               morph modifies.  This column will also be defined
//               within the format, and can be retrieved via
//               get_array_with() and/or get_column().
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  1 n 1 3141  
180 0 0 7 196 3155 0 0 685 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_morph_delta
//       Access: Published
//  Description: Returns the name of the column that defines the
//               nth morph.  This contains the delta offsets that are
//               to be applied to the column defined by
//               get_morph_base().  This column will be defined
//               within the format, and can be retrieved via
//               get_array_with() and/or get_column().
//
//               This may only be called after the format has been
//               registered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  1 n 1 3141  
181 0 0 4 197 3137 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 3170  3 out 1 3139  
182 0 0 4 198 3137 0 0 222 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::write
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 3 4 this 3 3170  3 out 1 3139  12 indent_level 1 3141  
183 0 0 4 199 3137 0 0 232 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::write_with_data
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 4 4 this 3 3170  3 out 1 3139  12 indent_level 1 3141  4 data 1 3172  
184 0 0 7 200 3170 0 0 322 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3
//       Access: Published, Static
//  Description: Returns a standard vertex format with just a
//               3-component vertex position.
//////////////////////////////////////////////////////////////////// 0 
185 0 0 7 201 3170 0 0 344 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 3-component
//               normal and a 3-component vertex position.
//////////////////////////////////////////////////////////////////// 0 
186 0 0 7 202 3170 0 0 378 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3t2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair and a 3-component vertex
//               position.
//////////////////////////////////////////////////////////////////// 0 
187 0 0 7 203 3170 0 0 403 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3t2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a 3-component normal, and a
//               3-component vertex position.
//////////////////////////////////////////////////////////////////// 0 
188 0 0 7 204 3170 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3cp
//       Access: Published, Static
//  Description: Returns a standard vertex format with a packed
//               color and a 3-component vertex position.
//////////////////////////////////////////////////////////////////// 0 
189 0 0 7 205 3170 0 0 397 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3cpt2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a packed color, and a
//               3-component vertex position.
//////////////////////////////////////////////////////////////////// 0 
190 0 0 7 206 3170 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3cp
//       Access: Published, Static
//  Description: Returns a standard vertex format with a packed
//               color, a 3-component normal, and a 3-component vertex
//               position.
//////////////////////////////////////////////////////////////////// 0 
191 0 0 7 207 3170 0 0 438 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3cpt2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a packed color, a
//               3-component normal, and a 3-component vertex
//               position.
//////////////////////////////////////////////////////////////////// 0 
192 0 0 7 208 3170 0 0 343 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3c4
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 4-component
//               color and a 3-component vertex position.
//////////////////////////////////////////////////////////////////// 0 
193 0 0 7 209 3170 0 0 402 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3c4t2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a 4-component color, and a
//               3-component vertex position.
//////////////////////////////////////////////////////////////////// 0 
194 0 0 7 210 3170 0 0 385 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3c4
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 4-component
//               color, a 3-component normal, and a 3-component vertex
//               position.
//////////////////////////////////////////////////////////////////// 0 
195 0 0 7 211 3170 0 0 443 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexFormat::get_v3n3c4t2
//       Access: Published, Static
//  Description: Returns a standard vertex format with a 2-component
//               texture coordinate pair, a 4-component color, a
//               3-component normal, and a 3-component vertex
//               position.
//////////////////////////////////////////////////////////////////// 0 
196 0 0 7 212 3158 0 0 0 0 
197 0 0 7 156 3167 0 0 0 1 4 this 3 3169  
198 0 0 7 157 3169 1691 0 0 1 4 this 3 3167  
199 0 0 6 158 3168 0 0 0 1 4 this 3 3169  
200 0 0 7 159 3169 1691 0 0 1 4 this 3 3168  
201 0 0 7 219 3174 1747 0 222 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 name 1 3131  8 max_size 1 3132  
202 0 0 6 221 3132 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::get_total_size
//       Access: Published
//  Description: Returns the total size of all objects currently
//               active on the LRU.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3175  
203 0 0 6 222 3132 0 0 317 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::get_max_size
//       Access: Published
//  Description: Returns the max size of all objects that are allowed
//               to be active on the LRU.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3175  
204 0 0 4 223 3137 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::set_max_size
//       Access: Published
//  Description: Changes the max size of all objects that are allowed
//               to be active on the LRU.
//
//               If the size is (size_t)-1, there is no limit.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3174  8 max_size 1 3132  
205 0 0 6 224 3132 0 0 337 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::count_active_size
//       Access: Published
//  Description: Returns the total size of the pages that were
//               enqueued since the last call to begin_epoch().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3175  
206 0 0 4 225 3137 0 0 275 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::consider_evict
//       Access: Published
//  Description: Evicts a sequence of objects if the queue is full.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3174  
207 0 0 4 226 3137 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::evict_to
//       Access: Published
//  Description: Evicts a sequence of objects until the queue fits
//               within the indicated target size, regardless of its
//               normal max size.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3174  11 target_size 1 3132  
208 0 0 4 227 3137 0 0 441 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::begin_epoch
//       Access: Published
//  Description: Marks the end of the previous epoch and the beginning
//               of the next one.  This will evict any objects that
//               are pending eviction, and also update any internal
//               bookkeeping.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3174  
209 0 0 6 228 3138 0 0 363 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::validate
//       Access: Published
//  Description: Checks that the LRU is internally self-consistent.
//               Returns true if successful, false if there is some
//               problem.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3174  
210 0 0 4 229 3137 0 0 217 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3175  3 out 1 3139  
211 0 0 4 230 3137 0 0 225 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLru::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3175  3 out 1 3139  12 indent_level 1 3141  
212 0 0 6 215 3177 0 0 0 1 4 this 3 3174  
213 0 0 6 216 3174 0 0 0 1 4 this 3 3177  
214 0 0 6 217 3178 0 0 0 1 4 this 3 3174  
215 0 0 6 218 3174 0 0 0 1 4 this 3 3178  
216 0 0 7 234 3181 1762 0 231 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::Copy Constructor
//       Access: Protected
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3179  
217 0 0 7 234 3181 1762 0 226 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::Constructor
//       Access: Protected
//  Description: 
//////////////////////////////////////////////////////////////////// 1 8 lru_size 1 3132  
218 0 0 6 235 3181 0 0 0 2 4 this 3 3181  4 copy 1 3179  
219 0 0 6 237 3174 0 0 329 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::get_lru
//       Access: Published
//  Description: Returns the LRU that manages this page, or NULL if it
//               is not currently managed by any LRU.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3179  
220 0 0 4 238 3137 0 0 443 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::enqueue_lru
//       Access: Published
//  Description: Adds the page to the LRU for the first time, or marks
//               it recently-accessed if it has already been added.
//
//               If lru is NULL, it means to remove this page from its
//               LRU.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3181  3 lru 1 3174  
221 0 0 4 239 3137 0 0 262 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::dequeue_lru
//       Access: Published
//  Description: Removes the page from its SimpleLru.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3181  
222 0 0 4 240 3137 0 0 481 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::mark_used_lru
//       Access: Published
//  Description: To be called when the page is used; this will move it
//               to the tail of the SimpleLru queue it is already on.
//
//               This method is const because it's not technically
//               modifying the contents of the page itself.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3179  
223 0 0 4 240 3137 0 0 344 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::mark_used_lru
//       Access: Published
//  Description: To be called when the page is used; this will move it
//               to the tail of the specified SimpleLru queue.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3181  3 lru 1 3174  
224 0 0 6 241 3132 0 0 318 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::get_lru_size
//       Access: Published
//  Description: Returns the size of this page as reported to the LRU,
//               presumably in bytes.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3179  
225 0 0 4 242 3137 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::set_lru_size
//       Access: Published
//  Description: Specifies the size of this page, presumably in bytes,
//               although any unit is possible.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3181  8 lru_size 1 3132  
226 0 0 4 243 3137 0 0 812 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::evict_lru
//       Access: Published, Virtual
//  Description: Evicts the page from the LRU.  Called internally when
//               the LRU determines that it is full.  May also be
//               called externally when necessary to explicitly evict
//               the page.
//
//               It is legal for this method to either evict the page
//               as requested, do nothing (in which case the eviction
//               will be requested again at the next epoch), or
//               requeue itself on the tail of the queue (in which
//               case the eviction will be requested again much
//               later).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3181  
227 0 0 4 244 3137 0 0 230 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3179  3 out 1 3139  
228 0 0 4 245 3137 0 0 229 ////////////////////////////////////////////////////////////////////
//     Function: SimpleLruPage::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3179  3 out 1 3139  12 indent_level 1 3141  
229 0 0 6 232 3177 0 0 0 1 4 this 3 3181  
230 0 0 6 233 3181 0 0 0 1 4 this 3 3177  
231 0 0 7 249 3184 1775 0 228 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 8 max_size 1 3132  4 lock 1 3182  
232 0 0 6 251 3185 0 0 451 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::alloc
//       Access: Published
//  Description: Allocates a new block.  Returns NULL if a block of the
//               requested size cannot be allocated.
//
//               To free the allocated block, call block->free(), or
//               simply delete the block pointer.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3184  4 size 1 3132  
233 0 0 6 252 3138 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::is_empty
//       Access: Published
//  Description: Returns true if there are no blocks allocated on this
//               page, or false if there is at least one.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3186  
234 0 0 6 253 3132 0 0 275 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::get_total_size
//       Access: Published
//  Description: Returns the total size of allocated objects.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3186  
235 0 0 6 254 3132 0 0 279 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::get_max_size
//       Access: Published
//  Description: Returns the available space for allocated objects.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3186  
236 0 0 4 255 3137 0 0 417 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::set_max_size
//       Access: Published
//  Description: Changes the available space for allocated objects.
//               This will not affect any already-allocated objects,
//               but will have an effect on future calls to alloc().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3184  8 max_size 1 3132  
237 0 0 6 256 3132 0 0 595 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::get_contiguous
//       Access: Published
//  Description: Returns an upper-bound estimate of the size of the
//               largest contiguous block that may be allocated.  It
//               is guaranteed that an attempt to allocate a block
//               larger than this will fail, though it is not
//               guaranteed that an attempt to allocate a block this
//               size or smaller will succeed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3186  
238 0 0 6 257 3185 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::get_first_block
//       Access: Published
//  Description: Returns a pointer to the first allocated block, or
//               NULL if there are no allocated blocks.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3186  
239 0 0 4 258 3137 0 0 223 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3186  3 out 1 3139  
240 0 0 4 259 3137 0 0 222 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocator::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3186  3 out 1 3139  
241 0 0 6 247 3177 0 0 0 1 4 this 3 3184  
242 0 0 6 248 3184 0 0 0 1 4 this 3 3177  
243 0 0 4 262 3137 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::free
//       Access: Published
//  Description: Releases the allocated space.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3185  
244 0 0 6 263 3184 0 0 351 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_allocator
//       Access: Published
//  Description: Returns the SimpleAllocator object that owns this
//               block.  Returns NULL if the block has been freed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3188  
245 0 0 6 264 3132 0 0 347 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_start
//       Access: Published
//  Description: Returns the starting point of this block.  It is an
//               error to call this if the block has been freed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3188  
246 0 0 6 265 3132 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_size
//       Access: Published
//  Description: Returns the size of this block.  It is an
//               error to call this if the block has been freed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3188  
247 0 0 6 266 3138 0 0 315 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::is_free
//       Access: Published
//  Description: Returns true if the block has been freed, false if it
//               is still valid.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3188  
248 0 0 6 267 3132 0 0 344 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_max_size
//       Access: Published
//  Description: Returns the maximum size this block can be
//               reallocated to, as limited by the following block.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3188  
249 0 0 6 268 3138 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::realloc
//       Access: Published
//  Description: Changes the size of this block to the specified size.
//               Returns true if the change is accepted, false if
//               there was not enough room.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3185  4 size 1 3132  
250 0 0 6 269 3185 0 0 359 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::get_next_block
//       Access: Published
//  Description: Returns a pointer to the next allocated block in the
//               chain, or NULL if there are no more allocated blocks.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3188  
251 0 0 4 270 3137 0 0 228 ////////////////////////////////////////////////////////////////////
//     Function: SimpleAllocatorBlock::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3188  3 out 1 3139  
252 0 0 6 272 3138 0 0 364 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataSaveFile::is_valid
//       Access: Public
//  Description: Returns true if the save file was successfully
//               created and is ready for use, false if there was an
//               error.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3190  
253 0 0 6 273 3132 0 0 334 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataSaveFile::get_total_file_size
//       Access: Public
//  Description: Returns the amount of space consumed by the save
//               file, including unused portions.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3190  
254 0 0 6 274 3132 0 0 326 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataSaveFile::get_used_file_size
//       Access: Public
//  Description: Returns the amount of space within the save file that
//               is currently in use.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3190  
255 0 0 6 281 3050 0 0 384 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_ram_class
//       Access: Published
//  Description: Returns the current ram class of the array.  If this
//               is other than RC_resident, the array data is not
//               resident in memory.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3192  
256 0 0 6 282 3050 0 0 484 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_pending_ram_class
//       Access: Published
//  Description: Returns the pending ram class of the array.  If this
//               is different from get_ram_class(), this page has been
//               queued to be processed by the thread.  Eventually the
//               page will be set to this ram class.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3192  
257 0 0 4 283 3137 0 0 379 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::request_resident
//       Access: Published
//  Description: Ensures that the page will become resident soon.
//               Future calls to get_page_data() will eventually
//               return non-NULL.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3194  
258 0 0 7 284 3195 1833 0 450 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::alloc
//       Access: Published
//  Description: Allocates a new block.  Returns NULL if a block of the
//               requested size cannot be allocated.
//
//               To free the allocated block, call block->free(), or
//               simply delete the block pointer.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3194  4 size 1 3132  
259 0 0 7 285 3195 1833 0 337 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_first_block
//       Access: Published
//  Description: Returns a pointer to the first allocated block, or
//               NULL if there are no allocated blocks.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3192  
260 0 0 6 286 3196 0 0 274 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_book
//       Access: Published
//  Description: Returns a pointer to the book that owns this page.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3192  
261 0 0 6 287 3174 0 0 377 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_global_lru
//       Access: Published, Static
//  Description: Returns a pointer to the global LRU object that
//               manages the VertexDataPage's with the indicated
//               RamClass.
//////////////////////////////////////////////////////////////////// 1 6 rclass 1 3050  
262 0 0 6 288 3174 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_pending_lru
//       Access: Published, Static
//  Description: Returns a pointer to the global LRU object that
//               manages the VertexDataPage's that are pending
//               processing by the thread.
//////////////////////////////////////////////////////////////////// 0 
263 0 0 6 289 3197 0 0 378 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_save_file
//       Access: Published, Static
//  Description: Returns the global VertexDataSaveFile that will be
//               used to save vertex data buffers to disk when
//               necessary.
//////////////////////////////////////////////////////////////////// 0 
264 0 0 6 290 3138 0 0 467 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::save_to_disk
//       Access: Published
//  Description: Writes the page to disk, but does not evict it from
//               memory or affect its LRU status.  If it gets evicted
//               later without having been modified, it will not need
//               to write itself to disk again.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3194  
265 0 0 6 291 3141 0 0 589 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_num_threads
//       Access: Published, Static
//  Description: Returns the number of threads that have been spawned
//               to service vertex paging requests, or 0 if no threads
//               have been spawned (which may mean either that all
//               paging requests will be handled by the main thread,
//               or simply that no paging requests have yet been
//               issued).
//////////////////////////////////////////////////////////////////// 0 
266 0 0 6 292 3141 0 0 342 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_num_pending_reads
//       Access: Published, Static
//  Description: Returns the number of read requests that are waiting
//               to be serviced by a thread.
//////////////////////////////////////////////////////////////////// 0 
267 0 0 6 293 3141 0 0 344 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::get_num_pending_writes
//       Access: Published, Static
//  Description: Returns the number of write requests that are waiting
//               to be serviced by a thread.
//////////////////////////////////////////////////////////////////// 0 
268 0 0 4 294 3137 0 0 397 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::stop_threads
//       Access: Published, Static
//  Description: Call this to stop the paging threads, if they were
//               started.  This may block until all of the pending
//               tasks have been completed.
//////////////////////////////////////////////////////////////////// 0 
269 0 0 4 295 3137 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::flush_threads
//       Access: Published, Static
//  Description: Waits for all of the pending thread tasks to finish
//               before returning.
//////////////////////////////////////////////////////////////////// 0 
270 0 0 4 296 3137 0 0 231 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3192  3 out 1 3139  
271 0 0 4 297 3137 0 0 230 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataPage::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3192  3 out 1 3139  12 indent_level 1 3141  
272 0 0 7 298 3158 0 0 0 0 
273 0 0 6 276 3184 0 0 0 1 4 this 3 3194  
274 0 0 6 277 3194 0 0 0 1 4 this 3 3184  
275 0 0 6 278 3181 0 0 0 1 4 this 3 3194  
276 0 0 6 279 3194 0 0 0 1 4 this 3 3181  
277 0 0 7 300 3196 1821 0 227 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 10 block_size 1 3132  
278 0 0 7 302 3195 1833 0 305 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::alloc
//       Access: Published
//  Description: Allocates and returns a new VertexDataBuffer of the
//               requested size.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3196  4 size 1 3132  
279 0 0 6 303 3141 0 0 278 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::get_num_pages
//       Access: Published
//  Description: Returns the number of pages created for the book.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3198  
280 0 0 6 304 3132 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::count_total_page_size
//       Access: Published
//  Description: Returns the total size of all bytes owned by all
//               pages owned by this book.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3198  
281 0 0 6 304 3132 0 0 379 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::count_total_page_size
//       Access: Published
//  Description: Returns the total size of all bytes owned by all
//               pages owned by this book that have the indicated ram
//               class.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3198  9 ram_class 1 3050  
282 0 0 6 305 3132 0 0 331 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::count_allocated_size
//       Access: Published
//  Description: Returns the total size of all bytes allocated within
//               pages owned by this book.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3198  
283 0 0 6 305 3132 0 0 382 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::count_allocated_size
//       Access: Published
//  Description: Returns the total size of all bytes allocated within
//               pages owned by this book that have the indicated ram
//               class.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3198  9 ram_class 1 3050  
284 0 0 4 306 3137 0 0 486 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBook::save_to_disk
//       Access: Published
//  Description: Writes all pages to disk immediately, just in case
//               they get evicted later.  It makes sense to make this
//               call just before taking down a loading screen, to
//               minimize chugs from saving pages inadvertently later.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3196  
285 0 0 6 313 3194 0 0 296 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBlock::get_page
//       Access: Published
//  Description: Returns the page from which this buffer was
//               allocated.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3200  
286 0 0 7 314 3195 1833 0 354 ////////////////////////////////////////////////////////////////////
//     Function: VertexDataBlock::get_next_block
//       Access: Published
//  Description: Returns a pointer to the next allocated block in the
//               chain, or NULL if there are no more allocated blocks.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3200  
287 0 0 6 308 3185 0 0 0 1 4 this 3 3195  
288 0 0 7 309 3195 1833 0 0 1 4 this 3 3185  
289 0 0 7 311 3202 0 0 0 1 4 this 3 3195  
290 0 0 7 312 3195 1833 0 0 1 4 this 3 3202  
291 0 0 7 325 3203 1842 0 237 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3165  
292 0 0 7 325 3203 1842 0 232 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 12 array_format 1 3163  10 usage_hint 1 3030  
293 0 0 7 326 3203 1842 0 0 2 4 this 3 3203  4 copy 1 3165  
294 0 0 4 328 3137 0 0 0 2 4 this 3 3203  4 size 1 3132  
295 0 0 6 331 3141 0 0 330 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::compare_to
//       Access: Published
//  Description: Returns 0 if the two arrays are equivalent, even if
//               they are not the same pointer.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3165  5 other 1 3165  
296 0 0 7 332 3163 0 0 289 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_array_format
//       Access: Published
//  Description: Returns the format object that describes this array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3165  
297 0 0 6 333 3030 0 0 409 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_usage_hint
//       Access: Published
//  Description: Returns the usage hint that describes to the
//               rendering backend how often the vertex data will be
//               modified and/or rendered.  See geomEnums.h.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3165  
298 0 0 4 334 3137 0 0 514 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::set_usage_hint
//       Access: Published
//  Description: Changes the UsageHint hint for this array.  See
//               get_usage_hint().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3203  10 usage_hint 1 3030  
299 0 0 6 335 3138 0 0 404 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::has_column
//       Access: Published
//  Description: Returns true if the array has the named column,
//               false otherwise.  This is really just a shortcut for
//               asking the same thing from the format.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3165  4 name 1 3155  
300 0 0 6 336 3141 0 0 454 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_num_rows
//       Access: Published
//  Description: Returns the number of rows stored in the array,
//               based on the number of bytes and the stride.  This
//               should be the same for all arrays within a given
//               GeomVertexData object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3165  
301 0 0 6 337 3138 0 0 1075 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::set_num_rows
//       Access: Published
//  Description: Sets the length of the array to n rows.
//
//               Normally, you would not call this directly, since all
//               of the arrays in a particular GeomVertexData must
//               have the same number of rows; instead, call
//               GeomVertexData::set_num_rows().
//
//               The return value is true if the number of rows
//               was changed, false if the object already contained n
//               rows (or if there was some error).
//
//               The new vertex data is initialized to 0, including
//               the "color" column (but see
//               GeomVertexData::set_num_rows()).
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3203  1 n 1 3141  
302 0 0 6 338 3138 0 0 757 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::unclean_set_num_rows
//       Access: Published
//  Description: This method behaves like set_num_rows(), except the
//               new data is not initialized.  Furthermore, after this
//               call, *any* of the data in the GeomVertexArrayData
//               may be uninitialized, including the earlier rows.
//
//               Normally, you would not call this directly, since all
//               of the arrays in a particular GeomVertexData must
//               have the same number of rows; instead, call
//               GeomVertexData::unclean_set_num_rows().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3203  1 n 1 3141  
303 0 0 6 339 3138 0 0 611 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::reserve_num_rows
//       Access: Published
//  Description: This ensures that enough memory space for n rows is
//               allocated, so that you may increase the number of
//               rows to n without causing a new memory allocation.
//               This is a performance optimization only; it is
//               especially useful when you know ahead of time that
//               you will be adding n rows to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3203  1 n 1 3141  
304 0 0 4 340 3137 0 0 329 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::clear_rows
//       Access: Published
//  Description: Removes all of the rows in the array.
//               Functionally equivalent to set_num_rows(0).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3203  
305 0 0 6 341 3141 0 0 288 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_data_size_bytes
//       Access: Published
//  Description: Returns the number of bytes stored in the array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3165  
306 0 0 7 342 3205 0 0 377 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the array vertex data is
//               modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3165  
307 0 0 4 343 3137 0 0 227 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3165  3 out 1 3139  
308 0 0 4 344 3137 0 0 226 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3165  3 out 1 3139  12 indent_level 1 3141  
309 0 0 6 345 3138 0 0 566 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::request_resident
//       Access: Published
//  Description: Returns true if the vertex data is currently resident
//               in memory.  If this returns true, the next call to
//               get_handle()->get_read_pointer() will probably not
//               block.  If this returns false, the vertex data will
//               be brought back into memory shortly; try again later.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3165  
310 0 0 7 346 3209 0 0 529 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_handle
//       Access: Published
//  Description: Returns an object that can be used to read the actual
//               data bytes stored in the array.  Calling this method
//               locks the data, and will block any other threads
//               attempting to read or write the data, until the
//               returned object destructs.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3165  14 current_thread 1 3207  
311 0 0 7 347 3210 1879 0 541 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::modify_handle
//       Access: Published
//  Description: Returns an object that can be used to read or write
//               the actual data bytes stored in the array.  Calling
//               this method locks the data, and will block any other
//               threads attempting to read or write the data, until
//               the returned object destructs.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3203  14 current_thread 1 3207  
312 0 0 4 348 3137 0 0 648 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::prepare
//       Access: Public
//  Description: Indicates that the data should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.  This will ensure the
//               data is already loaded into the GSG if it is expected
//               to be rendered soon.
//
//               Use this function instead of prepare_now() to preload
//               datas from a user interface standpoint.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3203  16 prepared_objects 1 3211  
313 0 0 6 349 3138 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::is_prepared
//       Access: Published
//  Description: Returns true if the data has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3165  16 prepared_objects 1 3211  
314 0 0 6 350 3214 0 0 894 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::prepare_now
//       Access: Public
//  Description: Creates a context for the data on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) VertexBufferContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               datas.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a data does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3203  16 prepared_objects 1 3211  3 gsg 1 3212  
315 0 0 6 351 3138 0 0 400 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::release
//       Access: Public
//  Description: Frees the data context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3203  16 prepared_objects 1 3211  
316 0 0 6 352 3141 0 0 398 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::release_all
//       Access: Public
//  Description: Frees the context allocated on all objects for which
//               the data has been declared.  Returns the number of
//               contexts which have been freed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3203  
317 0 0 6 353 3174 0 0 399 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_independent_lru
//       Access: Published, Static
//  Description: Returns a pointer to the global LRU object that
//               manages the GeomVertexArrayData's that have not (yet)
//               been paged out.
//////////////////////////////////////////////////////////////////// 0 
318 0 0 6 354 3174 0 0 400 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_small_lru
//       Access: Published, Static
//  Description: Returns a pointer to the global LRU object that
//               manages the GeomVertexArrayData's that are deemed too
//               small to be paged out.
//////////////////////////////////////////////////////////////////// 0 
319 0 0 4 355 3137 0 0 382 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::lru_epoch
//       Access: Published, Static
//  Description: Marks that an epoch has passed in each LRU.  Asks the
//               LRU's to consider whether they should perform
//               evictions.
//////////////////////////////////////////////////////////////////// 0 
320 0 0 6 356 3196 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::get_book
//       Access: Published, Static
//  Description: Returns the global VertexDataBook that will be
//               used to allocate vertex data buffers.
//////////////////////////////////////////////////////////////////// 0 
321 0 0 6 357 3141 0 0 0 3 4 this 3 3203  4 view 1 3215  5 flags 1 3141  
322 0 0 6 357 3141 0 0 0 3 4 this 3 3165  4 view 1 3215  5 flags 1 3141  
323 0 0 4 358 3137 0 0 0 2 4 this 3 3165  4 view 1 3215  
324 0 0 7 359 3158 0 0 0 0 
325 0 0 7 319 3217 0 0 0 1 4 this 3 3203  
326 0 0 7 320 3203 1842 0 0 1 4 this 3 3217  
327 0 0 6 321 3181 0 0 0 1 4 this 3 3203  
328 0 0 7 322 3203 1842 0 0 1 4 this 3 3181  
329 0 0 6 323 3168 0 0 0 1 4 this 3 3203  
330 0 0 7 324 3203 1842 0 0 1 4 this 3 3168  
331 0 0 7 366 3203 1842 0 236 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_object
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3210  
332 0 0 7 366 3165 0 0 236 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_object
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3209  
333 0 0 7 367 3163 0 0 242 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_array_format
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3209  
334 0 0 6 368 3030 0 0 240 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_usage_hint
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3209  
335 0 0 6 369 3141 0 0 238 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_num_rows
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3209  
336 0 0 6 370 3138 0 0 236 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::set_num_rows
//       Access: Public
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3210  1 n 1 3141  
337 0 0 6 371 3138 0 0 244 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::unclean_set_num_rows
//       Access: Public
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3210  1 n 1 3141  
338 0 0 6 372 3138 0 0 240 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::reserve_num_rows
//       Access: Public
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3210  1 n 1 3141  
339 0 0 4 373 3137 0 0 236 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::clear_rows
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3210  
340 0 0 6 374 3141 0 0 245 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_data_size_bytes
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3209  
341 0 0 7 375 3205 0 0 238 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_modified
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3209  
342 0 0 6 376 3138 0 0 566 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayData::request_resident
//       Access: Published
//  Description: Returns true if the vertex data is currently resident
//               in memory.  If this returns true, the next call to
//               get_handle()->get_read_pointer() will probably not
//               block.  If this returns false, the vertex data will
//               be brought back into memory shortly; try again later.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3209  
343 0 0 6 377 3214 0 0 900 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::prepare_now
//       Access: Public
//  Description: Creates a context for the data on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) VertexBufferContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               datas.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a data does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3209  16 prepared_objects 1 3211  3 gsg 1 3212  
344 0 0 4 378 3137 0 0 289 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::copy_data_from
//       Access: Public
//  Description: Copies the entire data array from the other object.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3210  5 other 1 3209  
345 0 0 4 378 3137 0 0 0 2 4 this 3 3210  6 buffer 1 3218  
346 0 0 4 379 3137 0 0 476 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::copy_subdata_from
//       Access: Public
//  Description: Copies a portion of the data array from the other
//               object into a portion of the data array of this
//               object.  If to_size != from_size, the size of this
//               data array is adjusted accordingly.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3210  8 to_start 1 3132  7 to_size 1 3132  5 other 1 3209  10 from_start 1 3132  9 from_size 1 3132  
347 0 0 4 379 3137 0 0 0 4 4 this 3 3210  8 to_start 1 3132  7 to_size 1 3132  6 buffer 1 3218  
348 0 0 4 379 3137 0 0 0 6 4 this 3 3210  8 to_start 1 3132  7 to_size 1 3132  6 buffer 1 3218  10 from_start 1 3132  9 from_size 1 3132  
349 0 0 6 380 3131 0 0 445 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_data
//       Access: Published
//  Description: Returns the entire raw data of the
//               GeomVertexArrayData object, formatted as a string.
//               This is primarily for the benefit of high-level
//               languages such as Python.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3209  
350 0 0 4 381 3137 0 0 415 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::set_data
//       Access: Public
//  Description: Replaces the entire raw data array with the contents
//               of the indicated string.  This is primarily for the
//               benefit of high-level languages like Python.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3210  4 data 1 3131  
351 0 0 6 382 3131 0 0 453 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::get_subdata
//       Access: Published
//  Description: Returns a subset of the raw data of the
//               GeomVertexArrayData object, formatted as a string.
//               This is primarily for the benefit of high-level
//               languages such as Python.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3209  5 start 1 3132  4 size 1 3132  
352 0 0 4 383 3137 0 0 518 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::set_subdata
//       Access: Public
//  Description: Replaces a portion of the data array from the
//               indicated string.  If size != data.size(), the size
//               of this data array is adjusted accordingly.
//
//               This is primarily for the benefit of high-level
//               languages like Python.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3210  5 start 1 3132  4 size 1 3132  4 data 1 3131  
353 0 0 4 384 3137 0 0 271 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexArrayDataHandle::mark_used
//       Access: Published
//  Description: Marks the array data recently-used.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3209  
354 0 0 7 385 3158 0 0 0 0 
355 0 0 7 361 3202 0 0 0 1 4 this 3 3210  
356 0 0 7 362 3210 1879 0 0 1 4 this 3 3202  
357 0 0 6 363 3168 0 0 0 1 4 this 3 3210  
358 0 0 7 364 3210 1879 0 0 1 4 this 3 3168  
359 0 0 4 387 3137 0 0 818 ////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::set_max_size
//       Access: Published
//  Description: Specifies the maximum number of entries in the cache
//               for storing pre-processed data for rendering
//               vertices.  This limit is flexible, and may be
//               temporarily exceeded if many different Geoms are
//               pre-processed during the space of a single frame.
//
//               This is not a limit on the actual vertex data, which
//               is what it is; it is also not a limit on the amount
//               of memory used by the video driver or the system
//               graphics interface, which Panda has no control over.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3221  8 max_size 1 3141  
360 0 0 6 388 3141 0 0 390 ////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::get_max_size
//       Access: Published
//  Description: Returns the maximum number of entries in the cache
//               for storing pre-processed data for rendering
//               vertices.  See set_max_size().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3221  
361 0 0 6 389 3141 0 0 285 ////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::get_total_size
//       Access: Published
//  Description: Returns the number of entries currently in the cache.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3221  
362 0 0 4 390 3137 0 0 269 ////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::flush
//       Access: Published
//  Description: Immediately empties all elements in the cache.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3223  
363 0 0 6 391 3223 0 0 281 ////////////////////////////////////////////////////////////////////
//     Function: GeomCacheManager::get_global_ptr
//       Access: Published, Static
//  Description: Returns the global cache manager pointer.
//////////////////////////////////////////////////////////////////// 0 
364 0 0 4 393 3137 0 0 0 2 4 this 3 3224  6 matrix 1 3226  
365 0 0 4 394 3137 0 0 579 ////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::mult_matrix
//       Access: Published, Virtual
//  Description: Premultiplies this transform's matrix with the
//               indicated previous matrix, so that the result is the
//               net composition of the given transform with this
//               transform.  The result is stored in the parameter
//               "result", which should not be the same matrix as
//               previous.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3224  6 result 1 3226  8 previous 1 3229  
366 0 0 4 395 3137 0 0 477 ////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::accumulate_matrix
//       Access: Published, Virtual
//  Description: Adds the value of this transform's matrix, modified
//               by the indicated weight, into the indicated
//               accumulation matrix.  This is used to compute the
//               result of several blended transforms.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3224  5 accum 1 3226  6 weight 1 3142  
367 0 0 7 396 3205 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::get_modified
//       Access: Published
//  Description: Returns a sequence number that's guaranteed to change
//               at least every time the value reported by
//               get_matrix() changes.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3224  14 current_thread 1 3207  
368 0 0 4 397 3137 0 0 232 ////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3224  3 out 1 3139  
369 0 0 4 398 3137 0 0 231 ////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3224  3 out 1 3139  12 indent_level 1 3141  
370 0 0 7 399 3205 0 0 765 ////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::get_next_modified
//       Access: Public, Static
//  Description: Returns a monotonically increasing sequence.  Each
//               time this is called, a new sequence number is
//               returned, higher than the previous value.
//
//               This is used to ensure that all
//               VertexTransform::get_modified() calls return an
//               increasing number in the same space, so that
//               TransformBlend::get_modified() is easy to determine.
//               It is similar to Geom::get_modified(), but it is in a
//               different space.
//////////////////////////////////////////////////////////////////// 1 14 current_thread 1 3207  
371 0 0 7 400 3205 0 0 474 ////////////////////////////////////////////////////////////////////
//     Function: VertexTransform::get_global_modified
//       Access: Published, Static
//  Description: Returns the currently highest
//               VertexTransform::get_modified() value in the world.
//               This can be used as a quick way to determine if any
//               VertexTransforms have changed value recently.
//////////////////////////////////////////////////////////////////// 1 14 current_thread 1 3207  
372 0 0 7 401 3158 0 0 0 0 
373 0 0 7 403 3231 0 0 227 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 0 
374 0 0 7 403 3231 0 0 232 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3232  
375 0 0 7 404 3231 0 0 0 2 4 this 3 3231  4 copy 1 3232  
376 0 0 6 405 3138 0 0 507 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::is_registered
//       Access: Published
//  Description: Returns true if this table has been registered.
//               Once it has been registered, the set of transforms in
//               a TransformTable may not be further modified; but
//               it must be registered before it can be assigned to a
//               Geom.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3232  
377 0 0 7 406 3232 0 0 927 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::register_table
//       Access: Published, Static
//  Description: Registers a TransformTable for use.  This is
//               similar to GeomVertexFormat::register_format().  Once
//               registered, a TransformTable may no longer be
//               modified (although the individual VertexTransform
//               objects may modify their reported transforms).
//
//               This must be called before a table may be used in a
//               Geom.  After this call, you should discard the
//               original pointer you passed in (which may or may not
//               now be invalid) and let its reference count decrement
//               normally; you should use only the returned value from
//               this point on.
//////////////////////////////////////////////////////////////////// 1 5 table 1 3232  
378 0 0 6 407 3141 0 0 280 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::get_num_transforms
//       Access: Published
//  Description: Returns the number of transforms in the table.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3232  
379 0 0 7 408 3224 0 0 268 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::get_transform
//       Access: Published
//  Description: Returns the nth transform in the table.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3232  1 n 1 3141  
380 0 0 7 409 3205 0 0 569 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::get_modified
//       Access: Published
//  Description: Returns a sequence number that's guaranteed to change
//               at least when any VertexTransforms in the table
//               change.  (However, this is only true for a registered
//               table.  An unregistered table may or may not
//               reflect an update here when a VertexTransform
//               changes.)
//////////////////////////////////////////////////////////////////// 2 4 this 3 3232  14 current_thread 1 3207  
381 0 0 4 410 3137 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::set_transform
//       Access: Published
//  Description: Replaces the nth transform.  Only valid for
//               unregistered tables.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3231  1 n 1 3141  9 transform 1 3224  
382 0 0 4 411 3137 0 0 312 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::remove_transform
//       Access: Published
//  Description: Removes the nth transform.  Only valid for
//               unregistered tables.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3231  1 n 1 3141  
383 0 0 6 412 3141 0 0 562 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::add_transform
//       Access: Published
//  Description: Adds a new transform to the table and returns the
//               index number of the new transform.  Only valid for
//               unregistered tables.
//
//               This does not automatically uniquify the pointer; if
//               the transform is already present in the table, it
//               will be added twice.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3231  9 transform 1 3224  
384 0 0 4 413 3137 0 0 221 ////////////////////////////////////////////////////////////////////
//     Function: TransformTable::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3232  3 out 1 3139  
385 0 0 7 414 3158 0 0 0 0 
386 0 0 7 416 3234 1928 0 227 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 0 
387 0 0 7 416 3234 1928 0 232 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3235  
388 0 0 7 416 3234 1928 0 227 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 10 transform0 1 3224  7 weight0 1 3142  
389 0 0 7 416 3234 1928 0 227 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 4 10 transform0 1 3224  7 weight0 1 3142  10 transform1 1 3224  7 weight1 1 3142  
390 0 0 7 416 3234 1928 0 227 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 6 10 transform0 1 3224  7 weight0 1 3142  10 transform1 1 3224  7 weight1 1 3142  10 transform2 1 3224  7 weight2 1 3142  
391 0 0 7 416 3234 1928 0 227 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 8 10 transform0 1 3224  7 weight0 1 3142  10 transform1 1 3224  7 weight1 1 3142  10 transform2 1 3224  7 weight2 1 3142  10 transform3 1 3224  7 weight3 1 3142  
392 0 0 6 417 3234 0 0 0 2 4 this 3 3234  4 copy 1 3235  
393 0 0 6 419 3141 0 0 300 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::compare_to
//       Access: Published
//  Description: Defines an arbitrary ordering for TransformBlend
//               objects.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3235  5 other 1 3235  
394 0 0 6 420 3138 0 0 0 2 4 this 3 3235  5 other 1 3235  
395 0 0 6 421 3138 0 0 0 2 4 this 3 3235  5 other 1 3235  
396 0 0 6 422 3138 0 0 0 2 4 this 3 3235  5 other 1 3235  
397 0 0 4 423 3137 0 0 344 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::add_transform
//       Access: Published
//  Description: Adds a new transform to the blend.  If the transform
//               already existed, increases its weight factor.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3234  9 transform 1 3224  6 weight 1 3142  
398 0 0 4 424 3137 0 0 279 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::remove_transform
//       Access: Published
//  Description: Removes the indicated transform from the blend.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3234  9 transform 1 3224  
399 0 0 4 425 3137 0 0 458 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::limit_transforms
//       Access: Published
//  Description: If the total number of transforms in the blend
//               exceeds max_transforms, removes the n least-important
//               transforms as needed to reduce the number of
//               transforms to max_transforms.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3234  14 max_transforms 1 3141  
400 0 0 4 426 3137 0 0 456 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::normalize_weights
//       Access: Published
//  Description: Rescales all of the weights on the various transforms
//               so that they sum to 1.0.  It is generally a good idea
//               to call this after adding or removing transforms from
//               the blend.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3234  
401 0 0 6 427 3138 0 0 317 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::has_transform
//       Access: Published
//  Description: Returns true if the blend has the indicated
//               transform, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3235  9 transform 1 3224  
402 0 0 6 428 3142 0 0 364 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_weight
//       Access: Published
//  Description: Returns the weight associated with the indicated
//               transform, or 0 if there is no entry for the
//               transform.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3235  9 transform 1 3224  
403 0 0 6 428 3142 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_weight
//       Access: Published
//  Description: Returns the weight associated with the nth transform
//               stored in the blend object.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3235  1 n 1 3141  
404 0 0 6 429 3141 0 0 311 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_num_transforms
//       Access: Published
//  Description: Returns the number of transforms stored in the blend
//               object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3235  
405 0 0 7 430 3224 0 0 299 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_transform
//       Access: Published
//  Description: Returns the nth transform stored in the blend
//               object.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3235  1 n 1 3141  
406 0 0 4 431 3137 0 0 300 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::set_transform
//       Access: Published
//  Description: Replaces the nth transform stored in the blend
//               object.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3234  1 n 1 3141  9 transform 1 3224  
407 0 0 4 432 3137 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::set_weight
//       Access: Published
//  Description: Replaces the weight associated with the nth transform
//               stored in the blend object.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3234  1 n 1 3141  6 weight 1 3142  
408 0 0 4 433 3137 0 0 405 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::update_blend
//       Access: Published
//  Description: Recomputes the internal representation of the blend
//               value, if necessary.  You should call this before
//               calling get_blend() or transform_point().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3235  14 current_thread 1 3207  
409 0 0 4 434 3137 0 0 522 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_blend
//       Access: Published
//  Description: Returns the current value of the blend, based on the
//               current value of all of the nested transform objects
//               and their associated weights.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3235  6 result 1 3226  14 current_thread 1 3207  
410 0 0 4 435 3137 0 0 419 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::transform_point (double)
//       Access: Published
//  Description: Transforms the indicated point by the blend matrix.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3235  5 point 1 3237  14 current_thread 1 3207  
411 0 0 4 435 3137 0 0 0 3 4 this 3 3235  5 point 1 3239  14 current_thread 1 3207  
412 0 0 4 435 3137 0 0 419 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::transform_point (double)
//       Access: Published
//  Description: Transforms the indicated point by the blend matrix.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3235  5 point 1 3241  14 current_thread 1 3207  
413 0 0 4 435 3137 0 0 0 3 4 this 3 3235  5 point 1 3243  14 current_thread 1 3207  
414 0 0 4 436 3137 0 0 421 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::transform_vector (double)
//       Access: Published
//  Description: Transforms the indicated vector by the blend matrix.
//
//               You should call update_blend() to ensure that the
//               cache is up-to-date before calling this.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3235  5 point 1 3245  14 current_thread 1 3207  
415 0 0 4 436 3137 0 0 0 3 4 this 3 3235  5 point 1 3247  14 current_thread 1 3207  
416 0 0 7 437 3205 0 0 351 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::get_modified
//       Access: Published
//  Description: Returns a counter which is guaranteed to increment at
//               least as often as the result of get_blend() changes.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3235  14 current_thread 1 3207  
417 0 0 4 438 3137 0 0 222 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3235  3 out 1 3139  
418 0 0 4 439 3137 0 0 221 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlend::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3235  3 out 1 3139  12 indent_level 1 3141  
419 0 0 7 440 3158 0 0 0 0 
420 0 0 7 442 3249 0 0 232 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 0 
421 0 0 7 442 3249 0 0 237 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3250  
422 0 0 7 443 3249 0 0 0 2 4 this 3 3249  4 copy 1 3250  
423 0 0 6 444 3141 0 0 322 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_num_blends
//       Access: Published
//  Description: Returns the total number of different blend
//               combinations in the table.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3250  
424 0 0 6 445 3235 0 0 265 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_blend
//       Access: Published
//  Description: Returns the nth blend in the table.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3250  1 n 1 3141  
425 0 0 7 446 3205 0 0 382 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_modified
//       Access: Published
//  Description: Returns a counter which is guaranteed to increment at
//               least when any TransformBlends within the table
//               have changed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3250  14 current_thread 1 3207  
426 0 0 4 447 3137 0 0 311 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::set_blend
//       Access: Published
//  Description: Replaces the blend at the nth position with the
//               indicated value.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3249  1 n 1 3141  5 blend 1 3235  
427 0 0 4 448 3137 0 0 271 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::remove_blend
//       Access: Published
//  Description: Removes the blend at the nth position.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3249  1 n 1 3141  
428 0 0 6 449 3141 0 0 414 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::add_blend
//       Access: Published
//  Description: Adds a new blend to the table, and returns its
//               index number.  If there is already an identical blend
//               in the table, simply returns that number instead.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3249  5 blend 1 3235  
429 0 0 6 450 3141 0 0 603 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_num_transforms
//       Access: Published
//  Description: Returns the number of unique VertexTransform objects
//               represented in the table.  This will correspond to
//               the size of the TransformTable object that would
//               represent the same table.  This is also the same
//               limit reflected by
//               GraphicsStateGuardian::get_max_vertex_transform_indices().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3250  
430 0 0 6 451 3141 0 0 503 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_max_simultaneous_transforms
//       Access: Published
//  Description: Returns the maximum number of unique VertexTransform
//               objects that are applied to any one vertex
//               simultaneously.  This is the same limit reflected by
//               GraphicsStateGuardian::get_max_vertex_transforms().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3250  
431 0 0 4 452 3137 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::set_rows
//       Access: Published
//  Description: Specifies the subset of rows (vertices) in the
//               associated GeomVertexData that this
//               TransformBlendTable actually affects.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3249  4 rows 1 3252  
432 0 0 6 453 3252 0 0 381 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::get_rows
//       Access: Published
//  Description: Returns the subset of rows (vertices) in the
//               associated GeomVertexData that this
//               TransformBlendTable actually affects.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3250  
433 0 0 6 454 3255 0 0 458 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::modify_rows
//       Access: Published
//  Description: Returns a modifiable reference to the SparseArray
//               that specifies the subset of rows (vertices) in the
//               associated GeomVertexData that this
//               TransformBlendTable actually affects.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3249  
434 0 0 4 455 3137 0 0 226 ////////////////////////////////////////////////////////////////////
//     Function: TransformBlendTable::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3250  3 out 1 3139  12 indent_level 1 3141  
435 0 0 7 456 3158 0 0 0 0 
436 0 0 7 458 3155 0 0 457 ////////////////////////////////////////////////////////////////////
//     Function: VertexSlider::get_name
//       Access: Published
//  Description: Returns the name of this particular slider.  Every
//               unique blend shape within a particular Geom must be
//               identified with a different name, which is shared by
//               the slider that controls it.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3256  
437 0 0 6 459 3142 0 0 0 1 4 this 3 3256  
438 0 0 7 460 3205 0 0 377 ////////////////////////////////////////////////////////////////////
//     Function: VertexSlider::get_modified
//       Access: Published
//  Description: Returns a sequence number that's guaranteed to change
//               at least every time the value reported by
//               get_slider() changes.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3256  14 current_thread 1 3207  
439 0 0 4 461 3137 0 0 229 ////////////////////////////////////////////////////////////////////
//     Function: VertexSlider::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3256  3 out 1 3139  
440 0 0 4 462 3137 0 0 228 ////////////////////////////////////////////////////////////////////
//     Function: VertexSlider::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3256  3 out 1 3139  12 indent_level 1 3141  
441 0 0 7 463 3158 0 0 0 0 
442 0 0 7 465 3258 0 0 224 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 0 
443 0 0 7 465 3258 0 0 229 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3259  
444 0 0 7 466 3258 0 0 0 2 4 this 3 3258  4 copy 1 3259  
445 0 0 6 467 3138 0 0 498 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::is_registered
//       Access: Published
//  Description: Returns true if this table has been registered.
//               Once it has been registered, the set of sliders in
//               a SliderTable may not be further modified; but
//               it must be registered before it can be assigned to a
//               Geom.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3259  
446 0 0 7 468 3259 0 0 912 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::register_table
//       Access: Published, Static
//  Description: Registers a SliderTable for use.  This is
//               similar to GeomVertexFormat::register_format().  Once
//               registered, a SliderTable may no longer be
//               modified (although the individual VertexSlider
//               objects may modify their reported sliders).
//
//               This must be called before a table may be used in a
//               Geom.  After this call, you should discard the
//               original pointer you passed in (which may or may not
//               now be invalid) and let its reference count decrement
//               normally; you should use only the returned value from
//               this point on.
//////////////////////////////////////////////////////////////////// 1 5 table 1 3259  
447 0 0 6 469 3141 0 0 271 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::get_num_sliders
//       Access: Published
//  Description: Returns the number of sliders in the table.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3259  
448 0 0 7 470 3256 0 0 259 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::get_slider
//       Access: Published
//  Description: Returns the nth slider in the table.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3259  1 n 1 3141  
449 0 0 6 471 3252 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::get_slider_rows
//       Access: Published
//  Description: Returns the set of rows (vertices) governed by the
//               nth slider in the table.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3259  1 n 1 3141  
450 0 0 6 472 3252 0 0 416 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::find_sliders
//       Access: Published
//  Description: Returns a list of slider indices that represent the
//               list of sliders with the indicated name, or an empty
//               SparseArray if no slider in the table has that name.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3259  4 name 1 3155  
451 0 0 6 473 3138 0 0 329 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::has_slider
//       Access: Published
//  Description: Returns true if the table has at least one slider by
//               the indicated name, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3259  4 name 1 3155  
452 0 0 6 474 3138 0 0 309 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::is_empty
//       Access: Published
//  Description: Returns true if the table has no sliders, false if it
//               has at least one.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3259  
453 0 0 7 475 3205 0 0 560 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::get_modified
//       Access: Published
//  Description: Returns a sequence number that's guaranteed to change
//               at least when any VertexSliders in the table
//               change.  (However, this is only true for a registered
//               table.  An unregistered table may or may not
//               reflect an update here when a VertexSlider
//               changes.)
//////////////////////////////////////////////////////////////////// 2 4 this 3 3259  14 current_thread 1 3207  
454 0 0 4 476 3137 0 0 301 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::set_slider
//       Access: Published
//  Description: Replaces the nth slider.  Only valid for
//               unregistered tables.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3258  1 n 1 3141  6 slider 1 3256  
455 0 0 4 477 3137 0 0 327 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::set_slider_rows
//       Access: Published
//  Description: Replaces the rows affected by the nth slider.  Only
//               valid for unregistered tables.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3258  1 n 1 3141  4 rows 1 3252  
456 0 0 4 478 3137 0 0 303 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::remove_slider
//       Access: Published
//  Description: Removes the nth slider.  Only valid for
//               unregistered tables.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3258  1 n 1 3141  
457 0 0 6 479 3141 0 0 373 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::add_slider
//       Access: Published
//  Description: Adds a new slider to the table, and returns the
//               index number of the new slider.  Only valid for
//               unregistered tables.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3258  6 slider 1 3256  4 rows 1 3252  
458 0 0 4 480 3137 0 0 218 ////////////////////////////////////////////////////////////////////
//     Function: SliderTable::write
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3259  3 out 1 3139  
459 0 0 7 481 3158 0 0 0 0 
460 0 0 7 487 3261 1995 0 231 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3172  
461 0 0 7 487 3261 1995 0 477 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::Constructor
//       Access: Published
//  Description: This constructor copies all of the basic properties
//               of the source VertexData, like usage_hint and
//               animation tables, but does not copy the actual data,
//               and it allows you to specify a different format.
//////////////////////////////////////////////////////////////////// 2 4 copy 1 3172  6 format 1 3170  
462 0 0 7 487 3261 1995 0 226 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 3 4 name 1 3131  6 format 1 3170  10 usage_hint 1 3030  
463 0 0 7 488 3261 1995 0 0 2 4 this 3 3261  4 copy 1 3172  
464 0 0 4 490 3137 0 0 0 2 4 this 3 3261  4 size 1 3132  
465 0 0 6 493 3141 0 0 326 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::compare_to
//       Access: Published
//  Description: Returns 0 if the two objects are equivalent, even if
//               they are not the same pointer.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3172  5 other 1 3172  
466 0 0 6 494 3131 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_name
//       Access: Published
//  Description: Returns the name passed to the constructor, if any.
//               This name is reported on the PStats graph for vertex
//               computations.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
467 0 0 4 495 3137 0 0 345 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_name
//       Access: Published
//  Description: Changes the name of the vertex data.  This name is
//               reported on the PStats graph for vertex computations.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  4 name 1 3131  
468 0 0 6 496 3030 0 0 778 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_usage_hint
//       Access: Published
//  Description: Returns the usage hint that was passed to the
//               constructor, and which will be passed to each array
//               data object created initially, and arrays created as
//               the result of a convert_to() operation.  See
//               geomEnums.h.
//
//               However, each individual array may be replaced with a
//               different array object with an independent usage hint
//               specified, so there is no guarantee that the
//               individual arrays all have the same usage_hint.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
469 0 0 4 497 3137 0 0 580 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_usage_hint
//       Access: Published
//  Description: Changes the UsageHint hint for this vertex data, and
//               for all of the arrays that share this data.  See
//               get_usage_hint().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  10 usage_hint 1 3030  
470 0 0 7 498 3170 0 0 318 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_format
//       Access: Published
//  Description: Returns a pointer to the GeomVertexFormat structure
//               that defines this data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
471 0 0 4 499 3137 0 0 585 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_format
//       Access: Published
//  Description: Changes the format of the vertex data.  If the data
//               is not empty, this will implicitly change every row
//               to match the new format.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  6 format 1 3170  
472 0 0 4 500 3137 0 0 784 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::unclean_set_format
//       Access: Published
//  Description: Changes the format of the vertex data, without
//               reformatting the data to match.  The data is exactly
//               the same after this operation, but will be
//               reinterpreted according to the new format.  This
//               assumes that the new format is fundamentally
//               compatible with the old format; in particular, it
//               must have the same number of arrays with the same
//               stride in each one.  No checking is performed that
//               the data remains sensible.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  6 format 1 3170  
473 0 0 6 501 3138 0 0 398 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::has_column
//       Access: Published
//  Description: Returns true if the data has the named column,
//               false otherwise.  This is really just a shortcut for
//               asking the same thing from the format.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3172  4 name 1 3155  
474 0 0 6 502 3141 0 0 362 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_num_rows
//       Access: Published
//  Description: Returns the number of rows stored within all the
//               arrays.  All arrays store data for the same n
//               rows.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
475 0 0 6 503 3138 0 0 1162 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_num_rows
//       Access: Published
//  Description: Sets the length of the array to n rows in all of
//               the various arrays (presumably by adding rows).
//
//               The new vertex data is initialized to 0, except for
//               the "color" column, which is initialized to (1, 1, 1,
//               1).
//
//               The return value is true if the number of rows
//               was changed, false if the object already contained n
//               rows (or if there was some error).
//
//               This can be used when you know exactly how many
//               rows you will be needing.  It is faster than
//               reserve_num_rows().  Also see unclean_set_num_rows()
//               if you are planning to fill in all the data yourself.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  1 n 1 3141  
476 0 0 6 504 3138 0 0 893 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::unclean_set_num_rows
//       Access: Published
//  Description: This method behaves like set_num_rows(), except the
//               new data is not initialized.  Furthermore, after this
//               call, *any* of the data in the GeomVertexData may be
//               uninitialized, including the earlier rows.
//
//               This is intended for applications that are about to
//               completely fill the GeomVertexData with new data
//               anyway; it provides a tiny performance boost over
//               set_num_rows().
//
//               This can be used when you know exactly how many
//               rows you will be needing.  It is faster than
//               reserve_num_rows().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  1 n 1 3141  
477 0 0 6 505 3138 0 0 799 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::reserve_num_rows
//       Access: Published
//  Description: This ensures that enough memory space for n rows is
//               allocated, so that you may increase the number of
//               rows to n without causing a new memory allocation.
//               This is a performance optimization only; it is
//               especially useful when you know ahead of time that
//               you will be adding n rows to the data.
//
//               If you know exactly how many rows you will be
//               needing, it is significantly faster to use
//               set_num_rows() or unclean_set_num_rows() instead.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  1 n 1 3141  
478 0 0 4 506 3137 0 0 554 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_rows
//       Access: Published
//  Description: Removes all of the rows from the arrays;
//               functionally equivalent to set_num_rows(0) (but
//               faster).
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3261  
479 0 0 6 507 3141 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_num_arrays
//       Access: Published
//  Description: Returns the number of individual arrays stored within
//               the data.  This must match
//               get_format()->get_num_arrays().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
480 0 0 7 508 3165 0 0 412 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_array
//       Access: Published
//  Description: Returns a const pointer to the vertex data for the
//               indicated array, for application code to directly
//               examine (but not modify) the underlying vertex data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3172  1 i 1 3141  
481 0 0 7 509 3203 1842 0 757 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::modify_array
//       Access: Published
//  Description: Returns a modifiable pointer to the indicated vertex
//               array, so that application code may directly
//               manipulate the data.  You should avoid changing
//               the length of this array, since all of the arrays
//               should be kept in sync--use set_num_rows()
//               instead.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  1 i 1 3141  
482 0 0 4 510 3137 0 0 667 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_array
//       Access: Published
//  Description: Replaces the indicated vertex data array with
//               a completely new array.  You should be careful that
//               the new array has the same length and format as the
//               old one, unless you know what you are doing.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3261  1 i 1 3141  5 array 1 3165  
483 0 0 7 511 3232 0 0 868 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_transform_table
//       Access: Published
//  Description: Returns a const pointer to the TransformTable
//               assigned to this data.  Vertices within the table
//               will index into this table to indicate their
//               dynamic skinning information; this table is used when
//               the vertex animation is to be performed by the
//               graphics hardware (but also see
//               get_transform_blend_table()).
//
//               This will return NULL if the vertex data does not
//               have a TransformTable assigned (which implies the
//               vertices will not be animated by the graphics
//               hardware).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
484 0 0 4 512 3137 0 0 708 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_transform_table
//       Access: Published
//  Description: Replaces the TransformTable on this vertex
//               data with the indicated table.  The length of this
//               table should be consistent with the maximum table
//               index assigned to the vertices under the
//               "transform_index" name.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  5 table 1 3232  
485 0 0 4 513 3137 0 0 401 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_transform_table
//       Access: Published
//  Description: Sets the TransformTable pointer to NULL,
//               removing the table from the vertex data.  This
//               disables hardware-driven vertex animation.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3261  
486 0 0 7 514 3250 0 0 816 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_transform_blend_table
//       Access: Published
//  Description: Returns a const pointer to the TransformBlendTable
//               assigned to this data.  Vertices within the table
//               will index into this table to indicate their
//               dynamic skinning information; this table is used when
//               the vertex animation is to be performed by the CPU
//               (but also see get_transform_table()).
//
//               This will return NULL if the vertex data does not
//               have a TransformBlendTable assigned (which implies
//               the vertices will not be animated by the CPU).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
487 0 0 7 515 3249 0 0 665 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::modify_transform_blend_table
//       Access: Published
//  Description: Returns a modifiable pointer to the current
//               TransformBlendTable on this vertex data, if any, or
//               NULL if there is not a TransformBlendTable.  See
//               get_transform_blend_table().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3261  
488 0 0 4 516 3137 0 0 719 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_transform_blend_table
//       Access: Published
//  Description: Replaces the TransformBlendTable on this vertex
//               data with the indicated table.  The length of this
//               table should be consistent with the maximum table
//               index assigned to the vertices under the
//               "transform_blend" name.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  5 table 1 3250  
489 0 0 4 517 3137 0 0 407 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_transform_blend_table
//       Access: Published
//  Description: Sets the TransformBlendTable pointer to NULL,
//               removing the table from the vertex data.  This
//               disables CPU-driven vertex animation.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3261  
490 0 0 7 518 3259 0 0 558 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_slider_table
//       Access: Published
//  Description: Returns a const pointer to the SliderTable
//               assigned to this data.  Vertices within the vertex
//               data will look up their morph offsets, if any, within
//               this table.
//
//               This will return NULL if the vertex data does not
//               have a SliderTable assigned.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
491 0 0 4 519 3137 0 0 777 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_slider_table
//       Access: Published
//  Description: Replaces the SliderTable on this vertex
//               data with the indicated table.  There should be an
//               entry in this table for each kind of morph offset
//               defined in the vertex data.
//
//               The SliderTable object must have been registered
//               prior to setting it on the GeomVertexData.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  5 table 1 3259  
492 0 0 4 520 3137 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_slider_table
//       Access: Published
//  Description: Sets the SliderTable pointer to NULL,
//               removing the table from the vertex data.  This
//               disables morph (blend shape) animation.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3261  
493 0 0 6 521 3141 0 0 332 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_num_bytes
//       Access: Published
//  Description: Returns the total number of bytes consumed by the
//               different arrays of the vertex data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
494 0 0 7 522 3205 0 0 366 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::get_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the vertex data is
//               modified.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3172  14 current_thread 1 3207  
495 0 0 6 523 3138 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::request_resident
//       Access: Published
//  Description: Returns true if the vertex data is currently resident
//               in memory.  If this returns false, the vertex data will
//               be brought back into memory shortly; try again later.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
496 0 0 4 524 3137 0 0 1099 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::copy_from
//       Access: Published
//  Description: Copies all the data from the other array into the
//               corresponding data types in this array, by matching
//               data types name-by-name.
//
//               keep_data_objects specifies what to do when one or
//               more of the arrays can be copied without the need to
//               apply any conversion operation.  If it is true, the
//               original GeomVertexArrayData objects in this object
//               are retained, and their data arrays are copied
//               byte-by-byte from the source; if it is false, then the
//               GeomVertexArrayData objects are copied pointerwise
//               from the source.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3261  6 source 1 3172  17 keep_data_objects 1 3138  14 current_thread 1 3207  
497 0 0 4 525 3137 0 0 643 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::copy_row_from
//       Access: Published
//  Description: Copies a single row of the data from the other array
//               into the indicated row of this array.  In this case,
//               the source format must exactly match the destination
//               format.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3261  8 dest_row 1 3141  6 source 1 3172  10 source_row 1 3141  14 current_thread 1 3207  
498 0 0 7 526 3172 0 0 408 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::convert_to
//       Access: Published
//  Description: Returns a new GeomVertexData that represents the same
//               contents as this one, with all data types matched up
//               name-by-name to the indicated new format.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3172  10 new_format 1 3170  
499 0 0 7 527 3172 0 0 466 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::scale_color
//       Access: Published
//  Description: Returns a new GeomVertexData object with the color
//               table modified in-place to apply the indicated scale.
//
//               If the vertex data does not include a color column, a
//               new one will not be added.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3172  11 color_scale 1 3262  
500 0 0 7 527 3172 0 0 599 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::scale_color
//       Access: Published
//  Description: Returns a new GeomVertexData object with the color
//               table replaced with a new color table that has been
//               scaled by the indicated value.  The new color table
//               will be added as a new array; if the old color table
//               was interleaved with a previous array, the previous
//               array will not be repacked.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3172  11 color_scale 1 3262  14 num_components 1 3141  12 numeric_type 1 3034  8 contents 1 3035  
501 0 0 7 528 3172 0 0 453 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_color
//       Access: Published
//  Description: Returns a new GeomVertexData object with the color
//               data modified in-place with the new value.
//
//               If the vertex data does not include a color column, a
//               new one will not be added.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3172  5 color 1 3266  
502 0 0 7 528 3172 0 0 599 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::set_color
//       Access: Published
//  Description: Returns a new GeomVertexData object with the color
//               table replaced with a new color table for which each
//               vertex has the indicated value.  The new color table
//               will be added as a new array; if the old color table
//               was interleaved with a previous array, the previous
//               array will not be repacked.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3172  5 color 1 3266  14 num_components 1 3141  12 numeric_type 1 3034  8 contents 1 3035  
503 0 0 7 529 3172 0 0 577 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::reverse_normals
//       Access: Published
//  Description: Returns a new GeomVertexData object with the normal
//               data modified in-place, so that each lighting normal
//               is now facing in the opposite direction.
//
//               If the vertex data does not include a normal column,
//               this returns the original GeomVertexData object,
//               unchanged.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3172  
504 0 0 7 530 3172 0 0 1321 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::animate_vertices
//       Access: Published
//  Description: Returns a GeomVertexData that represents the results
//               of computing the vertex animation on the CPU for this
//               GeomVertexData.
//
//               If there is no CPU-defined vertex animation on this
//               object, this just returns the original object.
//
//               If there is vertex animation, but the VertexTransform
//               values have not changed since last time, this may
//               return the same pointer it returned previously.  Even
//               if the VertexTransform values have changed, it may
//               still return the same pointer, but with its contents
//               modified (this is preferred, since it allows the
//               graphics backend to update vertex buffers optimally).
//
//               If force is false, this method may return immediately
//               with stale data, if the vertex data is not completely
//               resident.  If force is true, this method will never
//               return stale data, but may block until the data is
//               available.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3172  5 force 1 3138  14 current_thread 1 3207  
505 0 0 4 531 3137 0 0 555 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_animated_vertices
//       Access: Published
//  Description: Removes the cache of animated vertices computed by a
//               previous call to animate_vertices() within the same
//               frame.  This will force the next call to
//               animate_vertices() to recompute these values from
//               scratch.  Normally it is not necessary to call this.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3261  
506 0 0 4 532 3137 0 0 461 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::transform_vertices
//       Access: Published
//  Description: Applies the indicated transform matrix to all of the
//               vertices in the GeomVertexData.  The transform is
//               applied to all "point" and "vector" type columns
//               described in the format.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3261  3 mat 1 3229  
507 0 0 4 532 3137 0 0 486 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::transform_vertices
//       Access: Published
//  Description: Applies the indicated transform matrix to all of the
//               vertices from begin_row up to but not including
//               end_row.  The transform is applied to all "point" and
//               "vector" type columns described in the format.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3261  3 mat 1 3229  9 begin_row 1 3141  7 end_row 1 3141  
508 0 0 7 533 3261 1995 0 776 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::replace_column
//       Access: Published
//  Description: Returns a new GeomVertexData object, suitable for
//               modification, with the indicated data type replaced
//               with a new table filled with undefined values.  The
//               new table will be added as a new array; if the old
//               table was interleaved with a previous array, the
//               previous array will not be repacked.
//
//               If num_components is 0, the indicated name is simply
//               removed from the type, without replacing it with
//               anything else.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3172  4 name 1 3154  14 num_components 1 3141  12 numeric_type 1 3034  8 contents 1 3035  
509 0 0 4 534 3137 0 0 221 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 3172  3 out 1 3139  
510 0 0 4 535 3137 0 0 220 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::write
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 3 4 this 3 3172  3 out 1 3139  12 indent_level 1 3141  
511 0 0 4 536 3137 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::describe_vertex
//       Access: Published
//  Description: Writes a verbose, human-friendly description of the
//               indicated vertex number.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3172  3 out 1 3139  3 row 1 3141  
512 0 0 4 537 3137 0 0 556 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_cache
//       Access: Published
//  Description: Removes all of the previously-cached results of
//               convert_to().
//
//               This blows away the entire cache, upstream and
//               downstream the pipeline.  Use clear_cache_stage()
//               instead if you only want to blow away the cache at
//               the current stage and upstream.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3261  
513 0 0 4 538 3137 0 0 608 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexData::clear_cache_stage
//       Access: Published
//  Description: Removes all of the previously-cached results of
//               convert_to(), at the current pipeline stage and
//               upstream.  Does not affect the downstream cache.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3261  
514 0 0 7 539 3158 0 0 0 0 
515 0 0 7 483 3217 0 0 0 1 4 this 3 3261  
516 0 0 7 484 3261 1995 0 0 1 4 this 3 3217  
517 0 0 6 485 3168 0 0 0 1 4 this 3 3261  
518 0 0 7 486 3261 1995 0 0 1 4 this 3 3168  
519 0 0 7 542 3270 2049 0 271 ////////////////////////////////////////////////////////////////////
//     Function: AnimateVerticesRequest::Constructor
//       Access: Published
//  Description: Create a new AnimateVerticesRequest.
//////////////////////////////////////////////////////////////////// 1 16 geom_vertex_data 1 3261  
520 0 0 6 543 3138 0 0 322 ////////////////////////////////////////////////////////////////////
//     Function: AnimateVerticesRequest::is_ready
//       Access: Published
//  Description: Returns true if this request has completed, false if
//               it is still pending.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3271  
521 0 0 7 544 3158 0 0 0 0 
522 0 0 7 548 3158 0 0 0 0 
523 0 0 6 554 3132 0 0 550 ////////////////////////////////////////////////////////////////////
//     Function: BufferContext::get_data_size_bytes
//       Access: Public
//  Description: Returns the number of bytes previously reported for
//               the data object.  This is used to track changes in
//               the data object's allocated size; if it changes from
//               this, we need to create a new buffer.  This is also
//               used to track memory utilization in PStats.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3273  
524 0 0 7 555 3205 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: BufferContext::get_modified
//       Access: Public
//  Description: Returns the UpdateSeq that was recorded the last time
//               mark_loaded() was called.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3273  
525 0 0 6 556 3138 0 0 382 ////////////////////////////////////////////////////////////////////
//     Function: BufferContext::get_active
//       Access: Public
//  Description: Returns the active flag associated with this object.
//               An object is considered "active" if it was rendered
//               in the current frame.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3273  
526 0 0 6 557 3138 0 0 396 ////////////////////////////////////////////////////////////////////
//     Function: BufferContext::get_resident
//       Access: Public
//  Description: Returns the resident flag associated with this
//               object.  An object is considered "resident" if it
//               appears to be resident in texture memory.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3273  
527 0 0 7 558 3158 0 0 0 0 
528 0 0 6 551 3276 0 0 0 1 4 this 3 3275  
529 0 0 6 552 3275 0 0 0 1 4 this 3 3276  
530 0 0 7 564 3277 2065 0 0 2 4 this 3 3277  4 copy 1 3278  
531 0 0 4 566 3137 0 0 0 2 4 this 3 3277  4 size 1 3132  
532 0 0 7 569 3277 2065 0 0 1 4 this 3 3278  
533 0 0 6 570 3033 0 0 0 1 4 this 3 3278  
534 0 0 6 571 3141 0 0 397 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_geom_rendering
//       Access: Published, Virtual
//  Description: Returns the set of GeomRendering bits that represent
//               the rendering properties required to properly render
//               this primitive.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
535 0 0 6 572 3032 0 0 416 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_shade_model
//       Access: Published
//  Description: Returns the ShadeModel hint for this primitive.
//               This is intended as a hint to the renderer to tell it
//               how the per-vertex colors and normals are applied.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
536 0 0 4 573 3137 0 0 865 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_shade_model
//       Access: Published
//  Description: Changes the ShadeModel hint for this primitive.
//               This is different from the ShadeModelAttrib that
//               might also be applied from the scene graph.  This
//               does not affect the shade model that is in effect
//               when rendering, but rather serves as a hint to the
//               renderer to tell it how the per-vertex colors and
//               normals on this primitive are applied.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3277  11 shade_model 1 3032  
537 0 0 6 574 3030 0 0 921 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_usage_hint
//       Access: Published
//  Description: Returns the usage hint for this primitive.  See
//               geomEnums.h.  This has nothing to do with the usage
//               hint associated with the primitive's vertices; this
//               only specifies how often the vertex indices that
//               define the primitive will be modified.
//
//               It is perfectly legal (and, in fact, common) for a
//               GeomPrimitive to have UH_static on itself, while
//               referencing vertex data with UH_dynamic.  This means
//               that the vertices themselves will be animated, but
//               the primitive will always reference the same set of
//               vertices from the pool.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
538 0 0 4 575 3137 0 0 512 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_usage_hint
//       Access: Published
//  Description: Changes the UsageHint hint for this primitive.  See
//               get_usage_hint().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3277  10 usage_hint 1 3030  
539 0 0 6 576 3034 0 0 342 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_index_type
//       Access: Public
//  Description: Returns the numeric type of the index column.
//               Normally, this will be either NT_uint16 or NT_uint32.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
540 0 0 4 577 3137 0 0 939 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_index_type
//       Access: Published
//  Description: Changes the numeric type of the index column.
//               Normally, this should be either NT_uint16 or
//               NT_uint32.
//
//               The index type must be large enough to include all of
//               the index values in the primitive.  It may be
//               automatically elevated, if necessary, to a larger
//               index type, by a subsequent call to add_index() that
//               names an index value that does not fit in the index
//               type you specify.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3277  10 index_type 1 3034  
541 0 0 6 578 3138 0 0 439 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::is_composite
//       Access: Published
//  Description: Returns true if the primitive is a composite
//               primitive such as a tristrip or trifan, or false if
//               it is a fundamental primitive such as a collection of
//               triangles.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
542 0 0 6 579 3138 0 0 683 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::is_indexed
//       Access: Published
//  Description: Returns true if the primitive is indexed, false
//               otherwise.  An indexed primitive stores a table of
//               index numbers into its GeomVertexData, so that it can
//               reference the vertices in any order.  A nonindexed
//               primitive, on the other hand, stores only the first
//               vertex number and number of vertices used, so that it
//               can only reference the vertices consecutively.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
543 0 0 6 580 3141 0 0 536 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_first_vertex
//       Access: Published
//  Description: Returns the first vertex number referenced by the
//               primitive.  This is particularly important in the
//               case of a nonindexed primitive, in which case
//               get_first_vertex() and get_num_vertices() completely
//               define the extent of the vertex range.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
544 0 0 6 581 3141 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_vertices
//       Access: Published
//  Description: Returns the number of indices used by all the
//               primitives in this object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
545 0 0 6 582 3141 0 0 267 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_vertex
//       Access: Published
//  Description: Returns the ith vertex index in the table.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  1 i 1 3141  
546 0 0 4 583 3137 0 0 780 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_vertex
//       Access: Published
//  Description: Adds the indicated vertex to the list of vertex
//               indices used by the graphics primitive type.  To
//               define a primitive, you must call add_vertex() for
//               each vertex of the new primitive, and then call
//               close_primitive() after you have specified the last
//               vertex of each primitive.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3277  6 vertex 1 3141  
547 0 0 4 584 3137 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_vertices
//       Access: Public
//  Description: Adds several vertices in a row.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3277  2 v1 1 3141  2 v2 1 3141  
548 0 0 4 584 3137 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_vertices
//       Access: Public
//  Description: Adds several vertices in a row.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3277  2 v1 1 3141  2 v2 1 3141  2 v3 1 3141  
549 0 0 4 584 3137 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_vertices
//       Access: Public
//  Description: Adds several vertices in a row.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3277  2 v1 1 3141  2 v2 1 3141  2 v3 1 3141  2 v4 1 3141  
550 0 0 4 585 3137 0 0 531 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_consecutive_vertices
//       Access: Published
//  Description: Adds a consecutive sequence of vertices, beginning at
//               start, to the primitive.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3277  5 start 1 3141  12 num_vertices 1 3141  
551 0 0 4 586 3137 0 0 621 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::add_next_vertices
//       Access: Published
//  Description: Adds the next n vertices in sequence, beginning from
//               the last vertex added to the primitive + 1.
//
//               This is most useful when you are building up a
//               primitive and a GeomVertexData at the same time, and
//               you just want the primitive to reference the first n
//               vertices from the data, then the next n, and so on.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3277  12 num_vertices 1 3141  
552 0 0 4 587 3137 0 0 1259 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::reserve_num_vertices
//       Access: Published
//  Description: This ensures that enough memory space for n vertices
//               is allocated, so that you may increase the number of
//               vertices to n without causing a new memory
//               allocation.  This is a performance optimization only;
//               it is especially useful when you know ahead of time
//               that you will be adding n vertices to the primitive.
//
//               Note that the total you specify here should also
//               include implicit vertices which may be added at each
//               close_primitive() call, according to
//               get_num_unused_vertices_per_primitive().
//
//               Note also that making this call will implicitly make
//               the primitive indexed if it is not already, which
//               could result in a performance *penalty*.  If you
//               would prefer not to lose the nonindexed nature of
//               your existing GeomPrimitives, check is_indexed()
//               before making this call.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3277  12 num_vertices 1 3141  
553 0 0 6 588 3138 0 0 654 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::close_primitive
//       Access: Published
//  Description: Indicates that the previous n calls to add_vertex(),
//               since the last call to close_primitive(), have fully
//               defined a new primitive.  Returns true if successful,
//               false otherwise.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3277  
554 0 0 4 589 3137 0 0 527 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::clear_vertices
//       Access: Published
//  Description: Removes all of the vertices and primitives from the
//               object, so they can be re-added.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3277  
555 0 0 4 590 3137 0 0 508 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::offset_vertices
//       Access: Published
//  Description: Adds the indicated offset to all vertices used by the
//               primitive.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3277  6 offset 1 3141  
556 0 0 4 590 3137 0 0 662 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::offset_vertices
//       Access: Published
//  Description: Adds the indicated offset to the indicated segment
//               of vertices used by the primitive.  Unlike the
//               other version of offset_vertices, this makes the
//               geometry indexed if it isn't already.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3277  6 offset 1 3141  9 begin_row 1 3141  7 end_row 1 3141  
557 0 0 4 591 3137 0 0 466 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_nonindexed
//       Access: Published
//  Description: Converts the primitive from indexed to nonindexed by
//               duplicating vertices as necessary into the indicated
//               dest GeomVertexData.  Note: does not support
//               primitives with strip cut indices.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3277  4 dest 1 3261  6 source 1 3172  
558 0 0 4 592 3137 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::pack_vertices
//       Access: Published
//  Description: Packs the vertices used by the primitive from the
//               indicated source array onto the end of the indicated
//               destination array.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3277  4 dest 1 3261  6 source 1 3172  
559 0 0 4 593 3137 0 0 817 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_indexed
//       Access: Published
//  Description: Converts the primitive from nonindexed form to
//               indexed form.  This will simply create an index table
//               that is numbered consecutively from
//               get_first_vertex(); it does not automatically
//               collapse together identical vertices that may have
//               been split apart by a previous call to
//               make_nonindexed().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3277  
560 0 0 6 594 3141 0 0 372 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_primitives
//       Access: Published
//  Description: Returns the number of individual primitives stored
//               within this object.  All primitives are the same
//               type.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
561 0 0 6 595 3141 0 0 798 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_start
//       Access: Published
//  Description: Returns the element within the _vertices list at which
//               the nth primitive starts.
//
//               If i is one more than the highest valid primitive
//               vertex, the return value will be one more than the
//               last valid vertex.  Thus, it is generally true that
//               the vertices used by a particular primitive i are the
//               set get_primitive_start(n) <= vi <
//               get_primitive_start(n + 1) (although this range also
//               includes the unused vertices between primitives).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  1 n 1 3141  
562 0 0 6 596 3141 0 0 408 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_end
//       Access: Published
//  Description: Returns the element within the _vertices list at which
//               the nth primitive ends.  This is one past the last
//               valid element for the nth primitive.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  1 n 1 3141  
563 0 0 6 597 3141 0 0 406 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_num_vertices
//       Access: Published
//  Description: Returns the number of vertices used by the nth
//               primitive.  This is the same thing as
//               get_primitive_end(n) - get_primitive_start(n).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  1 n 1 3141  
564 0 0 6 598 3141 0 0 579 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_used_vertices
//       Access: Published
//  Description: Returns the number of vertices used by all of the
//               primitives.  This is the same as summing
//               get_primitive_num_vertices(n) for n in
//               get_num_primitives().  It is like get_num_vertices
//               except that it excludes all of the degenerate
//               vertices and strip-cut indices.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
565 0 0 6 599 3141 0 0 393 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_faces
//       Access: Published
//  Description: Returns the number of triangles or other fundamental
//               type (such as line segments) represented by all the
//               primitives in this object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
566 0 0 6 600 3141 0 0 402 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_num_faces
//       Access: Published
//  Description: Returns the number of triangles or other fundamental
//               type (such as line segments) represented by the nth
//               primitive in this object.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  1 n 1 3141  
567 0 0 6 601 3141 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_min_vertex
//       Access: Published
//  Description: Returns the minimum vertex index number used by all
//               the primitives in this object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
568 0 0 6 602 3141 0 0 337 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_min_vertex
//       Access: Published
//  Description: Returns the minimum vertex index number used by the
//               nth primitive in this object.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  1 n 1 3141  
569 0 0 6 603 3141 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_max_vertex
//       Access: Published
//  Description: Returns the maximum vertex index number used by all
//               the primitives in this object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
570 0 0 6 604 3141 0 0 337 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_primitive_max_vertex
//       Access: Published
//  Description: Returns the maximum vertex index number used by the
//               nth primitive in this object.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  1 n 1 3141  
571 0 0 7 605 3278 0 0 795 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::decompose
//       Access: Published
//  Description: Decomposes a complex primitive type into a simpler
//               primitive type, for instance triangle strips to
//               triangles, and returns a pointer to the new primitive
//               definition.  If the decomposition cannot be
//               performed, this might return the original object.
//
//               This method is useful for application code that wants
//               to iterate through the set of triangles on the
//               primitive without having to write handlers for each
//               possible kind of primitive type.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
572 0 0 7 606 3278 0 0 739 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::rotate
//       Access: Published
//  Description: Returns a new primitive with the shade_model reversed
//               (if it is flat shaded), if possible.  If the
//               primitive type cannot be rotated, returns the
//               original primitive, unrotated.
//
//               If the current shade_model indicates
//               flat_vertex_last, this should bring the last vertex
//               to the first position; if it indicates
//               flat_vertex_first, this should bring the first vertex
//               to the last position.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
573 0 0 7 607 3278 0 0 842 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::doubleside
//       Access: Published
//  Description: Duplicates triangles in the primitive so that each
//               triangle is back-to-back with another triangle facing
//               in the opposite direction.  Note that this doesn't
//               affect vertex normals, so this operation alone won't
//               work in the presence of lighting (but see
//               SceneGraphReducer::doubleside()).
//
//               Also see CullFaceAttrib, which can enable rendering
//               of both sides of a triangle without having to
//               duplicate it (but which doesn't necessarily work in
//               the presence of lighting).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
574 0 0 7 608 3278 0 0 823 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::reverse
//       Access: Published
//  Description: Reverses the winding order in the primitive so that
//               each triangle is facing in the opposite direction it
//               was originally.  Note that this doesn't affect vertex
//               normals, so this operation alone won't work in the
//               presence of lighting (but see
//               SceneGraphReducer::reverse()).
//
//               Also see CullFaceAttrib, which can change the visible
//               direction of a triangle without having to duplicate
//               it (but which doesn't necessarily work in the
//               presence of lighting).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
575 0 0 7 609 3278 0 0 672 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::match_shade_model
//       Access: Published
//  Description: Returns a new primitive that is compatible with the
//               indicated shade model, if possible, or NULL if this
//               is not possible.
//
//               In most cases, this will return either NULL or the
//               original primitive.  In the case of a
//               SM_flat_first_vertex vs. a SM_flat_last_vertex (or
//               vice-versa), however, it will return a rotated
//               primitive.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  11 shade_model 1 3032  
576 0 0 7 610 3278 0 0 519 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_points
//       Access: Published
//  Description: Returns a new GeomPoints primitive that represents
//               each of the vertices in the original primitive,
//               rendered exactly once.  If the original primitive is
//               already a GeomPoints primitive, returns the original
//               primitive unchanged.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
577 0 0 7 611 3278 0 0 509 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_lines
//       Access: Published
//  Description: Returns a new GeomLines primitive that represents
//               each of the edges in the original primitive rendered
//               as a line.  If the original primitive is already a
//               GeomLines primitive, returns the original primitive
//               unchanged.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
578 0 0 7 612 3278 0 0 738 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::make_patches
//       Access: Published
//  Description: Decomposes a complex primitive type into a simpler
//               primitive type, for instance triangle strips to
//               triangles, puts these in a new GeomPatches object
//               and returns a pointer to the new primitive
//               definition.  If the decomposition cannot be
//               performed, this might return the original object.
//
//               This method is useful for application code that wants
//               to use tesselation shaders on arbitrary geometry.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
579 0 0 6 613 3141 0 0 322 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_bytes
//       Access: Published
//  Description: Returns the number of bytes consumed by the primitive
//               and its index table(s).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
580 0 0 6 614 3141 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_data_size_bytes
//       Access: Published
//  Description: Returns the number of bytes stored in the vertices
//               array.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
581 0 0 7 615 3205 0 0 372 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the vertex index array is
//               modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
582 0 0 6 616 3138 0 0 451 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::request_resident
//       Access: Published
//  Description: Returns true if the primitive data is currently
//               resident in memory.  If this returns false, the
//               primitive data will be brought back into memory
//               shortly; try again later.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
583 0 0 6 617 3138 0 0 455 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::check_valid
//       Access: Published
//  Description: Verifies that the primitive only references vertices
//               that actually exist within the indicated
//               GeomVertexData.  Returns true if the primitive
//               appears to be valid, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  11 vertex_data 1 3172  
584 0 0 4 618 3137 0 0 229 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::output
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 3278  3 out 1 3139  
585 0 0 4 619 3137 0 0 228 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::write
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 3 4 this 3 3278  3 out 1 3139  12 indent_level 1 3141  
586 0 0 7 620 3165 0 0 812 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_vertices
//       Access: Published
//  Description: Returns a const pointer to the vertex index array so
//               application code can read it directly.  This might
//               return NULL if the primitive is nonindexed.  Do not
//               attempt to modify the returned array; use
//               modify_vertices() or set_vertices() for this.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
587 0 0 7 621 3203 1842 0 1321 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::modify_vertices
//       Access: Published
//  Description: Returns a modifiable pointer to the vertex index
//               list, so application code can directly fiddle with
//               this data.  Use with caution, since there are no
//               checks that the data will be left in a stable state.
//
//               If this is called on a nonindexed primitive, it will
//               implicitly be converted to an indexed primitive.
//
//               If num_vertices is not -1, it specifies an artificial
//               limit to the number of vertices in the array.
//               Otherwise, all of the vertices in the array will be
//               used.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 2 4 this 3 3277  12 num_vertices 1 3141  
588 0 0 4 622 3137 0 0 1115 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_vertices
//       Access: Published
//  Description: Completely replaces the vertex index list with a new
//               table.  Chances are good that you should also replace
//               the ends list with set_ends() at the same time.
//
//               If num_vertices is not -1, it specifies an artificial
//               limit to the number of vertices in the array.
//               Otherwise, all of the vertices in the array will be
//               used.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 3 4 this 3 3277  8 vertices 1 3165  12 num_vertices 1 3141  
589 0 0 4 623 3137 0 0 808 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_nonindexed_vertices
//       Access: Published
//  Description: Sets the primitive up as a nonindexed primitive,
//               using the indicated vertex range.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 3 4 this 3 3277  12 first_vertex 1 3141  12 num_vertices 1 3141  
590 0 0 6 624 3141 0 0 642 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_index_stride
//       Access: Published
//  Description: A convenience function to return the gap between
//               successive index numbers, in bytes, of the index
//               data.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
591 0 0 6 625 3141 0 0 457 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_strip_cut_index
//       Access: Published
//  Description: If relevant, returns the index value that may be
//               used in some cases to signify the end of a
//               primitive.  This is typically the highest value
//               that the numeric type can store.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
592 0 0 7 626 3282 0 0 936 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_ends
//       Access: Published
//  Description: Returns a const pointer to the primitive ends
//               array so application code can read it directly.  Do
//               not attempt to modify the returned array; use
//               modify_ends() or set_ends() for this.
//
//               Note that simple primitive types, like triangles, do
//               not have a ends array: since all the primitives
//               have the same number of vertices, it is not needed.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
593 0 0 7 627 3285 0 0 1159 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::modify_ends
//       Access: Published
//  Description: Returns a modifiable pointer to the primitive ends
//               array, so application code can directly fiddle with
//               this data.  Use with caution, since there are no
//               checks that the data will be left in a stable state.
//
//               Note that simple primitive types, like triangles, do
//               not have a ends array: since all the primitives
//               have the same number of vertices, it is not needed.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3277  
594 0 0 4 628 3137 0 0 1117 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_ends
//       Access: Published
//  Description: Completely replaces the primitive ends array with
//               a new table.  Chances are good that you should also
//               replace the vertices list with set_vertices() at the
//               same time.
//
//               Note that simple primitive types, like triangles, do
//               not have a ends array: since all the primitives
//               have the same number of vertices, it is not needed.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 2 4 this 3 3277  4 ends 1 3282  
595 0 0 7 629 3165 0 0 827 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_mins
//       Access: Published
//  Description: Returns a const pointer to the primitive mins
//               array so application code can read it directly.  Do
//               not attempt to modify the returned array; use
//               set_minmax() for this.
//
//               Note that simple primitive types, like triangles, do
//               not have a mins array.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
596 0 0 7 630 3165 0 0 818 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_maxs
//       Access: Published
//  Description: Returns a const pointer to the primitive maxs
//               array so application code can read it directly.  Do
//               not attempt to modify the returned array; use
//               set_minmax().
//
//               Note that simple primitive types, like triangles, do
//               not have a maxs array.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
597 0 0 4 631 3137 0 0 1093 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::set_minmax
//       Access: Published
//  Description: Explicitly specifies the minimum and maximum
//               vertices, as well as the lists of per-component min
//               and max.
//
//               Use this method with extreme caution.  It's generally
//               better to let the GeomPrimitive compute these
//               explicitly, unless for some reason you can do it
//               faster and you absolutely need the speed improvement.
//
//               Note that any modification to the vertex array will
//               normally cause this to be recomputed, unless you set
//               it immediately again.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 5 4 this 3 3277  10 min_vertex 1 3141  10 max_vertex 1 3141  4 mins 1 3203  4 maxs 1 3203  
598 0 0 4 632 3137 0 0 643 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::clear_minmax
//       Access: Published
//  Description: Undoes a previous call to set_minmax(), and allows
//               the minimum and maximum values to be recomputed
//               normally.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3277  
599 0 0 6 633 3141 0 0 948 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_vertices_per_primitive
//       Access: Published, Virtual
//  Description: If the primitive type is a simple type in which all
//               primitives have the same number of vertices, like
//               triangles, returns the number of vertices per
//               primitive.  If the primitive type is a more complex
//               type in which different primitives might have
//               different numbers of vertices, for instance a
//               triangle strip, returns 0.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
600 0 0 6 634 3141 0 0 654 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_min_num_vertices_per_primitive
//       Access: Published, Virtual
//  Description: Returns the minimum number of vertices that must be
//               added before close_primitive() may legally be called.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
601 0 0 6 635 3141 0 0 845 ////////////////////////////////////////////////////////////////////
//     Function: GeomPrimitive::get_num_unused_vertices_per_primitive
//       Access: Published, Virtual
//  Description: Returns the number of vertices that are added between
//               primitives that aren't, strictly speaking, part of
//               the primitives themselves.  This is used, for
//               instance, to define degenerate triangles to connect
//               otherwise disconnected triangle strips.
//
//               This method is intended for low-level usage only.
//               There are higher-level methods for more common usage.
//               We recommend you do not use this method directly.  If
//               you do, be sure you know what you are doing!
//////////////////////////////////////////////////////////////////// 1 4 this 3 3278  
602 0 0 7 636 3158 0 0 0 0 
603 0 0 7 560 3217 0 0 0 1 4 this 3 3277  
604 0 0 7 561 3277 2065 0 0 1 4 this 3 3217  
605 0 0 6 562 3168 0 0 0 1 4 this 3 3277  
606 0 0 7 563 3277 2065 0 0 1 4 this 3 3168  
607 0 0 7 638 3286 0 0 269 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::Copy Constructor
//       Access: Published
//  Description: Initialize the texture stage from other
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3286  
608 0 0 7 638 3286 0 0 269 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::Constructor
//       Access: Published
//  Description: Initialize the texture stage at construction
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
609 0 0 7 639 3286 0 0 0 2 4 this 3 3286  4 copy 1 3287  
610 0 0 4 644 3137 0 0 260 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_name
//       Access: Published
//  Description: Changes the name of this texture stage
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  4 name 1 3131  
611 0 0 6 645 3131 0 0 260 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_name
//       Access: Published
//  Description: Returns the name of this texture stage
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
612 0 0 4 646 3137 0 0 768 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_sort
//       Access: Published
//  Description: Changes the order in which the texture associated
//               with this stage is rendered relative to the other
//               texture stages.  When geometry is rendered with
//               multiple textures, the textures are rendered in order
//               from the lowest sort number to the highest sort
//               number.
//
//               Also see set_priority(), which is used to select the
//               most important textures for rendering when some must
//               be omitted because of hardware limitations.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  4 sort 1 3141  
613 0 0 6 647 3141 0 0 267 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_sort
//       Access: Published
//  Description: Returns the sort order of this texture stage.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
614 0 0 4 648 3137 0 0 919 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_priority
//       Access: Published
//  Description: Changes the relative importance of the texture
//               associated with this stage relative to the other
//               texture stages that are applied simultaneously.
//
//               This is unrelated to set_sort(), which controls the
//               order in which multiple textures are applied.  The
//               priority number is used to decide which of the
//               requested textures are to be selected for rendering
//               when more textures are requested than the hardware
//               will support.  The highest-priority n textures are
//               selected for rendering, and then rendered in order by
//               their sort factor.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  8 priority 1 3141  
615 0 0 6 649 3141 0 0 406 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_priority
//       Access: Published
//  Description: Returns the priority associated with this stage.
//
//               This is specially helpful for cards that do not
//               support more than n stages of multi-texturing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
616 0 0 4 650 3137 0 0 412 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_texcoord_name
//       Access: Published
//  Description: Indicate which set of UV's this texture stage will
//               use.  Geometry may have any number of associated UV
//               sets, each of which must have a unique name.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  4 name 1 3154  
617 0 0 4 650 3137 0 0 412 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_texcoord_name
//       Access: Published
//  Description: Indicate which set of UV's this texture stage will
//               use.  Geometry may have any number of associated UV
//               sets, each of which must have a unique name.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  13 texcoord_name 1 3131  
618 0 0 7 651 3154 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_texcoord_name
//       Access: Published
//  Description: See set_texcoord_name.  The default is
//               InternalName::get_texcoord().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
619 0 0 7 652 3154 0 0 403 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_tangent_name
//       Access: Published
//  Description: Returns the set of tangents this texture stage will
//               use.  This is the same as get_texcoord_name(),
//               except that the first part is "tangent".
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
620 0 0 7 653 3154 0 0 406 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_binormal_name
//       Access: Published
//  Description: Returns the set of binormals this texture stage will
//               use.  This is the same as get_binormal_name(),
//               except that the first part is "binormal".
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
621 0 0 4 654 3137 0 0 256 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_mode
//       Access: Published
//  Description: Set the mode of this texture stage
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  4 mode 1 3073  
622 0 0 6 655 3073 0 0 251 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_mode
//       Access: Published
//  Description: Return the mode of this stage
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
623 0 0 6 656 3138 0 0 416 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::is_fixed_function
//       Access: Published
//  Description: Returns true if the TextureStage is relevant to
//               the classic fixed function pipeline.  This excludes
//               texture stages such as normal mapping and the like.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
624 0 0 4 657 3137 0 0 251 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_color
//       Access: Published
//  Description: Set the color for this stage
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  5 color 1 3266  
625 0 0 7 658 3289 0 0 254 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_color
//       Access: Published
//  Description: return the color for this stage
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
626 0 0 4 659 3137 0 0 490 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_rgb_scale
//       Access: Published
//  Description: Sets an additional factor that will scale all three
//               r, g, b components after the texture has been
//               applied.  This is used only when the mode is
//               CM_combine.
//
//               The only legal values are 1, 2, or 4.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  9 rgb_scale 1 3141  
627 0 0 6 660 3141 0 0 247 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_rgb_scale
//       Access: Published
//  Description: See set_rgb_scale().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
628 0 0 4 661 3137 0 0 465 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_alpha_scale
//       Access: Published
//  Description: Sets an additional factor that will scale the
//               alpha component after the texture has been applied.
//               This is used only when the mode is CM_combine.
//
//               The only legal values are 1, 2, or 4.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  11 alpha_scale 1 3141  
629 0 0 6 662 3141 0 0 251 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_alpha_scale
//       Access: Published
//  Description: See set_alpha_scale().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
630 0 0 4 663 3137 0 0 825 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_saved_result
//       Access: Published
//  Description: Sets the saved_result flag.  When this is true, the
//               output of this stage will be supplied as the
//               "last_saved_result" source for any future stages,
//               until the next TextureStage with a saved_result set
//               true is encountered.
//
//               This can be used to reuse the results of this texture
//               stage as input to more than one stage later in the
//               pipeline.
//
//               The last texture in the pipeline (the one with the
//               highest sort value) should not have this flag set.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  12 saved_result 1 3138  
631 0 0 6 664 3138 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_saved_result
//       Access: Published
//  Description: Returns the current setting of the saved_result flag.
//               See set_saved_result().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
632 0 0 4 665 3137 0 0 654 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_tex_view_offset
//       Access: Published
//  Description: Sets the tex_view_offset value.  This is used only
//               when a special multiview texture is bound to the
//               TextureStage, and it selects the particular view of
//               the texture that is to be used.
//
//               This value is added to the similar parameter on
//               DisplayRegion to derive the final texture view index
//               that is selected for rendering.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3286  15 tex_view_offset 1 3141  
633 0 0 6 666 3141 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_tex_view_offset
//       Access: Published
//  Description: Returns the current setting of the tex_view_offset.
//               See set_tex_view_offset().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
634 0 0 4 667 3137 0 0 384 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_rgb
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a one-parameter operation.  Specifically,
//               this is CM_replace only.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3286  4 mode 1 3074  7 source0 1 3075  8 operand0 1 3076  
635 0 0 4 667 3137 0 0 437 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_rgb
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a two-parameter operation.  Specifically,
//               this is everything except for CM_replace and
//               CM_interpolate.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3286  4 mode 1 3074  7 source0 1 3075  8 operand0 1 3076  7 source1 1 3075  8 operand1 1 3076  
636 0 0 4 667 3137 0 0 388 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_rgb
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a one-parameter operation.  Specifically,
//               this is CM_interpolate only.
//////////////////////////////////////////////////////////////////// 8 4 this 3 3286  4 mode 1 3074  7 source0 1 3075  8 operand0 1 3076  7 source1 1 3075  8 operand1 1 3076  7 source2 1 3075  8 operand2 1 3076  
637 0 0 6 668 3074 0 0 258 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_mode
//       Access: Published
//  Description: Get the combine_rgb_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
638 0 0 6 669 3141 0 0 401 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_num_combine_rgb_operands
//       Access: Published
//  Description: Returns the number of meaningful operands that may be
//               retrieved via get_combine_rgb_sourceN() and
//               get_combine_rgb_operandN().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
639 0 0 6 670 3075 0 0 268 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_source0
//       Access: Published
//  Description: Get source0 of combine_rgb_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
640 0 0 6 671 3076 0 0 270 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_operand0
//       Access: Published
//  Description: Get operand0 of combine_rgb_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
641 0 0 6 672 3075 0 0 268 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_source1
//       Access: Published
//  Description: Get source1 of combine_rgb_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
642 0 0 6 673 3076 0 0 270 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_operand1
//       Access: Published
//  Description: Get operand1 of combine_rgb_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
643 0 0 6 674 3075 0 0 268 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_source2
//       Access: Published
//  Description: Get source2 of combine_rgb_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
644 0 0 6 675 3076 0 0 270 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_rgb_operand2
//       Access: Published
//  Description: Get operand2 of combine_rgb_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
645 0 0 4 676 3137 0 0 386 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_alpha
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a one-parameter operation.  Specifically,
//               this is CM_replace only.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3286  4 mode 1 3074  7 source0 1 3075  8 operand0 1 3076  
646 0 0 4 676 3137 0 0 439 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_alpha
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a two-parameter operation.  Specifically,
//               this is everything except for CM_replace and
//               CM_interpolate.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3286  4 mode 1 3074  7 source0 1 3075  8 operand0 1 3076  7 source1 1 3075  8 operand1 1 3076  
647 0 0 4 676 3137 0 0 390 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::set_combine_alpha
//       Access: Published
//  Description: Specifies any of the CombineMode values that
//               represent a one-parameter operation.  Specifically,
//               this is CM_interpolate only.
//////////////////////////////////////////////////////////////////// 8 4 this 3 3286  4 mode 1 3074  7 source0 1 3075  8 operand0 1 3076  7 source1 1 3075  8 operand1 1 3076  7 source2 1 3075  8 operand2 1 3076  
648 0 0 6 677 3074 0 0 253 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha
//       Access: Published
//  Description: Get combine_alpha_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
649 0 0 6 678 3141 0 0 407 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_num_combine_alpha_operands
//       Access: Published
//  Description: Returns the number of meaningful operands that may be
//               retrieved via get_combine_alpha_sourceN() and
//               get_combine_alpha_operandN().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
650 0 0 6 679 3075 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_source0
//       Access: Published
//  Description: Get source0 of combine_alpha_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
651 0 0 6 680 3076 0 0 274 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_operand0
//       Access: Published
//  Description: Get operand0 of combine_alpha_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
652 0 0 6 681 3075 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_source1
//       Access: Published
//  Description: Get source1 of combine_alpha_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
653 0 0 6 682 3076 0 0 274 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_operand1
//       Access: Published
//  Description: Get operand1 of combine_alpha_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
654 0 0 6 683 3075 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_source2
//       Access: Published
//  Description: Get source2 of combine_alpha_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
655 0 0 6 684 3076 0 0 274 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_combine_alpha_operand2
//       Access: Published
//  Description: Get operand2 of combine_alpha_mode
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
656 0 0 6 685 3138 0 0 377 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::involves_color_scale
//       Access: Published
//  Description: Returns true if the TextureStage is affected by the
//               setting of the current ColorScaleAttrib, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
657 0 0 6 686 3138 0 0 364 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::uses_color
//       Access: Published
//  Description: Returns true if the TextureStage makes use of
//               whatever color is specified in set_color(), false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
658 0 0 6 687 3138 0 0 331 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::uses_primary_color
//       Access: Published
//  Description: Returns true if the TextureStage makes use of
//               the CS_primary_color combine source.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
659 0 0 6 688 3138 0 0 335 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::uses_last_saved_result
//       Access: Published
//  Description: Returns true if the TextureStage makes use of
//               the CS_primary_color combine source.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3287  
660 0 0 6 689 3138 0 0 0 2 4 this 3 3287  5 other 1 3287  
661 0 0 6 690 3138 0 0 0 2 4 this 3 3287  5 other 1 3287  
662 0 0 6 691 3138 0 0 0 2 4 this 3 3287  5 other 1 3287  
663 0 0 6 692 3141 0 0 540 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this TextureStage
//               sorts before the other one, greater than zero if it
//               sorts after, or zero if they are equivalent.  The
//               sorting order is arbitrary and largely meaningless,
//               except to differentiate different stages.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3287  5 other 1 3287  
664 0 0 4 693 3137 0 0 256 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::Destructor
//       Access: Published
//  Description: Writes the details of this stage
//////////////////////////////////////////////////////////////////// 2 4 this 3 3287  3 out 1 3139  
665 0 0 4 694 3137 0 0 249 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::Destructor
//       Access: Published
//  Description: Just a single line output
//////////////////////////////////////////////////////////////////// 2 4 this 3 3287  3 out 1 3139  
666 0 0 7 695 3286 0 0 447 ////////////////////////////////////////////////////////////////////
//     Function: TextureStage::get_default
//       Access: Published, Static
//  Description: Returns the default TextureStage that will be used
//               for all texturing that does not name a particular
//               stage.  This generally handles the normal
//               single-texture case.
//////////////////////////////////////////////////////////////////// 0 
667 0 0 7 696 3158 0 0 0 0 
668 0 0 7 702 3290 2198 0 216 ////////////////////////////////////////////////////////////////////
//     Function: Geom::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 data 1 3172  
669 0 0 7 703 3290 2198 0 0 2 4 this 3 3290  4 copy 1 3291  
670 0 0 4 705 3137 0 0 0 2 4 this 3 3290  4 size 1 3132  
671 0 0 7 708 3290 2198 0 458 ////////////////////////////////////////////////////////////////////
//     Function: Geom::make_copy
//       Access: Protected, Virtual
//  Description: Returns a newly-allocated Geom that is a shallow copy
//               of this one.  It will be a different Geom pointer,
//               but its internal data may or may not be shared with
//               that of the original Geom.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
672 0 0 6 709 3033 0 0 664 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_primitive_type
//       Access: Published
//  Description: Returns the fundamental primitive type that is common
//               to all GeomPrimitives added within the Geom.  All
//               nested primitives within a particular Geom must be
//               the same type (that is, you can mix triangles and
//               tristrips, because they are both the same fundamental
//               type PT_polygons, but you cannot mix triangles and
//               points withn the same Geom).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
673 0 0 6 710 3032 0 0 359 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_shade_model
//       Access: Published
//  Description: Returns the shade model common to all of the
//               individual GeomPrimitives that have been added to the
//               geom.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
674 0 0 6 711 3141 0 0 374 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_geom_rendering
//       Access: Published
//  Description: Returns the set of GeomRendering bits that represent
//               the rendering properties required to properly render
//               this Geom.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
675 0 0 6 712 3030 0 0 381 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_usage_hint
//       Access: Published
//  Description: Returns the minimum (i.e. most dynamic) usage_hint
//               among all of the individual GeomPrimitives that have
//               been added to the geom.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
676 0 0 4 713 3137 0 0 558 ////////////////////////////////////////////////////////////////////
//     Function: Geom::set_usage_hint
//       Access: Published
//  Description: Changes the UsageHint hint for all of the primitives
//               on this Geom to the same value.  See
//               get_usage_hint().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  10 usage_hint 1 3030  
677 0 0 7 714 3172 0 0 387 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_vertex_data
//       Access: Published
//  Description: Returns a const pointer to the GeomVertexData,
//               for application code to directly examine (but not
//               modify) the geom's underlying data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3291  14 current_thread 1 3207  
678 0 0 7 715 3261 1995 0 583 ////////////////////////////////////////////////////////////////////
//     Function: Geom::modify_vertex_data
//       Access: Published
//  Description: Returns a modifiable pointer to the GeomVertexData,
//               so that application code may directly maniuplate the
//               geom's underlying data.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
679 0 0 4 716 3137 0 0 512 ////////////////////////////////////////////////////////////////////
//     Function: Geom::set_vertex_data
//       Access: Published
//  Description: Replaces the Geom's underlying vertex data table with
//               a completely new table.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  4 data 1 3172  
680 0 0 4 717 3137 0 0 847 ////////////////////////////////////////////////////////////////////
//     Function: Geom::offset_vertices
//       Access: Published
//  Description: Replaces a Geom's vertex table with a new table, and
//               simultaneously adds the indicated offset to all
//               vertex references within the Geom's primitives.  This
//               is intended to be used to combine multiple
//               GeomVertexDatas from different Geoms into a single
//               big buffer, with each Geom referencing a subset of
//               the vertices in the buffer.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3290  4 data 1 3172  6 offset 1 3141  
681 0 0 6 718 3141 0 0 728 ////////////////////////////////////////////////////////////////////
//     Function: Geom::make_nonindexed
//       Access: Published
//  Description: Converts the geom from indexed to nonindexed by
//               duplicating vertices as necessary.  If composite_only
//               is true, then only composite primitives such as
//               trifans and tristrips are converted.  Returns the
//               number of GeomPrimitive objects converted.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  14 composite_only 1 3138  
682 0 0 6 719 3138 0 0 337 ////////////////////////////////////////////////////////////////////
//     Function: Geom::is_empty
//       Access: Published
//  Description: Returns true if there appear to be no vertices to be
//               rendered by this Geom, false if has some actual data.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
683 0 0 6 720 3141 0 0 395 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_num_primitives
//       Access: Published
//  Description: Returns the number of GeomPrimitive objects stored
//               within the Geom, each of which represents a number of
//               primitives of a particular type.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
684 0 0 7 721 3278 0 0 464 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_primitive
//       Access: Published
//  Description: Returns a const pointer to the ith GeomPrimitive
//               object stored within the Geom.  Use this call only to
//               inspect the ith object; use modify_primitive() or
//               set_primitive() if you want to modify it.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3291  1 i 1 3141  
685 0 0 7 722 3277 2065 0 632 ////////////////////////////////////////////////////////////////////
//     Function: Geom::modify_primitive
//       Access: Published
//  Description: Returns a modifiable pointer to the ith GeomPrimitive
//               object stored within the Geom, so application code
//               can directly manipulate the properties of this
//               primitive.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  1 i 1 3141  
686 0 0 4 723 3137 0 0 514 ////////////////////////////////////////////////////////////////////
//     Function: Geom::set_primitive
//       Access: Published
//  Description: Replaces the ith GeomPrimitive object stored within
//               the Geom with the new object.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3290  1 i 1 3141  9 primitive 1 3278  
687 0 0 4 724 3137 0 0 637 ////////////////////////////////////////////////////////////////////
//     Function: Geom::add_primitive
//       Access: Published
//  Description: Adds a new GeomPrimitive structure to the Geom
//               object.  This specifies a particular subset of
//               vertices that are used to define geometric primitives
//               of the indicated type.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  9 primitive 1 3278  
688 0 0 4 725 3137 0 0 459 ////////////////////////////////////////////////////////////////////
//     Function: Geom::remove_primitive
//       Access: Published
//  Description: Removes the ith primitive from the list.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  1 i 1 3141  
689 0 0 4 726 3137 0 0 633 ////////////////////////////////////////////////////////////////////
//     Function: Geom::clear_primitives
//       Access: Published
//  Description: Removes all the primitives from the Geom object (but
//               keeps the same table of vertices).  You may then
//               re-add primitives one at a time via calls to
//               add_primitive().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
690 0 0 7 727 3290 2198 0 354 ////////////////////////////////////////////////////////////////////
//     Function: Geom::decompose
//       Access: Published
//  Description: Decomposes all of the primitives within this Geom,
//               returning the result.  See
//               GeomPrimitive::decompose().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
691 0 0 7 728 3290 2198 0 357 ////////////////////////////////////////////////////////////////////
//     Function: Geom::doubleside
//       Access: Published
//  Description: Doublesides all of the primitives within this Geom,
//               returning the result.  See
//               GeomPrimitive::doubleside().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
692 0 0 7 729 3290 2198 0 348 ////////////////////////////////////////////////////////////////////
//     Function: Geom::reverse
//       Access: Published
//  Description: Reverses all of the primitives within this Geom,
//               returning the result.  See
//               GeomPrimitive::reverse().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
693 0 0 7 730 3290 2198 0 345 ////////////////////////////////////////////////////////////////////
//     Function: Geom::rotate
//       Access: Published
//  Description: Rotates all of the primitives within this Geom,
//               returning the result.  See
//               GeomPrimitive::rotate().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
694 0 0 7 731 3290 2198 0 890 ////////////////////////////////////////////////////////////////////
//     Function: Geom::unify
//       Access: Published
//  Description: Unifies all of the primitives contained within this
//               Geom into a single (or as few as possible, within the
//               constraints of max_indices) primitive objects.  This
//               may require decomposing the primitives if, for
//               instance, the Geom contains both triangle strips and
//               triangle fans.
//
//               max_indices represents the maximum number of indices
//               that will be put in any one GeomPrimitive.  If
//               preserve_order is true, then the primitives will not
//               be reordered during the operation, even if this
//               results in a suboptimal result.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3291  11 max_indices 1 3141  14 preserve_order 1 3138  
695 0 0 7 732 3290 2198 0 319 ////////////////////////////////////////////////////////////////////
//     Function: Geom::make_points
//       Access: Published
//  Description: Returns a new Geom with points at all the vertices.
//               See GeomPrimitive::make_points().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
696 0 0 7 733 3290 2198 0 313 ////////////////////////////////////////////////////////////////////
//     Function: Geom::make_lines
//       Access: Published
//  Description: Returns a new Geom with lines at all the edges.
//               See GeomPrimitive::make_lines().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
697 0 0 7 734 3290 2198 0 323 ////////////////////////////////////////////////////////////////////
//     Function: Geom::make_patches
//       Access: Published
//  Description: Returns a new Geom with each primitive converted
//               into a patch.  Calls decompose() first.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
698 0 0 4 735 3137 0 0 568 ////////////////////////////////////////////////////////////////////
//     Function: Geom::decompose_in_place
//       Access: Published
//  Description: Decomposes all of the primitives within this Geom,
//               leaving the results in place.  See
//               GeomPrimitive::decompose().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
699 0 0 4 736 3137 0 0 571 ////////////////////////////////////////////////////////////////////
//     Function: Geom::doubleside_in_place
//       Access: Published
//  Description: Doublesides all of the primitives within this Geom,
//               leaving the results in place.  See
//               GeomPrimitive::doubleside().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
700 0 0 4 737 3137 0 0 562 ////////////////////////////////////////////////////////////////////
//     Function: Geom::reverse_in_place
//       Access: Published
//  Description: Reverses all of the primitives within this Geom,
//               leaving the results in place.  See
//               GeomPrimitive::reverse().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
701 0 0 4 738 3137 0 0 559 ////////////////////////////////////////////////////////////////////
//     Function: Geom::rotate_in_place
//       Access: Published
//  Description: Rotates all of the primitives within this Geom,
//               leaving the results in place.  See
//               GeomPrimitive::rotate().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
702 0 0 4 739 3137 0 0 1096 ////////////////////////////////////////////////////////////////////
//     Function: Geom::unify_in_place
//       Access: Published
//  Description: Unifies all of the primitives contained within this
//               Geom into a single (or as few as possible, within the
//               constraints of max_indices) primitive objects.  This
//               may require decomposing the primitives if, for
//               instance, the Geom contains both triangle strips and
//               triangle fans.
//
//               max_indices represents the maximum number of indices
//               that will be put in any one GeomPrimitive.  If
//               preserve_order is true, then the primitives will not
//               be reordered during the operation, even if this
//               results in a suboptimal result.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3290  11 max_indices 1 3141  14 preserve_order 1 3138  
703 0 0 4 740 3137 0 0 567 ////////////////////////////////////////////////////////////////////
//     Function: Geom::make_points_in_place
//       Access: Published
//  Description: Replaces the GeomPrimitives within this Geom with
//               corresponding GeomPoints.  See
//               GeomPrimitive::make_points().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
704 0 0 4 741 3137 0 0 608 ////////////////////////////////////////////////////////////////////
//     Function: Geom::make_lines_in_place
//       Access: Published
//  Description: Replaces the GeomPrimitives within this Geom with
//               corresponding GeomLines, representing a wireframe
//               of the primitives.  See GeomPrimitive::make_lines().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
705 0 0 4 742 3137 0 0 570 ////////////////////////////////////////////////////////////////////
//     Function: Geom::make_patches_in_place
//       Access: Published
//  Description: Replaces the GeomPrimitives within this Geom with
//               corresponding GeomPatches.  See
//               GeomPrimitive::make_patches().
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
706 0 0 6 743 3138 0 0 792 ////////////////////////////////////////////////////////////////////
//     Function: Geom::copy_primitives_from
//       Access: Published, Virtual
//  Description: Copies the primitives from the indicated Geom into
//               this one.  This does require that both Geoms contain
//               the same fundamental type primitives, both have a
//               compatible shade model, and both use the same
//               GeomVertexData.  Both Geoms must also be the same
//               specific class type (i.e. if one is a GeomTextGlyph,
//               they both must be.)
//
//               Returns true if the copy is successful, or false
//               otherwise (because the Geoms were mismatched).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  5 other 1 3291  
707 0 0 6 744 3141 0 0 341 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_num_bytes
//       Access: Published
//  Description: Returns the number of bytes consumed by the geom and
//               its primitives (but not including its vertex table).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
708 0 0 7 745 3205 0 0 564 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time any of the primitives in
//               the Geom is modified, or the set of primitives is
//               modified.  However, this does not include
//               modifications to the vertex data, which should be
//               tested separately.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3291  14 current_thread 1 3207  
709 0 0 6 746 3138 0 0 571 ////////////////////////////////////////////////////////////////////
//     Function: Geom::request_resident
//       Access: Published
//  Description: Returns true if all the primitive arrays are
//               currently resident in memory.  If this returns false,
//               the data will be brought back into memory shortly;
//               try again later.
//
//               This does not also test the Geom's associated
//               GeomVertexData.  That must be tested separately.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
710 0 0 4 747 3137 0 0 808 ////////////////////////////////////////////////////////////////////
//     Function: Geom::transform_vertices
//       Access: Published
//  Description: Applies the indicated transform to all of the
//               vertices in the Geom.  If the Geom happens to share a
//               vertex table with another Geom, this operation will
//               duplicate the vertex table instead of breaking the
//               other Geom; however, if multiple Geoms with shared
//               tables are transformed by the same matrix, they will
//               no longer share tables after the operation.  Consider
//               using the GeomTransformer if you will be applying the
//               same transform to multiple Geoms.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  3 mat 1 3229  
711 0 0 6 748 3138 0 0 460 ////////////////////////////////////////////////////////////////////
//     Function: Geom::check_valid
//       Access: Published
//  Description: Verifies that the all of the primitives within the
//               geom reference vertices that actually exist within
//               the geom's GeomVertexData.  Returns true if the geom
//               appears to be valid, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
712 0 0 6 748 3138 0 0 463 ////////////////////////////////////////////////////////////////////
//     Function: Geom::check_valid
//       Access: Published
//  Description: Verifies that the all of the primitives within the
//               geom reference vertices that actually exist within
//               the indicated GeomVertexData.  Returns true if the
//               geom appears to be valid, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3291  11 vertex_data 1 3172  
713 0 0 7 749 3295 0 0 257 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_bounds
//       Access: Published
//  Description: Returns the bounding volume for the Geom.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3291  14 current_thread 1 3207  
714 0 0 6 750 3141 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_nested_vertices
//       Access: Published
//  Description: Returns the number of vertices rendered by all
//               primitives within the Geom.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3291  14 current_thread 1 3207  
715 0 0 4 751 3137 0 0 390 ////////////////////////////////////////////////////////////////////
//     Function: Geom::mark_bounds_stale
//       Access: Published
//  Description: Marks the bounding volume of the Geom as stale so
//               that it should be recomputed.  Usually it is not
//               necessary to call this explicitly.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
716 0 0 4 752 3137 0 0 969 ////////////////////////////////////////////////////////////////////
//     Function: Geom::set_bounds_type
//       Access: Published
//  Description: Specifies the desired type of bounding volume that
//               will be created for this Geom.  This is normally
//               BoundingVolume::BT_default, which means to set the
//               type according to the config variable "bounds-type".
//
//               If this is BT_sphere or BT_box, a BoundingSphere or
//               BoundingBox is explicitly created.  If it is BT_best,
//               a BoundingBox is created.
//
//               This affects the implicit bounding volume only.  If
//               an explicit bounding volume is set on the Geom with
//               set_bounds(), that bounding volume type is used.
//               (This is different behavior from the similar method
//               on PandaNode.)
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  11 bounds_type 1 3296  
717 0 0 6 753 3296 0 0 298 ////////////////////////////////////////////////////////////////////
//     Function: Geom::get_bounds_type
//       Access: Published
//  Description: Returns the bounding volume type set with
//               set_bounds_type().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3291  
718 0 0 4 754 3137 0 0 726 ////////////////////////////////////////////////////////////////////
//     Function: Geom::set_bounds
//       Access: Published
//  Description: Resets the bounding volume so that it is the
//               indicated volume.  When it is explicitly set, the
//               bounding volume will no longer be automatically
//               computed; call clear_bounds() if you would like to
//               return the bounding volume to its default behavior.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  6 volume 1 3295  
719 0 0 4 755 3137 0 0 614 ////////////////////////////////////////////////////////////////////
//     Function: Geom::clear_bounds
//       Access: Published
//  Description: Reverses the effect of a previous call to
//               set_bounds(), and allows the bounding volume to be
//               automatically computed once more based on the
//               vertices.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
720 0 0 4 756 3137 0 0 220 ////////////////////////////////////////////////////////////////////
//     Function: Geom::output
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 3291  3 out 1 3139  
721 0 0 4 757 3137 0 0 219 ////////////////////////////////////////////////////////////////////
//     Function: Geom::write
//       Access: Published, Virtual
//  Description:
//////////////////////////////////////////////////////////////////// 3 4 this 3 3291  3 out 1 3139  12 indent_level 1 3141  
722 0 0 4 758 3137 0 0 546 ////////////////////////////////////////////////////////////////////
//     Function: Geom::clear_cache
//       Access: Published
//  Description: Removes all of the previously-cached results of
//               munge_geom().
//
//               This blows away the entire cache, upstream and
//               downstream the pipeline.  Use clear_cache_stage()
//               instead if you only want to blow away the cache at
//               the current stage and upstream.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
723 0 0 4 759 3137 0 0 598 ////////////////////////////////////////////////////////////////////
//     Function: Geom::clear_cache_stage
//       Access: Published
//  Description: Removes all of the previously-cached results of
//               munge_geom(), at the current pipeline stage and
//               upstream.  Does not affect the downstream cache.
//
//               Don't call this in a downstream thread unless you
//               don't mind it blowing away other changes you might
//               have recently made in an upstream thread.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  14 current_thread 1 3207  
724 0 0 4 760 3137 0 0 640 ////////////////////////////////////////////////////////////////////
//     Function: Geom::prepare
//       Access: Published
//  Description: Indicates that the geom should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.  This will ensure the
//               geom is already loaded into geom memory if it
//               is expected to be rendered soon.
//
//               Use this function instead of prepare_now() to preload
//               geoms from a user interface standpoint.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  16 prepared_objects 1 3211  
725 0 0 6 761 3138 0 0 368 ////////////////////////////////////////////////////////////////////
//     Function: Geom::is_prepared
//       Access: Published
//  Description: Returns true if the geom has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3291  16 prepared_objects 1 3211  
726 0 0 6 762 3138 0 0 388 ////////////////////////////////////////////////////////////////////
//     Function: Geom::release
//       Access: Published
//  Description: Frees the geom context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3290  16 prepared_objects 1 3211  
727 0 0 6 763 3141 0 0 386 ////////////////////////////////////////////////////////////////////
//     Function: Geom::release_all
//       Access: Published
//  Description: Frees the context allocated on all objects for which
//               the geom has been declared.  Returns the number of
//               contexts which have been freed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3290  
728 0 0 6 764 3297 0 0 871 ////////////////////////////////////////////////////////////////////
//     Function: Geom::prepare_now
//       Access: Public
//  Description: Creates a context for the geom on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) GeomContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               geoms.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a geom does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3290  16 prepared_objects 1 3211  3 gsg 1 3212  
729 0 0 7 765 3158 0 0 0 0 
730 0 0 7 698 3217 0 0 0 1 4 this 3 3290  
731 0 0 7 699 3290 2198 0 0 1 4 this 3 3217  
732 0 0 6 700 3168 0 0 0 1 4 this 3 3290  
733 0 0 7 701 3290 2198 0 0 1 4 this 3 3168  
734 0 0 7 767 3290 2198 0 220 ////////////////////////////////////////////////////////////////////
//     Function: GeomContext::get_geom
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3298  
735 0 0 7 768 3158 0 0 0 0 
736 0 0 7 771 3300 2065 0 222 ////////////////////////////////////////////////////////////////////
//     Function: GeomLines::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 10 usage_hint 1 3030  
737 0 0 7 771 3300 2065 0 227 ////////////////////////////////////////////////////////////////////
//     Function: GeomLines::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3301  
738 0 0 4 772 3137 0 0 0 2 4 this 3 3300  4 size 1 3132  
739 0 0 7 775 3158 0 0 0 0 
740 0 0 7 777 3303 2065 0 227 ////////////////////////////////////////////////////////////////////
//     Function: GeomLinestrips::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 10 usage_hint 1 3030  
741 0 0 7 777 3303 2065 0 232 ////////////////////////////////////////////////////////////////////
//     Function: GeomLinestrips::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3304  
742 0 0 4 778 3137 0 0 0 2 4 this 3 3303  4 size 1 3132  
743 0 0 7 781 3158 0 0 0 0 
744 0 0 7 783 3308 2065 0 229 ////////////////////////////////////////////////////////////////////
//     Function: GeomPatches::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3306  
745 0 0 7 783 3308 2065 0 512 ////////////////////////////////////////////////////////////////////
//     Function: GeomPatches::Constructor
//       Access: Published
//  Description: The number of vertices per patch must be specified to
//               the GeomPatches constructor, and it may not be
//               changed during the lifetime of the GeomPatches
//               object.  Create a new GeomPatches if you need to have
//               a different value.
//////////////////////////////////////////////////////////////////// 2 22 num_vertices_per_patch 1 3141  10 usage_hint 1 3030  
746 0 0 4 784 3137 0 0 0 2 4 this 3 3308  4 size 1 3132  
747 0 0 7 787 3158 0 0 0 0 
748 0 0 7 789 3309 2065 0 223 ////////////////////////////////////////////////////////////////////
//     Function: GeomPoints::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 10 usage_hint 1 3030  
749 0 0 7 789 3309 2065 0 228 ////////////////////////////////////////////////////////////////////
//     Function: GeomPoints::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3310  
750 0 0 4 790 3137 0 0 0 2 4 this 3 3309  4 size 1 3132  
751 0 0 7 793 3158 0 0 0 0 
752 0 0 7 795 3312 2065 0 226 ////////////////////////////////////////////////////////////////////
//     Function: GeomTriangles::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 10 usage_hint 1 3030  
753 0 0 7 795 3312 2065 0 231 ////////////////////////////////////////////////////////////////////
//     Function: GeomTriangles::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3313  
754 0 0 4 796 3137 0 0 0 2 4 this 3 3312  4 size 1 3132  
755 0 0 7 799 3158 0 0 0 0 
756 0 0 7 801 3315 2065 0 224 ////////////////////////////////////////////////////////////////////
//     Function: GeomTrifans::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 10 usage_hint 1 3030  
757 0 0 7 801 3315 2065 0 229 ////////////////////////////////////////////////////////////////////
//     Function: GeomTrifans::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3316  
758 0 0 4 802 3137 0 0 0 2 4 this 3 3315  4 size 1 3132  
759 0 0 7 805 3158 0 0 0 0 
760 0 0 7 807 3318 2065 0 226 ////////////////////////////////////////////////////////////////////
//     Function: GeomTristrips::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 10 usage_hint 1 3030  
761 0 0 7 807 3318 2065 0 231 ////////////////////////////////////////////////////////////////////
//     Function: GeomTristrips::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3319  
762 0 0 4 808 3137 0 0 0 2 4 this 3 3318  4 size 1 3132  
763 0 0 7 811 3158 0 0 0 0 
764 0 0 7 813 3321 2300 0 322 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Constructor
//       Access: Published
//  Description: Constructs a new reader to process the vertices of
//               the indicated array only.
//////////////////////////////////////////////////////////////////// 2 10 array_data 1 3165  14 current_thread 1 3207  
765 0 0 7 813 3321 2300 0 322 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Constructor
//       Access: Published
//  Description: Constructs a new reader to process the vertices of
//               the indicated array only.
//////////////////////////////////////////////////////////////////// 3 10 array_data 1 3165  6 column 1 3141  14 current_thread 1 3207  
766 0 0 7 813 3321 2300 0 417 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Constructor
//       Access: Published
//  Description: Constructs a new reader to process the vertices of
//               the indicated data object.  This flavor creates the
//               reader specifically to process the named data type.
//////////////////////////////////////////////////////////////////// 3 11 vertex_data 1 3172  4 name 1 3155  14 current_thread 1 3207  
767 0 0 7 813 3321 2300 0 323 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Constructor
//       Access: Published
//  Description: Constructs a new reader to process the vertices of
//               the indicated data object.
//////////////////////////////////////////////////////////////////// 2 11 vertex_data 1 3172  14 current_thread 1 3207  
768 0 0 7 813 3321 2300 0 234 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3322  
769 0 0 7 813 3321 2300 0 438 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::Default Constructor
//       Access: Published
//  Description: Constructs an invalid GeomVertexReader.  You must use
//               the assignment operator to assign a valid
//               GeomVertexReader to this object before you can use
//               it.
//////////////////////////////////////////////////////////////////// 1 14 current_thread 1 3207  
770 0 0 6 814 3321 0 0 0 2 4 this 3 3321  4 copy 1 3322  
771 0 0 7 816 3172 0 0 408 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_vertex_data
//       Access: Published
//  Description: Returns the vertex data object that the
//               reader is processing.  This may return NULL if the
//               reader was constructed with just an array pointer.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
772 0 0 7 817 3165 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_array_data
//       Access: Published
//  Description: Returns the particular array object that the
//               reader is currently processing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
773 0 0 7 818 3209 0 0 400 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_array_handle
//       Access: Published
//  Description: Returns the read handle to the array object that the
//               read is currently processing.  This low-level call
//               should be used with caution.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
774 0 0 6 819 3132 0 0 459 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_stride
//       Access: Published
//  Description: Returns the per-row stride (bytes between consecutive
//               rows) of the underlying vertex array.  This low-level
//               information is normally not needed to use the
//               GeomVertexReader directly.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
775 0 0 7 820 3207 0 0 359 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_current_thread
//       Access: Published
//  Description: Returns the Thread pointer of the currently-executing
//               thread, as passed to the constructor of this object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
776 0 0 4 821 3137 0 0 928 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_force
//       Access: Published
//  Description: Sets the value of the force flag.  When this is true
//               (the default), vertex data will be paged in from disk
//               if necessary.  When this is false, the GeomVertexData
//               will simply return a failure code when attempting to
//               read vertex data that is not resident (but will put
//               it on the queue to become resident later).
//
//               Normally, vertex data is always resident, so this
//               will not be an issue.  It is only possible for vertex
//               data to be nonresident if you have enabled vertex
//               paging via the GeomVertexArrayData and VertexDataPage
//               interfaces.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3321  5 force 1 3138  
777 0 0 6 822 3138 0 0 298 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_force
//       Access: Published
//  Description: Returns the value of the force flag.  See
//               set_force().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
778 0 0 6 823 3138 0 0 616 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_column
//       Access: Published
//  Description: Sets up the reader to use the data type with the
//               indicated name.
//
//               This also resets the read row number to the start row
//               (the same value passed to a previous call to
//               set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3321  4 name 1 3155  
779 0 0 6 823 3138 0 0 638 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_column
//       Access: Published
//  Description: Sets up the reader to use the nth data type of the
//               GeomVertexFormat, numbering from 0.
//
//               This also resets the read row number to the start row
//               (the same value passed to a previous call to
//               set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3321  6 column 1 3141  
780 0 0 6 823 3138 0 0 638 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_column
//       Access: Published
//  Description: Sets up the reader to use the indicated column
//               description on the given array.
//
//               This also resets the current read row number to the
//               start row (the same value passed to a previous call
//               to set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3321  5 array 1 3141  6 column 1 3160  
781 0 0 4 824 3137 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::clear
//       Access: Published
//  Description: Resets the GeomVertexReader to the initial state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
782 0 0 6 825 3138 0 0 445 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::has_column
//       Access: Published
//  Description: Returns true if a valid data type has been
//               successfully set, or false if the data type does not
//               exist (or if get_force() is false and the vertex data
//               is nonresident).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
783 0 0 6 826 3141 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_array
//       Access: Published
//  Description: Returns the array index containing the data type that
//               the reader is working on.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
784 0 0 6 827 3160 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_column
//       Access: Published
//  Description: Returns the description of the data type that the
//               reader is working on.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
785 0 0 4 828 3137 0 0 655 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_row_unsafe
//       Access: Published
//  Description: Sets the start row to the indicated value, without
//               internal checks.  This is the same as set_row(), but
//               it does not check for the possibility that the array
//               has been reallocated internally for some reason; use
//               only when you are confident that the array is
//               unchanged and you really need every bit of available
//               performance.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3321  3 row 1 3141  
786 0 0 4 829 3137 0 0 533 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::set_row
//       Access: Published
//  Description: Sets the start row to the indicated value.  The
//               reader will begin reading from the indicated row;
//               each subsequent get_data*() call will return the data
//               from the subsequent row.  If set_column() is called,
//               the reader will return to this row.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3321  3 row 1 3141  
787 0 0 6 830 3141 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_start_row
//       Access: Published
//  Description: Returns the row index at which the reader started.
//               It will return to this row if you reset the current
//               column.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
788 0 0 6 831 3141 0 0 339 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_read_row
//       Access: Published
//  Description: Returns the row index from which the data will be
//               retrieved by the next call to get_data*().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
789 0 0 6 832 3138 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::is_at_end
//       Access: Published
//  Description: Returns true if the reader is currently at the end of
//               the list of vertices, false otherwise.  If this is
//               true, another call to get_data*() will result in a
//               crash.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3322  
790 0 0 6 833 3143 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data1f
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 1-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
791 0 0 6 834 3324 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data2f
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 2-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
792 0 0 6 835 3327 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data3f
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 3-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
793 0 0 6 836 3330 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data4f
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 4-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
794 0 0 7 837 3333 0 0 474 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix3f
//       Access: Published
//  Description: Returns the 3-by-3 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
795 0 0 7 838 3334 0 0 474 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix4f
//       Access: Published
//  Description: Returns the 4-by-4 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
796 0 0 6 839 3335 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data1d
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 1-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
797 0 0 6 840 3336 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data2d
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 2-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
798 0 0 6 841 3339 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data3d
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 3-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
799 0 0 6 842 3342 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data4d
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 4-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
800 0 0 7 843 3346 0 0 474 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix3d
//       Access: Published
//  Description: Returns the 3-by-3 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
801 0 0 7 844 3348 0 0 474 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix4d
//       Access: Published
//  Description: Returns the 4-by-4 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
802 0 0 6 845 3142 0 0 368 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data1
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 1-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
803 0 0 6 846 3349 0 0 368 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data2
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 2-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
804 0 0 6 847 3352 0 0 368 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data3
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 3-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
805 0 0 6 848 3262 0 0 368 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data4
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 4-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
806 0 0 7 849 3356 0 0 473 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix3
//       Access: Published
//  Description: Returns the 3-by-3 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
807 0 0 7 850 3226 0 0 473 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_matrix4
//       Access: Published
//  Description: Returns the 4-by-4 matrix associated with the read
//               row and advances the read row.  This is a special
//               method that only works when the column in question
//               contains a matrix of an appropriate size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
808 0 0 6 851 3141 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data1i
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 1-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
809 0 0 6 852 3357 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data2i
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 2-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
810 0 0 6 853 3360 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data3i
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 3-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
811 0 0 6 854 3363 0 0 369 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::get_data4i
//       Access: Published
//  Description: Returns the data associated with the read row,
//               expressed as a 4-component value, and advances the
//               read row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3321  
812 0 0 4 855 3137 0 0 224 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexReader::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3322  3 out 1 3139  
813 0 0 7 857 3366 2343 0 322 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Constructor
//       Access: Published
//  Description: Constructs a new writer to process the vertices of
//               the indicated array only.
//////////////////////////////////////////////////////////////////// 2 10 array_data 1 3203  14 current_thread 1 3207  
814 0 0 7 857 3366 2343 0 322 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Constructor
//       Access: Published
//  Description: Constructs a new writer to process the vertices of
//               the indicated array only.
//////////////////////////////////////////////////////////////////// 3 10 array_data 1 3203  6 column 1 3141  14 current_thread 1 3207  
815 0 0 7 857 3366 2343 0 417 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Constructor
//       Access: Published
//  Description: Constructs a new writer to process the vertices of
//               the indicated data object.  This flavor creates the
//               writer specifically to process the named data type.
//////////////////////////////////////////////////////////////////// 3 11 vertex_data 1 3261  4 name 1 3155  14 current_thread 1 3207  
816 0 0 7 857 3366 2343 0 323 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Constructor
//       Access: Published
//  Description: Constructs a new writer to process the vertices of
//               the indicated data object.
//////////////////////////////////////////////////////////////////// 2 11 vertex_data 1 3261  14 current_thread 1 3207  
817 0 0 7 857 3366 2343 0 233 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3367  
818 0 0 7 857 3366 2343 0 438 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::Default Constructor
//       Access: Published
//  Description: Constructs an invalid GeomVertexWriter.  You must use
//               the assignment operator to assign a valid
//               GeomVertexWriter to this object before you can use
//               it.
//////////////////////////////////////////////////////////////////// 1 14 current_thread 1 3207  
819 0 0 6 858 3366 0 0 0 2 4 this 3 3366  4 copy 1 3367  
820 0 0 7 860 3261 1995 0 408 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_vertex_data
//       Access: Published
//  Description: Returns the vertex data object that the
//               writer is processing.  This may return NULL if the
//               writer was constructed with just an array pointer.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
821 0 0 7 861 3203 1842 0 325 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_array_data
//       Access: Published
//  Description: Returns the particular array object that the
//               writer is currently processing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
822 0 0 7 862 3210 1879 0 523 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_array_handle
//       Access: Published
//  Description: Returns the write handle to the array object that the
//               writer is currently processing.  This low-level call
//               should be used with caution; be careful with
//               modifying the data in the handle out from under the
//               GeomVertexWriter.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
823 0 0 6 863 3132 0 0 459 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_stride
//       Access: Published
//  Description: Returns the per-row stride (bytes between consecutive
//               rows) of the underlying vertex array.  This low-level
//               information is normally not needed to use the
//               GeomVertexWriter directly.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
824 0 0 7 864 3207 0 0 359 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_current_thread
//       Access: Published
//  Description: Returns the Thread pointer of the currently-executing
//               thread, as passed to the constructor of this object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
825 0 0 6 865 3138 0 0 613 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_column
//       Access: Published
//  Description: Sets up the writer to use the data type with the
//               indicated name.
//
//               This also resets the write number to the start row
//               (the same value passed to a previous call to
//               set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 name 1 3155  
826 0 0 6 865 3138 0 0 639 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_column
//       Access: Published
//  Description: Sets up the writer to use the nth data type of the
//               GeomVertexFormat, numbering from 0.
//
//               This also resets the write row number to the start
//               row (the same value passed to a previous call to
//               set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  6 column 1 3141  
827 0 0 6 865 3138 0 0 639 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_column
//       Access: Published
//  Description: Sets up the writer to use the indicated column
//               description on the given array.
//
//               This also resets the current write row number to the
//               start row (the same value passed to a previous call
//               to set_row(), or 0 if set_row() was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3366  5 array 1 3141  6 column 1 3160  
828 0 0 4 866 3137 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::clear
//       Access: Published
//  Description: Resets the GeomVertexWriter to the initial state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3366  
829 0 0 6 867 3138 0 0 597 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::reserve_num_rows
//       Access: Published
//  Description: This ensures that enough memory space for num_rows is
//               allocated, so that you may add up to num_rows rows
//               without causing a new memory allocation.  This is a
//               performance optimization only; it is especially
//               useful when you know the number of rows you will be
//               adding ahead of time.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  8 num_rows 1 3141  
830 0 0 6 868 3138 0 0 364 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::has_column
//       Access: Published
//  Description: Returns true if a valid data type has been
//               successfully set, or false if the data type does not
//               exist.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
831 0 0 6 869 3141 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_array
//       Access: Published
//  Description: Returns the array index containing the data type that
//               the writer is working on.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
832 0 0 6 870 3160 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_column
//       Access: Published
//  Description: Returns the description of the data type that the
//               writer is working on.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
833 0 0 4 871 3137 0 0 655 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_row_unsafe
//       Access: Published
//  Description: Sets the start row to the indicated value, without
//               internal checks.  This is the same as set_row(), but
//               it does not check for the possibility that the array
//               has been reallocated internally for some reason; use
//               only when you are confident that the array is
//               unchanged and you really need every bit of available
//               performance.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 row 1 3141  
834 0 0 4 872 3137 0 0 530 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_row
//       Access: Published
//  Description: Sets the start row to the indicated value.  The
//               writer will begin writing to the indicated row;
//               each subsequent set_data*() call will store the data
//               into the subsequent row.  If set_column() is called,
//               the writer will return to this row.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 row 1 3141  
835 0 0 6 873 3141 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_start_row
//       Access: Published
//  Description: Returns the row index at which the writer
//               started.  It will return to this row if you reset
//               the current column.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
836 0 0 6 874 3141 0 0 368 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::get_write_row
//       Access: Published
//  Description: Returns the row index to which the data will be
//               written at the next call to set_data*() or
//               add_data*().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
837 0 0 6 875 3138 0 0 509 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::is_at_end
//       Access: Published
//  Description: Returns true if the writer is currently at the end of
//               the list of vertices, false otherwise.  If this is
//               true, another call to set_data*() will result in a
//               crash, but another call to add_data*() will add a new
//               row.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3367  
838 0 0 4 876 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data1f
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3143  
839 0 0 4 877 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2f
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3324  
840 0 0 4 877 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2f
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3366  1 x 1 3143  1 y 1 3143  
841 0 0 4 878 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3f
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3327  
842 0 0 4 878 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3f
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3366  1 x 1 3143  1 y 1 3143  1 z 1 3143  
843 0 0 4 879 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4f
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3330  
844 0 0 4 879 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4f
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3366  1 x 1 3143  1 y 1 3143  1 z 1 3143  1 w 1 3143  
845 0 0 4 880 3137 0 0 500 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix3f
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3369  
846 0 0 4 881 3137 0 0 500 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix4f
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3371  
847 0 0 4 882 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data1d
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3335  
848 0 0 4 883 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2d
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3336  
849 0 0 4 883 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2d
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3366  1 x 1 3335  1 y 1 3335  
850 0 0 4 884 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3d
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3339  
851 0 0 4 884 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3d
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3366  1 x 1 3335  1 y 1 3335  1 z 1 3335  
852 0 0 4 885 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4d
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3342  
853 0 0 4 885 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4d
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3366  1 x 1 3335  1 y 1 3335  1 z 1 3335  1 w 1 3335  
854 0 0 4 886 3137 0 0 500 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix3d
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3373  
855 0 0 4 887 3137 0 0 500 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix4d
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3375  
856 0 0 4 888 3137 0 0 428 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data1
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3142  
857 0 0 4 889 3137 0 0 428 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3349  
858 0 0 4 889 3137 0 0 428 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3366  1 x 1 3142  1 y 1 3142  
859 0 0 4 890 3137 0 0 428 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3352  
860 0 0 4 890 3137 0 0 428 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3366  1 x 1 3142  1 y 1 3142  1 z 1 3142  
861 0 0 4 891 3137 0 0 428 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3262  
862 0 0 4 891 3137 0 0 428 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3366  1 x 1 3142  1 y 1 3142  1 z 1 3142  1 w 1 3142  
863 0 0 4 892 3137 0 0 499 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix3
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3377  
864 0 0 4 893 3137 0 0 499 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_matrix4
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3229  
865 0 0 4 894 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data1i
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3141  
866 0 0 4 895 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2i
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3357  
867 0 0 4 895 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data2i
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3366  1 a 1 3141  1 b 1 3141  
868 0 0 4 896 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3i
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3360  
869 0 0 4 896 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data3i
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3366  1 a 1 3141  1 b 1 3141  1 c 1 3141  
870 0 0 4 897 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4i
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3363  
871 0 0 4 897 3137 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::set_data4i
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               It is an error for the write row to advance past
//               the end of data.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3366  1 a 1 3141  1 b 1 3141  1 c 1 3141  1 d 1 3141  
872 0 0 4 898 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data1f
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3143  
873 0 0 4 899 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2f
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3324  
874 0 0 4 899 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2f
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3366  1 x 1 3143  1 y 1 3143  
875 0 0 4 900 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3f
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3327  
876 0 0 4 900 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3f
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3366  1 x 1 3143  1 y 1 3143  1 z 1 3143  
877 0 0 4 901 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4f
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3330  
878 0 0 4 901 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4f
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3366  1 x 1 3143  1 y 1 3143  1 z 1 3143  1 w 1 3143  
879 0 0 4 902 3137 0 0 521 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix3f
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3369  
880 0 0 4 903 3137 0 0 521 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix4f
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3371  
881 0 0 4 904 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data1d
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3335  
882 0 0 4 905 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2d
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3336  
883 0 0 4 905 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2d
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3366  1 x 1 3335  1 y 1 3335  
884 0 0 4 906 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3d
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3339  
885 0 0 4 906 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3d
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3366  1 x 1 3335  1 y 1 3335  1 z 1 3335  
886 0 0 4 907 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4d
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3342  
887 0 0 4 907 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4d
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3366  1 x 1 3335  1 y 1 3335  1 z 1 3335  1 w 1 3335  
888 0 0 4 908 3137 0 0 521 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix3d
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3373  
889 0 0 4 909 3137 0 0 521 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix4d
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3375  
890 0 0 4 910 3137 0 0 449 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data1
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3142  
891 0 0 4 911 3137 0 0 449 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3349  
892 0 0 4 911 3137 0 0 449 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3366  1 x 1 3142  1 y 1 3142  
893 0 0 4 912 3137 0 0 449 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3352  
894 0 0 4 912 3137 0 0 449 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3366  1 x 1 3142  1 y 1 3142  1 z 1 3142  
895 0 0 4 913 3137 0 0 449 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3262  
896 0 0 4 913 3137 0 0 449 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3366  1 x 1 3142  1 y 1 3142  1 z 1 3142  1 w 1 3142  
897 0 0 4 914 3137 0 0 520 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix3
//       Access: Published
//  Description: Sets the write row to a 3-by-3 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3377  
898 0 0 4 915 3137 0 0 520 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_matrix4
//       Access: Published
//  Description: Sets the write row to a 4-by-4 matrix, and advances
//               the write row.  This is a special method that can
//               only be used on matrix columns.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  3 mat 1 3229  
899 0 0 4 916 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data1i
//       Access: Published
//  Description: Sets the write row to a particular 1-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3141  
900 0 0 4 917 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2i
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3357  
901 0 0 4 917 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data2i
//       Access: Published
//  Description: Sets the write row to a particular 2-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3366  1 a 1 3141  1 b 1 3141  
902 0 0 4 918 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3i
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3360  
903 0 0 4 918 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data3i
//       Access: Published
//  Description: Sets the write row to a particular 3-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3366  1 a 1 3141  1 b 1 3141  1 c 1 3141  
904 0 0 4 919 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4i
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3366  4 data 1 3363  
905 0 0 4 919 3137 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::add_data4i
//       Access: Published
//  Description: Sets the write row to a particular 4-component
//               value, and advances the write row.
//
//               If the write row advances past the end of data,
//               implicitly adds a new row to the data.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3366  1 a 1 3141  1 b 1 3141  1 c 1 3141  1 d 1 3141  
906 0 0 4 920 3137 0 0 224 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexWriter::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3367  3 out 1 3139  
907 0 0 7 926 3379 2411 0 326 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Constructor
//       Access: Published
//  Description: Constructs a new rewriter to process the vertices of
//               the indicated array only.
//////////////////////////////////////////////////////////////////// 2 10 array_data 1 3203  14 current_thread 1 3207  
908 0 0 7 926 3379 2411 0 326 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Constructor
//       Access: Published
//  Description: Constructs a new rewriter to process the vertices of
//               the indicated array only.
//////////////////////////////////////////////////////////////////// 3 10 array_data 1 3203  6 column 1 3141  14 current_thread 1 3207  
909 0 0 7 926 3379 2411 0 423 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Constructor
//       Access: Published
//  Description: Constructs a new rewriter to process the vertices of
//               the indicated data object.  This flavor creates the
//               rewriter specifically to process the named data type.
//////////////////////////////////////////////////////////////////// 3 11 vertex_data 1 3261  4 name 1 3155  14 current_thread 1 3207  
910 0 0 7 926 3379 2411 0 327 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Constructor
//       Access: Published
//  Description: Constructs a new rewriter to process the vertices of
//               the indicated data object.
//////////////////////////////////////////////////////////////////// 2 11 vertex_data 1 3261  14 current_thread 1 3207  
911 0 0 7 926 3379 2411 0 236 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Copy Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3380  
912 0 0 7 926 3379 2411 0 444 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::Default Constructor
//       Access: Published
//  Description: Constructs an invalid GeomVertexRewriter.  You must use
//               the assignment operator to assign a valid
//               GeomVertexRewriter to this object before you can use
//               it.
//////////////////////////////////////////////////////////////////// 1 14 current_thread 1 3207  
913 0 0 6 927 3379 0 0 0 2 4 this 3 3379  4 copy 1 3380  
914 0 0 7 929 3261 1995 0 315 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_vertex_data
//       Access: Published
//  Description: Returns the vertex data object that the
//               rewriter is processing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
915 0 0 7 930 3203 1842 0 329 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_array_data
//       Access: Published
//  Description: Returns the particular array object that the
//               rewriter is currently processing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
916 0 0 7 931 3210 1879 0 529 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_array_handle
//       Access: Published
//  Description: Returns the write handle to the array object that the
//               rewriter is currently processing.  This low-level call
//               should be used with caution; be careful with
//               modifying the data in the handle out from under the
//               GeomVertexRewriter.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
917 0 0 6 932 3132 0 0 463 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_stride
//       Access: Published
//  Description: Returns the per-row stride (bytes between consecutive
//               rows) of the underlying vertex array.  This low-level
//               information is normally not needed to use the
//               GeomVertexRewriter directly.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
918 0 0 7 933 3207 0 0 361 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_current_thread
//       Access: Published
//  Description: Returns the Thread pointer of the currently-executing
//               thread, as passed to the constructor of this object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
919 0 0 6 934 3138 0 0 653 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_column
//       Access: Published
//  Description: Sets up the rewriter to use the data type with the
//               indicated name.
//
//               This also resets both the read and write row
//               numbers to the start row (the same value passed to
//               a previous call to set_row(), or 0 if set_row()
//               was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3379  4 name 1 3155  
920 0 0 6 934 3138 0 0 675 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_column
//       Access: Published
//  Description: Sets up the rewriter to use the nth data type of the
//               GeomVertexFormat, numbering from 0.
//
//               This also resets both the read and write row
//               numbers to the start row (the same value passed to
//               a previous call to set_row(), or 0 if set_row()
//               was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3379  6 column 1 3141  
921 0 0 6 934 3138 0 0 667 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_column
//       Access: Published
//  Description: Sets up the rewriter to use the indicated column
//               description on the given array.
//
//               This also resets both the read and write row
//               numbers to the start row (the same value passed to
//               a previous call to set_row(), or 0 if set_row()
//               was never called.)
//
//               The return value is true if the data type is valid,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3379  5 array 1 3141  6 column 1 3160  
922 0 0 4 935 3137 0 0 276 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::clear
//       Access: Published
//  Description: Resets the GeomVertexRewriter to the initial state.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3379  
923 0 0 6 936 3138 0 0 366 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::has_column
//       Access: Published
//  Description: Returns true if a valid data type has been
//               successfully set, or false if the data type does not
//               exist.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
924 0 0 6 937 3141 0 0 327 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_array
//       Access: Published
//  Description: Returns the array index containing the data type that
//               the rewriter is working on.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
925 0 0 6 938 3160 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_column
//       Access: Published
//  Description: Returns the description of the data type that the
//               rewriter is working on.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
926 0 0 4 939 3137 0 0 657 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_row_unsafe
//       Access: Published
//  Description: Sets the start row to the indicated value, without
//               internal checks.  This is the same as set_row(), but
//               it does not check for the possibility that the array
//               has been reallocated internally for some reason; use
//               only when you are confident that the array is
//               unchanged and you really need every bit of available
//               performance.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3379  3 row 1 3141  
927 0 0 4 940 3137 0 0 379 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::set_row
//       Access: Published
//  Description: Sets the start, write, and write index to the
//               indicated value.  The rewriter will begin traversing
//               from the given row.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3379  3 row 1 3141  
928 0 0 6 941 3141 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::get_start_row
//       Access: Published
//  Description: Returns the row index at which the rewriter
//               started.  It will return to this row if you reset
//               the current column.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
929 0 0 6 942 3138 0 0 348 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::is_at_end
//       Access: Published
//  Description: Returns true if the reader or writer is currently at
//               the end of the list of vertices, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3380  
930 0 0 4 943 3137 0 0 226 ////////////////////////////////////////////////////////////////////
//     Function: GeomVertexRewriter::output
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3380  3 out 1 3139  
931 0 0 6 922 3366 0 0 0 1 4 this 3 3379  
932 0 0 6 923 3379 0 0 0 1 4 this 3 3366  
933 0 0 6 924 3321 0 0 0 1 4 this 3 3379  
934 0 0 6 925 3379 0 0 0 1 4 this 3 3321  
935 0 0 7 947 3382 2466 0 303 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::Constructor
//       Access: Published
//  Description: Creates a new SamplerState initialized to the
//               default values.
//////////////////////////////////////////////////////////////////// 0 
936 0 0 6 948 3383 0 0 322 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_default
//       Access: Published, Static
//  Description: Returns a reference to the global default immutable
//               SamplerState object.
//////////////////////////////////////////////////////////////////// 0 
937 0 0 4 949 3137 0 0 479 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_wrap_u
//       Access: Published
//  Description: This setting determines what happens when the
//               SamplerState is sampled with a U value outside the range
//               0.0-1.0.  The default is WM_repeat, which indicates
//               that the SamplerState should repeat indefinitely.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  4 wrap 1 3091  
938 0 0 4 950 3137 0 0 479 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_wrap_v
//       Access: Published
//  Description: This setting determines what happens when the
//               SamplerState is sampled with a V value outside the range
//               0.0-1.0.  The default is WM_repeat, which indicates
//               that the SamplerState should repeat indefinitely.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  4 wrap 1 3091  
939 0 0 4 951 3137 0 0 280 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_wrap_w
//       Access: Published
//  Description: The W wrap direction is only used for 3-d SamplerStates.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  4 wrap 1 3091  
940 0 0 4 952 3137 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_minfilter
//       Access: Published
//  Description: Sets the filtering method that should be used when
//               viewing the SamplerState from a distance.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  6 filter 1 3090  
941 0 0 4 953 3137 0 0 329 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_magfilter
//       Access: Published
//  Description: Sets the filtering method that should be used when
//               viewing the SamplerState up close.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  6 filter 1 3090  
942 0 0 4 954 3137 0 0 748 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_anisotropic_degree
//       Access: Published
//  Description: Specifies the level of anisotropic filtering to apply
//               to the SamplerState.  Set this 0 to indicate the default
//               value, which is specified in the
//               SamplerState-anisotropic-degree config variable.
//
//               To explicitly disable anisotropic filtering, set this
//               value to 1.  To explicitly enable anisotropic
//               filtering, set it to a value higher than 1; larger
//               numbers indicate greater degrees of filtering.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  18 anisotropic_degree 1 3141  
943 0 0 4 955 3137 0 0 461 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_border_color
//       Access: Published
//  Description: Specifies the solid color of the SamplerState's border.
//               Some OpenGL implementations use a border for tiling
//               SamplerStates; in Panda, it is only used for specifying
//               the clamp color.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  5 color 1 3266  
944 0 0 4 956 3137 0 0 368 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_min_lod
//       Access: Published
//  Description: Sets the minimum level of detail that will be used
//               when sampling this texture.  This may be a negative
//               value.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  7 min_lod 1 3142  
945 0 0 4 957 3137 0 0 404 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_max_lod
//       Access: Published
//  Description: Sets the maximum level of detail that will be used
//               when sampling this texture.  This may exceed the
//               number of mipmap levels that the texture has.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  7 max_lod 1 3142  
946 0 0 4 958 3137 0 0 471 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::set_lod_bias
//       Access: Published
//  Description: Sets the value that will be added to the level of
//               detail when sampling the texture.  This may be a
//               negative value, although some graphics hardware may
//               not support the use of negative LOD values.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3382  8 lod_bias 1 3142  
947 0 0 6 959 3091 0 0 297 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_wrap_u
//       Access: Published
//  Description: Returns the wrap mode of the texture in the U
//               direction.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
948 0 0 6 960 3091 0 0 297 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_wrap_v
//       Access: Published
//  Description: Returns the wrap mode of the texture in the V
//               direction.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
949 0 0 6 961 3091 0 0 360 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_wrap_w
//       Access: Published
//  Description: Returns the wrap mode of the texture in the W
//               direction.  This is the depth direction of 3-d
//               textures.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
950 0 0 6 962 3090 0 0 492 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_minfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               minification.  If this is one of the mipmap
//               constants, then the texture requires mipmaps.  This
//               may return FT_default; see also
//               get_effective_minfilter().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
951 0 0 6 963 3090 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_magfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               magnification.  The mipmap constants are invalid
//               here.  This may return FT_default; see also
//               get_effective_minfilter().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
952 0 0 6 964 3090 0 0 470 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_effective_minfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               minification, with special treatment for FT_default.
//               This will normally not return FT_default, unless
//               there is an error in the config file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
953 0 0 6 965 3090 0 0 471 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_effective_magfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               magnification, with special treatment for FT_default.
//               This will normally not return FT_default, unless
//               there is an error in the config file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
954 0 0 6 966 3141 0 0 468 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_anisotropic_degree
//       Access: Published
//  Description: Returns the degree of anisotropic filtering that
//               should be applied to the texture.  This value may
//               return 0, indicating the default value; see also
//               get_effective_anisotropic_degree.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
955 0 0 6 967 3141 0 0 464 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_effective_anisotropic_degree
//       Access: Published
//  Description: Returns the degree of anisotropic filtering that
//               should be applied to the texture.  This value will
//               normally not return 0, unless there is an error in
//               the config file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
956 0 0 6 968 3266 0 0 449 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_border_color
//       Access: Published
//  Description: Returns the solid color of the texture's border.
//               Some OpenGL implementations use a border for tiling
//               textures; in Panda, it is only used for specifying
//               the clamp color.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
957 0 0 6 969 3142 0 0 327 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_min_lod
//       Access: Published
//  Description: Returns the minimum level of detail that will be
//               observed when sampling this texture.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
958 0 0 6 970 3142 0 0 327 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_max_lod
//       Access: Published
//  Description: Returns the maximum level of detail that will be
//               observed when sampling this texture.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
959 0 0 6 971 3142 0 0 337 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::get_lod_bias
//       Access: Published
//  Description: Returns the bias that will be added to the texture
//               level of detail when sampling this texture.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
960 0 0 6 972 3138 0 0 360 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::uses_mipmaps
//       Access: Public
//  Description: Returns true if the minfilter settings on this
//               sampler indicate the use of mipmapping, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3383  
961 0 0 6 973 3138 0 0 343 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::is_mipmap
//       Access: Published, Static
//  Description: Returns true if the indicated filter type requires
//               the use of mipmaps, or false if it does not.
//////////////////////////////////////////////////////////////////// 1 4 type 1 3090  
962 0 0 6 974 3131 0 0 317 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::format_filter_type
//       Access: Published, Static
//  Description: Returns the indicated FilterType converted to a
//               string word.
//////////////////////////////////////////////////////////////////// 1 2 ft 1 3090  
963 0 0 6 975 3090 0 0 411 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::string_filter_type
//       Access: Public
//  Description: Returns the FilterType value associated with the given
//               string representation, or FT_invalid if the string
//               does not match any known FilterType value.
//////////////////////////////////////////////////////////////////// 1 3 str 1 3131  
964 0 0 6 976 3131 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::format_wrap_mode
//       Access: Published, Static
//  Description: Returns the indicated WrapMode converted to a
//               string word.
//////////////////////////////////////////////////////////////////// 1 2 wm 1 3091  
965 0 0 6 977 3091 0 0 405 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::string_wrap_mode
//       Access: Public
//  Description: Returns the WrapMode value associated with the given
//               string representation, or WM_invalid if the string
//               does not match any known WrapMode value.
//////////////////////////////////////////////////////////////////// 1 3 str 1 3131  
966 0 0 6 978 3138 0 0 0 2 4 this 3 3383  5 other 1 3383  
967 0 0 6 979 3138 0 0 0 2 4 this 3 3383  5 other 1 3383  
968 0 0 6 980 3138 0 0 0 2 4 this 3 3383  5 other 1 3383  
969 0 0 4 981 3137 0 0 519 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::prepare
//       Access: Published
//  Description: Indicates that the sampler should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.
//
//               Use this function instead of prepare_now() to preload
//               samplers from a user interface standpoint.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3383  16 prepared_objects 1 3211  
970 0 0 6 982 3138 0 0 379 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::is_prepared
//       Access: Published
//  Description: Returns true if the sampler has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3383  16 prepared_objects 1 3211  
971 0 0 4 983 3137 0 0 399 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::release
//       Access: Published
//  Description: Frees the texture context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3383  16 prepared_objects 1 3211  
972 0 0 6 984 3385 0 0 894 ////////////////////////////////////////////////////////////////////
//     Function: SamplerState::prepare_now
//       Access: Published
//  Description: Creates a context for the sampler on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) SamplerContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               textures.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a sampler does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3383  16 prepared_objects 1 3211  3 gsg 1 3212  
973 0 0 7 985 3158 0 0 0 0 
974 0 0 7 999 3387 2472 0 446 ////////////////////////////////////////////////////////////////////
//     Function: Texture::Constructor
//       Access: Published
//  Description: Constructs an empty texture.  The default is to set
//               up the texture as an empty 2-d texture; follow up
//               with one of the variants of setup_texture() if this
//               is not what you want.
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
975 0 0 7 1001 3387 2472 0 680 ////////////////////////////////////////////////////////////////////
//     Function: Texture::make_copy
//       Access: Published
//  Description: Returns a new copy of the same Texture.  This copy,
//               if applied to geometry, will be copied into texture
//               as a separate texture from the original, so it will
//               be duplicated in texture memory (and may be
//               independently modified if desired).
//
//               If the Texture is a VideoTexture, the resulting
//               duplicate may be animated independently of the
//               original.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
976 0 0 4 1002 3137 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear
//       Access: Published, Virtual
//  Description: Reinitializes the texture to its default, empty
//               state (except for the name).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
977 0 0 4 1003 3137 0 0 513 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_texture
//       Access: Published
//  Description: Sets the texture to the indicated type and
//               dimensions, presumably in preparation for calling
//               read() or load(), or set_ram_image() or
//               modify_ram_image(), or use set_clear_color to let
//               the texture be cleared to a solid color.
//////////////////////////////////////////////////////////////////// 7 4 this 3 3387  12 texture_type 1 3093  6 x_size 1 3141  6 y_size 1 3141  6 z_size 1 3141  14 component_type 1 3094  6 format 1 3095  
978 0 0 4 1004 3137 0 0 504 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_1d_texture
//       Access: Published
//  Description: Sets the texture as an empty 1-d texture with no
//               dimensions.  Follow up with read() or load() to fill
//               the texture properties and image data, or use
//               set_clear_color to let the texture be cleared to a
//               solid color.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
979 0 0 4 1004 3137 0 0 528 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_1d_texture
//       Access: Published
//  Description: Sets the texture as an empty 1-d texture with the
//               specified dimensions and properties.  Follow up with
//               set_ram_image() or modify_ram_image() to fill the
//               image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  6 x_size 1 3141  14 component_type 1 3094  6 format 1 3095  
980 0 0 4 1005 3137 0 0 504 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_2d_texture
//       Access: Published
//  Description: Sets the texture as an empty 2-d texture with no
//               dimensions.  Follow up with read() or load() to fill
//               the texture properties and image data, or use
//               set_clear_color to let the texture be cleared to a
//               solid color.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
981 0 0 4 1005 3137 0 0 528 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_2d_texture
//       Access: Published
//  Description: Sets the texture as an empty 2-d texture with the
//               specified dimensions and properties.  Follow up with
//               set_ram_image() or modify_ram_image() to fill the
//               image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3387  6 x_size 1 3141  6 y_size 1 3141  14 component_type 1 3094  6 format 1 3095  
982 0 0 4 1006 3137 0 0 603 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_3d_texture
//       Access: Published
//  Description: Sets the texture as an empty 3-d texture with no
//               dimensions (though if you know the depth ahead
//               of time, it saves a bit of reallocation later).
//               Follow up with read() or load() to fill the texture
//               properties and image data, or use set_clear_color
//               to let the texture be cleared to a solid color.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  6 z_size 1 3141  
983 0 0 4 1006 3137 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_3d_texture
//       Access: Published
//  Description: Sets the texture as an empty 3-d texture with the
//               specified dimensions and properties.  Follow up with
//               set_ram_image() or modify_ram_image() to fill the
//               image data.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3387  6 x_size 1 3141  6 y_size 1 3141  6 z_size 1 3141  14 component_type 1 3094  6 format 1 3095  
984 0 0 4 1007 3137 0 0 507 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_cube_map
//       Access: Published
//  Description: Sets the texture as an empty cube map texture with no
//               dimensions.  Follow up with read() or load() to fill
//               the texture properties and image data, or use
//               set_clear_color to let the texture be cleared to a
//               solid color.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
985 0 0 4 1007 3137 0 0 713 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_cube_map
//       Access: Published
//  Description: Sets the texture as an empty cube map texture with
//               the specified dimensions and properties.  Follow up
//               with set_ram_image() or modify_ram_image() to fill
//               the image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
//
//               Note that a cube map should always consist of six
//               square images, so x_size and y_size will be the same,
//               and z_size is always 6.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  4 size 1 3141  14 component_type 1 3094  6 format 1 3095  
986 0 0 4 1008 3137 0 0 615 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_2d_texture_array
//       Access: Published
//  Description: Sets the texture as an empty 2-d texture array with
//               no dimensions (though if you know the depth ahead
//               of time, it saves a bit of reallocation later).
//               Follow up with read() or load() to fill the texture
//               properties and image data, or use set_clear_color
//               to let the texture be cleared to a solid color.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  6 z_size 1 3141  
987 0 0 4 1008 3137 0 0 539 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_2d_texture_array
//       Access: Published
//  Description: Sets the texture as an empty 2-d texture array with the
//               specified dimensions and properties. Follow up with
//               set_ram_image() or modify_ram_image() to fill the
//               image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3387  6 x_size 1 3141  6 y_size 1 3141  6 z_size 1 3141  14 component_type 1 3094  6 format 1 3095  
988 0 0 4 1009 3137 0 0 637 ////////////////////////////////////////////////////////////////////
//     Function: Texture::setup_buffer_texture
//       Access: Published
//  Description: Sets the texture as an empty buffer texture with
//               the specified size and properties.  Follow up
//               with set_ram_image() or modify_ram_image() to fill
//               the image data, or use set_clear_color to let the
//               texture be cleared to a solid color.
//
//               Note that a buffer texture's format needs to match
//               the component type.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3387  4 size 1 3141  14 component_type 1 3094  6 format 1 3095  5 usage 1 3030  
989 0 0 4 1010 3137 0 0 601 ////////////////////////////////////////////////////////////////////
//     Function: Texture::generate_normalization_cube_map
//       Access: Published
//  Description: Generates a special cube map image in the texture
//               that can be used to apply bump mapping effects: for
//               each texel in the cube map that is indexed by the 3-d
//               texture coordinates (x, y, z), the resulting value is
//               the normalized vector (x, y, z) (compressed from
//               -1..1 into 0..1).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  4 size 1 3141  
990 0 0 4 1011 3137 0 0 534 ////////////////////////////////////////////////////////////////////
//     Function: Texture::generate_alpha_scale_map
//       Access: Published
//  Description: Generates a special 256x1 1-d texture that can be
//               used to apply an arbitrary alpha scale to objects by
//               judicious use of texture matrix.  The texture is a
//               gradient, with an alpha of 0 on the left (U = 0), and
//               255 on the right (U = 1).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
991 0 0 4 1012 3137 0 0 772 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_image
//       Access: Published
//  Description: Clears the texture data without changing its format
//               or resolution.  The texture is cleared on both the
//               graphics hardware and from RAM, unlike clear_ram_image,
//               which only removes the data from RAM.
//
//               If a clear color has been specified using
//               set_clear_color, the texture will be cleared using
//               a solid color.
//
//               The texture data will be cleared the first time in
//               which the texture is used after this method is called.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
992 0 0 6 1013 3138 0 0 306 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_clear_color
//       Access: Published
//  Description: Returns true if a color was previously set using
//               set_clear_color.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
993 0 0 7 1014 3289 0 0 305 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_clear_color
//       Access: Published
//  Description: Returns the color that was previously set using
//               set_clear_color.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
994 0 0 4 1015 3137 0 0 659 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_clear_color
//       Access: Published
//  Description: Sets the color that will be used to fill the
//               texture image in absence of any image data.  It is
//               used when any of the setup_texture functions or
//               clear_image is called and image data is not
//               provided using read() or modify_ram_image().
//
//               This does not affect a texture that has already
//               been cleared; call clear_image to clear it again.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  5 color 1 3266  
995 0 0 6 1016 3131 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_clear_data
//       Access: Published
//  Description: Returns the raw image data for a single pixel if
//               it were set to the clear color.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
996 0 0 6 1017 3138 0 0 519 ////////////////////////////////////////////////////////////////////
//     Function: Texture::read
//       Access: Published
//  Description: Combine a 3-component image with a grayscale image
//               to get a 4-component image.
//
//               See the description of the full-parameter read()
//               method for the meaning of the
//               primary_file_num_channels and alpha_file_channel
//               parameters.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3387  8 fullpath 1 3390  14 alpha_fullpath 1 3390  25 primary_file_num_channels 1 3141  18 alpha_file_channel 1 3141  7 options 1 3393  
997 0 0 6 1017 3138 0 0 3902 ////////////////////////////////////////////////////////////////////
//     Function: Texture::read
//       Access: Published
//  Description: Reads the texture from the indicated filename.  If
//               primary_file_num_channels is not 0, it specifies the
//               number of components to downgrade the image to if it
//               is greater than this number.
//
//               If the filename has the extension .txo, this
//               implicitly reads a texture object instead of a
//               filename (which replaces all of the texture
//               properties).  In this case, all the rest of the
//               parameters are ignored, and the filename should not
//               contain any hash marks; just the one named file will
//               be read, since a single .txo file can contain all
//               pages and mipmaps necessary to define a texture.
//
//               If alpha_fullpath is not empty, it specifies the name
//               of a file from which to retrieve the alpha.  In this
//               case, alpha_file_channel represents the numeric
//               channel of this image file to use as the resulting
//               texture's alpha channel; usually, this is 0 to
//               indicate the grayscale combination of r, g, b; or it
//               may be a one-based channel number, e.g. 1 for the red
//               channel, 2 for the green channel, and so on.
//
//               If read pages is false, then z indicates the page
//               number into which this image will be assigned.
//               Normally this is 0 for the first (or only) page of
//               the texture.  3-D textures have one page for each
//               level of depth, and cube map textures always have six
//               pages.
//
//               If read_pages is true, multiple images will be read
//               at once, one for each page of a cube map or a 3-D
//               texture.  In this case, the filename should contain a
//               sequence of one or more hash marks ("#") which will
//               be filled in with the z value of each page,
//               zero-based.  In this case, the z parameter indicates
//               the maximum z value that will be loaded, or 0 to load
//               all filenames that exist.
//
//               If read_mipmaps is false, then n indicates the mipmap
//               level to which this image will be assigned.  Normally
//               this is 0 for the base texture image, but it is
//               possible to load custom mipmap levels into the later
//               images.  After the base texture image is loaded (thus
//               defining the size of the texture), you can call
//               get_expected_num_mipmap_levels() to determine the
//               maximum sensible value for n.
//
//               If read_mipmaps is true, multiple images will be read
//               as above, but this time the images represent the
//               different mipmap levels of the texture image.  In
//               this case, the n parameter indicates the maximum n
//               value that will be loaded, or 0 to load all filenames
//               that exist (up to the expected number of mipmap
//               levels).
//
//               If both read_pages and read_mipmaps is true, then
//               both sequences will be read; the filename should
//               contain two sequences of hash marks, separated by
//               some character such as a hyphen, underscore, or dot.
//               The first hash mark sequence will be filled in with
//               the mipmap level, while the second hash mark sequence
//               will be the page index.
//
//               This method implicitly sets keep_ram_image to false.
//////////////////////////////////////////////////////////////////// 11 4 this 3 3387  8 fullpath 1 3390  14 alpha_fullpath 1 3390  25 primary_file_num_channels 1 3141  18 alpha_file_channel 1 3141  1 z 1 3141  1 n 1 3141  10 read_pages 1 3138  12 read_mipmaps 1 3138  6 record 1 3396  7 options 1 3393  
998 0 0 6 1017 3138 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: Texture::read
//       Access: Published
//  Description: Reads the named filename into the texture.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3387  8 fullpath 1 3390  7 options 1 3393  
999 0 0 6 1017 3138 0 0 524 ////////////////////////////////////////////////////////////////////
//     Function: Texture::read
//       Access: Published
//  Description: Reads a single file into a single page or mipmap
//               level, or automatically reads a series of files into
//               a series of pages and/or mipmap levels.
//
//               See the description of the full-parameter read()
//               method for the meaning of the various parameters.
//////////////////////////////////////////////////////////////////// 7 4 this 3 3387  8 fullpath 1 3390  1 z 1 3141  1 n 1 3141  10 read_pages 1 3138  12 read_mipmaps 1 3138  7 options 1 3393  
1000 0 0 6 1018 3138 0 0 255 ////////////////////////////////////////////////////////////////////
//     Function: Texture::write
//       Access: Published
//  Description: Writes the texture to the named filename.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  8 fullpath 1 3390  
1001 0 0 6 1018 3138 0 0 3125 ////////////////////////////////////////////////////////////////////
//     Function: Texture::write
//       Access: Published
//  Description: Writes a single page or mipmap level to a single
//               file, or automatically writes a series of pages
//               and/or mipmap levels to a numbered series of files.
//
//               If the filename ends in the extension .txo, this
//               implicitly writes a Panda texture object (.txo)
//               instead of an image file.  In this case, the
//               remaining parameters are ignored, and only one file
//               is written, which will contain all of the pages and
//               resident mipmap levels in the texture.
//
//               If write_pages is false, then z indicates the page
//               number to write.  3-D textures have one page number
//               for each level of depth; cube maps have six pages
//               number 0 through 5.  Other kinds of textures have
//               only one page, numbered 0.  If there are multiple
//               views, the range of z is increased; the total range
//               is [0, get_num_pages()).
//
//               If write_pages is true, then all pages of the texture
//               will be written.  In this case z is ignored, and the
//               filename should contain a sequence of hash marks
//               ("#") which will be filled in with the page index
//               number.
//
//               If write_mipmaps is false, then n indicates the
//               mipmap level number to write.  Normally, this is 0,
//               for the base texture image.  Normally, the mipmap
//               levels of a texture are not available in RAM (they
//               are generated automatically by the graphics card).
//               However, if you have the mipmap levels available, for
//               instance because you called
//               generate_ram_mipmap_images() to generate them
//               internally, or you called
//               GraphicsEngine::extract_texture_data() to retrieve
//               them from the graphics card, then you may write out
//               each mipmap level with this parameter.
//
//               If write_mipmaps is true, then all mipmap levels of
//               the texture will be written.  In this case n is
//               ignored, and the filename should contain a sequence
//               of hash marks ("#") which will be filled in with the
//               mipmap level number.
//
//               If both write_pages and write_mipmaps is true, then
//               all pages and all mipmap levels will be written.  In
//               this case, the filename should contain two different
//               sequences of hash marks, separated by a character
//               such as a hyphen, underscore, or dot.  The first hash
//               mark sequence will be filled in with the mipmap
//               level, while the second hash mark sequence will be
//               the page index.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3387  8 fullpath 1 3390  1 z 1 3141  1 n 1 3141  11 write_pages 1 3138  13 write_mipmaps 1 3138  
1002 0 0 4 1018 3137 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: Texture::write
//       Access: Published
//  Description: Not to be confused with write(Filename), this method
//               simply describes the texture properties.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3388  3 out 1 3139  12 indent_level 1 3141  
1003 0 0 6 1019 3138 0 0 692 ////////////////////////////////////////////////////////////////////
//     Function: Texture::read_txo
//       Access: Published
//  Description: Reads the texture from a Panda texture object.  This
//               defines the complete Texture specification, including
//               the image data as well as all texture properties.
//               This only works if the txo file contains a static
//               Texture image, as opposed to a subclass of Texture
//               such as a movie texture.
//
//               Pass a real filename if it is available, or empty
//               string if it is not.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3387  2 in 1 3398  8 filename 1 3131  
1004 0 0 7 1020 3387 2472 0 621 ////////////////////////////////////////////////////////////////////
//     Function: Texture::make_from_txo
//       Access: Published, Static
//  Description: Constructs a new Texture object from the txo file.
//               This is similar to Texture::read_txo(), but it
//               constructs and returns a new object, which allows it
//               to return a subclass of Texture (for instance, a
//               movie texture).
//
//               Pass a real filename if it is available, or empty
//               string if it is not.
//////////////////////////////////////////////////////////////////// 2 2 in 1 3398  8 filename 1 3131  
1005 0 0 6 1021 3138 0 0 463 ////////////////////////////////////////////////////////////////////
//     Function: Texture::write_txo
//       Access: Published
//  Description: Writes the texture to a Panda texture object.  This
//               defines the complete Texture specification, including
//               the image data as well as all texture properties.
//
//               The filename is just for reference.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3388  3 out 1 3139  8 filename 1 3131  
1006 0 0 6 1022 3138 0 0 674 ////////////////////////////////////////////////////////////////////
//     Function: Texture::read_dds
//       Access: Published
//  Description: Reads the texture from a DDS file object.  This is a
//               Microsoft-defined file format; it is similar in
//               principle to a txo object, in that it is designed to
//               contain the texture image in a form as similar as
//               possible to its runtime image, and it can contain
//               mipmaps, pre-compressed textures, and so on.
//
//               As with read_txo, the filename is just for reference.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  2 in 1 3398  8 filename 1 3131  11 header_only 1 3138  
1007 0 0 6 1023 3138 0 0 259 ////////////////////////////////////////////////////////////////////
//     Function: Texture::load
//       Access: Published
//  Description: Replaces the texture with the indicated image.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3387  8 pnmimage 1 3400  7 options 1 3393  
1008 0 0 6 1023 3138 0 0 305 ////////////////////////////////////////////////////////////////////
//     Function: Texture::load
//       Access: Published
//  Description: Stores the indicated image in the given page and
//               mipmap level.  See read().
//////////////////////////////////////////////////////////////////// 5 4 this 3 3387  8 pnmimage 1 3400  1 z 1 3141  1 n 1 3141  7 options 1 3393  
1009 0 0 6 1023 3138 0 0 259 ////////////////////////////////////////////////////////////////////
//     Function: Texture::load
//       Access: Published
//  Description: Replaces the texture with the indicated image.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3387  3 pfm 1 3403  7 options 1 3393  
1010 0 0 6 1023 3138 0 0 305 ////////////////////////////////////////////////////////////////////
//     Function: Texture::load
//       Access: Published
//  Description: Stores the indicated image in the given page and
//               mipmap level.  See read().
//////////////////////////////////////////////////////////////////// 5 4 this 3 3387  3 pfm 1 3403  1 z 1 3141  1 n 1 3141  7 options 1 3393  
1011 0 0 6 1024 3138 0 0 628 ////////////////////////////////////////////////////////////////////
//     Function: Texture::load_sub_image
//       Access: Published
//  Description: Stores the indicated image in a region of the
//               texture.  The texture properties remain unchanged.
//               This can be more efficient than updating an entire
//               texture, but has a few restrictions: for one, you
//               must ensure that the texture is still in RAM (eg.
//               using set_keep_ram_image) and it may not be
//               compressed.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3387  8 pnmimage 1 3400  1 x 1 3141  1 y 1 3141  1 z 1 3141  1 n 1 3141  
1012 0 0 6 1025 3138 0 0 306 ////////////////////////////////////////////////////////////////////
//     Function: Texture::store
//       Access: Published
//  Description: Saves the texture to the indicated PNMImage, but does
//               not write it to disk.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  8 pnmimage 1 3406  
1013 0 0 6 1025 3138 0 0 304 ////////////////////////////////////////////////////////////////////
//     Function: Texture::store
//       Access: Published
//  Description: Saves the indicated page and mipmap level of the
//               texture to the PNMImage.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3388  8 pnmimage 1 3406  1 z 1 3141  1 n 1 3141  
1014 0 0 6 1025 3138 0 0 305 ////////////////////////////////////////////////////////////////////
//     Function: Texture::store
//       Access: Published
//  Description: Saves the texture to the indicated PfmFile, but does
//               not write it to disk.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  3 pfm 1 3407  
1015 0 0 6 1025 3138 0 0 303 ////////////////////////////////////////////////////////////////////
//     Function: Texture::store
//       Access: Published
//  Description: Saves the indicated page and mipmap level of the
//               texture to the PfmFile.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3388  3 pfm 1 3407  1 z 1 3141  1 n 1 3141  
1016 0 0 6 1026 3138 0 0 532 ////////////////////////////////////////////////////////////////////
//     Function: Texture::reload
//       Access: Published
//  Description: Re-reads the Texture from its disk file.  Useful when
//               you know the image on disk has recently changed, and
//               you want to update the Texture image.
//
//               Returns true on success, false on failure (in which
//               case, the Texture may or may not still be valid).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1017 0 0 7 1027 3387 2472 0 444 ////////////////////////////////////////////////////////////////////
//     Function: Texture::load_related
//       Access: Published
//  Description: Loads a texture whose filename is derived by
//               concatenating a suffix to the filename of this
//               texture.  May return NULL, for example, if this
//               texture doesn't have a filename.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  6 suffix 1 3155  
1018 0 0 6 1028 3138 0 0 318 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_filename
//       Access: Published
//  Description: Returns true if the filename has been set and
//               is available.  See set_filename().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1019 0 0 6 1029 3390 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_filename
//       Access: Published
//  Description: Returns the filename that has been set.  This is the
//               name of the file as it was requested.  Also see
//               get_fullpath().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1020 0 0 6 1030 3138 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_alpha_filename
//       Access: Published
//  Description: Returns true if the alpha_filename has been set and
//               is available.  See set_alpha_filename().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1021 0 0 6 1031 3390 0 0 475 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_alpha_filename
//       Access: Published
//  Description: Returns the alpha_filename that has been set.  If
//               this is set, it represents the name of the alpha
//               component, which is stored in a separate file.  See
//               also get_filename(), and get_alpha_fullpath().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1022 0 0 6 1032 3138 0 0 318 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_fullpath
//       Access: Published
//  Description: Returns true if the fullpath has been set and
//               is available.  See set_fullpath().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1023 0 0 6 1033 3390 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_fullpath
//       Access: Published
//  Description: Returns the fullpath that has been set.  This is the
//               full path to the file as it was found along the
//               texture search path.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1024 0 0 6 1034 3138 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_alpha_fullpath
//       Access: Published
//  Description: Returns true if the alpha_fullpath has been set and
//               is available.  See set_alpha_fullpath().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1025 0 0 6 1035 3390 0 0 429 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_alpha_fullpath
//       Access: Published
//  Description:
//               Returns the alpha_fullpath that has been set.  This
//               is the full path to the alpha part of the image file
//               as it was found along the texture search path.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1026 0 0 6 1036 3141 0 0 268 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_x_size
//       Access: Published
//  Description: Returns the width of the texture image in texels.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1027 0 0 6 1037 3141 0 0 321 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_y_size
//       Access: Published
//  Description: Returns the height of the texture image in texels.
//               For a 1-d texture, this will be 1.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1028 0 0 6 1038 3141 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_z_size
//       Access: Published
//  Description: Returns the depth of the texture image in texels.
//               For a 1-d texture or 2-d texture, this will be 1.
//               For a cube map texture, this will be 6.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1029 0 0 6 1039 3141 0 0 758 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_views
//       Access: Published
//  Description: Returns the number of "views" in the texture.  A view
//               is a completely separate image stored within the
//               Texture object.  Most textures have only one view,
//               but a stereo texture, for instance, may have two
//               views, a left and a right image.  Other uses for
//               multiple views are not yet defined.
//
//               If this value is greater than one, the additional
//               views are accessed as additional pages beyond
//               get_z_size().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1030 0 0 6 1040 3141 0 0 602 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_pages
//       Access: Published
//  Description: Returns the total number of pages in the texture.
//               Each "page" is a 2-d texture image within the larger
//               image--a face of a cube map, or a level of a 3-d
//               texture.  Normally, get_num_pages() is the same as
//               get_z_size().  However, in a multiview texture, this
//               returns get_z_size() * get_num_views().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1031 0 0 6 1041 3141 0 0 456 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_components
//       Access: Published
//  Description: Returns the number of color components for each texel
//               of the texture image.  This is 3 for an rgb texture
//               or 4 for an rgba texture; it may also be 1 or 2 for a
//               grayscale texture.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1032 0 0 6 1042 3141 0 0 390 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_component_width
//       Access: Published
//  Description: Returns the number of bytes stored for each color
//               component of a texel.  Typically this is 1, but it
//               may be 2 for 16-bit texels.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1033 0 0 6 1043 3093 0 0 275 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_texture_type
//       Access: Published
//  Description: Returns the overall interpretation of the texture.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1034 0 0 6 1044 3095 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_format
//       Access: Published
//  Description: Returns the format of the texture, which represents
//               both the semantic meaning of the texels and, to some
//               extent, their storage information.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1035 0 0 6 1045 3094 0 0 312 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_component_type
//       Access: Published
//  Description: Returns the numeric interpretation of each component
//               of the texture.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1036 0 0 6 1046 3030 0 0 340 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_usage_hint
//       Access: Published
//  Description: Returns the usage hint specified for buffer textures,
//               or UH_unspecified for all other texture types.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1037 0 0 4 1047 3137 0 0 0 2 4 this 3 3387  4 wrap 1 3408  
1038 0 0 4 1048 3137 0 0 0 2 4 this 3 3387  4 wrap 1 3408  
1039 0 0 4 1049 3137 0 0 0 2 4 this 3 3387  4 wrap 1 3408  
1040 0 0 4 1050 3137 0 0 0 2 4 this 3 3387  6 filter 1 3409  
1041 0 0 4 1051 3137 0 0 0 2 4 this 3 3387  6 filter 1 3409  
1042 0 0 4 1052 3137 0 0 916 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_anisotropic_degree
//       Access: Published
//  Description: Specifies the level of anisotropic filtering to apply
//               to the texture.  Set this 0 to indicate the default
//               value, which is specified in the
//               texture-anisotropic-degree config variable.
//
//               To explicitly disable anisotropic filtering, set this
//               value to 1.  To explicitly enable anisotropic
//               filtering, set it to a value higher than 1; larger
//               numbers indicate greater degrees of filtering.
//
//               This sets the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  18 anisotropic_degree 1 3141  
1043 0 0 4 1053 3137 0 0 629 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_border_color
//       Access: Published
//  Description: Specifies the solid color of the texture's border.
//               Some OpenGL implementations use a border for tiling
//               textures; in Panda, it is only used for specifying
//               the clamp color.
//
//               This sets the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  5 color 1 3266  
1044 0 0 4 1054 3137 0 0 1035 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_compression
//       Access: Published
//  Description: Requests that this particular Texture be compressed
//               when it is loaded into texture memory.
//
//               This refers to the internal compression of the
//               texture image within texture memory; it is not
//               related to jpeg or png compression, which are disk
//               file compression formats.  The actual disk file that
//               generated this texture may be stored in a compressed
//               or uncompressed format supported by Panda; it will be
//               decompressed on load, and then recompressed by the
//               graphics API if this parameter is not CM_off.
//
//               If the GSG does not support this texture compression
//               mode, the texture will silently be loaded
//               uncompressed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  11 compression 1 3098  
1045 0 0 4 1055 3137 0 0 905 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_render_to_texture
//       Access: Published
//  Description: Sets a flag on the texture that indicates whether the
//               texture is intended to be used as a direct-render
//               target, by binding a framebuffer to a texture and
//               rendering directly into the texture.
//
//               This controls some low-level choices made about the
//               texture object itself.  For instance, compressed
//               textures are disallowed when this flag is set true.
//
//               Normally, a user should not need to set this flag
//               directly; it is set automatically by the low-level
//               display code when a texture is bound to a
//               framebuffer.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  17 render_to_texture 1 3138  
1046 0 0 6 1056 3383 0 0 501 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_default_sampler
//       Access: Published
//  Description: This returns the default sampler state for this
//               texture, containing the wrap and filter properties
//               specified on the texture level; it may still be
//               overridden by a sampler state specified at a higher
//               level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1047 0 0 4 1057 3137 0 0 851 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_default_sampler
//       Access: Published
//  Description: This sets the default sampler state for this
//               texture, containing the wrap and filter properties
//               specified on the texture level; it may still be
//               overridden by a sampler state specified at a higher
//               level.  This encompasses the settings for get_wrap_u,
//               get_minfilter, get_anisotropic_degree, etc.
//
//               This makes a copy of the SamplerState object, so
//               future modifications of the same SamplerState will
//               have no effect on this texture unless you call
//               set_default_sampler again.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  7 sampler 1 3383  
1048 0 0 6 1058 3091 0 0 478 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_wrap_u
//       Access: Published
//  Description: Returns the wrap mode of the texture in the U
//               direction.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1049 0 0 6 1059 3091 0 0 478 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_wrap_v
//       Access: Published
//  Description: Returns the wrap mode of the texture in the V
//               direction.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1050 0 0 6 1060 3091 0 0 541 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_wrap_w
//       Access: Published
//  Description: Returns the wrap mode of the texture in the W
//               direction.  This is the depth direction of 3-d
//               textures.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1051 0 0 6 1061 3090 0 0 673 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_minfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               minification.  If this is one of the mipmap
//               constants, then the texture requires mipmaps.  This
//               may return FT_default; see also
//               get_effective_minfilter().
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1052 0 0 6 1062 3090 0 0 621 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_magfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               magnification.  The mipmap constants are invalid
//               here.  This may return FT_default; see also
//               get_effective_minfilter().
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1053 0 0 6 1063 3090 0 0 651 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_effective_minfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               minification, with special treatment for FT_default.
//               This will normally not return FT_default, unless
//               there is an error in the config file.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1054 0 0 6 1064 3090 0 0 652 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_effective_magfilter
//       Access: Published
//  Description: Returns the filter mode of the texture for
//               magnification, with special treatment for FT_default.
//               This will normally not return FT_default, unless
//               there is an error in the config file.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1055 0 0 6 1065 3141 0 0 649 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_anisotropic_degree
//       Access: Published
//  Description: Returns the degree of anisotropic filtering that
//               should be applied to the texture.  This value may
//               return 0, indicating the default value; see also
//               get_effective_anisotropic_degree.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1056 0 0 6 1066 3141 0 0 645 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_effective_anisotropic_degree
//       Access: Published
//  Description: Returns the degree of anisotropic filtering that
//               should be applied to the texture.  This value will
//               normally not return 0, unless there is an error in
//               the config file.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1057 0 0 7 1067 3289 0 0 630 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_border_color
//       Access: Published
//  Description: Returns the solid color of the texture's border.
//               Some OpenGL implementations use a border for tiling
//               textures; in Panda, it is only used for specifying
//               the clamp color.
//
//               This returns the default sampler state for this
//               texture; it may still be overridden by a sampler
//               state specified at a higher level.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1058 0 0 6 1068 3098 0 0 765 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_compression
//       Access: Published
//  Description: Returns the compression mode requested for this
//               particular texture, or CM_off if the texture is not
//               to be compressed.
//
//               If a value other than CM_off is returned, this is
//               not a guarantee that the texture is actually
//               successfully compressed on the GSG.  It may be that
//               the GSG does not support the requested compression
//               mode, in which case the texture may actually be
//               stored uncompressed in texture memory.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1059 0 0 6 1069 3138 0 0 764 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_compression
//       Access: Published
//  Description: Returns true if the texture indicates it wants to be
//               compressed, either with CM_on or higher, or
//               CM_default and compressed-textures is true.
//
//               If true returned, this is not a guarantee that the
//               texture is actually successfully compressed on the
//               GSG.  It may be that the GSG does not support the
//               requested compression mode, in which case the texture
//               may actually be stored uncompressed in texture
//               memory.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1060 0 0 6 1070 3138 0 0 701 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_render_to_texture
//       Access: Published
//  Description: Returns a flag on the texture that indicates whether the
//               texture is intended to be used as a direct-render
//               target, by binding a framebuffer to a texture and
//               rendering directly into the texture.
//
//               Normally, a user should not need to set this flag
//               directly; it is set automatically by the low-level
//               display code when a texture is bound to a
//               framebuffer.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1061 0 0 6 1071 3138 0 0 355 ////////////////////////////////////////////////////////////////////
//     Function: Texture::uses_mipmaps
//       Access: Public
//  Description: Returns true if the minfilter settings on this
//               texture indicate the use of mipmapping, false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1062 0 0 4 1072 3137 0 0 535 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_quality_level
//       Access: Public
//  Description: Sets a hint to the renderer about the desired
//               performance / quality tradeoff for this particular
//               texture.  This is most useful for the tinydisplay
//               software renderer; for normal, hardware-accelerated
//               renderers, this may have little or no effect.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  13 quality_level 1 3099  
1063 0 0 6 1073 3099 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_quality_level
//       Access: Public
//  Description: Returns the current quality_level hint.  See
//               set_quality_level().  This value may return
//               QL_default; see get_effective_quality_level().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1064 0 0 6 1074 3099 0 0 519 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_effective_quality_level
//       Access: Public
//  Description: Returns the current quality_level hint, or the global
//               default quality_level if this texture doesn't specify
//               a quality level.  This value will not normally return
//               QL_default (unless there is an error in the config
//               file)
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1065 0 0 6 1075 3141 0 0 536 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_num_mipmap_levels
//       Access: Published
//  Description: Returns the number of mipmap levels that should be
//               defined for this texture, given the texture's size.
//
//               Note that this returns a number appropriate for
//               mipmapping, even if the texture does not currently
//               have mipmapping enabled.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1066 0 0 6 1076 3141 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_mipmap_x_size
//       Access: Published
//  Description: Returns the x_size that the nth mipmap level should
//               have, based on the texture's size.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1067 0 0 6 1077 3141 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_mipmap_y_size
//       Access: Published
//  Description: Returns the y_size that the nth mipmap level should
//               have, based on the texture's size.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1068 0 0 6 1078 3141 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_mipmap_z_size
//       Access: Published
//  Description: Returns the z_size that the nth mipmap level should
//               have, based on the texture's size.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1069 0 0 6 1079 3141 0 0 566 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_mipmap_num_pages
//       Access: Published
//  Description: Returns the total number of pages that the nth mipmap
//               level should have, based on the texture's size.  This
//               is usually the same as get_expected_mipmap_z_size(),
//               except for a multiview texture, in which case it is
//               get_expected_mipmap_z_size() * get_num_views().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1070 0 0 6 1080 3138 0 0 1616 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_ram_image
//       Access: Published
//  Description: Returns true if the Texture has its image contents
//               available in main RAM, false if it exists only in
//               texture memory or in the prepared GSG context.
//
//               Note that this has nothing to do with whether
//               get_ram_image() will fail or not.  Even if
//               has_ram_image() returns false, get_ram_image() may
//               still return a valid RAM image, because
//               get_ram_image() will automatically load the texture
//               from disk if necessary.  The only thing
//               has_ram_image() tells you is whether the texture is
//               available right now without hitting the disk first.
//
//               Note also that if an application uses only one GSG,
//               it may appear that has_ram_image() returns true if
//               the texture has not yet been loaded by the GSG, but
//               this correlation is not true in general and should
//               not be depended on.  Specifically, if an application
//               ever uses multiple GSG's in its lifetime (for
//               instance, by opening more than one window, or by
//               closing its window and opening another one later),
//               then has_ram_image() may well return false on
//               textures that have never been loaded on the current
//               GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1071 0 0 6 1081 3138 0 0 401 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_uncompressed_ram_image
//       Access: Published
//  Description: Returns true if the Texture has its image contents
//               available in main RAM and is uncompressed, false
//               otherwise.  See has_ram_image().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1072 0 0 6 1082 3138 0 0 578 ////////////////////////////////////////////////////////////////////
//     Function: Texture::might_have_ram_image
//       Access: Published
//  Description: Returns true if the texture's image contents are
//               currently available in main RAM, or there is reason
//               to believe it can be loaded on demand.  That is, this
//               function returns a "best guess" as to whether
//               get_ram_image() will succeed without actually calling
//               it first.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1073 0 0 6 1083 3132 0 0 388 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_image_size
//       Access: Published
//  Description: Returns the total number of bytes used by the
//               in-memory image, across all pages and views, or 0 if
//               there is no in-memory image.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1074 0 0 6 1084 3132 0 0 467 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_view_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image per view, or 0 if there is no in-memory image.
//               Since each view is a stack of z_size pages, this is
//               get_z_size() * get_ram_page_size().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1075 0 0 6 1085 3132 0 0 647 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_page_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image per page, or 0 if there is no in-memory image.
//
//               For a non-compressed texture, this is the same as
//               get_expected_ram_page_size().  For a compressed
//               texture, this may be a smaller value.  (We do assume
//               that all pages will be the same size on a compressed
//               texture).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1076 0 0 6 1086 3132 0 0 378 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_image_size
//       Access: Published
//  Description: Returns the number of bytes that *ought* to be used
//               by the in-memory image, based on the texture
//               parameters.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1077 0 0 6 1087 3132 0 0 447 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_page_size
//       Access: Published
//  Description: Returns the number of bytes that should be used per
//               each Z page of the 3-d texture.  For a 2-d or 1-d
//               texture, this is the same as
//               get_expected_ram_image_size().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1078 0 0 7 1088 3412 0 0 1676 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_image
//       Access: Published
//  Description: Returns the system-RAM image data associated with the
//               texture.  If the texture does not currently have an
//               associated RAM image, and the texture was generated
//               by loading an image from a disk file (the most common
//               case), this forces the reload of the same texture.
//               This can happen if keep_texture_ram is configured to
//               false, and we have previously prepared this texture
//               with a GSG.
//
//               Note that it is not correct to call has_ram_image()
//               first to test whether this function will fail.  A
//               false return value from has_ram_image() indicates
//               only that get_ram_image() may need to reload the
//               texture from disk, which it will do automatically.
//               However, you can call might_have_ram_image(), which
//               will return true if the ram image exists, or there is
//               a reasonable reason to believe it can be loaded.
//
//               On the other hand, it is possible that the texture
//               cannot be found on disk or is otherwise unavailable.
//               If that happens, this function will return NULL.
//               There is no way to predict with 100% accuracy whether
//               get_ram_image() will return NULL without calling it
//               first; might_have_ram_image() is the closest.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1079 0 0 6 1089 3098 0 0 633 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_image_compression
//       Access: Published
//  Description: Returns the compression mode in which the ram image
//               is already stored pre-compressed.  If this is other
//               than CM_off, you cannot rely on the contents of the
//               ram image to be anything predicatable (it will not be
//               an array of x by y pixels, and it probably won't have
//               the same length as get_expected_ram_image_size()).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1080 0 0 7 1090 3412 0 0 973 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_uncompressed_ram_image
//       Access: Published
//  Description: Returns the system-RAM image associated with the
//               texture, in an uncompressed form if at all possible.
//
//               If get_ram_image_compression() is CM_off, then the
//               system-RAM image is already uncompressed, and this
//               returns the same thing as get_ram_image().
//
//               If get_ram_image_compression() is anything else, then
//               the system-RAM image is compressed.  In this case,
//               the image will be reloaded from the *original* file
//               (not from the cache), in the hopes that an
//               uncompressed image will be found there.
//
//               If an uncompressed image cannot be found, returns
//               NULL.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1081 0 0 7 1091 3412 0 0 1762 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_image_as
//       Access: Published
//  Description: Returns the uncompressed system-RAM image data
//               associated with the texture. Rather than
//               just returning a pointer to the data, like
//               get_uncompressed_ram_image, this function first
//               processes the data and reorders the components
//               using the specified format string, and places these
//               into a new char array. The 'format' argument should
//               specify in which order the components of the texture
//               must be. For example, valid format strings are
//               "RGBA", "GA", "ABRG" or "AAA". A component can
//               also be written as "0" or "1", which means an
//               empty/black or a full/white channel, respectively.
//               This function is particularly useful to
//               copy an image in-memory to a different library
//               (for example, PIL or wxWidgets) that require
//               a different component order than Panda's internal
//               format, BGRA. Note, however, that this conversion
//               can still be too slow if you want to do it every
//               frame, and should thus be avoided for that purpose.
//               The only requirement for the reordering is that
//               an uncompressed image must be available. If the
//               RAM image is compressed, it will attempt to re-load
//               the texture from disk, if it doesn't find an
//               uncompressed image there, it will return NULL.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  16 requested_format 1 3131  
1082 0 0 7 1092 3415 0 0 517 ////////////////////////////////////////////////////////////////////
//     Function: Texture::modify_ram_image
//       Access: Published
//  Description: Returns a modifiable pointer to the system-RAM image.
//               This assumes the RAM image should be uncompressed.
//               If the RAM image has been dumped, or is stored
//               compressed, creates a new one.
//
//               This does *not* affect keep_ram_image.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1083 0 0 7 1093 3415 0 0 455 ////////////////////////////////////////////////////////////////////
//     Function: Texture::make_ram_image
//       Access: Published
//  Description: Discards the current system-RAM image for the
//               texture, if any, and allocates a new buffer of the
//               appropriate size.  Returns the new buffer.
//
//               This does *not* affect keep_ram_image.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1084 0 0 4 1094 3137 0 0 501 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_ram_image
//       Access: Published
//  Description: Replaces the current system-RAM image with the new
//               data.  If compression is not CM_off, it indicates
//               that the new data is already pre-compressed in the
//               indicated format.
//
//               This does *not* affect keep_ram_image.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  5 image 1 3412  11 compression 1 3098  9 page_size 1 3132  
1085 0 0 4 1095 3137 0 0 597 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_ram_image_as
//       Access: Published
//  Description: Replaces the current system-RAM image with the new
//               data, converting it first if necessary from the
//               indicated component-order format.  See
//               get_ram_image_as() for specifications about the
//               format.  This method cannot support compressed image
//               data or sub-pages; use set_ram_image() for that.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3387  5 image 1 3412  15 provided_format 1 3131  
1086 0 0 4 1096 3137 0 0 262 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_ram_image
//       Access: Published
//  Description: Discards the current system-RAM image.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1087 0 0 4 1097 3137 0 0 827 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_keep_ram_image
//       Access: Published
//  Description: Sets the flag that indicates whether this Texture is
//               eligible to have its main RAM copy of the texture
//               memory dumped when the texture is prepared for
//               rendering.
//
//               This will be false for most textures, which can
//               reload their images if needed by rereading the input
//               file.  However, textures that were generated
//               dynamically and cannot be easily reloaded will want
//               to set this flag to true, so that the texture will
//               always keep its image copy around.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  14 keep_ram_image 1 3138  
1088 0 0 6 1098 3138 0 0 477 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_keep_ram_image
//       Access: Published, Virtual
//  Description: Returns the flag that indicates whether this Texture
//               is eligible to have its main RAM copy of the texture
//               memory dumped when the texture is prepared for
//               rendering.  See set_keep_ram_image().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1089 0 0 6 1099 3138 0 0 464 ////////////////////////////////////////////////////////////////////
//     Function: Texture::is_cacheable
//       Access: Published, Virtual
//  Description: Returns true if there is enough information in this
//               Texture object to write it to the bam cache
//               successfully, false otherwise.  For most textures,
//               this is the same as has_ram_image().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1090 0 0 6 1100 3138 0 0 1257 ////////////////////////////////////////////////////////////////////
//     Function: Texture::compress_ram_image
//       Access: Published
//  Description: Attempts to compress the texture's RAM image
//               internally, to a format supported by the indicated
//               GSG.  In order for this to work, the squish library
//               must have been compiled into Panda.
//
//               If compression is CM_on, then an appropriate
//               compression method that is supported by the indicated
//               GSG is automatically chosen.  If the GSG pointer is
//               NULL, any of the standard DXT1/3/5 compression
//               methods will be used, regardless of whether it is
//               supported.
//
//               If compression is any specific compression method,
//               that method is used regardless of whether the GSG
//               supports it.
//
//               quality_level determines the speed/quality tradeoff
//               of the compression.  If it is QL_default, the
//               texture's own quality_level parameter is used.
//
//               Returns true if successful, false otherwise.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  11 compression 1 3098  13 quality_level 1 3099  3 gsg 1 3212  
1091 0 0 6 1101 3138 0 0 573 ////////////////////////////////////////////////////////////////////
//     Function: Texture::uncompress_ram_image
//       Access: Published
//  Description: Attempts to uncompress the texture's RAM image
//               internally.  In order for this to work, the squish
//               library must have been compiled into Panda, and the
//               ram image must be compressed in a format supported by
//               squish.
//
//               Returns true if successful, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1092 0 0 6 1102 3141 0 0 584 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_ram_mipmap_images
//       Access: Published
//  Description: Returns the maximum number of mipmap level images
//               available in system memory.  The actual number may be
//               less than this (that is, there might be gaps in the
//               sequence); use has_ram_mipmap_image() to verify each
//               level.
//
//               Also see get_num_loadable_ram_mipmap_images().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1093 0 0 6 1103 3138 0 0 608 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_ram_mipmap_image
//       Access: Published
//  Description: Returns true if the Texture has the nth mipmap level
//               available in system memory, false otherwise.  If the
//               texture's minfilter mode requires mipmapping (see
//               uses_mipmaps()), and all the texture's mipmap levels
//               are not available when the texture is rendered, they
//               will be generated automatically.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1094 0 0 6 1104 3141 0 0 955 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_num_loadable_ram_mipmap_images
//       Access: Published
//  Description: Returns the number of contiguous mipmap levels that
//               exist in RAM, up until the first gap in the sequence.
//               It is guaranteed that at least mipmap levels [0,
//               get_num_ram_mipmap_images()) exist.
//
//               The number returned will never exceed the number of
//               required mipmap images based on the size of the
//               texture and its filter mode.
//
//               This method is different from
//               get_num_ram_mipmap_images() in that it returns only
//               the number of mipmap levels that can actually be
//               usefully loaded, regardless of the actual number that
//               may be stored.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1095 0 0 6 1105 3138 0 0 403 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_all_ram_mipmap_images
//       Access: Published
//  Description: Returns true if all expected mipmap levels have been
//               defined and exist in the system RAM, or false if even
//               one mipmap level is missing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1096 0 0 6 1106 3132 0 0 402 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_image_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image for mipmap level n, or 0 if there is no
//               in-memory image for this mipmap level.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1097 0 0 6 1107 3132 0 0 913 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_view_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image per view for mipmap level n, or 0 if there is
//               no in-memory image for this mipmap level.
//
//               A "view" is a collection of z_size pages for each
//               mipmap level.  Most textures have only one view,
//               except for multiview or stereo textures.
//
//               For a non-compressed texture, this is the same as
//               get_expected_ram_mipmap_view_size().  For a compressed
//               texture, this may be a smaller value.  (We do assume
//               that all pages will be the same size on a compressed
//               texture).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1098 0 0 6 1108 3132 0 0 719 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_page_size
//       Access: Published
//  Description: Returns the number of bytes used by the in-memory
//               image per page for mipmap level n, or 0 if there is
//               no in-memory image for this mipmap level.
//
//               For a non-compressed texture, this is the same as
//               get_expected_ram_mipmap_page_size().  For a compressed
//               texture, this may be a smaller value.  (We do assume
//               that all pages will be the same size on a compressed
//               texture).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1099 0 0 6 1109 3132 0 0 404 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_mipmap_image_size
//       Access: Published
//  Description: Returns the number of bytes that *ought* to be used
//               by the in-memory image for mipmap level n, based on
//               the texture parameters.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1100 0 0 6 1110 3132 0 0 547 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_mipmap_view_size
//       Access: Published
//  Description: Returns the number of bytes that *ought* to be used
//               by each view of the in-memory image for mipmap level
//               n, based on the texture parameters.  For a normal,
//               non-multiview texture, this is the same as
//               get_expected_ram_mipmap_image_size(n).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1101 0 0 6 1111 3132 0 0 480 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_expected_ram_mipmap_page_size
//       Access: Published
//  Description: Returns the number of bytes that should be used per
//               each Z page of the 3-d texture, for mipmap level n.
//               For a 2-d or 1-d texture, this is the same as
//               get_expected_ram_mipmap_view_size(n).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1102 0 0 7 1112 3412 0 0 400 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_image
//       Access: Published
//  Description: Returns the system-RAM image data associated with the
//               nth mipmap level, if present.  Returns NULL if the
//               nth mipmap level is not present.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1103 0 0 4 1113 3137 0 0 447 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_ram_mipmap_pointer
//       Access: Published
//  Description: Similiar to get_ram_mipmap_image(), however, in this
//               case the void pointer for the given ram image is
//               returned.  This will be NULL unless it has been
//               explicitly set.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  1 n 1 3141  
1104 0 0 7 1114 3415 0 0 511 ////////////////////////////////////////////////////////////////////
//     Function: Texture::modify_ram_mipmap_image
//       Access: Published
//  Description: Returns a modifiable pointer to the system-RAM image
//               for the nth mipmap level.  This assumes the RAM image
//               is uncompressed; if this is not the case, raises an
//               assertion.
//
//               This does *not* affect keep_ram_image.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  1 n 1 3141  
1105 0 0 7 1115 3415 0 0 471 ////////////////////////////////////////////////////////////////////
//     Function: Texture::make_ram_mipmap_image
//       Access: Published
//  Description: Discards the current system-RAM image for the
//               nth mipmap level, if any, and allocates a new buffer
//               of the appropriate size.  Returns the new buffer.
//
//               This does *not* affect keep_ram_image.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  1 n 1 3141  
1106 0 0 4 1117 3137 0 0 592 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_ram_mipmap_pointer_from_int
//       Access: Published
//  Description: Accepts a raw pointer cast as an int, which is then
//               passed to set_ram_mipmap_pointer(); see the
//               documentation for that method.
//
//               This variant is particularly useful to set an
//               external pointer from a language like Python, which
//               doesn't support void pointers directly.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  7 pointer 1 3416  1 n 1 3141  9 page_size 1 3141  
1107 0 0 4 1118 3137 0 0 556 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_ram_mipmap_image
//       Access: Published
//  Description: Replaces the current system-RAM image for the
//               indicated mipmap level with the new data.  If
//               compression is not CM_off, it indicates that the new
//               data is already pre-compressed in the indicated
//               format.
//
//               This does *not* affect keep_ram_image.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  1 n 1 3141  5 image 1 3412  9 page_size 1 3132  
1108 0 0 4 1119 3137 0 0 311 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_ram_mipmap_image
//       Access: Published
//  Description: Discards the current system-RAM image for the nth
//               mipmap level.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  1 n 1 3141  
1109 0 0 4 1120 3137 0 0 342 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_ram_mipmap_images
//       Access: Published
//  Description: Discards the current system-RAM image for all
//               mipmap levels, except level 0 (the base image).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1110 0 0 4 1121 3137 0 0 794 ////////////////////////////////////////////////////////////////////
//     Function: Texture::generate_ram_mipmap_images
//       Access: Published
//  Description: Automatically fills in the n mipmap levels of the
//               Texture, based on the texture's source image.  This
//               requires the texture's uncompressed ram image to be
//               available in system memory.  If it is not already, it
//               will be fetched if possible.
//
//               This call is not normally necessary, since the mipmap
//               levels will be generated automatically if needed.
//               But there may be certain cases in which you would
//               like to call this explicitly.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1111 0 0 6 1122 3141 0 0 276 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_x_size
//       Access: Published
//  Description: Returns the width of the "simple" image in texels.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1112 0 0 6 1123 3141 0 0 277 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_y_size
//       Access: Published
//  Description: Returns the height of the "simple" image in texels.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1113 0 0 6 1124 3138 0 0 326 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_simple_ram_image
//       Access: Published, Virtual
//  Description: Returns true if the Texture has a "simple" image
//               available in main RAM.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1114 0 0 6 1125 3132 0 0 340 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_ram_image_size
//       Access: Published
//  Description: Returns the number of bytes used by the "simple"
//               image, or 0 if there is no simple image.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1115 0 0 7 1126 3412 0 0 879 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_ram_image
//       Access: Published
//  Description: Returns the image data associated with the "simple"
//               texture image.  This is provided for some textures as
//               an option to display while the main texture image is
//               being loaded from disk.
//
//               Unlike get_ram_image(), this function will always
//               return immediately.  Either the simple image is
//               available, or it is not.
//
//               The "simple" image is always 4 components, 1 byte
//               each, regardless of the parameters of the full
//               texture.  The simple image is only supported for
//               ordinary 2-d textures.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1116 0 0 4 1127 3137 0 0 1051 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_simple_ram_image
//       Access: Published
//  Description: Replaces the internal "simple" texture image.  This
//               can be used as an option to display while the main
//               texture image is being loaded from disk.  It is
//               normally a very small image, 16x16 or smaller (and
//               maybe even 1x1), that is designed to give just enough
//               sense of color to serve as a placeholder until the
//               full texture is available.
//
//               The "simple" image is always 4 components, 1 byte
//               each, regardless of the parameters of the full
//               texture.  The simple image is only supported for
//               ordinary 2-d textures.
//
//               Also see generate_simple_ram_image(),
//               modify_simple_ram_image(), and
//               new_simple_ram_image().
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  5 image 1 3412  6 x_size 1 3141  6 y_size 1 3141  
1117 0 0 7 1128 3415 0 0 346 ////////////////////////////////////////////////////////////////////
//     Function: Texture::modify_simple_ram_image
//       Access: Published
//  Description: Returns a modifiable pointer to the internal "simple"
//               texture image.  See set_simple_ram_image().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1118 0 0 7 1129 3415 0 0 413 ////////////////////////////////////////////////////////////////////
//     Function: Texture::new_simple_ram_image
//       Access: Published
//  Description: Creates an empty array for the simple ram image of
//               the indicated size, and returns a modifiable pointer
//               to the new array.  See set_simple_ram_image().
//////////////////////////////////////////////////////////////////// 3 4 this 3 3387  6 x_size 1 3141  6 y_size 1 3141  
1119 0 0 4 1130 3137 0 0 453 ////////////////////////////////////////////////////////////////////
//     Function: Texture::generate_simple_ram_image
//       Access: Published
//  Description: Computes the "simple" ram image by loading the main
//               RAM image, if it is not already available, and
//               reducing it to 16x16 or smaller.  This may be an
//               expensive operation.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1120 0 0 4 1131 3137 0 0 267 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_simple_ram_image
//       Access: Published
//  Description: Discards the current "simple" image.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1121 0 0 7 1132 3417 3014 0 826 ////////////////////////////////////////////////////////////////////
//     Function: Texture::peek
//       Access: Published
//  Description: Returns a TexturePeeker object that can be used to
//               examine the individual texels stored within this
//               Texture by (u, v) coordinate.
//
//               If the texture has a ram image resident, that image
//               is used.  If it does not have a full ram image but
//               does have a simple_ram_image resident, that image is
//               used instead.  If neither image is resident the full
//               image is reloaded.
//
//               Returns NULL if the texture cannot find an image to
//               load, or the texture format is incompatible.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1122 0 0 7 1133 3205 0 0 403 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_properties_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture properties
//               (unrelated to the image) are modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1123 0 0 7 1134 3205 0 0 399 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_image_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture image data
//               (including mipmap levels) are modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1124 0 0 7 1135 3205 0 0 390 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_simple_image_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture's "simple"
//               image data is modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1125 0 0 4 1136 3137 0 0 421 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_auto_texture_scale
//       Access: Published
//  Description: Specifies the power-of-2 texture-scaling mode that
//               will be applied to this particular texture when it is
//               next loaded from disk.  See set_textures_power_2().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  5 scale 1 3418  
1126 0 0 6 1137 3418 0 0 419 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_auto_texture_scale
//       Access: Published
//  Description: Returns the power-of-2 texture-scaling mode that will
//               be applied to this particular texture when it is next
//               loaded from disk.  See set_textures_power_2().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1127 0 0 6 1138 3138 0 0 387 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_auto_texture_scale
//       Access: Published
//  Description: Returns true if set_auto_texture_scale() has been set
//               to something other than ATS_unspecified for this
//               particular texture.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1128 0 0 4 1139 3137 0 0 655 ////////////////////////////////////////////////////////////////////
//     Function: Texture::prepare
//       Access: Published
//  Description: Indicates that the texture should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.  This will ensure the
//               texture is already loaded into texture memory if it
//               is expected to be rendered soon.
//
//               Use this function instead of prepare_now() to preload
//               textures from a user interface standpoint.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  16 prepared_objects 1 3211  
1129 0 0 6 1140 3138 0 0 374 ////////////////////////////////////////////////////////////////////
//     Function: Texture::is_prepared
//       Access: Published
//  Description: Returns true if the texture has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  16 prepared_objects 1 3211  
1130 0 0 6 1141 3138 0 0 437 ////////////////////////////////////////////////////////////////////
//     Function: Texture::was_image_modified
//       Access: Published
//  Description: Returns true if the texture needs to be re-loaded
//               onto the indicated GSG, either because its image data
//               is out-of-date, or because it's not fully prepared
//               now.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  16 prepared_objects 1 3211  
1131 0 0 6 1142 3132 0 0 639 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_data_size_bytes
//       Access: Public
//  Description: Returns the number of bytes which the texture is
//               reported to consume within graphics memory, for the
//               indicated GSG.  This may return a nonzero value even
//               if the texture is not currently resident; you should
//               also check get_resident() if you want to know how
//               much space the texture is actually consuming right
//               now.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  16 prepared_objects 1 3211  
1132 0 0 6 1143 3138 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_active
//       Access: Public
//  Description: Returns true if this Texture was rendered in the most
//               recent frame within the indicated GSG.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  16 prepared_objects 1 3211  
1133 0 0 6 1144 3138 0 0 353 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_resident
//       Access: Public
//  Description: Returns true if this Texture is reported to be
//               resident within graphics memory for the indicated
//               GSG.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  16 prepared_objects 1 3211  
1134 0 0 6 1145 3138 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: Texture::release
//       Access: Published
//  Description: Frees the texture context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  16 prepared_objects 1 3211  
1135 0 0 6 1146 3141 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: Texture::release_all
//       Access: Published
//  Description: Frees the context allocated on all objects for which
//               the texture has been declared.  Returns the number of
//               contexts which have been freed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1136 0 0 6 1147 3132 0 0 775 ////////////////////////////////////////////////////////////////////
//     Function: Texture::estimate_texture_memory
//       Access: Published
//  Description: Estimates the amount of texture memory that will be
//               consumed by loading this texture.  This returns a
//               value that is not specific to any particular graphics
//               card or driver; it tries to make a reasonable
//               assumption about how a driver will load the texture.
//               It does not account for texture compression or
//               anything fancy.  This is mainly useful for debugging
//               and reporting purposes.
//
//               Returns a value in bytes.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1137 0 0 4 1148 3137 0 0 523 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_aux_data
//       Access: Published
//  Description: Records an arbitrary object in the Texture,
//               associated with a specified key.  The object may
//               later be retrieved by calling get_aux_data() with the
//               same key.
//
//               These data objects are not recorded to a bam or txo
//               file.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3387  3 key 1 3131  8 aux_data 1 3419  
1138 0 0 4 1149 3137 0 0 296 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_aux_data
//       Access: Published
//  Description: Removes a record previously recorded via
//               set_aux_data().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  3 key 1 3131  
1139 0 0 7 1150 3419 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_aux_data
//       Access: Published
//  Description: Returns a record previously recorded via
//               set_aux_data().  Returns NULL if there was no record
//               associated with the indicated key.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3388  3 key 1 3131  
1140 0 0 4 1151 3137 0 0 520 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_textures_power_2
//       Access: Published, Static
//  Description: Set this flag to ATS_none, ATS_up, ATS_down, or
//               ATS_pad to control the scaling of textures in
//               general, if a particular texture does not override
//               this.  See also set_auto_texture_scale() for the
//               per-texture override.
//////////////////////////////////////////////////////////////////// 1 5 scale 1 3418  
1141 0 0 6 1152 3418 0 0 536 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_textures_power_2
//       Access: Published, Static
//  Description: This flag returns ATS_none, ATS_up, or ATS_down
//               and controls the scaling of textures in general.  It
//               is initialized from the config variable of the same
//               name, but it can be subsequently adjusted.  See also
//               get_auto_texture_scale().
//////////////////////////////////////////////////////////////////// 0 
1142 0 0 6 1153 3138 0 0 452 ////////////////////////////////////////////////////////////////////
//     Function: Texture::has_textures_power_2
//       Access: Published, Static
//  Description: If true, then get_textures_power_2 has been
//               set using set_textures_power_2.
//               If false, then get_textures_power_2 simply
//               returns the config variable of the same name.
//////////////////////////////////////////////////////////////////// 0 
1143 0 0 4 1154 3137 0 0 690 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_filename
//       Access: Published
//  Description: Sets the name of the file that contains the image's
//               contents.  Normally, this is set automatically when
//               the image is loaded, for instance via
//               Texture::read().
//
//               The Texture's get_name() function used to return
//               the filename, but now returns just the basename
//               (without the extension), which is a more useful name
//               for identifying an image in show code.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  8 filename 1 3390  
1144 0 0 4 1155 3137 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_filename
//       Access: Published
//  Description: Removes the alpha filename, if it was previously set.
//               See set_filename().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1145 0 0 4 1156 3137 0 0 915 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_alpha_filename
//       Access: Published
//  Description: Sets the name of the file that contains the image's
//               alpha channel contents.  Normally, this is set
//               automatically when the image is loaded, for instance
//               via Texture::read().
//
//               The Texture's get_filename() function returns the
//               name of the image file that was loaded into the
//               buffer.  In the case where a texture specified two
//               separate files to load, a 1- or 3-channel color image
//               and a 1-channel alpha image, this Filename is update
//               to contain the name of the image file that was loaded
//               into the buffer's alpha channel.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  14 alpha_filename 1 3390  
1146 0 0 4 1157 3137 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_alpha_filename
//       Access: Published
//  Description: Removes the alpha filename, if it was previously set.
//               See set_alpha_filename().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1147 0 0 4 1158 3137 0 0 470 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_fullpath
//       Access: Published
//  Description: Sets the full pathname to the file that contains the
//               image's contents, as found along the search path.
//               Normally, this is set automatically when the image is
//               loaded, for instance via Texture::read().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  8 fullpath 1 3390  
1148 0 0 4 1159 3137 0 0 313 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_fullpath
//       Access: Published
//  Description: Removes the alpha fullpath, if it was previously set.
//               See set_fullpath().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1149 0 0 4 1160 3137 0 0 508 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_alpha_fullpath
//       Access: Published
//  Description: Sets the full pathname to the file that contains the
//               image's alpha channel contents, as found along the
//               search path.  Normally, this is set automatically
//               when the image is loaded, for instance via
//               Texture::read().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  14 alpha_fullpath 1 3390  
1150 0 0 4 1161 3137 0 0 325 ////////////////////////////////////////////////////////////////////
//     Function: Texture::clear_alpha_fullpath
//       Access: Published
//  Description: Removes the alpha fullpath, if it was previously set.
//               See set_alpha_fullpath().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1151 0 0 4 1162 3137 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_x_size
//       Access: Published
//  Description: Changes the x size indicated for the texture.  This
//               also implicitly unloads the texture if it has already
//               been loaded.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  6 x_size 1 3141  
1152 0 0 4 1163 3137 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_y_size
//       Access: Published
//  Description: Changes the y size indicated for the texture.  This
//               also implicitly unloads the texture if it has already
//               been loaded.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  6 y_size 1 3141  
1153 0 0 4 1164 3137 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_z_size
//       Access: Published
//  Description: Changes the z size indicated for the texture.  This
//               also implicitly unloads the texture if it has already
//               been loaded.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  6 z_size 1 3141  
1154 0 0 4 1165 3137 0 0 866 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_num_views
//       Access: Published
//  Description: Sets the number of "views" within a texture.  A view
//               is a completely separate image stored within the
//               Texture object.  Most textures have only one view,
//               but a stereo texture, for instance, may have two
//               views, a left and a right image.  Other uses for
//               multiple views are not yet defined.
//
//               If this value is greater than one, the additional
//               views are accessed as additional pages beyond
//               get_z_size().
//
//               This also implicitly unloads the texture if it has
//               already been loaded.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  9 num_views 1 3141  
1155 0 0 6 1166 3141 0 0 273 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_pad_x_size
//       Access: Published
//  Description: Returns size of the pad region.  See set_pad_size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1156 0 0 6 1167 3141 0 0 273 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_pad_y_size
//       Access: Published
//  Description: Returns size of the pad region.  See set_pad_size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1157 0 0 6 1168 3141 0 0 273 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_pad_z_size
//       Access: Published
//  Description: Returns size of the pad region.  See set_pad_size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1158 0 0 7 1169 3421 0 0 866 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_tex_scale
//       Access: Published
//  Description: Returns a scale pair that is suitable for applying to
//               geometry via NodePath::set_tex_scale(), which will
//               convert texture coordinates on the geometry from the
//               range 0..1 into the appropriate range to render the
//               video part of the texture.
//
//               This is necessary only if a padding size has been set
//               via set_pad_size() (or implicitly via something like
//               "textures-power-2 pad" in the config.prc file).  In
//               this case, this is a convenient way to generate UV's
//               that reflect the built-in padding size.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1159 0 0 4 1170 3137 0 0 813 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_pad_size
//       Access: Published
//  Description: Sets the size of the pad region.
//
//               Sometimes, when a video card demands power-of-two
//               textures, it is necessary to create a big texture
//               and then only use a portion of it.  The pad region
//               indicates which portion of the texture is not
//               really in use.  All operations use the texture
//               as a whole, including the pad region, unless they
//               explicitly state that they use only the non-pad
//               region.
//
//               Changing the texture's size clears the pad region.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  1 x 1 3141  1 y 1 3141  1 z 1 3141  
1160 0 0 4 1171 3137 0 0 348 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_size_padded
//       Access: Published
//  Description: Changes the size of the texture, padding
//               if necessary, and setting the pad region
//               as well.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  1 x 1 3141  1 y 1 3141  1 z 1 3141  
1161 0 0 6 1172 3141 0 0 414 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_orig_file_x_size
//       Access: Published
//  Description: Returns the X size of the original disk image that
//               this Texture was loaded from (if it came from a disk
//               file), before any automatic rescaling by Panda.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1162 0 0 6 1173 3141 0 0 414 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_orig_file_y_size
//       Access: Published
//  Description: Returns the Y size of the original disk image that
//               this Texture was loaded from (if it came from a disk
//               file), before any automatic rescaling by Panda.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1163 0 0 6 1174 3141 0 0 414 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_orig_file_z_size
//       Access: Published
//  Description: Returns the Z size of the original disk image that
//               this Texture was loaded from (if it came from a disk
//               file), before any automatic rescaling by Panda.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1164 0 0 4 1175 3137 0 0 343 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_orig_file_size
//       Access: Published
//  Description: Specifies the size of the texture as it exists in its
//               original disk file, before any Panda scaling.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  1 x 1 3141  1 y 1 3141  1 z 1 3141  
1165 0 0 4 1176 3137 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_format
//       Access: Published
//  Description: Changes the format value for the texture components.
//               This implicitly sets num_components as well.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  6 format 1 3095  
1166 0 0 4 1177 3137 0 0 340 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_component_type
//       Access: Published
//  Description: Changes the data value for the texture components.
//               This implicitly sets component_width as well.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  14 component_type 1 3094  
1167 0 0 4 1178 3137 0 0 553 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_loaded_from_image
//       Access: Published
//  Description: Sets the flag that indicates the texture has been
//               loaded from a disk file or PNMImage.  You should also
//               ensure the filename has been set correctly.  When
//               this flag is true, the texture may be automatically
//               reloaded when its ram image needs to be replaced.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1168 0 0 6 1179 3138 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_loaded_from_image
//       Access: Published
//  Description: Returns the flag that indicates the texture has been
//               loaded from a disk file or PNMImage.  See
//               set_loaded_from_image().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1169 0 0 4 1180 3137 0 0 452 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_loaded_from_txo
//       Access: Published
//  Description: Sets the flag that indicates the texture has been
//               loaded from a txo file.  You probably shouldn't be
//               setting this directly; it is set automatically when a
//               Texture is loaded.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1170 0 0 6 1181 3138 0 0 321 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_loaded_from_txo
//       Access: Published
//  Description: Returns the flag that indicates the texture has been
//               loaded from a txo file.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1171 0 0 6 1182 3138 0 0 588 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_match_framebuffer_format
//       Access: Public
//  Description: Returns true if the special flag was set that
//               indicates to the GSG that the Texture's format should
//               be chosen to exactly match the framebuffer's format,
//               presumably because the application intends to copy
//               image data from the framebuffer into the Texture (or
//               vice-versa).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1172 0 0 4 1183 3137 0 0 743 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_match_framebuffer_format
//       Access: Public
//  Description: Sets the special flag that, if true, indicates to the
//               GSG that the Texture's format should be chosen to
//               exactly match the framebuffer's format, presumably
//               because the application intends to copy image data
//               from the framebuffer into the Texture (or
//               vice-versa).
//
//               This sets only the graphics card's idea of the
//               texture format; it is not related to the
//               system-memory format.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  4 flag 1 3138  
1173 0 0 6 1184 3138 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: Texture::get_post_load_store_cache
//       Access: Public
//  Description: Returns the setting of the post_load_store_cache
//               flag.  See set_post_load_store_cache().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3388  
1174 0 0 4 1185 3137 0 0 742 ////////////////////////////////////////////////////////////////////
//     Function: Texture::set_post_load_store_cache
//       Access: Public
//  Description: Sets the post_load_store_cache flag.  When this is
//               set, the next time the texture is loaded on a GSG, it
//               will automatically extract its RAM image from the GSG
//               and save it to the global BamCache.
//
//               This is used to store compressed RAM images in the
//               BamCache.  This flag should not be set explicitly; it
//               is set automatically by the TexturePool when
//               model-cache-compressed-textures is set true.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  4 flag 1 3138  
1175 0 0 6 1186 3422 0 0 889 ////////////////////////////////////////////////////////////////////
//     Function: Texture::prepare_now
//       Access: Published
//  Description: Creates a context for the texture on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) TextureContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               textures.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a texture does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3387  4 view 1 3141  16 prepared_objects 1 3211  3 gsg 1 3212  
1176 0 0 6 1187 3141 0 0 310 ////////////////////////////////////////////////////////////////////
//     Function: Texture::up_to_power_2
//       Access: Published, Static
//  Description: Returns the smallest power of 2 greater than or equal
//               to value.
//////////////////////////////////////////////////////////////////// 1 5 value 1 3141  
1177 0 0 6 1188 3141 0 0 308 ////////////////////////////////////////////////////////////////////
//     Function: Texture::down_to_power_2
//       Access: Published, Static
//  Description: Returns the largest power of 2 less than or equal
//               to value.
//////////////////////////////////////////////////////////////////// 1 5 value 1 3141  
1178 0 0 4 1189 3137 0 0 782 ////////////////////////////////////////////////////////////////////
//     Function: Texture::consider_rescale
//       Access: Published
//  Description: Asks the PNMImage to change its scale when it reads
//               the image, according to the whims of the Config.prc
//               file.
//
//               For most efficient results, this method should be
//               called after pnmimage.read_header() has been called,
//               but before pnmimage.read().  This method may also be
//               called after pnmimage.read(), i.e. when the pnmimage
//               is already loaded; in this case it will rescale the
//               image on the spot.  Also see rescale_texture().
//////////////////////////////////////////////////////////////////// 2 4 this 3 3387  8 pnmimage 1 3406  
1179 0 0 4 1189 3137 0 0 790 ////////////////////////////////////////////////////////////////////
//     Function: Texture::consider_rescale
//       Access: Published, Static
//  Description: Asks the PNMImage to change its scale when it reads
//               the image, according to the whims of the Config.prc
//               file.
//
//               For most efficient results, this method should be
//               called after pnmimage.read_header() has been called,
//               but before pnmimage.read().  This method may also be
//               called after pnmimage.read(), i.e. when the pnmimage
//               is already loaded; in this case it will rescale the
//               image on the spot.  Also see rescale_texture().
//////////////////////////////////////////////////////////////////// 3 8 pnmimage 1 3406  4 name 1 3131  18 auto_texture_scale 1 3418  
1180 0 0 6 1190 3138 0 0 711 ////////////////////////////////////////////////////////////////////
//     Function: Texture::rescale_texture
//       Access: Published
//  Description: This method is similar to consider_rescale(), but
//               instead of scaling a separate PNMImage, it will ask
//               the Texture to rescale its own internal image to a
//               power of 2, according to the config file
//               requirements.  This may be useful after loading a
//               Texture image by hand, instead of reading it from a
//               disk file.  Returns true if the texture is changed,
//               false if it was not.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3387  
1181 0 0 6 1191 3131 0 0 314 ////////////////////////////////////////////////////////////////////
//     Function: Texture::format_texture_type
//       Access: Published, Static
//  Description: Returns the indicated TextureType converted to a
//               string word.
//////////////////////////////////////////////////////////////////// 1 2 tt 1 3093  
1182 0 0 6 1192 3093 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: Texture::string_texture_type
//       Access: Published, Static
//  Description: Returns the TextureType corresponding to the
//               indicated string word.
//////////////////////////////////////////////////////////////////// 1 3 str 1 3131  
1183 0 0 6 1193 3131 0 0 318 ////////////////////////////////////////////////////////////////////
//     Function: Texture::format_component_type
//       Access: Published, Static
//  Description: Returns the indicated ComponentType converted to a
//               string word.
//////////////////////////////////////////////////////////////////// 1 2 ct 1 3094  
1184 0 0 6 1194 3094 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: Texture::string_component_type
//       Access: Published, Static
//  Description: Returns the ComponentType corresponding to the
//               indicated string word.
//////////////////////////////////////////////////////////////////// 1 3 str 1 3131  
1185 0 0 6 1195 3131 0 0 303 ////////////////////////////////////////////////////////////////////
//     Function: Texture::format_format
//       Access: Published, Static
//  Description: Returns the indicated Format converted to a
//               string word.
//////////////////////////////////////////////////////////////////// 1 1 f 1 3095  
1186 0 0 6 1196 3095 0 0 309 ////////////////////////////////////////////////////////////////////
//     Function: Texture::string_format
//       Access: Published, Static
//  Description: Returns the Format corresponding to the
//               indicated string word.
//////////////////////////////////////////////////////////////////// 1 3 str 1 3131  
1187 0 0 6 1197 3131 0 0 322 ////////////////////////////////////////////////////////////////////
//     Function: Texture::format_compression_mode
//       Access: Published, Static
//  Description: Returns the indicated CompressionMode converted to a
//               string word.
//////////////////////////////////////////////////////////////////// 1 2 cm 1 3098  
1188 0 0 6 1198 3098 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: Texture::string_compression_mode
//       Access: Public
//  Description: Returns the CompressionMode value associated with the
//               given string representation.
//////////////////////////////////////////////////////////////////// 1 3 str 1 3131  
1189 0 0 6 1199 3131 0 0 316 ////////////////////////////////////////////////////////////////////
//     Function: Texture::format_quality_level
//       Access: Published, Static
//  Description: Returns the indicated QualityLevel converted to a
//               string word.
//////////////////////////////////////////////////////////////////// 1 3 tql 1 3099  
1190 0 0 6 1200 3099 0 0 322 ////////////////////////////////////////////////////////////////////
//     Function: Texture::string_quality_level
//       Access: Public
//  Description: Returns the QualityLevel value associated with the
//               given string representation.
//////////////////////////////////////////////////////////////////// 1 3 str 1 3131  
1191 0 0 7 1201 3158 0 0 0 0 
1192 0 0 7 988 3167 0 0 0 1 4 this 3 3387  
1193 0 0 7 989 3387 2472 0 0 1 4 this 3 3167  
1194 0 0 6 990 3178 0 0 0 1 4 this 3 3387  
1195 0 0 7 991 3387 2472 0 0 1 4 this 3 3178  
1196 0 0 7 1207 3423 0 0 261 ////////////////////////////////////////////////////////////////////
//     Function: Shader::load
//       Access: Published, Static
//  Description: Loads the shader with the given filename.
//////////////////////////////////////////////////////////////////// 2 4 file 1 3390  4 lang 1 3101  
1197 0 0 7 1207 3423 0 0 303 ////////////////////////////////////////////////////////////////////
//     Function: Shader::load
//       Access: Published, Static
//  Description: This variant of Shader::load loads all shader
//               programs separately.
//////////////////////////////////////////////////////////////////// 6 4 lang 1 3101  6 vertex 1 3390  8 fragment 1 3390  8 geometry 1 3390  12 tess_control 1 3390  15 tess_evaluation 1 3390  
1198 0 0 7 1208 3423 0 0 277 //////////////////////////////////////////////////////////////////////
//     Function: Shader::make
//       Access: Published, Static
//  Description: Loads the shader, using the strings as shader bodies.
////////////////////////////////////////////////////////////////////// 6 4 lang 1 3101  6 vertex 1 3131  8 fragment 1 3131  8 geometry 1 3131  12 tess_control 1 3131  15 tess_evaluation 1 3131  
1199 0 0 7 1208 3423 0 0 274 //////////////////////////////////////////////////////////////////////
//     Function: Shader::make
//       Access: Published, Static
//  Description: Loads the shader, using the string as shader body.
////////////////////////////////////////////////////////////////////// 2 4 body 1 3131  4 lang 1 3101  
1200 0 0 7 1209 3423 0 0 251 ////////////////////////////////////////////////////////////////////
//     Function: Shader::load_compute
//       Access: Published, Static
//  Description: Loads a compute shader.
//////////////////////////////////////////////////////////////////// 2 4 lang 1 3101  2 fn 1 3390  
1201 0 0 7 1210 3423 0 0 279 //////////////////////////////////////////////////////////////////////
//     Function: Shader::make_compute
//       Access: Published, Static
//  Description: Loads the compute shader from the given string.
////////////////////////////////////////////////////////////////////// 2 4 lang 1 3101  4 body 1 3131  
1202 0 0 7 1211 3426 0 0 292 ////////////////////////////////////////////////////////////////////
//     Function: Shader::get_filename
//       Access: Published
//  Description: Return the Shader's filename for the given shader
//               type.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3424  4 type 1 3102  
1203 0 0 6 1212 3131 0 0 267 ////////////////////////////////////////////////////////////////////
//     Function: Shader::get_text
//       Access: Published
//  Description: Return the Shader's text for the given shader type.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3424  4 type 1 3102  
1204 0 0 6 1213 3138 0 0 399 ////////////////////////////////////////////////////////////////////
//     Function: Shader::get_error_flag
//       Access: Public
//  Description: Returns true if the shader contains a compile-time
//               error.  This doesn't tell you whether or not the
//               shader is supported on the current video card.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3424  
1205 0 0 6 1214 3101 0 0 298 ////////////////////////////////////////////////////////////////////
//     Function: Shader::get_language
//       Access: Published
//  Description: Returns the shader language in which this shader
//               was written.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3424  
1206 0 0 6 1215 3054 0 0 509 ////////////////////////////////////////////////////////////////////
//     Function: Shader::get_shader_utilization
//       Access: Published, Static
//  Description: This flag returns SUT_none, SUT_basic, or
//               SUT_advanced and controls the automatic generation
//               of shaders.  It is initialized from the config
//               variable of the same name, but it can be
//               subsequently adjusted.
//////////////////////////////////////////////////////////////////// 0 
1207 0 0 4 1216 3137 0 0 382 ////////////////////////////////////////////////////////////////////
//     Function: Shader::set_shader_utilization
//       Access: Published, Static
//  Description: Set this flag to SUT_none, SUT_basic, or
//               SUT_advanced to limit panda's automatic shader
//               generation facilities.
//////////////////////////////////////////////////////////////////// 1 3 utl 1 3054  
1208 0 0 6 1217 3138 0 0 460 ////////////////////////////////////////////////////////////////////
//     Function: Shader::have_shader_utilization
//       Access: Published, Static
//  Description: If true, then get_shader_utilization has been
//               set using set_shader_utilization.
//               If false, then get_shader_utilization simply
//               returns the config variable of the same name.
//////////////////////////////////////////////////////////////////// 0 
1209 0 0 4 1218 3137 0 0 653 ////////////////////////////////////////////////////////////////////
//     Function: Shader::prepare
//       Access: Published
//  Description: Indicates that the shader should be enqueued to be
//               prepared in the indicated prepared_objects at the
//               beginning of the next frame.  This will ensure the
//               texture is already loaded into texture memory if it
//               is expected to be rendered soon.
//
//               Use this function instead of prepare_now() to preload
//               textures from a user interface standpoint.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3423  16 prepared_objects 1 3211  
1210 0 0 6 1219 3138 0 0 372 ////////////////////////////////////////////////////////////////////
//     Function: Shader::is_prepared
//       Access: Published
//  Description: Returns true if the shader has already been prepared
//               or enqueued for preparation on the indicated GSG,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3424  16 prepared_objects 1 3211  
1211 0 0 6 1220 3138 0 0 393 ////////////////////////////////////////////////////////////////////
//     Function: Shader::release
//       Access: Published
//  Description: Frees the texture context only on the indicated object,
//               if it exists there.  Returns true if it was released,
//               false if it had not been prepared.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3423  16 prepared_objects 1 3211  
1212 0 0 6 1221 3141 0 0 391 ////////////////////////////////////////////////////////////////////
//     Function: Shader::release_all
//       Access: Published
//  Description: Frees the context allocated on all objects for which
//               the texture has been declared.  Returns the number of
//               contexts which have been freed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3423  
1213 0 0 6 1222 3427 0 0 885 ////////////////////////////////////////////////////////////////////
//     Function: Shader::prepare_now
//       Access: Published
//  Description: Creates a context for the shader on the particular
//               GSG, if it does not already exist.  Returns the new
//               (or old) ShaderContext.  This assumes that the
//               GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               textures.  If this is not necessarily the case, you
//               should use prepare() instead.
//
//               Normally, this is not called directly except by the
//               GraphicsStateGuardian; a shader does not need to be
//               explicitly prepared by the user before it may be
//               rendered.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3423  16 prepared_objects 1 3211  3 gsg 1 3212  
1214 0 0 7 1223 3158 0 0 0 0 
1215 0 0 6 1225 3131 0 0 414 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_name
//       Access: Public
//  Description: Returns the name of the PreparedGraphicsObjects
//               structure.  This is an arbitrary name that serves
//               mainly to uniquify the context for PStats reporting.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1216 0 0 4 1226 3137 0 0 873 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::set_graphics_memory_limit
//       Access: Public
//  Description: Sets an artificial cap on graphics memory that
//               will be imposed on this GSG.
//
//               This limits the total amount of graphics memory,
//               including texture memory and vertex buffer memory,
//               that will be consumed by the GSG, regardless of
//               whether the hardware claims to provide more graphics
//               memory than this. It is useful to put a ceiling on
//               graphics memory consumed, since some drivers seem to
//               allow the application to consume more memory than the
//               hardware can realistically support.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  5 limit 1 3132  
1217 0 0 6 1227 3132 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_graphics_memory_limit
//       Access: Public
//  Description: Returns the artificial cap on graphics memory that
//               will be imposed on this GSG.  See
//               set_graphics_memory_limit().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1218 0 0 4 1228 3137 0 0 393 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::show_graphics_memory_lru
//       Access: Public
//  Description: Writes to the indicated ostream a report of how the
//               various textures and vertex buffers are allocated in
//               the LRU.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  3 out 1 3139  
1219 0 0 4 1229 3137 0 0 392 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::show_residency_trackers
//       Access: Public
//  Description: Writes to the indicated ostream a report of how the
//               various textures and vertex buffers are allocated in
//               the LRU.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  3 out 1 3139  
1220 0 0 4 1230 3137 0 0 284 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all
//       Access: Public
//  Description: Releases all prepared objects of all kinds at once.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3211  
1221 0 0 6 1231 3141 0 0 346 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued
//       Access: Public
//  Description: Returns the number of objects of any kind that have
//               been enqueued to be prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1222 0 0 6 1232 3141 0 0 341 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared
//       Access: Public
//  Description: Returns the number of objects of any kind that have
//               already been prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1223 0 0 4 1233 3137 0 0 413 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_texture
//       Access: Public
//  Description: Indicates that a texture would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  3 tex 1 3387  
1224 0 0 6 1234 3138 0 0 329 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_texture_queued
//       Access: Public
//  Description: Returns true if the texture has been queued on this
//               GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  3 tex 1 3388  
1225 0 0 6 1235 3138 0 0 733 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_texture
//       Access: Public
//  Description: Removes a texture from the queued list of textures to
//               be prepared.  Normally it is not necessary to call
//               this, unless you change your mind about preparing it
//               at the last minute, since the texture will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the texture is
//               successfully dequeued, false if it had not been
//               queued.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  3 tex 1 3387  
1226 0 0 6 1236 3138 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_texture_prepared
//       Access: Public
//  Description: Returns true if the texture has been prepared on
//               this GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  3 tex 1 3388  
1227 0 0 4 1237 3137 0 0 347 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_texture
//       Access: Public
//  Description: Releases a texture if it has already been prepared,
//               or removes it from the preparation queue.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  3 tex 1 3387  
1228 0 0 4 1237 3137 0 0 822 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_texture
//       Access: Public
//  Description: Indicates that a texture context, created by a
//               previous call to prepare_texture(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release textures--this
//               prevents conflicts from threading or multiple GSG's
//               sharing textures (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_texture is called).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  2 tc 1 3422  
1229 0 0 6 1238 3141 0 0 460 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_textures
//       Access: Public
//  Description: Releases all textures at once.  This will force them
//               to be reloaded into texture memory for all GSG's that
//               share this object.  Returns the number of textures
//               released.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3211  
1230 0 0 6 1239 3141 0 0 344 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_textures
//       Access: Public
//  Description: Returns the number of textures that have been
//               enqueued to be prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1231 0 0 6 1240 3141 0 0 339 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_textures
//       Access: Public
//  Description: Returns the number of textures that have already been
//               prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1232 0 0 6 1241 3422 0 0 1165 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_texture_now
//       Access: Public
//  Description: Immediately creates a new TextureContext for the
//               indicated texture and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               textures.  If this is not necessarily the case, you
//               should use enqueue_texture() instead.
//
//               Normally, this function is not called directly.  Call
//               Texture::prepare_now() instead.
//
//               The TextureContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular texture, and will exist as long as the
//               texture is ready to be rendered.
//
//               When either the Texture or the
//               PreparedGraphicsObjects object destructs, the
//               TextureContext will be deleted.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3211  3 tex 1 3387  4 view 1 3141  3 gsg 1 3212  
1233 0 0 4 1242 3137 0 0 413 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_sampler
//       Access: Public
//  Description: Indicates that a sampler would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  7 sampler 1 3383  
1234 0 0 6 1243 3138 0 0 329 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_sampler_queued
//       Access: Public
//  Description: Returns true if the sampler has been queued on this
//               GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  7 sampler 1 3383  
1235 0 0 6 1244 3138 0 0 733 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_sampler
//       Access: Public
//  Description: Removes a sampler from the queued list of samplers to
//               be prepared.  Normally it is not necessary to call
//               this, unless you change your mind about preparing it
//               at the last minute, since the sampler will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the sampler is
//               successfully dequeued, false if it had not been
//               queued.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  7 sampler 1 3383  
1236 0 0 6 1245 3138 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_sampler_prepared
//       Access: Public
//  Description: Returns true if the sampler has been prepared on
//               this GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  7 sampler 1 3383  
1237 0 0 4 1246 3137 0 0 546 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_sampler
//       Access: Public
//  Description: Indicates that a sampler context, created by a
//               previous call to prepare_sampler(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release samplers.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  2 sc 1 3385  
1238 0 0 4 1246 3137 0 0 347 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_sampler
//       Access: Public
//  Description: Releases a sampler if it has already been prepared,
//               or removes it from the preparation queue.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  7 sampler 1 3383  
1239 0 0 6 1247 3141 0 0 422 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_samplers
//       Access: Public
//  Description: Releases all samplers at once.  This will force them
//               to be reloaded for all GSG's that share this object.
//               Returns the number of samplers released.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3211  
1240 0 0 6 1248 3141 0 0 344 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_samplers
//       Access: Public
//  Description: Returns the number of samplers that have been
//               enqueued to be prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1241 0 0 6 1249 3141 0 0 339 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_samplers
//       Access: Public
//  Description: Returns the number of samplers that have already been
//               prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1242 0 0 6 1250 3385 0 0 1164 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_sampler_now
//       Access: Public
//  Description: Immediately creates a new SamplerContext for the
//               indicated sampler and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               samplers.  If this is not necessarily the case, you
//               should use enqueue_sampler() instead.
//
//               Normally, this function is not called directly.
//               Call Sampler::prepare_now() instead.
//
//               The SamplerContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular sampler, and will exist as long as the
//               sampler is ready to be rendered.
//
//               When either the Sampler or the
//               PreparedGraphicsObjects object destructs, the
//               SamplerContext will be deleted.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3211  7 sampler 1 3383  3 gsg 1 3212  
1243 0 0 4 1251 3137 0 0 407 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_geom
//       Access: Public
//  Description: Indicates that a geom would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  4 geom 1 3290  
1244 0 0 6 1252 3138 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_geom_queued
//       Access: Public
//  Description: Returns true if the geom has been queued on this
//               GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  4 geom 1 3291  
1245 0 0 6 1253 3138 0 0 718 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_geom
//       Access: Public
//  Description: Removes a geom from the queued list of geoms to
//               be prepared.  Normally it is not necessary to call
//               this, unless you change your mind about preparing it
//               at the last minute, since the geom will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the geom is
//               successfully dequeued, false if it had not been
//               queued.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  4 geom 1 3290  
1246 0 0 6 1254 3138 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_geom_prepared
//       Access: Public
//  Description: Returns true if the vertex buffer has been prepared on
//               this GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  4 geom 1 3291  
1247 0 0 4 1255 3137 0 0 804 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_geom
//       Access: Public
//  Description: Indicates that a geom context, created by a
//               previous call to prepare_geom(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release geoms--this
//               prevents conflicts from threading or multiple GSG's
//               sharing geoms (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_geom is called).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  2 gc 1 3297  
1248 0 0 6 1256 3141 0 0 448 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_geoms
//       Access: Public
//  Description: Releases all geoms at once.  This will force them
//               to be reloaded into geom memory for all GSG's that
//               share this object.  Returns the number of geoms
//               released.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3211  
1249 0 0 6 1257 3141 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_geoms
//       Access: Public
//  Description: Returns the number of geoms that have been
//               enqueued to be prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1250 0 0 6 1258 3141 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_geoms
//       Access: Public
//  Description: Returns the number of geoms that have already been
//               prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1251 0 0 6 1259 3297 0 0 1132 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_geom_now
//       Access: Public
//  Description: Immediately creates a new GeomContext for the
//               indicated geom and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               geoms.  If this is not necessarily the case, you
//               should use enqueue_geom() instead.
//
//               Normally, this function is not called directly.  Call
//               Geom::prepare_now() instead.
//
//               The GeomContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular geom, and will exist as long as the
//               geom is ready to be rendered.
//
//               When either the Geom or the
//               PreparedGraphicsObjects object destructs, the
//               GeomContext will be deleted.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3211  4 geom 1 3290  3 gsg 1 3212  
1252 0 0 4 1260 3137 0 0 411 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_shader
//       Access: Public
//  Description: Indicates that a shader would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  6 shader 1 3423  
1253 0 0 6 1261 3138 0 0 327 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_shader_queued
//       Access: Public
//  Description: Returns true if the shader has been queued on this
//               GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  6 shader 1 3424  
1254 0 0 6 1262 3138 0 0 728 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_shader
//       Access: Public
//  Description: Removes a shader from the queued list of shaders to
//               be prepared.  Normally it is not necessary to call
//               this, unless you change your mind about preparing it
//               at the last minute, since the shader will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the shader is
//               successfully dequeued, false if it had not been
//               queued.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  6 shader 1 3423  
1255 0 0 6 1263 3138 0 0 331 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_shader_prepared
//       Access: Public
//  Description: Returns true if the shader has been prepared on
//               this GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  6 shader 1 3424  
1256 0 0 4 1264 3137 0 0 816 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_shader
//       Access: Public
//  Description: Indicates that a shader context, created by a
//               previous call to prepare_shader(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release shaders--this
//               prevents conflicts from threading or multiple GSG's
//               sharing shaders (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_shader is called).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  2 sc 1 3427  
1257 0 0 6 1265 3141 0 0 456 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_shaders
//       Access: Public
//  Description: Releases all shaders at once.  This will force them
//               to be reloaded into shader memory for all GSG's that
//               share this object.  Returns the number of shaders
//               released.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3211  
1258 0 0 6 1266 3141 0 0 342 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_shaders
//       Access: Public
//  Description: Returns the number of shaders that have been
//               enqueued to be prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1259 0 0 6 1267 3141 0 0 337 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_shaders
//       Access: Public
//  Description: Returns the number of shaders that have already been
//               prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1260 0 0 6 1268 3427 0 0 1154 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_shader_now
//       Access: Public
//  Description: Immediately creates a new ShaderContext for the
//               indicated shader and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               shaders.  If this is not necessarily the case, you
//               should use enqueue_shader() instead.
//
//               Normally, this function is not called directly.  Call
//               Shader::prepare_now() instead.
//
//               The ShaderContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular shader, and will exist as long as the
//               shader is ready to be rendered.
//
//               When either the Shader or the
//               PreparedGraphicsObjects object destructs, the
//               ShaderContext will be deleted.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3211  6 shader 1 3423  3 gsg 1 3212  
1261 0 0 4 1269 3137 0 0 418 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_vertex_buffer
//       Access: Public
//  Description: Indicates that a buffer would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  4 data 1 3203  
1262 0 0 6 1270 3138 0 0 341 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_vertex_buffer_queued
//       Access: Public
//  Description: Returns true if the vertex buffer has been queued on
//               this GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  4 data 1 3165  
1263 0 0 6 1271 3138 0 0 737 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_vertex_buffer
//       Access: Public
//  Description: Removes a buffer from the queued list of data
//               arrays to be prepared.  Normally it is not necessary
//               to call this, unless you change your mind about
//               preparing it at the last minute, since the data will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the buffer is
//               successfully dequeued, false if it had not been
//               queued.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  4 data 1 3203  
1264 0 0 6 1272 3138 0 0 345 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_vertex_buffer_prepared
//       Access: Public
//  Description: Returns true if the vertex buffer has been prepared on
//               this GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  4 data 1 3165  
1265 0 0 4 1273 3137 0 0 831 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_vertex_buffer
//       Access: Public
//  Description: Indicates that a data context, created by a
//               previous call to prepare_vertex_buffer(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release datas--this
//               prevents conflicts from threading or multiple GSG's
//               sharing datas (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_vertex_buffer is called).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  3 vbc 1 3214  
1266 0 0 6 1274 3141 0 0 457 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_vertex_buffers
//       Access: Public
//  Description: Releases all datas at once.  This will force them
//               to be reloaded into data memory for all GSG's that
//               share this object.  Returns the number of datas
//               released.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3211  
1267 0 0 6 1275 3141 0 0 356 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_vertex_buffers
//       Access: Public
//  Description: Returns the number of vertex buffers that have been
//               enqueued to be prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1268 0 0 6 1276 3141 0 0 351 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_vertex_buffers
//       Access: Public
//  Description: Returns the number of vertex buffers that have
//               already been prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1269 0 0 6 1277 3214 0 0 1174 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_vertex_buffer_now
//       Access: Public
//  Description: Immediately creates a new VertexBufferContext for the
//               indicated data and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               datas.  If this is not necessarily the case, you
//               should use enqueue_vertex_buffer() instead.
//
//               Normally, this function is not called directly.  Call
//               Data::prepare_now() instead.
//
//               The VertexBufferContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular data, and will exist as long as the
//               data is ready to be rendered.
//
//               When either the Data or the
//               PreparedGraphicsObjects object destructs, the
//               VertexBufferContext will be deleted.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3211  4 data 1 3203  3 gsg 1 3212  
1270 0 0 4 1278 3137 0 0 417 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::enqueue_index_buffer
//       Access: Public
//  Description: Indicates that a buffer would like to be put on the
//               list to be prepared when the GSG is next ready to
//               do this (presumably at the next frame).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  4 data 1 3277  
1271 0 0 6 1279 3138 0 0 339 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_index_buffer_queued
//       Access: Public
//  Description: Returns true if the index buffer has been queued on
//               this GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  4 data 1 3278  
1272 0 0 6 1280 3138 0 0 736 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::dequeue_index_buffer
//       Access: Public
//  Description: Removes a buffer from the queued list of data
//               arrays to be prepared.  Normally it is not necessary
//               to call this, unless you change your mind about
//               preparing it at the last minute, since the data will
//               automatically be dequeued and prepared at the next
//               frame.
//
//               The return value is true if the buffer is
//               successfully dequeued, false if it had not been
//               queued.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  4 data 1 3277  
1273 0 0 6 1281 3138 0 0 343 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::is_index_buffer_prepared
//       Access: Public
//  Description: Returns true if the index buffer has been prepared on
//               this GSG, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3428  4 data 1 3278  
1274 0 0 4 1282 3137 0 0 828 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_index_buffer
//       Access: Public
//  Description: Indicates that a data context, created by a
//               previous call to prepare_index_buffer(), is no longer
//               needed.  The driver resources will not be freed until
//               some GSG calls update(), indicating it is at a
//               stage where it is ready to release datas--this
//               prevents conflicts from threading or multiple GSG's
//               sharing datas (we have no way of knowing which
//               graphics context is currently active, or what state
//               it's in, at the time release_index_buffer is called).
//////////////////////////////////////////////////////////////////// 2 4 this 3 3211  3 ibc 1 3430  
1275 0 0 6 1283 3141 0 0 456 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::release_all_index_buffers
//       Access: Public
//  Description: Releases all datas at once.  This will force them
//               to be reloaded into data memory for all GSG's that
//               share this object.  Returns the number of datas
//               released.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3211  
1276 0 0 6 1284 3141 0 0 354 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_queued_index_buffers
//       Access: Public
//  Description: Returns the number of index buffers that have been
//               enqueued to be prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1277 0 0 6 1285 3141 0 0 349 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::get_num_prepared_index_buffers
//       Access: Public
//  Description: Returns the number of index buffers that have
//               already been prepared on this GSG.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3428  
1278 0 0 6 1286 3430 0 0 1169 ////////////////////////////////////////////////////////////////////
//     Function: PreparedGraphicsObjects::prepare_index_buffer_now
//       Access: Public
//  Description: Immediately creates a new IndexBufferContext for the
//               indicated data and returns it.  This assumes that
//               the GraphicsStateGuardian is the currently active
//               rendering context and that it is ready to accept new
//               datas.  If this is not necessarily the case, you
//               should use enqueue_index_buffer() instead.
//
//               Normally, this function is not called directly.  Call
//               Data::prepare_now() instead.
//
//               The IndexBufferContext contains all of the pertinent
//               information needed by the GSG to keep track of this
//               one particular data, and will exist as long as the
//               data is ready to be rendered.
//
//               When either the Data or the
//               PreparedGraphicsObjects object destructs, the
//               IndexBufferContext will be deleted.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3211  4 data 1 3277  3 gsg 1 3212  
1279 0 0 7 1292 3277 2065 0 299 ////////////////////////////////////////////////////////////////////
//     Function: IndexBufferContext::get_data
//       Access: Public
//  Description: Returns the pointer to the client-side array data
//               object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3431  
1280 0 0 6 1293 3138 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: IndexBufferContext::changed_size
//       Access: Public
//  Description: Returns true if the data has changed size since the
//               last time mark_loaded() was called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3431  6 reader 1 3433  
1281 0 0 6 1294 3138 0 0 349 ////////////////////////////////////////////////////////////////////
//     Function: IndexBufferContext::changed_usage_hint
//       Access: Public
//  Description: Returns true if the data has changed its usage hint
//               since the last time mark_loaded() was called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3431  6 reader 1 3433  
1282 0 0 6 1295 3138 0 0 334 ////////////////////////////////////////////////////////////////////
//     Function: IndexBufferContext::was_modified
//       Access: Public
//  Description: Returns true if the data has been modified since the
//               last time mark_loaded() was called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3431  6 reader 1 3433  
1283 0 0 7 1296 3158 0 0 0 0 
1284 0 0 6 1288 3275 0 0 0 1 4 this 3 3430  
1285 0 0 6 1289 3430 0 0 0 1 4 this 3 3275  
1286 0 0 6 1290 3146 0 0 0 1 4 this 3 3430  
1287 0 0 6 1291 3430 0 0 0 1 4 this 3 3146  
1288 0 0 7 1300 3438 2830 0 0 1 4 this 3 3436  
1289 0 0 6 1301 3138 0 0 786 ////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude
//       Access: Published
//  Description: Given a 2-d point in the range (-1,1) in both
//               dimensions, where (0,0) is the center of the
//               lens and (-1,-1) is the lower-left corner,
//               compute the corresponding vector in space that maps
//               to this point, if such a vector can be determined.
//               The vector is returned by indicating the points on
//               the near plane and far plane that both map to the
//               indicated 2-d point.
//
//               Returns true if the vector is defined, or false
//               otherwise.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3436  7 point2d 1 3439  10 near_point 1 3443  9 far_point 1 3443  
1290 0 0 6 1301 3138 0 0 852 ////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude
//       Access: Published
//  Description: Given a 2-d point in the range (-1,1) in both
//               dimensions, where (0,0) is the center of the
//               lens and (-1,-1) is the lower-left corner,
//               compute the corresponding vector in space that maps
//               to this point, if such a vector can be determined.
//               The vector is returned by indicating the points on
//               the near plane and far plane that both map to the
//               indicated 2-d point.
//
//               The z coordinate of the 2-d point is ignored.
//
//               Returns true if the vector is defined, or false
//               otherwise.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3436  7 point2d 1 3445  10 near_point 1 3443  9 far_point 1 3443  
1291 0 0 6 1302 3138 0 0 528 ////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude_depth
//       Access: Published
//  Description: Uses the depth component of the 3-d result from
//               project() to compute the original point in 3-d space
//               corresponding to a particular point on the lens.
//               This exactly reverses project(), assuming the point
//               does fall legitimately within the lens.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3436  7 point2d 1 3445  7 point3d 1 3443  
1292 0 0 6 1303 3138 0 0 885 ////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude_vec
//       Access: Published
//  Description: Given a 2-d point in the range (-1,1) in both
//               dimensions, where (0,0) is the center of the
//               lens and (-1,-1) is the lower-left corner,
//               compute the vector that corresponds to the view
//               direction.  This will be parallel to the normal on
//               the surface (the far plane) corresponding to the lens
//               shape at this point.
//
//               See the comment block on Lens::extrude_vec_impl() for
//               a more in-depth comment on the meaning of this
//               vector.
//
//               Returns true if the vector is defined, or false
//               otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3436  7 point2d 1 3439  5 vec3d 1 3447  
1293 0 0 6 1303 3138 0 0 951 ////////////////////////////////////////////////////////////////////
//     Function: Lens::extrude_vec
//       Access: Published
//  Description: Given a 2-d point in the range (-1,1) in both
//               dimensions, where (0,0) is the center of the
//               lens and (-1,-1) is the lower-left corner,
//               compute the vector that corresponds to the view
//               direction.  This will be parallel to the normal on
//               the surface (the far plane) corresponding to the lens
//               shape at this point.
//
//               See the comment block on Lens::extrude_vec_impl() for
//               a more in-depth comment on the meaning of this
//               vector.
//
//               The z coordinate of the 2-d point is ignored.
//
//               Returns true if the vector is defined, or false
//               otherwise.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3436  7 point2d 1 3445  5 vec3d 1 3447  
1294 0 0 6 1304 3138 0 0 769 ////////////////////////////////////////////////////////////////////
//     Function: Lens::project
//       Access: Published
//  Description: Given a 3-d point in space, determine the 2-d point
//               this maps to, in the range (-1,1) in both dimensions,
//               where (0,0) is the center of the lens and
//               (-1,-1) is the lower-left corner.
//
//               Returns true if the 3-d point is in front of the lens
//               and within the viewing frustum (in which case point2d
//               is filled in), or false otherwise (in which case
//               point2d will be filled in with something, which may
//               or may not be meaningful).
//////////////////////////////////////////////////////////////////// 3 4 this 3 3436  7 point3d 1 3445  7 point2d 1 3449  
1295 0 0 6 1304 3138 0 0 980 ////////////////////////////////////////////////////////////////////
//     Function: Lens::project
//       Access: Published
//  Description: Given a 3-d point in space, determine the 2-d point
//               this maps to, in the range (-1,1) in both dimensions,
//               where (0,0) is the center of the lens and
//               (-1,-1) is the lower-left corner.
//
//               The z coordinate will also be set to a value in the
//               range (-1, 1), where 1 represents a point on the near
//               plane, and -1 represents a point on the far plane.
//
//               Returns true if the 3-d point is in front of the lens
//               and within the viewing frustum (in which case point2d
//               is filled in), or false otherwise (in which case
//               point2d will be filled in with something, which may
//               or may not be meaningful).
//////////////////////////////////////////////////////////////////// 3 4 this 3 3436  7 point3d 1 3445  7 point2d 1 3443  
1296 0 0 4 1305 3137 0 0 643 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_change_event
//       Access: Published
//  Description: Sets the name of the event that will be generated
//               whenever any properties of the Lens have
//               changed.  If this is not set for a particular lens,
//               no event will be generated.
//
//               The event is thrown with one parameter, the lens
//               itself.  This can be used to automatically track
//               changes to camera fov, etc. in the application.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  5 event 1 3131  
1297 0 0 6 1306 3131 0 0 370 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_change_event
//       Access: Published
//  Description: Returns the name of the event that will be generated
//               whenever any properties of this particular Lens have
//               changed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1298 0 0 4 1307 3137 0 0 385 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_coordinate_system
//       Access: Published
//  Description: Specifies the coordinate system that all 3-d
//               computations are performed within for this
//               Lens.  Normally, this is CS_default.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  2 cs 1 3450  
1299 0 0 6 1308 3450 0 0 383 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_coordinate_system
//       Access: Published
//  Description: Returns the coordinate system that all 3-d
//               computations are performed within for this
//               Lens.  Normally, this is CS_default.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1300 0 0 4 1309 3137 0 0 289 ////////////////////////////////////////////////////////////////////
//     Function: Lens::clear
//       Access: Published
//  Description: Resets all lens parameters to their initial default
//               settings.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3438  
1301 0 0 4 1310 3137 0 0 1181 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_size
//       Access: Published
//  Description: Sets the size and shape of the "film" within the
//               lens.  This both establishes the units used by
//               calls like set_focal_length(), and establishes the
//               aspect ratio of the frame.
//
//               In a physical camera, the field of view of a lens is
//               determined by the lens' focal length and by the size
//               of the film area exposed by the lens.  For instance,
//               a 35mm camera exposes a rectangle on the film about
//               24mm x 36mm, which means a 50mm lens gives about a
//               40-degree horizontal field of view.
//
//               In the virtual camera, you may set the film size to
//               any units here, and specify a focal length in the
//               same units to simulate the same effect.  Or, you may
//               ignore this parameter, and specify the field of view
//               and aspect ratio of the lens directly.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  9 film_size 1 3349  
1302 0 0 4 1310 3137 0 0 459 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_size
//       Access: Published
//  Description: Sets the horizontal size of the film without changing
//               its shape.  The aspect ratio remains unchanged; this
//               computes the vertical size of the film to
//               automatically maintain the aspect ratio.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  5 width 1 3142  
1303 0 0 4 1310 3137 0 0 1181 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_size
//       Access: Published
//  Description: Sets the size and shape of the "film" within the
//               lens.  This both establishes the units used by
//               calls like set_focal_length(), and establishes the
//               aspect ratio of the frame.
//
//               In a physical camera, the field of view of a lens is
//               determined by the lens' focal length and by the size
//               of the film area exposed by the lens.  For instance,
//               a 35mm camera exposes a rectangle on the film about
//               24mm x 36mm, which means a 50mm lens gives about a
//               40-degree horizontal field of view.
//
//               In the virtual camera, you may set the film size to
//               any units here, and specify a focal length in the
//               same units to simulate the same effect.  Or, you may
//               ignore this parameter, and specify the field of view
//               and aspect ratio of the lens directly.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3438  5 width 1 3142  6 height 1 3142  
1304 0 0 6 1311 3349 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_film_size
//       Access: Published
//  Description: Returns the horizontal and vertical film size of
//               the virtual film.  See set_film_size().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1305 0 0 4 1312 3137 0 0 448 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_offset
//       Access: Published
//  Description: Sets the horizontal and vertical offset amounts of
//               this Lens.  These are both in the same units
//               specified in set_film_size().
//
//               This can be used to establish an off-axis lens.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  11 film_offset 1 3349  
1306 0 0 4 1312 3137 0 0 448 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_film_offset
//       Access: Published
//  Description: Sets the horizontal and vertical offset amounts of
//               this Lens.  These are both in the same units
//               specified in set_film_size().
//
//               This can be used to establish an off-axis lens.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3438  1 x 1 3142  1 y 1 3142  
1307 0 0 6 1313 3451 0 0 326 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_film_offset
//       Access: Published
//  Description: Returns the horizontal and vertical offset amounts of
//               this Lens.  See set_film_offset().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1308 0 0 4 1314 3137 0 0 515 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_focal_length
//       Access: Published
//  Description: Sets the focal length of the lens.  This may adjust
//               the field-of-view correspondingly, and is an
//               alternate way to specify field of view.
//
//               For certain kinds of lenses (e.g. OrthographicLens),
//               the focal length has no meaning.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  12 focal_length 1 3142  
1309 0 0 6 1315 3142 0 0 527 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_focal_length
//       Access: Published
//  Description: Returns the focal length of the lens.  This may have
//               been set explicitly by a previous call to
//               set_focal_length(), or it may be computed based on
//               the lens' fov and film_size.  For certain kinds of
//               lenses, the focal length has no meaning.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1310 0 0 4 1316 3137 0 0 836 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_min_fov
//       Access: Published
//  Description: Sets the field of view of the smallest dimension of
//               the window.  If the window is wider than it is tall,
//               this specifies the vertical field of view; if it is
//               taller than it is wide, this specifies the horizontal
//               field of view.
//
//               In many cases, this is preferable to setting either
//               the horizontal or vertical field of view explicitly.
//               Setting this parameter means that pulling the window
//               wider will widen the field of view, which is usually
//               what you expect to happen.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  7 min_fov 1 3142  
1311 0 0 4 1317 3137 0 0 626 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_fov
//       Access: Published
//  Description: Sets the field of view of the lens in both
//               dimensions.  This establishes both the field of view
//               and the aspect ratio of the lens.  This is one way to
//               specify the field of view of a lens;
//               set_focal_length() is another way.
//
//               For certain kinds of lenses (like OrthographicLens),
//               the field of view has no meaning.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  3 fov 1 3349  
1312 0 0 4 1317 3137 0 0 402 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_fov
//       Access: Published
//  Description: Sets the horizontal field of view of the lens without
//               changing the aspect ratio.  The vertical field of
//               view is adjusted to maintain the same aspect ratio.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  3 fov 1 3142  
1313 0 0 4 1317 3137 0 0 619 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_fov
//       Access: Published
//  Description: Sets the field of view of the lens in both
//               dimensions.  This establishes both the field of view
//               and the aspect ratio of the lens.  This is one way to
//               specify the field of view of a lens;
//               set_focal_length() is another way.
//
//               For certain kinds of lenses (like OrthoLens),
//               the field of view has no meaning.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3438  4 hfov 1 3142  4 vfov 1 3142  
1314 0 0 6 1318 3349 0 0 312 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_fov
//       Access: Published
//  Description: Returns the horizontal and vertical film size of
//               the virtual film.  See set_fov().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1315 0 0 6 1319 3142 0 0 292 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_hfov
//       Access: Published
//  Description: Returns the horizontal component of fov only.  See
//               get_fov().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1316 0 0 6 1320 3142 0 0 290 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_vfov
//       Access: Published
//  Description: Returns the vertical component of fov only.  See
//               get_fov().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1317 0 0 6 1321 3142 0 0 321 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_min_fov
//       Access: Published
//  Description: Returns the field of view of the narrowest dimension
//               of the window.  See set_min_fov().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1318 0 0 4 1322 3137 0 0 444 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_aspect_ratio
//       Access: Published
//  Description: Sets the aspect ratio of the lens.  This is the ratio
//               of the height to the width of the generated image.
//               Setting this overrides the two-parameter fov or film
//               size setting.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  12 aspect_ratio 1 3142  
1319 0 0 6 1323 3142 0 0 368 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_aspect_ratio
//       Access: Published
//  Description: Returns the aspect ratio of the Lens.  This is
//               determined based on the indicated film size; see
//               set_film_size().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1320 0 0 4 1324 3137 0 0 377 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_near
//       Access: Published
//  Description: Defines the position of the near plane (or cylinder,
//               sphere, whatever).  Points closer to the lens than
//               this may not be rendered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  13 near_distance 1 3142  
1321 0 0 6 1325 3142 0 0 302 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_near
//       Access: Published
//  Description: Returns the position of the near plane (or cylinder,
//               sphere, whatever).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1322 0 0 4 1326 3137 0 0 378 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_far
//       Access: Published
//  Description: Defines the position of the far plane (or cylinder,
//               sphere, whatever).  Points farther from the lens than
//               this may not be rendered.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  12 far_distance 1 3142  
1323 0 0 6 1327 3142 0 0 300 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_far
//       Access: Published
//  Description: Returns the position of the far plane (or cylinder,
//               sphere, whatever).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1324 0 0 4 1328 3137 0 0 265 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_near_far
//       Access: Published
//  Description: Simultaneously changes the near and far planes.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3438  13 near_distance 1 3142  12 far_distance 1 3142  
1325 0 0 6 1329 3142 0 0 391 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_default_near
//       Access: Published, Static
//  Description: Returns the default near plane distance that will be
//               assigned to each newly-created lens.  This is read
//               from the Configrc file.
//////////////////////////////////////////////////////////////////// 0 
1326 0 0 6 1330 3142 0 0 389 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_default_far
//       Access: Published, Static
//  Description: Returns the default far plane distance that will be
//               assigned to each newly-created lens.  This is read
//               from the Configrc file.
//////////////////////////////////////////////////////////////////// 0 
1327 0 0 4 1331 3137 0 0 593 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_hpr
//       Access: Published
//  Description: Sets the direction in which the lens is facing.
//               Normally, this is down the forward axis (usually the
//               Y axis), but it may be rotated.  This is only one way
//               of specifying the rotation; you may also specify an
//               explicit vector in which to look, or you may give a
//               complete transformation matrix.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  8 view_hpr 1 3352  
1328 0 0 4 1331 3137 0 0 593 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_hpr
//       Access: Published
//  Description: Sets the direction in which the lens is facing.
//               Normally, this is down the forward axis (usually the
//               Y axis), but it may be rotated.  This is only one way
//               of specifying the rotation; you may also specify an
//               explicit vector in which to look, or you may give a
//               complete transformation matrix.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3438  1 h 1 3142  1 p 1 3142  1 r 1 3142  
1329 0 0 6 1332 3352 0 0 268 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_view_hpr
//       Access: Published
//  Description: Returns the direction in which the lens is facing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1330 0 0 4 1333 3137 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_vector
//       Access: Published
//  Description: Specifies the direction in which the lens is facing
//               by giving an axis to look along, and a perpendicular
//               (or at least non-parallel) up axis.
//
//               See also set_view_hpr().
//////////////////////////////////////////////////////////////////// 3 4 this 3 3438  11 view_vector 1 3455  9 up_vector 1 3455  
1331 0 0 4 1333 3137 0 0 440 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_vector
//       Access: Published
//  Description: Specifies the direction in which the lens is facing
//               by giving an axis to look along, and a perpendicular
//               (or at least non-parallel) up axis.
//
//               See also set_view_hpr().
//////////////////////////////////////////////////////////////////// 7 4 this 3 3438  1 x 1 3142  1 y 1 3142  1 z 1 3142  1 i 1 3142  1 j 1 3142  1 k 1 3142  
1332 0 0 6 1334 3455 0 0 269 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_view_vector
//       Access: Published
//  Description: Returns the axis along which the lens is facing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1333 0 0 6 1335 3455 0 0 329 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_up_vector
//       Access: Published
//  Description: Returns the axis perpendicular to the camera's view
//               vector that indicates the "up" direction.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1334 0 0 7 1336 3443 0 0 317 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_nodal_point
//       Access: Published
//  Description: Returns the center point of the lens: the point from
//               which the lens is viewing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1335 0 0 4 1337 3137 0 0 796 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_interocular_distance
//       Access: Published
//  Description: Sets the distance between the left and right eyes of
//               a stereo camera.  This distance is used to apply a
//               stereo effect when the lens is rendered on a stereo
//               display region.  It only has an effect on a
//               PerspectiveLens.
//
//               The left eye and the right eye are each offset along
//               the X axis by half of this distance, so that this
//               parameter specifies the total distance between them.
//
//               Also see set_convergence_distance(), which relates.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  20 interocular_distance 1 3142  
1336 0 0 6 1338 3142 0 0 261 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_interocular_distance
//       Access: Published
//  Description: See set_interocular_distance().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1337 0 0 4 1339 3137 0 0 1921 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_convergence_distance
//       Access: Published
//  Description: Sets the distance between between the camera plane
//               and the point in the distance that the left and right
//               eyes are both looking at.  This distance is used to
//               apply a stereo effect when the lens is rendered on a
//               stereo display region.  It only has an effect on a
//               PerspectiveLens.
//
//               This parameter must be greater than 0, but may be as
//               large as you like.  It controls the distance at
//               which the two stereo images will appear to converge,
//               which is a normal property of stereo vision.  Normally
//               this should be set to the distance from the camera to
//               the area of interest in your scene.  Anything beyond
//               this distance will appear to go into the screen, and
//               anything closer will appear to come out of the screen.
//               If you want to simulate parallel stereo, set this
//               to infinity.
//
//               Note that this creates an off-axis frustum, which
//               means that the lenses are still pointing in the
//               same direction, which is usually more desirable
//               than the more naive toe-in approach, where the
//               two lenses are simply tilted toward each other.
//
//               Prior to Panda3D 1.9.0, the convergence was being
//               calculated incorrectly.  It has since been corrected.
//               To restore the legacy behavior you can set the
//               stereo-lens-old-convergence variable to true.
//
//               Also see set_interocular_distance(), which relates.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  20 convergence_distance 1 3142  
1338 0 0 6 1340 3142 0 0 261 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_convergence_distance
//       Access: Published
//  Description: See set_convergence_distance().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1339 0 0 4 1341 3137 0 0 831 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_view_mat
//       Access: Published
//  Description: Sets an arbitrary transformation on the lens.  This
//               replaces the individual transformation components
//               like set_view_hpr().
//
//               Setting a transformation here will have a slightly
//               different effect than putting one on the LensNode
//               that contains this lens.  In particular, lighting and
//               other effects computations will still be performed on
//               the lens in its untransformed (facing forward)
//               position, but the actual projection matrix will be
//               transformed by this matrix.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  8 view_mat 1 3229  
1340 0 0 6 1342 3229 0 0 268 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_view_mat
//       Access: Published
//  Description: Returns the direction in which the lens is facing.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1341 0 0 4 1343 3137 0 0 258 ////////////////////////////////////////////////////////////////////
//     Function: Lens::clear_view_mat
//       Access: Published
//  Description: Resets the lens transform to identity.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3438  
1342 0 0 4 1344 3137 0 0 989 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_keystone
//       Access: Published
//  Description: Indicates the ratio of keystone correction to perform
//               on the lens, in each of three axes.  This will build
//               a special non-affine scale factor into the projection
//               matrix that will compensate for keystoning of a
//               projected image; this can be used to compensate for a
//               projector that for physical reasons cannot be aimed
//               directly at its screen.  
//
//               The default value is taken from the default-keystone
//               Config variable.  0, 0 indicates no keystone
//               correction; specify a small value (usually in the
//               range -1 .. 1) in either the x or y position to
//               generate a keystone correction in that axis.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  8 keystone 1 3349  
1343 0 0 6 1345 3349 0 0 290 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_keystone
//       Access: Published
//  Description: Returns the keystone correction specified for the
//               lens.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1344 0 0 4 1346 3137 0 0 258 ////////////////////////////////////////////////////////////////////
//     Function: Lens::clear_keystone
//       Access: Published
//  Description: Disables the lens keystone correction.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3438  
1345 0 0 4 1347 3137 0 0 743 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_custom_film_mat
//       Access: Published
//  Description: Specifies a custom matrix to transform the points on
//               the film after they have been converted into nominal
//               film space (-1 .. 1 in U and V).  This can be used to
//               introduce arbitrary scales, rotations, or other
//               linear transforms to the media plane.  This is
//               normally a 2-d matrix, but a full 4x4 matrix may be
//               specified.  This is applied on top of any film size,
//               lens shift, and/or keystone correction.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3438  15 custom_film_mat 1 3229  
1346 0 0 6 1348 3229 0 0 293 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_custom_film_mat
//       Access: Published
//  Description: Returns the custom_film_mat specified for the
//               lens.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1347 0 0 4 1349 3137 0 0 272 ////////////////////////////////////////////////////////////////////
//     Function: Lens::clear_custom_film_mat
//       Access: Published
//  Description: Disables the lens custom_film_mat correction.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3438  
1348 0 0 4 1351 3137 0 0 3080 ////////////////////////////////////////////////////////////////////
//     Function: Lens::set_frustum_from_corners
//       Access: Published
//  Description: Sets up the lens to use the frustum defined by the
//               four indicated points.  This is most useful for a
//               PerspectiveLens, but it may be called for other kinds
//               of lenses as well.
//
//               The frustum will be rooted at the origin (or by
//               whatever translation might have been specified in a
//               previous call to set_view_mat).
//
//               It is legal for the four points not to be arranged in
//               a rectangle; if this is the case, the frustum will be
//               fitted as tightly as possible to cover all four
//               points.
//
//               The flags parameter contains the union of one or more
//               of the following bits to control the behavior of this
//               function:
//
//               FC_roll - If this is included, the camera may be
//               rotated so that its up vector is perpendicular to the
//               top line.  Otherwise, the standard up vector is used.
//
//               FC_camera_plane - This allows the camera plane to be
//               adjusted to be as nearly perpendicular to the center
//               of the frustum as possible.  Without this bit, the
//               orientation camera plane is defined by position of
//               the four points (which should all be coplanar).  With
//               this bit, the camera plane is arbitarary, and may be
//               chosen so that the four points do not themselves lie
//               in the camera plane (but the points will still be
//               within the frustum).
//
//               FC_off_axis - This allows the resulting frustum to be
//               off-axis to get the tightest possible fit.  Without
//               this bit, the viewing axis will be centered within
//               the frustum, but there may be more wasted space along
//               the edges.
//
//               FC_aspect_ratio - This allows the frustum to be
//               scaled non-proportionately in the vertical and
//               horizontal dimensions, if necessary, to get a tighter
//               fit.  Without this bit, the current aspect ratio will
//               be preserved.
//
//               FC_shear - This allows the frustum to be sheared, if
//               necessary, to get the tightest possible fit.  This
//               may result in a parallelogram-based frustum, which
//               will give a slanted appearance to the rendered image.
//               Without this bit, the frustum will be
//               rectangle-based.
//
//               In general, if 0 is passed in as the value for flags,
//               the generated frustum will be a loose fit but sane;
//               if -1 is passed in, it will be a tighter fit and
//               possibly screwy.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3438  2 ul 1 3352  2 ur 1 3352  2 ll 1 3352  2 lr 1 3352  5 flags 1 3141  
1349 0 0 4 1352 3137 0 0 405 ////////////////////////////////////////////////////////////////////
//     Function: Lens::recompute_all
//       Access: Published
//  Description: Forces all internal parameters of the Lens to be
//               recomputed.  Normally, this should never need to be
//               called; it is provided only to assist in debugging.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3438  
1350 0 0 6 1353 3138 0 0 464 ////////////////////////////////////////////////////////////////////
//     Function: Lens::is_linear
//       Access: Published, Virtual
//  Description: Returns true if the lens represents a linear
//               projection (e.g. PerspectiveLens, OrthographicLens),
//               and therefore there is a valid matrix returned by
//               get_projection_mat(), or false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1351 0 0 6 1354 3138 0 0 372 ////////////////////////////////////////////////////////////////////
//     Function: Lens::is_perspective
//       Access: Published, Virtual
//  Description: Returns true if the lens represents a perspective
//               projection (i.e. it is a PerspectiveLens), false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1352 0 0 6 1355 3138 0 0 375 ////////////////////////////////////////////////////////////////////
//     Function: Lens::is_orthographic
//       Access: Published, Virtual
//  Description: Returns true if the lens represents a orthographic
//               projection (i.e. it is a OrthographicLens), false
//               otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1353 0 0 7 1356 3290 2198 0 515 ////////////////////////////////////////////////////////////////////
//     Function: Lens::make_geometry
//       Access: Published, Virtual
//  Description: Allocates and returns a new Geom that can be rendered
//               to show a visible representation of the frustum used
//               for this kind of lens, if it makes sense to do
//               so.  If a visible representation cannot be created,
//               returns NULL.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3438  
1354 0 0 7 1357 3457 0 0 450 ////////////////////////////////////////////////////////////////////
//     Function: Lens::make_bounds
//       Access: Published, Virtual
//  Description: Allocates and returns a new BoundingVolume that
//               encloses the frustum used for this kind of
//               lens, if possible.  If a suitable bounding
//               volume cannot be created, returns NULL.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1355 0 0 6 1358 3229 0 0 441 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_projection_mat
//       Access: Published
//  Description: Returns the complete transformation matrix from a 3-d
//               point in space to a point on the film, if such a
//               matrix exists, or the identity matrix if the lens is
//               nonlinear.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3436  7 channel 1 3108  
1356 0 0 6 1359 3229 0 0 376 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_projection_mat_inv
//       Access: Published
//  Description: Returns the matrix that transforms from a 2-d point
//               on the film to a 3-d vector in space, if such a
//               matrix exists.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3436  7 channel 1 3108  
1357 0 0 6 1360 3229 0 0 322 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_film_mat
//       Access: Published
//  Description: Returns the matrix that transforms from a point
//               behind the lens to a point on the film.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1358 0 0 6 1361 3229 0 0 326 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_film_mat_inv
//       Access: Published
//  Description: Returns the matrix that transforms from a point on
//               the film to a point behind the lens.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1359 0 0 6 1362 3229 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_lens_mat
//       Access: Published
//  Description: Returns the matrix that transforms from a point
//               in front of the lens to a point in space.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1360 0 0 6 1363 3229 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_lens_mat_inv
//       Access: Published
//  Description: Returns the matrix that transforms from a point in
//               space to a point in front of the lens.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1361 0 0 4 1364 3137 0 0 221 ////////////////////////////////////////////////////////////////////
//     Function: Lens::output
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 2 4 this 3 3436  3 out 1 3139  
1362 0 0 4 1365 3137 0 0 220 ////////////////////////////////////////////////////////////////////
//     Function: Lens::write
//       Access: Published, Virtual
//  Description: 
//////////////////////////////////////////////////////////////////// 3 4 this 3 3436  3 out 1 3139  12 indent_level 1 3141  
1363 0 0 7 1366 3205 0 0 447 ////////////////////////////////////////////////////////////////////
//     Function: Lens::get_last_change
//       Access: Published
//  Description: Returns the UpdateSeq that is incremented whenever
//               the lens properties are changed.  As long as this
//               number remains the same, you may assume the lens
//               properties are unchanged.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3436  
1364 0 0 7 1367 3158 0 0 0 0 
1365 0 0 7 1374 3460 2837 0 225 ////////////////////////////////////////////////////////////////////
//     Function: Material::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3458  
1366 0 0 7 1374 3460 2837 0 220 ////////////////////////////////////////////////////////////////////
//     Function: Material::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
1367 0 0 7 1375 3460 2837 0 0 2 4 this 3 3460  4 copy 1 3458  
1368 0 0 7 1377 3460 2837 0 258 ////////////////////////////////////////////////////////////////////
//     Function: Material::get_default
//       Access: Published, Static
//  Description: Returns the default material.
//////////////////////////////////////////////////////////////////// 0 
1369 0 0 6 1378 3138 0 0 331 ////////////////////////////////////////////////////////////////////
//     Function: Material::has_ambient
//       Access: Published
//  Description: Returns true if the ambient color has been explicitly
//               set for this material, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1370 0 0 6 1379 3266 0 0 367 ////////////////////////////////////////////////////////////////////
//     Function: Material::get_ambient
//       Access: Published
//  Description: Returns the ambient color setting, if it has been
//               set.  Returns (0,0,0,0) if the ambient color has not
//               been set.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1371 0 0 4 1380 3137 0 0 592 ////////////////////////////////////////////////////////////////////
//     Function: Material::set_ambient
//       Access: Published
//  Description: Specifies the ambient color setting of the material.
//               This will be the multiplied by any ambient lights in
//               effect on the material to set its base color.
//
//               This is the color of the object as it appears in the
//               absence of direct light.
//
//               If this is not set, the object color will be used.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3460  5 color 1 3266  
1372 0 0 4 1381 3137 0 0 276 ////////////////////////////////////////////////////////////////////
//     Function: Material::clear_ambient
//       Access: Published
//  Description: Removes the explicit ambient color from the material.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3460  
1373 0 0 6 1382 3138 0 0 331 ////////////////////////////////////////////////////////////////////
//     Function: Material::has_diffuse
//       Access: Published
//  Description: Returns true if the diffuse color has been explicitly
//               set for this material, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1374 0 0 6 1383 3266 0 0 367 ////////////////////////////////////////////////////////////////////
//     Function: Material::get_diffuse
//       Access: Published
//  Description: Returns the diffuse color setting, if it has been
//               set.  Returns (1,1,1,1) if the diffuse color has not
//               been set.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1375 0 0 4 1384 3137 0 0 709 ////////////////////////////////////////////////////////////////////
//     Function: Material::set_diffuse
//       Access: Published
//  Description: Specifies the diffuse color setting of the material.
//               This will be multiplied by any lights in effect on
//               the material to get the color in the parts of the
//               object illuminated by the lights.
//
//               This is the primary color of an object; the color of
//               the object as it appears in direct light, in the
//               absence of highlights.
//
//               If this is not set, the object color will be used.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3460  5 color 1 3266  
1376 0 0 4 1385 3137 0 0 276 ////////////////////////////////////////////////////////////////////
//     Function: Material::clear_diffuse
//       Access: Published
//  Description: Removes the explicit diffuse color from the material.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3460  
1377 0 0 6 1386 3138 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: Material::has_specular
//       Access: Published
//  Description: Returns true if the specular color has been explicitly
//               set for this material, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1378 0 0 6 1387 3266 0 0 370 ////////////////////////////////////////////////////////////////////
//     Function: Material::get_specular
//       Access: Published
//  Description: Returns the specular color setting, if it has been
//               set.  Returns (0,0,0,0) if the specular color has not
//               been set.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1379 0 0 4 1388 3137 0 0 637 ////////////////////////////////////////////////////////////////////
//     Function: Material::set_specular
//       Access: Published
//  Description: Specifies the diffuse color setting of the material.
//               This will be multiplied by any lights in effect on
//               the material to compute the color of specular
//               highlights on the object.
//
//               This is the highlight color of an object: the color
//               of small highlight reflections.
//
//               If this is not set, highlights will not appear.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3460  5 color 1 3266  
1380 0 0 4 1389 3137 0 0 278 ////////////////////////////////////////////////////////////////////
//     Function: Material::clear_specular
//       Access: Published
//  Description: Removes the explicit specular color from the material.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3460  
1381 0 0 6 1390 3138 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: Material::has_emission
//       Access: Published
//  Description: Returns true if the emission color has been explicitly
//               set for this material, false otherwise.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1382 0 0 6 1391 3266 0 0 370 ////////////////////////////////////////////////////////////////////
//     Function: Material::get_emission
//       Access: Published
//  Description: Returns the emission color setting, if it has been
//               set.  Returns (0,0,0,0) if the emission color has not
//               been set.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1383 0 0 4 1392 3137 0 0 768 ////////////////////////////////////////////////////////////////////
//     Function: Material::set_emission
//       Access: Published
//  Description: Specifies the emission color setting of the material.
//               This is the color of the object as it appears in the
//               absence of any light whatsover, including ambient
//               light.  It is as if the object is glowing by this
//               color (although of course it will not illuminate
//               neighboring objects).
//
//               If this is not set, the object will not glow by its
//               own light and will only appear visible in the
//               presence of one or more lights.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3460  5 color 1 3266  
1384 0 0 4 1393 3137 0 0 278 ////////////////////////////////////////////////////////////////////
//     Function: Material::clear_emission
//       Access: Published
//  Description: Removes the explicit emission color from the material.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3460  
1385 0 0 6 1394 3142 0 0 270 ////////////////////////////////////////////////////////////////////
//     Function: Material::get_shininess
//       Access: Published
//  Description: Returns the shininess exponent of the material.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1386 0 0 4 1395 3137 0 0 598 ////////////////////////////////////////////////////////////////////
//     Function: Material::set_shininess
//       Access: Published
//  Description: Sets the shininess exponent of the material.  This
//               controls the size of the specular highlight spot.  In
//               general, larger number produce a smaller specular
//               highlight, which makes the object appear shinier.
//               Smaller numbers produce a larger highlight, which
//               makes the object appear less shiny.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3460  9 shininess 1 3142  
1387 0 0 6 1396 3138 0 0 267 ////////////////////////////////////////////////////////////////////
//     Function: Material::get_local
//       Access: Published
//  Description: Returns the local viewer flag.  Set set_local().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1388 0 0 4 1397 3137 0 0 519 ////////////////////////////////////////////////////////////////////
//     Function: Material::set_local
//       Access: Published
//  Description: Sets the local viewer flag.  Set this true to enable
//               camera-relative specular highlights, or false to use
//               orthogonal specular highlights.  The default value is
//               true.  Applications that use orthogonal projection
//               should specify false.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3460  5 local 1 3138  
1389 0 0 6 1398 3138 0 0 306 ////////////////////////////////////////////////////////////////////
//     Function: Material::get_twoside
//       Access: Published
//  Description: Returns the state of the two-sided lighting flag.
//               See set_twoside().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1390 0 0 4 1399 3137 0 0 513 ////////////////////////////////////////////////////////////////////
//     Function: Material::set_twoside
//       Access: Published
//  Description: Set this true to enable two-sided lighting.  When
//               two-sided lighting is on, both sides of a polygon
//               will be lit by this material.  The default is for
//               two-sided lighting to be off, in which case only the
//               front surface is lit.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3460  7 twoside 1 3138  
1391 0 0 6 1400 3138 0 0 0 2 4 this 3 3458  5 other 1 3458  
1392 0 0 6 1401 3138 0 0 0 2 4 this 3 3458  5 other 1 3458  
1393 0 0 6 1402 3138 0 0 0 2 4 this 3 3458  5 other 1 3458  
1394 0 0 6 1403 3141 0 0 535 ////////////////////////////////////////////////////////////////////
//     Function: Material::compare_to
//       Access: Published
//  Description: Returns a number less than zero if this material
//               sorts before the other one, greater than zero if it
//               sorts after, or zero if they are equivalent.  The
//               sorting order is arbitrary and largely meaningless,
//               except to differentiate different materials.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3458  5 other 1 3458  
1395 0 0 4 1404 3137 0 0 215 ////////////////////////////////////////////////////////////////////
//     Function: Material::output
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 this 3 3458  3 out 1 3139  
1396 0 0 4 1405 3137 0 0 214 ////////////////////////////////////////////////////////////////////
//     Function: Material::write
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 3 4 this 3 3458  3 out 1 3139  6 indent 1 3141  
1397 0 0 6 1406 3138 0 0 225 ////////////////////////////////////////////////////////////////////
//     Function: Material::is_attrib_locked
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3458  
1398 0 0 4 1407 3137 0 0 224 ////////////////////////////////////////////////////////////////////
//     Function: Material::set_attrib_lock
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3460  
1399 0 0 7 1408 3158 0 0 0 0 
1400 0 0 7 1370 3167 0 0 0 1 4 this 3 3460  
1401 0 0 7 1371 3460 2837 0 0 1 4 this 3 3167  
1402 0 0 6 1372 3178 0 0 0 1 4 this 3 3460  
1403 0 0 7 1373 3460 2837 0 0 1 4 this 3 3178  
1404 0 0 7 1410 3460 2837 0 1050 ////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::get_material
//       Access: Public, Static
//  Description: Returns a Material pointer that represents the
//               same material described by temp, except that it is a
//               shared pointer.
//
//               Each call to get_material() passing an equivalent
//               Material pointer will return the same shared pointer.
//
//               If you modify the shared pointer, it will
//               automatically disassociate it from the pool.
//
//               Also, the return value may be a different pointer
//               than that passed in, or it may be the same pointer.
//               In either case, the passed in pointer has now been
//               sacrificed to the greater good and should not be used
//               again (like any other PointerTo, it will be freed
//               when the last reference count is removed).
//////////////////////////////////////////////////////////////////// 1 4 temp 1 3460  
1405 0 0 4 1411 3137 0 0 283 ////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::release_material
//       Access: Published, Static
//  Description: Removes the indicated material from the pool.
//////////////////////////////////////////////////////////////////// 1 4 temp 1 3460  
1406 0 0 4 1412 3137 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::release_all_materials
//       Access: Published, Static
//  Description: Releases all materials in the pool and restores the
//               pool to the empty state.
//////////////////////////////////////////////////////////////////// 0 
1407 0 0 6 1413 3141 0 0 481 ////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::garbage_collect
//       Access: Public, Static
//  Description: Releases only those materials in the pool that have a
//               reference count of exactly 1; i.e. only those
//               materials that are not being used outside of the pool.
//               Returns the number of materials released.
//////////////////////////////////////////////////////////////////// 0 
1408 0 0 4 1414 3137 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::list_contents
//       Access: Public, Static
//  Description: Lists the contents of the material pool to the
//               indicated output stream.
//////////////////////////////////////////////////////////////////// 1 3 out 1 3139  
1409 0 0 4 1415 3137 0 0 315 ////////////////////////////////////////////////////////////////////
//     Function: MaterialPool::write
//       Access: Published, Static
//  Description: Lists the contents of the material pool to the
//               indicated output stream.
//////////////////////////////////////////////////////////////////// 1 3 out 1 3139  
1410 0 0 7 1418 3461 2889 0 219 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 0 
1411 0 0 4 1419 3137 0 0 938 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::set_user_mat
//       Access: Published
//  Description: Explicitly specifies the projection matrix.  This
//               matrix should convert X and Y to the range
//               [-film_size/2, film_size/2], where (-fs/2,-fs/2) is
//               the lower left corner of the screen and (fs/2, fs/2)
//               is the upper right.  Z should go to the range [-1,
//               1], where -1 is the far plane and 1 is the near
//               plane.  Note that this is a left-handed Y-up
//               coordinate system.
//
//               The default film_size for a MatrixLens is 2, so the
//               default range is [-1, 1] for both X and Y.  This is
//               consistent with the GL conventions for projection
//               matrices.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3461  8 user_mat 1 3229  
1412 0 0 6 1420 3229 0 0 404 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::get_user_mat
//       Access: Published
//  Description: Returns the explicit projection matrix as set by the
//               user.  This does not include transforms on the lens
//               or film (e.g. a film offset or view hpr).
//////////////////////////////////////////////////////////////////// 1 4 this 3 3462  
1413 0 0 4 1421 3137 0 0 761 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::set_left_eye_mat
//       Access: Published
//  Description: Sets a custom projection matrix for the left eye.
//               This is only used if the lens is attached to a stereo
//               camera, in which case the left eye matrix will be
//               used to draw the scene in the left eye (but the
//               center matrix--the user_mat--will still be used to
//               cull the scene).
//
//               This matrix should not be too different from the
//               center matrix (set by set_user_mat()) or culling
//               errors may become obvious.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3461  8 user_mat 1 3229  
1414 0 0 4 1422 3137 0 0 380 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::clear_left_eye_mat
//       Access: Published
//  Description: Removes the custom projection matrix set for the left
//               eye, and uses the center matrix (set by set_user_mat)
//               instead.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3461  
1415 0 0 6 1423 3138 0 0 441 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::has_left_eye_mat
//       Access: Published
//  Description: Returns true if the camera has a custom projection
//               matrix set for the left eye, or false if the center
//               matrix (set by set_user_mat) will be used for the
//               left eye.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3462  
1416 0 0 6 1424 3229 0 0 396 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::get_left_eye_mat
//       Access: Published
//  Description: Returns the custom projection matrix for the left
//               eye, if any, or the center matrix if there is no
//               custom matrix set for the left eye.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3462  
1417 0 0 4 1425 3137 0 0 765 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::set_right_eye_mat
//       Access: Published
//  Description: Sets a custom projection matrix for the right eye.
//               This is only used if the lens is attached to a stereo
//               camera, in which case the right eye matrix will be
//               used to draw the scene in the right eye (but the
//               center matrix--the user_mat--will still be used to
//               cull the scene).
//
//               This matrix should not be too different from the
//               center matrix (set by set_user_mat()) or culling
//               errors may become obvious.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3461  8 user_mat 1 3229  
1418 0 0 4 1426 3137 0 0 382 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::clear_right_eye_mat
//       Access: Published
//  Description: Removes the custom projection matrix set for the right
//               eye, and uses the center matrix (set by set_user_mat)
//               instead.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3461  
1419 0 0 6 1427 3138 0 0 444 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::has_right_eye_mat
//       Access: Published
//  Description: Returns true if the camera has a custom projection
//               matrix set for the right eye, or false if the center
//               matrix (set by set_user_mat) will be used for the
//               right eye.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3462  
1420 0 0 6 1428 3229 0 0 399 ////////////////////////////////////////////////////////////////////
//     Function: MatrixLens::get_right_eye_mat
//       Access: Published
//  Description: Returns the custom projection matrix for the right
//               eye, if any, or the center matrix if there is no
//               custom matrix set for the right eye.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3462  
1421 0 0 7 1429 3158 0 0 0 0 
1422 0 0 7 1432 3464 2892 0 225 ////////////////////////////////////////////////////////////////////
//     Function: OrthographicLens::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 0 
1423 0 0 7 1433 3158 0 0 0 0 
1424 0 0 7 1437 3465 2897 0 329 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureSampler::Constructor
//       Access: Published
//  Description: Creates a new ParamTextureSampler storing the given
//               texture and sampler objects.
//////////////////////////////////////////////////////////////////// 2 3 tex 1 3387  7 sampler 1 3383  
1425 0 0 7 1438 3387 2472 0 278 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureSampler::get_texture
//       Access: Published
//  Description: Retrieves the texture stored in the parameter.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3466  
1426 0 0 6 1439 3383 0 0 284 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureSampler::get_sampler
//       Access: Published
//  Description: Retrieves the sampler state stored in the parameter.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3466  
1427 0 0 7 1440 3158 0 0 0 0 
1428 0 0 7 1443 3468 2906 0 334 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::Constructor
//       Access: Published
//  Description: Creates a new ParamTextureImage storing the given
//               texture and image binding parameters.
//////////////////////////////////////////////////////////////////// 5 3 tex 1 3387  4 read 1 3138  5 write 1 3138  1 z 1 3141  1 n 1 3141  
1429 0 0 7 1444 3387 2472 0 276 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::get_texture
//       Access: Published
//  Description: Retrieves the texture stored in the parameter.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3469  
1430 0 0 6 1445 3138 0 0 319 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::has_read_access
//       Access: Published
//  Description: Returns true if this image should be bound with
//               read access enabled.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3469  
1431 0 0 6 1446 3138 0 0 321 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::has_write_access
//       Access: Published
//  Description: Returns true if this image should be bound with
//               write access enabled.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3469  
1432 0 0 6 1447 3138 0 0 324 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::get_bind_layered
//       Access: Published
//  Description: Returns true if all layers of this image should be
//               bound simultaneously.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3469  
1433 0 0 6 1448 3141 0 0 278 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::get_bind_level
//       Access: Published
//  Description: Returns the image level that should be bound.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3469  
1434 0 0 6 1449 3141 0 0 351 ////////////////////////////////////////////////////////////////////
//     Function: ParamTextureImage::get_bind_layer
//       Access: Published
//  Description: Returns the image layer that should be bound.  This
//               is undefined if get_bind_layered() returns false.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3469  
1435 0 0 7 1450 3158 0 0 0 0 
1436 0 0 7 1453 3471 2909 0 224 ////////////////////////////////////////////////////////////////////
//     Function: PerspectiveLens::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 0 
1437 0 0 7 1453 3471 2909 0 224 ////////////////////////////////////////////////////////////////////
//     Function: PerspectiveLens::Constructor
//       Access: Public
//  Description:
//////////////////////////////////////////////////////////////////// 2 4 hfov 1 3142  4 vfov 1 3142  
1438 0 0 7 1454 3158 0 0 0 0 
1439 0 0 7 1457 3472 2916 0 358 ////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::Constructor
//       Access: Published
//  Description: Create a new TextureReloadRequest, and add it to the loader
//               via load_async(), to begin an asynchronous load.
//////////////////////////////////////////////////////////////////// 4 4 name 1 3131  3 pgo 1 3211  7 texture 1 3387  16 allow_compressed 1 3138  
1440 0 0 7 1458 3211 0 0 366 ////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::get_prepared_graphics_objects
//       Access: Published
//  Description: Returns the PreparedGraphicsObjects object associated with
//               this asynchronous TextureReloadRequest.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3473  
1441 0 0 7 1459 3387 2472 0 332 ////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::get_texture
//       Access: Published
//  Description: Returns the Texture object associated with
//               this asynchronous TextureReloadRequest.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3473  
1442 0 0 6 1460 3138 0 0 350 ////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::get_allow_compressed
//       Access: Published
//  Description: Returns the "allow compressed" flag associated with
//               this asynchronous TextureReloadRequest.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3473  
1443 0 0 6 1461 3138 0 0 320 ////////////////////////////////////////////////////////////////////
//     Function: TextureReloadRequest::is_ready
//       Access: Published
//  Description: Returns true if this request has completed, false if
//               it is still pending.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3473  
1444 0 0 7 1462 3158 0 0 0 0 
1445 0 0 7 1469 3387 2472 0 294 ////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_texture
//       Access: Public
//  Description: Returns the pointer to the associated Texture
//               object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3475  
1446 0 0 6 1470 3141 0 0 394 ////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_view
//       Access: Public
//  Description: Returns the specific view of a multiview texture this
//               context represents.  In the usual case, with a
//               non-multiview texture, this will be 0.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3475  
1447 0 0 6 1471 3138 0 0 371 ////////////////////////////////////////////////////////////////////
//     Function: TextureContext::was_modified
//       Access: Public
//  Description: Returns true if the texture properties or image have
//               been modified since the last time mark_loaded() was
//               called.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3475  
1448 0 0 6 1472 3138 0 0 398 ////////////////////////////////////////////////////////////////////
//     Function: TextureContext::was_properties_modified
//       Access: Public
//  Description: Returns true if the texture properties (unrelated to
//               the image) have been modified since the last time
//               mark_loaded() was called.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3475  
1449 0 0 6 1473 3138 0 0 345 ////////////////////////////////////////////////////////////////////
//     Function: TextureContext::was_image_modified
//       Access: Public
//  Description: Returns true if the texture image has been modified
//               since the last time mark_loaded() was called.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3475  
1450 0 0 6 1474 3138 0 0 387 ////////////////////////////////////////////////////////////////////
//     Function: TextureContext::was_simple_image_modified
//       Access: Public
//  Description: Returns true if the texture's "simple" image has been
//               modified since the last time mark_simple_loaded() was
//               called.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3475  
1451 0 0 7 1475 3205 0 0 410 ////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_properties_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture properties
//               (unrelated to the image) are modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3475  
1452 0 0 7 1476 3205 0 0 406 ////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_image_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture image data
//               (including mipmap levels) are modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3475  
1453 0 0 7 1477 3205 0 0 397 ////////////////////////////////////////////////////////////////////
//     Function: TextureContext::get_simple_image_modified
//       Access: Published
//  Description: Returns a sequence number which is guaranteed to
//               change at least every time the texture's "simple"
//               image data is modified.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3475  
1454 0 0 7 1478 3158 0 0 0 0 
1455 0 0 6 1465 3275 0 0 0 1 4 this 3 3422  
1456 0 0 6 1466 3422 0 0 0 1 4 this 3 3275  
1457 0 0 6 1467 3146 0 0 0 1 4 this 3 3422  
1458 0 0 6 1468 3422 0 0 0 1 4 this 3 3146  
1459 0 0 7 1481 3423 0 0 227 ////////////////////////////////////////////////////////////////////
//     Function: ShaderContext::get_expansion
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 this 3 3477  
1460 0 0 7 1482 3158 0 0 0 0 
1461 0 0 7 1485 3479 2938 0 229 ////////////////////////////////////////////////////////////////////
//     Function: UserVertexSlider::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 name 1 3155  
1462 0 0 7 1485 3479 2938 0 229 ////////////////////////////////////////////////////////////////////
//     Function: UserVertexSlider::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
1463 0 0 4 1486 3137 0 0 262 ////////////////////////////////////////////////////////////////////
//     Function: UserVertexSlider::set_slider
//       Access: Published
//  Description: Stores the indicated slider value.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3479  6 slider 1 3142  
1464 0 0 7 1487 3158 0 0 0 0 
1465 0 0 7 1490 3480 2943 0 232 ////////////////////////////////////////////////////////////////////
//     Function: UserVertexTransform::Constructor
//       Access: Published
//  Description: 
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
1466 0 0 6 1491 3131 0 0 311 ////////////////////////////////////////////////////////////////////
//     Function: UserVertexTransform::get_name
//       Access: Published
//  Description: Returns the name passed to the constructor.
//               Completely arbitrary.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3481  
1467 0 0 4 1492 3137 0 0 259 ////////////////////////////////////////////////////////////////////
//     Function: UserVertexTransform::set_matrix
//       Access: Published
//  Description: Stores the indicated matrix.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3480  6 matrix 1 3229  
1468 0 0 7 1493 3158 0 0 0 0 
1469 0 0 6 1501 3138 0 0 482 ////////////////////////////////////////////////////////////////////
//     Function: VideoTexture::get_keep_ram_image
//       Access: Published, Virtual
//  Description: Returns the flag that indicates whether this Texture
//               is eligible to have its main RAM copy of the texture
//               memory dumped when the texture is prepared for
//               rendering.  See set_keep_ram_image().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3483  
1470 0 0 6 1502 3141 0 0 463 ////////////////////////////////////////////////////////////////////
//     Function: VideoTexture::get_video_width
//       Access: Published
//  Description: Returns the width in texels of the source video
//               stream.  This is not necessarily the width of the
//               actual texture, since the texture may have been
//               expanded to raise it to a power of 2.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3483  
1471 0 0 6 1503 3141 0 0 466 ////////////////////////////////////////////////////////////////////
//     Function: VideoTexture::get_video_height
//       Access: Published
//  Description: Returns the height in texels of the source video
//               stream.  This is not necessarily the height of the
//               actual texture, since the texture may have been
//               expanded to raise it to a power of 2.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3483  
1472 0 0 7 1504 3158 0 0 0 0 
1473 0 0 7 1496 3387 2472 0 0 1 4 this 3 3485  
1474 0 0 7 1497 3485 2952 0 0 1 4 this 3 3387  
1475 0 0 6 1499 3486 0 0 0 1 4 this 3 3485  
1476 0 0 7 1500 3485 2952 0 0 1 4 this 3 3486  
1477 0 0 7 1511 3203 1842 0 300 ////////////////////////////////////////////////////////////////////
//     Function: VertexBufferContext::get_data
//       Access: Public
//  Description: Returns the pointer to the client-side array data
//               object.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3487  
1478 0 0 6 1512 3138 0 0 334 ////////////////////////////////////////////////////////////////////
//     Function: VertexBufferContext::changed_size
//       Access: Public
//  Description: Returns true if the data has changed size since the
//               last time mark_loaded() was called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3487  6 reader 1 3209  
1479 0 0 6 1513 3138 0 0 350 ////////////////////////////////////////////////////////////////////
//     Function: VertexBufferContext::changed_usage_hint
//       Access: Public
//  Description: Returns true if the data has changed its usage hint
//               since the last time mark_loaded() was called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3487  6 reader 1 3209  
1480 0 0 6 1514 3138 0 0 335 ////////////////////////////////////////////////////////////////////
//     Function: VertexBufferContext::was_modified
//       Access: Public
//  Description: Returns true if the data has been modified since the
//               last time mark_loaded() was called.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3487  6 reader 1 3209  
1481 0 0 7 1515 3158 0 0 0 0 
1482 0 0 6 1507 3275 0 0 0 1 4 this 3 3214  
1483 0 0 6 1508 3214 0 0 0 1 4 this 3 3275  
1484 0 0 6 1509 3146 0 0 0 1 4 this 3 3214  
1485 0 0 6 1510 3214 0 0 0 1 4 this 3 3146  
1486 0 0 7 1518 3489 2965 0 229 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 0 
1487 0 0 7 1518 3489 2965 0 0 1 8 sequence 1 3218  
1488 0 0 7 1518 3489 2965 0 234 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::Copy Constructor
//       Access: Published
//  Description:
//////////////////////////////////////////////////////////////////// 1 4 copy 1 3490  
1489 0 0 6 1519 3489 0 0 0 2 4 this 3 3489  4 copy 1 3490  
1490 0 0 6 1521 3218 0 0 0 1 4 this 3 3490  
1491 0 0 4 1522 3137 0 0 267 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::add_texture
//       Access: Published
//  Description: Adds a new Texture to the collection.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3489  7 texture 1 3387  
1492 0 0 6 1523 3138 0 0 406 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::remove_texture
//       Access: Published
//  Description: Removes the indicated Texture from the collection.
//               Returns true if the texture was removed, false if it was
//               not a member of the collection.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3489  7 texture 1 3387  
1493 0 0 4 1524 3137 0 0 482 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::add_textures_from
//       Access: Published
//  Description: Adds all the Textures indicated in the other
//               collection to this texture.  The other textures are simply
//               appended to the end of the textures in this list;
//               duplicates are not automatically removed.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3489  5 other 1 3490  
1494 0 0 4 1525 3137 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::remove_textures_from
//       Access: Published
//  Description: Removes from this collection all of the Textures
//               listed in the other collection.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3489  5 other 1 3490  
1495 0 0 4 1526 3137 0 0 473 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::remove_duplicate_textures
//       Access: Published
//  Description: Removes any duplicate entries of the same Textures
//               on this collection.  If a Texture appears multiple
//               times, the first appearance is retained; subsequent
//               appearances are removed.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3489  
1496 0 0 6 1527 3138 0 0 329 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::has_texture
//       Access: Published
//  Description: Returns true if the indicated Texture appears in
//               this collection, false otherwise.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3490  7 texture 1 3387  
1497 0 0 4 1528 3137 0 0 265 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::clear
//       Access: Published
//  Description: Removes all Textures from the collection.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3489  
1498 0 0 4 1529 3137 0 0 403 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::reserve
//       Access: Published
//  Description: This is a hint to Panda to allocate enough memory
//               to hold the given number of NodePaths, if you know
//               ahead of time how many you will be adding.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3489  3 num 1 3132  
1499 0 0 7 1530 3387 2472 0 372 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::find_texture
//       Access: Published
//  Description: Returns the texture in the collection with the
//               indicated name, if any, or NULL if no texture has
//               that name.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3490  4 name 1 3131  
1500 0 0 6 1531 3141 0 0 284 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::get_num_textures
//       Access: Published
//  Description: Returns the number of Textures in the collection.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3490  
1501 0 0 7 1532 3387 2472 0 272 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::get_texture
//       Access: Published
//  Description: Returns the nth Texture in the collection.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3490  5 index 1 3141  
1502 0 0 7 1533 3387 2472 0 392 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::operator []
//       Access: Published
//  Description: Returns the nth Texture in the collection.  This is
//               the same as get_texture(), but it may be a more
//               convenient way to access it.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3490  5 index 1 3141  
1503 0 0 6 1534 3141 0 0 336 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::size
//       Access: Published
//  Description: Returns the number of textures in the collection.  This
//               is the same thing as get_num_textures().
//////////////////////////////////////////////////////////////////// 1 4 this 3 3490  
1504 0 0 6 1535 3489 0 0 0 2 4 this 3 3489  5 other 1 3490  
1505 0 0 7 1536 3489 2965 0 0 2 4 this 3 3490  5 other 1 3490  
1506 0 0 4 1537 3137 0 0 400 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::append
//       Access: Published
//  Description: Adds a new Texture to the collection.  This method
//               duplicates the add_texture() method; it is provided to
//               satisfy Python's naming convention.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3489  7 texture 1 3387  
1507 0 0 4 1538 3137 0 0 401 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::extend
//       Access: Published
//  Description: Appends the other list onto the end of this one.
//               This method duplicates the += operator; it is
//               provided to satisfy Python's naming convention.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3489  5 other 1 3490  
1508 0 0 4 1539 3137 0 0 334 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::output
//       Access: Published
//  Description: Writes a brief one-line description of the
//               TextureCollection to the indicated output stream.
//////////////////////////////////////////////////////////////////// 2 4 this 3 3490  3 out 1 3139  
1509 0 0 4 1540 3137 0 0 338 ////////////////////////////////////////////////////////////////////
//     Function: TextureCollection::write
//       Access: Published
//  Description: Writes a complete multi-line description of the
//               TextureCollection to the indicated output stream.
//////////////////////////////////////////////////////////////////// 3 4 this 3 3490  3 out 1 3139  12 indent_level 1 3141  
1510 0 0 6 1542 3138 0 0 315 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::has_texture
//       Access: Published, Static
//  Description: Returns true if the texture has ever been loaded,
//               false otherwise.
//////////////////////////////////////////////////////////////////// 1 8 filename 1 3390  
1511 0 0 6 1543 3138 0 0 611 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::verify_texture
//       Access: Published, Static
//  Description: Loads the given filename up into a texture, if it has
//               not already been loaded, and returns true to indicate
//               success, or false to indicate failure.  If this
//               returns true, it is guaranteed that a subsequent call
//               to load_texture() with the same texture name will
//               return a valid Texture pointer.
//////////////////////////////////////////////////////////////////// 1 8 filename 1 3390  
1512 0 0 7 1544 3387 2472 0 845 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_texture
//       Access: Published, Static
//  Description: Loads the given filename up into a texture, if it has
//               not already been loaded, and returns the new texture.
//               If a texture with the same filename was previously
//               loaded, returns that one instead.  If the texture
//               file cannot be found, returns NULL.
//
//               If read_mipmaps is true, both filenames should
//               contain a hash mark ('#'), which will be filled in
//               with the mipmap level number; and the texture will be
//               defined with a series of images, two for each mipmap
//               level.
//////////////////////////////////////////////////////////////////// 6 8 filename 1 3390  14 alpha_filename 1 3390  25 primary_file_num_channels 1 3141  18 alpha_file_channel 1 3141  12 read_mipmaps 1 3138  7 options 1 3393  
1513 0 0 7 1544 3387 2472 0 826 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_texture
//       Access: Published, Static
//  Description: Loads the given filename up into a texture, if it has
//               not already been loaded, and returns the new texture.
//               If a texture with the same filename was previously
//               loaded, returns that one instead.  If the texture
//               file cannot be found, returns NULL.
//
//               If read_mipmaps is true, the filename should contain
//               a hash mark ('#'), which will be filled in with the
//               mipmap level number; and the texture will be defined
//               with a series of images, one for each mipmap level.
//////////////////////////////////////////////////////////////////// 4 8 filename 1 3390  25 primary_file_num_channels 1 3141  12 read_mipmaps 1 3138  7 options 1 3393  
1514 0 0 7 1545 3387 2472 0 833 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_3d_texture
//       Access: Published, Static
//  Description: Loads a 3-D texture that is specified with a series
//               of n pages, all numbered in sequence, and beginning
//               with index 0.  The filename should include a sequence
//               of one or more hash characters ("#") which will be
//               filled in with the index number of each level.
//
//               If read_mipmaps is true, the filename should contain
//               an additional hash mark.  The first hash mark will be
//               filled in with the mipmap level number, and the
//               second with the index number of each 3-d level.
//////////////////////////////////////////////////////////////////// 3 16 filename_pattern 1 3390  12 read_mipmaps 1 3138  7 options 1 3393  
1515 0 0 7 1546 3387 2472 0 845 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_2d_texture_array
//       Access: Published, Static
//  Description: Loads a 2-D texture array that is specified with a series
//               of n pages, all numbered in sequence, and beginning
//               with index 0.  The filename should include a sequence
//               of one or more hash characters ("#") which will be
//               filled in with the index number of each level.
//
//               If read_mipmaps is true, the filename should contain
//               an additional hash mark.  The first hash mark will be
//               filled in with the mipmap level number, and the
//               second with the index number of each 2-d level.
//////////////////////////////////////////////////////////////////// 3 16 filename_pattern 1 3390  12 read_mipmaps 1 3138  7 options 1 3393  
1516 0 0 7 1547 3387 2472 0 798 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::load_cube_map
//       Access: Published, Static
//  Description: Loads a cube map texture that is specified with a
//               series of 6 pages, numbered 0 through 5.  The
//               filename should include a sequence of one or more
//               hash characters ("#") which will be filled in with
//               the index number of each pagee.
//
//               If read_mipmaps is true, the filename should contain
//               an additional hash mark.  The first hash mark will be
//               filled in with the mipmap level number, and the
//               second with the face number, 0 through 5.
//////////////////////////////////////////////////////////////////// 3 16 filename_pattern 1 3390  12 read_mipmaps 1 3138  7 options 1 3393  
1517 0 0 7 1548 3387 2472 0 619 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::get_normalization_cube_map
//       Access: Published, Static
//  Description: Returns a standard Texture object that has been
//               created with
//               Texture::generate_normalization_cube_map().  This
//               Texture may be shared by any application code
//               requiring a normalization cube map.  It will be at
//               least as large as the specified size, though it may
//               be larger.
//////////////////////////////////////////////////////////////////// 1 4 size 1 3141  
1518 0 0 7 1549 3387 2472 0 598 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::get_alpha_scale_map
//       Access: Published, Static
//  Description: Returns a standard Texture object that has been
//               created with Texture::generate_alpha_scale_map().
//
//               This Texture object is used internally by Panda to
//               apply an alpha scale to an object (instead of munging
//               its vertices) when gsg->get_alpha_scale_via_texture()
//               returns true.
//////////////////////////////////////////////////////////////////// 0 
1519 0 0 4 1550 3137 0 0 509 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::add_texture
//       Access: Published, Static
//  Description: Adds the indicated already-loaded texture to the
//               pool.  The texture must have a filename set for its
//               name.  The texture will always replace any
//               previously-loaded texture in the pool that had the
//               same filename.
//////////////////////////////////////////////////////////////////// 1 7 texture 1 3387  
1520 0 0 4 1551 3137 0 0 733 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::release_texture
//       Access: Published, Static
//  Description: Removes the indicated texture from the pool,
//               indicating it will never be loaded again; the texture
//               may then be freed.  If this function is never called,
//               a reference count will be maintained on every texture
//               every loaded, and textures will never be freed.
//
//               The texture's name should not have been changed
//               during its lifetime, or this function may fail to
//               locate it in the pool.
//////////////////////////////////////////////////////////////////// 1 7 texture 1 3387  
1521 0 0 4 1552 3137 0 0 333 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::release_all_textures
//       Access: Published, Static
//  Description: Releases all textures in the pool and restores the
//               pool to the empty state.
//////////////////////////////////////////////////////////////////// 0 
1522 0 0 4 1553 3137 0 0 378 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::rehash
//       Access: Published, Static
//  Description: Should be called when the model-path changes, to blow
//               away the cache of texture pathnames found along the
//               model-path.
//////////////////////////////////////////////////////////////////// 0 
1523 0 0 6 1554 3141 0 0 480 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::garbage_collect
//       Access: Published, Static
//  Description: Releases only those textures in the pool that have a
//               reference count of exactly 1; i.e. only those
//               textures that are not being used outside of the pool.
//               Returns the number of textures released.
//////////////////////////////////////////////////////////////////// 0 
1524 0 0 4 1555 3137 0 0 280 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::list_contents
//       Access: Published, Static
//  Description: Lists the contents of the texture pool to cout
//////////////////////////////////////////////////////////////////// 0 
1525 0 0 4 1555 3137 0 0 321 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::list_contents
//       Access: Published, Static
//  Description: Lists the contents of the texture pool to the
//               indicated output stream.
//////////////////////////////////////////////////////////////////// 1 3 out 1 3139  
1526 0 0 7 1556 3387 2472 0 449 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::find_texture
//       Access: Published, Static
//  Description: Returns the first texture found in the pool that
//               matches the indicated name (which may contain
//               wildcards).  Returns the texture if it is found, or
//               NULL if it is not.
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
1527 0 0 7 1557 3489 2965 0 382 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::find_all_textures
//       Access: Published, Static
//  Description: Returns the set of all textures found in the pool
//               that match the indicated name (which may contain
//               wildcards).
//////////////////////////////////////////////////////////////////// 1 4 name 1 3131  
1528 0 0 4 1558 3137 0 0 355 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::set_fake_texture_image
//       Access: Published, Static
//  Description: Sets a bogus filename that will be loaded in lieu of
//               any textures requested from this point on.
//////////////////////////////////////////////////////////////////// 1 8 filename 1 3390  
1529 0 0 4 1559 3137 0 0 330 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::clear_fake_texture_image
//       Access: Published, Static
//  Description: Restores normal behavior of loading the textures
//               actually requested.
//////////////////////////////////////////////////////////////////// 0 
1530 0 0 6 1560 3138 0 0 353 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::has_fake_texture_image
//       Access: Published, Static
//  Description: Returns true if fake_texture_image mode has been
//               enabled, false if we are in the normal mode.
//////////////////////////////////////////////////////////////////// 0 
1531 0 0 6 1561 3390 0 0 349 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::get_fake_texture_image
//       Access: Published, Static
//  Description: Returns the filename that was specified with a
//               previous call to set_fake_texture_image().
//////////////////////////////////////////////////////////////////// 0 
1532 0 0 7 1562 3387 2472 0 452 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::make_texture
//       Access: Published, Static
//  Description: Creates a new Texture object of the appropriate type
//               for the indicated filename extension, according to
//               the types that have been registered via
//               register_texture_type().
//////////////////////////////////////////////////////////////////// 1 9 extension 1 3131  
1533 0 0 4 1563 3137 0 0 345 ////////////////////////////////////////////////////////////////////
//     Function: TexturePool::write
//       Access: Published, Static
//  Description: Lists the contents of the texture pool to the
//               indicated output stream.
//               For debugging.
//////////////////////////////////////////////////////////////////// 1 3 out 1 3139  
1534 0 0 6 1566 3141 0 0 449 ////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::get_x_size
//       Access: Published
//  Description: Returns the width of the texture image that is
//               contributing to the TexturePeeker's information.
//               This may be either the Texture's full width, or its
//               simple ram image's width.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3492  
1535 0 0 6 1567 3141 0 0 452 ////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::get_y_size
//       Access: Published
//  Description: Returns the height of the texture image that is
//               contributing to the TexturePeeker's information.
//               This may be either the Texture's full height, or its
//               simple ram image's height.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3492  
1536 0 0 6 1568 3141 0 0 337 ////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::get_z_size
//       Access: Published
//  Description: Returns the depth of the texture image that is
//               contributing to the TexturePeeker's information.
//////////////////////////////////////////////////////////////////// 1 4 this 3 3492  
1537 0 0 4 1569 3137 0 0 609 ////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::lookup
//       Access: Published
//  Description: Fills "color" with the RGBA color of the texel at
//               point (u, v).
//
//               The texel color is determined via nearest-point
//               sampling (no filtering of adjacent pixels),
//               regardless of the filter type associated with the
//               texture.  u, v, and w will wrap around regardless of
//               the texture's wrap mode.
//////////////////////////////////////////////////////////////////// 4 4 this 3 3492  5 color 1 3289  1 u 1 3142  1 v 1 3142  
1538 0 0 4 1569 3137 0 0 612 ////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::lookup
//       Access: Published
//  Description: Fills "color" with the RGBA color of the texel at
//               point (u, v, w).
//
//               The texel color is determined via nearest-point
//               sampling (no filtering of adjacent pixels),
//               regardless of the filter type associated with the
//               texture.  u, v, and w will wrap around regardless of
//               the texture's wrap mode.
//////////////////////////////////////////////////////////////////// 5 4 this 3 3492  5 color 1 3289  1 u 1 3142  1 v 1 3142  1 w 1 3142  
1539 0 0 4 1570 3137 0 0 563 ////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::filter_rect
//       Access: Published
//  Description: Fills "color" with the average RGBA color of the
//               texels within the rectangle defined by the specified
//               coordinate range.
//
//               The texel color is linearly filtered over the entire
//               region.  u, v, and w will wrap around regardless of
//               the texture's wrap mode.
//////////////////////////////////////////////////////////////////// 6 4 this 3 3492  5 color 1 3289  5 min_u 1 3142  5 min_v 1 3142  5 max_u 1 3142  5 max_v 1 3142  
1540 0 0 4 1570 3137 0 0 563 ////////////////////////////////////////////////////////////////////
//     Function: TexturePeeker::filter_rect
//       Access: Published
//  Description: Fills "color" with the average RGBA color of the
//               texels within the rectangle defined by the specified
//               coordinate range.
//
//               The texel color is linearly filtered over the entire
//               region.  u, v, and w will wrap around regardless of
//               the texture's wrap mode.
//////////////////////////////////////////////////////////////////// 8 4 this 3 3492  5 color 1 3289  5 min_u 1 3142  5 min_v 1 3142  5 min_w 1 3142  5 max_u 1 3142  5 max_v 1 3142  5 max_w 1 3142  
1541 0 0 7 1574 3286 0 0 1060 ////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::get_stage
//       Access: Public, Static
//  Description: Returns a TextureStage pointer that represents the
//               same TextureStage described by temp, except that it is a
//               shared pointer.
//
//               Each call to get_stage() passing an equivalent
//               TextureStage pointer will return the same shared pointer.
//
//               If you modify the shared pointer, it will
//               automatically disassociate it from the pool.
//
//               Also, the return value may be a different pointer
//               than that passed in, or it may be the same pointer.
//               In either case, the passed in pointer has now been
//               sacrificed to the greater good and should not be used
//               again (like any other PointerTo, it will be freed
//               when the last reference count is removed).
//////////////////////////////////////////////////////////////////// 1 4 temp 1 3286  
1542 0 0 4 1575 3137 0 0 288 ////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::release_stage
//       Access: Published, Static
//  Description: Removes the indicated TextureStage from the pool.
//////////////////////////////////////////////////////////////////// 1 4 temp 1 3286  
1543 0 0 4 1576 3137 0 0 341 ////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::release_all_stages
//       Access: Published, Static
//  Description: Releases all TextureStages in the pool and restores the
//               pool to the empty state.
//////////////////////////////////////////////////////////////////// 0 
1544 0 0 4 1577 3137 0 0 847 ////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::set_mode
//       Access: Published, Static
//  Description: Specifies the fundamental operating mode of the
//               TextureStagePool.
//
//               If this is M_none, each call to get_stage() returns
//               the same TextureStage pointer that was passed in (the
//               pool is effectively disabled).  If this is M_name,
//               each call to get_stage() returns the last
//               TextureStage passed in with the same name, whether it
//               has different properties or not.  If this is
//               M_unique, then each call to get_stage() returns only
//               TextureStages with identical properties.
//////////////////////////////////////////////////////////////////// 1 4 mode 1 3130  
1545 0 0 6 1578 3130 0 0 331 ////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::get_mode
//       Access: Published, Static
//  Description: Returns the fundamental operating mode of the
//               TextureStagePool.  See set_mode().
//////////////////////////////////////////////////////////////////// 0 
1546 0 0 6 1579 3141 0 0 497 ////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::garbage_collect
//       Access: Public, Static
//  Description: Releases only those TextureStages in the pool that have a
//               reference count of exactly 1; i.e. only those
//               TextureStages that are not being used outside of the pool.
//               Returns the number of TextureStages released.
//////////////////////////////////////////////////////////////////// 0 
1547 0 0 4 1580 3137 0 0 328 ////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::list_contents
//       Access: Public, Static
//  Description: Lists the contents of the TextureStage pool to the
//               indicated output stream.
//////////////////////////////////////////////////////////////////// 1 3 out 1 3139  
1548 0 0 4 1581 3137 0 0 323 ////////////////////////////////////////////////////////////////////
//     Function: TextureStagePool::write
//       Access: Published, Static
//  Description: Lists the contents of the TextureStage pool to the
//               indicated output stream.
//////////////////////////////////////////////////////////////////// 1 3 out 1 3139  
471
3024 11 AdaptiveLru 0 26625 11 AdaptiveLru 11 AdaptiveLru 0 0 0 1 1549 1550 0 14 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 0 0 1 0 3025 0 0 0 0 572
////////////////////////////////////////////////////////////////////
//       Class : AdaptiveLru
// Description : A basic LRU-type algorithm, except that it is
//               adaptive and attempts to avoid evicting pages that
//               have been used more frequently (even if less
//               recently) than other pages.
//
//               The interface is designed to be identical to that for
//               SimpleLru, so that it may be used as a drop-in
//               replacement.
////////////////////////////////////////////////////////////////////

3025 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 324
////////////////////////////////////////////////////////////////////
//       Class : Namable
// Description : A base class for all things which can have a name.
//               The name is either empty or nonempty, but it is never
//               NULL.
////////////////////////////////////////////////////////////////////

3026 15 AdaptiveLruPage 0 26625 15 AdaptiveLruPage 15 AdaptiveLruPage 0 0 0 1 1569 1571 0 12 1570 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 0 0 2 3 3027 1565 1566 3 3028 1567 1568 0 0 918
////////////////////////////////////////////////////////////////////
//       Class : AdaptiveLruPage
// Description : One atomic piece that may be managed by a AdaptiveLru
//               chain.  To use this class, inherit from it and
//               override evict_lru().
//
//               This class multiply inherits from two classes which
//               in turn both inherit from LinkedListNode.  This is
//               just a sneaky C++ trick to allow this class to
//               inherit from LinkedListNode twice, so that pages can
//               be stored on two different linked lists
//               simultaneously.  The AdaptiveLru class depends on
//               this; it maintains its pages in two different lists,
//               one grouped by priority, and one in order by next
//               partial update needs.
////////////////////////////////////////////////////////////////////

3027 26 AdaptiveLruPageDynamicList 0 1050625 26 AdaptiveLruPageDynamicList 26 AdaptiveLruPageDynamicList 0 0 0 0 0 0 0 0 0 0 0 0 114
// See the comment in the head of AdaptiveLruPage, below, for an
// explanation of these two silly little classes.

3028 25 AdaptiveLruPageStaticList 0 1050625 25 AdaptiveLruPageStaticList 25 AdaptiveLruPageStaticList 0 0 0 0 0 0 0 0 0 0 0 0 0

3029 9 GeomEnums 0 141313 9 GeomEnums 9 GeomEnums 0 0 0 0 1583 0 0 0 0 0 0 7 3030 3031 3032 3033 3034 3035 3036 400
////////////////////////////////////////////////////////////////////
//       Class : GeomEnums
// Description : This class exists just to provide scoping for the
//               various enumerated types used by Geom,
//               GeomVertexData, GeomVertexArrayData, GeomPrimitive,
//               and other related classes.
////////////////////////////////////////////////////////////////////

3030 9 UsageHint 0 794624 20 GeomEnums::UsageHint 20 GeomEnums::UsageHint 3029 0 0 0 0 0 0 0 0 0 5 9 UH_client 20 GeomEnums::UH_client 80
// UH_client: don't attempt to upload the data; always keep it on
// the client.
0 9 UH_stream 20 GeomEnums::UH_stream 154
// UH_stream: the data will be created once, used to render a few
// times, and then discarded.  This should be used for short-lived
// temporary objects.
1 10 UH_dynamic 21 GeomEnums::UH_dynamic 169
// UH_dynamic: the data will be repeatedly modified and
// re-rendered.  This is for data that will be modified at
// runtime, such as animated or soft-skinned vertices.
2 9 UH_static 20 GeomEnums::UH_static 283
// UH_static: the data will be created once, and used to render
// many times, without modification.  This is the most common
// case, since typically vertex data is not directly animated
// (this is not related to scene graph animation, e.g. from
// adjusting transforms on a node).
3 14 UH_unspecified 25 GeomEnums::UH_unspecified 268
// UH_unspecified: the usage is unspecified.  This is intended as
// a "don't care" option for abstract objects; it should not be
// applied to any actual geometry to be rendered.  You take your
// chances if a geom actually gets into the scene graph with this
// set.
4 0 0

3031 13 GeomRendering 0 794624 24 GeomEnums::GeomRendering 24 GeomEnums::GeomRendering 3029 0 0 0 0 0 0 0 0 0 21 16 GR_indexed_point 27 GeomEnums::GR_indexed_point 31
// If there are indexed points.
1 16 GR_indexed_other 27 GeomEnums::GR_indexed_other 50
// If there is indexed geometry of any other type.
65536 15 GR_indexed_bits 26 GeomEnums::GR_indexed_bits 46
// The union of all of the indexed attributes.
65537 8 GR_point 19 GeomEnums::GR_point 34
// If there are any points at all.
2 21 GR_point_uniform_size 32 GeomEnums::GR_point_uniform_size 59
// If the points are all the same size, other than 1 pixel.
4 17 GR_per_point_size 28 GeomEnums::GR_per_point_size 52
// If the points have a per-vertex size designation.
8 20 GR_point_perspective 31 GeomEnums::GR_point_perspective 81
// If the points' size is specified in camera units rather than
// screen pixels.
16 21 GR_point_aspect_ratio 32 GeomEnums::GR_point_aspect_ratio 48
// If the points have a non-square aspect ratio.
32 14 GR_point_scale 25 GeomEnums::GR_point_scale 69
// If the points are under a scale transform, uniform or non-uniform.
64 15 GR_point_rotate 26 GeomEnums::GR_point_rotate 54
// If the points are rotated off the orthonormal axis.
128 15 GR_point_sprite 26 GeomEnums::GR_point_sprite 110
// If the points require texture coordinates interpolated across
// their face, to render textures as sprites.
256 26 GR_point_sprite_tex_matrix 37 GeomEnums::GR_point_sprite_tex_matrix 89
// If there is a texture matrix applied to the sprite's generated
// texture coordinates.
512 13 GR_point_bits 24 GeomEnums::GR_point_bits 72
// The union of all the above point attributes, except GR_indexed_point.
1022 17 GR_triangle_strip 28 GeomEnums::GR_triangle_strip 45
// If there are any of these composite types.
1024 15 GR_triangle_fan 26 GeomEnums::GR_triangle_fan 0
2048 13 GR_line_strip 24 GeomEnums::GR_line_strip 0
4096 17 GR_composite_bits 28 GeomEnums::GR_composite_bits 49
// The union of all of the above composite types.
7168 18 GR_strip_cut_index 29 GeomEnums::GR_strip_cut_index 66
// If strip-cut indices are used to restart a composite primitive.
131072 20 GR_flat_first_vertex 31 GeomEnums::GR_flat_first_vertex 68
// If the shade model requires a particular vertex for flat shading.
8192 19 GR_flat_last_vertex 30 GeomEnums::GR_flat_last_vertex 0
16384 19 GR_shade_model_bits 30 GeomEnums::GR_shade_model_bits 44
// The union of the above shade model types.
24576 0 265
// This type specifies a number of bits that are used to represent
// the rendering requirements of a particular Geom, as well as the
// rendering capabilities of the GSG.  The difference between the
// two indicates whether the Geom needs to be munged for the GSG.

3032 10 ShadeModel 0 794624 21 GeomEnums::ShadeModel 21 GeomEnums::ShadeModel 3029 0 0 0 0 0 0 0 0 0 4 10 SM_uniform 21 GeomEnums::SM_uniform 172
// SM_uniform: all vertices across all faces have the same colors
// and normals.  It doesn't really matter which ShadeModelAttrib
// mode is used to render this primitive.
0 9 SM_smooth 20 GeomEnums::SM_smooth 189
// SM_smooth: vertices within a single face have different
// colors/normals that should be smoothed across the face.  This
// primitive should be rendered with SmoothModelAttrib::M_smooth.
1 20 SM_flat_first_vertex 31 GeomEnums::SM_flat_first_vertex 341
// SM_flat_(first,last)_vertex: each face within the primitive
// might have a different color/normal than the other faces, but
// across a particular face there is only one color/normal.  Each
// face's color/normal is taken from the (first, last) vertex of
// the face.  This primitive should be rendered with
// SmoothModelAttrib::M_flat.
2 19 SM_flat_last_vertex 30 GeomEnums::SM_flat_last_vertex 0
3 0 235
// The shade model specifies whether the per-vertex colors and
// normals indexed by a given primitive truly represent per-vertex
// colors and normals, or whether they actually represent
// per-triangle flat-shaded colors and normals.

3033 13 PrimitiveType 0 794624 24 GeomEnums::PrimitiveType 24 GeomEnums::PrimitiveType 3029 0 0 0 0 0 0 0 0 0 5 7 PT_none 18 GeomEnums::PT_none 0
0 11 PT_polygons 22 GeomEnums::PT_polygons 0
1 8 PT_lines 19 GeomEnums::PT_lines 0
2 9 PT_points 20 GeomEnums::PT_points 0
3 10 PT_patches 21 GeomEnums::PT_patches 0
4 0 165
// The primitive type represents the core primitive type of a
// particular GeomPrimitive.  It's used for determining what kind of
// antialiasing should be enabled.

3034 11 NumericType 0 794624 22 GeomEnums::NumericType 22 GeomEnums::NumericType 3029 0 0 0 0 0 0 0 0 0 12 8 NT_uint8 19 GeomEnums::NT_uint8 20
// An integer 0..255
0 9 NT_uint16 20 GeomEnums::NT_uint16 22
// An integer 0..65535
1 9 NT_uint32 20 GeomEnums::NT_uint32 27
// An integer 0..4294967295
2 14 NT_packed_dcba 25 GeomEnums::NT_packed_dcba 53
// DirectX style, four byte values packed in a uint32
3 14 NT_packed_dabc 25 GeomEnums::NT_packed_dabc 36
// DirectX packed color order (ARGB)
4 10 NT_float32 21 GeomEnums::NT_float32 27
// A single-precision float
5 10 NT_float64 21 GeomEnums::NT_float64 27
// A double-precision float
6 11 NT_stdfloat 22 GeomEnums::NT_stdfloat 69
// Either single- or double-precision, according to vertices-float64.
7 7 NT_int8 18 GeomEnums::NT_int8 23
// An integer -128..127
8 8 NT_int16 19 GeomEnums::NT_int16 27
// An integer -32768..32767
9 8 NT_int32 19 GeomEnums::NT_int32 37
// An integer -2147483648..2147483647
10 16 NT_packed_ufloat 27 GeomEnums::NT_packed_ufloat 54
// Three 10/11-bit float components packed in a uint32
11 0 120
// The numeric type determines what physical representation is used
// to encode a numeric value within the vertex data.

3035 8 Contents 0 794624 19 GeomEnums::Contents 19 GeomEnums::Contents 3029 0 0 0 0 0 0 0 0 0 10 7 C_other 18 GeomEnums::C_other 36
// Arbitrary meaning, leave it alone
0 7 C_point 18 GeomEnums::C_point 32
// A point in 3-space or 4-space
1 12 C_clip_point 23 GeomEnums::C_clip_point 48
// A point pre-transformed into clip coordinates
2 8 C_vector 19 GeomEnums::C_vector 59
// A surface tangent or binormal (see C_normal for normals)
3 10 C_texcoord 21 GeomEnums::C_texcoord 23
// A texture coordinate
4 7 C_color 18 GeomEnums::C_color 48
// 3- or 4-component color, ordered R, G, B, [A]
5 7 C_index 18 GeomEnums::C_index 39
// An index value into some other table
6 13 C_morph_delta 24 GeomEnums::C_morph_delta 55
// A delta from some base value, defining a blend shape
7 8 C_matrix 19 GeomEnums::C_matrix 118
// A transformation matrix.  This is typically three or four
// columns, but we pretend it's only one for convenience.
8 8 C_normal 19 GeomEnums::C_normal 124
// A special version of C_vector that should be used for normal
// vectors, which are scaled differently from other vectors.
9 0 194
// The contents determine the semantic meaning of a numeric value
// within the vertex data.  This is also used to determine what
// automatic transforms might be applied to the various columns.

3036 13 AnimationType 0 794624 24 GeomEnums::AnimationType 24 GeomEnums::AnimationType 3029 0 0 0 0 0 0 0 0 0 3 7 AT_none 18 GeomEnums::AT_none 23
// No vertex animation.
0 8 AT_panda 19 GeomEnums::AT_panda 51
// Vertex animation calculated on the CPU by Panda.
1 11 AT_hardware 22 GeomEnums::AT_hardware 55
// Hardware-accelerated animation on the graphics card.
2 0 86
// The type of animation data that is represented by a particular
// GeomVertexFormat.

3037 23 GeomVertexAnimationSpec 0 141313 23 GeomVertexAnimationSpec 23 GeomVertexAnimationSpec 0 0 0 1 1584 1593 0 8 1585 1586 1587 1588 1589 1590 1591 1592 0 0 1 0 3029 0 0 0 0 881
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexAnimationSpec
// Description : This object describes how the vertex animation, if
//               any, represented in a GeomVertexData is encoded.
//
//               Vertex animation includes soft-skinned skeleton
//               animation and morphs (blend shapes), and might be
//               performed on the CPU by Panda, or passed down to the
//               graphics backed to be performed on the hardware
//               (depending on the hardware's advertised
//               capabilities).
//
//               Changing this setting doesn't by itself change the
//               way the animation is actually performed; this just
//               specifies how the vertices are set up to be animated.
////////////////////////////////////////////////////////////////////

3038 12 InternalName 0 75777 12 InternalName 12 InternalName 0 0 0 0 0 0 35 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 0 0 1 0 3039 0 0 0 0 837
////////////////////////////////////////////////////////////////////
//       Class : InternalName
// Description : Encodes a string name in a hash table, mapping it to
//               a pointer.  This is used to tokenify names so they
//               may be used efficiently in low-level Panda
//               structures, for instance to differentiate the
//               multiple sets of texture coordinates that might be
//               stored on a Geom.
//
//               InternalNames are hierarchical, with the '.' used by
//               convention as a separator character.  You can
//               construct a single InternalName as a composition of
//               one or more other names, or by giving it a source
//               string directly.
////////////////////////////////////////////////////////////////////

3039 27 TypedWritableReferenceCount 0 2049 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 722
////////////////////////////////////////////////////////////////////
//       Class : TypedWritableReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedWritable and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedWritables and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

3040 16 GeomVertexColumn 0 26625 16 GeomVertexColumn 16 GeomVertexColumn 0 0 0 1 1629 1631 0 22 1630 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 0 0 1 0 3029 0 0 0 0 441
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexColumn
// Description : This defines how a single column is interleaved
//               within a vertex array stored within a Geom.  The
//               GeomVertexArrayFormat class maintains a list of these
//               to completely define a particular array structure.
////////////////////////////////////////////////////////////////////

3041 21 GeomVertexArrayFormat 0 26625 21 GeomVertexArrayFormat 21 GeomVertexArrayFormat 0 0 0 1 1657 1659 0 26 1658 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1 3495 0 2 3 3039 1653 1654 3 3029 1655 1656 0 0 1094
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexArrayFormat
// Description : This describes the structure of a single array within
//               a Geom data.  See GeomVertexFormat for the parent
//               class which collects together all of the individual
//               GeomVertexArrayFormat objects.
//
//               A particular array may include any number of standard
//               or user-defined columns.  All columns consist of a
//               sequence of one or more numeric values, packed in any
//               of a variety of formats; the semantic meaning of each
//               column is defined in general with its contents
//               member, and in particular by its name.  The standard
//               array types used most often are named "vertex",
//               "normal", "texcoord", and "color"; other kinds of
//               data may be piggybacked into the data record simply
//               by choosing a unique name.
////////////////////////////////////////////////////////////////////

3042 16 GeomVertexFormat 0 26625 16 GeomVertexFormat 16 GeomVertexFormat 0 0 0 1 1689 1691 0 51 1690 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 8 3496 3497 3498 3499 3500 3501 3502 3503 0 2 3 3039 1685 1686 3 3029 1687 1688 0 0 1366
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexFormat
// Description : This class defines the physical layout of the vertex
//               data stored within a Geom.  The layout consists of a
//               list of named columns, each of which has a numeric
//               type and a size.
//
//               The columns are typically interleaved within a single
//               array, but they may also be distributed among
//               multiple different arrays; at the extreme, each
//               column may be alone within its own array (which
//               amounts to a parallel-array definition).
//
//               Thus, a GeomVertexFormat is really a list of
//               GeomVertexArrayFormats, each of which contains a list
//               of columns.  However, a particular column name should
//               not appear more than once in the format, even between
//               different arrays.
//
//               There are a handful of standard pre-defined
//               GeomVertexFormat objects, or you may define your own
//               as needed.  You may record any combination of
//               standard and/or user-defined columns in your custom
//               GeomVertexFormat constructions.
////////////////////////////////////////////////////////////////////

3043 9 SimpleLru 0 26625 9 SimpleLru 9 SimpleLru 0 0 0 1 1746 1747 0 10 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 0 0 2 3 3044 1742 1743 3 3025 1744 1745 0 0 270
////////////////////////////////////////////////////////////////////
//       Class : SimpleLru
// Description : An implementation of a very simple LRU algorithm.
//               Also see AdaptiveLru.
////////////////////////////////////////////////////////////////////

3044 14 LinkedListNode 0 2049 14 LinkedListNode 14 LinkedListNode 0 0 0 0 0 0 0 0 0 0 0 0 762
////////////////////////////////////////////////////////////////////
//       Class : LinkedListNode
// Description : This just stores the pointers to implement a
//               doubly-linked list of some kind of object.  There are
//               occasions when a hand-rolled linked list is more
//               appropriate than an STL container.
//
//               Typically, each node of the linked list, as well as
//               the root of the list, will inherit from this class.
//
//               Note that this class is not inherently thread-safe;
//               derived classes are responsible for protecting any
//               calls into it within mutexes, if necessary.
////////////////////////////////////////////////////////////////////

3045 13 SimpleLruPage 0 26625 13 SimpleLruPage 13 SimpleLruPage 0 0 0 1 1760 1762 0 10 1761 1763 1764 1765 1766 1767 1768 1769 1770 1771 0 0 1 3 3044 1758 1759 0 0 340
////////////////////////////////////////////////////////////////////
//       Class : SimpleLruPage
// Description : One atomic piece that may be managed by a SimpleLru
//               chain.  To use this class, inherit from it and
//               override evict_lru().
////////////////////////////////////////////////////////////////////

3046 15 SimpleAllocator 0 26625 15 SimpleAllocator 15 SimpleAllocator 0 0 0 1 1774 1775 0 9 1776 1777 1778 1779 1780 1781 1782 1783 1784 0 0 1 3 3044 1772 1773 0 0 465
////////////////////////////////////////////////////////////////////
//       Class : SimpleAllocator
// Description : An implementation of a very simple block allocator.
//               This class can allocate ranges of nonnegative
//               integers within a specified upper limit; it uses a
//               simple first-fit algorithm to find the next available
//               space.
////////////////////////////////////////////////////////////////////

3047 20 SimpleAllocatorBlock 0 26625 20 SimpleAllocatorBlock 20 SimpleAllocatorBlock 0 0 0 0 1785 0 9 1786 1787 1788 1789 1790 1791 1792 1793 1794 0 0 1 0 3044 0 0 0 0 267
////////////////////////////////////////////////////////////////////
//       Class : SimpleAllocatorBlock
// Description : A single block as returned from
//               SimpleAllocator::alloc().
////////////////////////////////////////////////////////////////////

3048 18 VertexDataSaveFile 0 75777 18 VertexDataSaveFile 18 VertexDataSaveFile 0 0 0 0 1775 0 3 1795 1796 1797 0 0 1 0 3046 0 0 0 0 399
////////////////////////////////////////////////////////////////////
//       Class : VertexDataSaveFile
// Description : A temporary file to hold the vertex data that has
//               been evicted from memory and written to disk.  All
//               vertex data arrays are written into one large flat
//               file.
////////////////////////////////////////////////////////////////////

3049 14 VertexDataPage 0 43009 14 VertexDataPage 14 VertexDataPage 0 0 0 0 0 0 18 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 0 0 2 3 3046 1798 1799 3 3045 1800 1801 0 1 3050 410
////////////////////////////////////////////////////////////////////
//       Class : VertexDataPage
// Description : A block of bytes that holds one or more
//               VertexDataBlocks.  The entire page may be paged out,
//               in the form of in-memory compression or to an on-disk
//               cache file, if necessary.
////////////////////////////////////////////////////////////////////

3050 8 RamClass 0 794624 24 VertexDataPage::RamClass 24 VertexDataPage::RamClass 3049 0 0 0 0 0 0 0 0 0 4 11 RC_resident 27 VertexDataPage::RC_resident 0
0 13 RC_compressed 29 VertexDataPage::RC_compressed 0
1 7 RC_disk 23 VertexDataPage::RC_disk 0
2 14 RC_end_of_list 30 VertexDataPage::RC_end_of_list 26
// list marker; do not use
3 0 159
// These are used to indicate the current residency state of the
// page, which may or may not have been temporarily evicted to
// satisfy memory requirements.

3051 14 VertexDataBook 0 26625 14 VertexDataBook 14 VertexDataBook 0 0 0 1 1820 1821 0 5 1822 1823 1824 1825 1826 0 0 0 0 0 295
////////////////////////////////////////////////////////////////////
//       Class : VertexDataBook
// Description : A collection of VertexDataPages, which can be used to
//               allocate new VertexDataBlock objects.
////////////////////////////////////////////////////////////////////

3052 15 VertexDataBlock 0 141313 15 VertexDataBlock 15 VertexDataBlock 0 0 0 0 1833 0 2 1831 1832 0 0 2 3 3047 1827 1828 3 3053 1829 1830 0 0 304
////////////////////////////////////////////////////////////////////
//       Class : VertexDataBlock
// Description : A block of bytes that stores the actual raw vertex
//               data referenced by a GeomVertexArrayData object.
////////////////////////////////////////////////////////////////////

3053 14 ReferenceCount 0 2049 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 425
////////////////////////////////////////////////////////////////////
//       Class : ReferenceCount
// Description : A base class for all things that want to be
//               reference-counted.  ReferenceCount works in
//               conjunction with PointerTo to automatically delete
//               objects when the last pointer to them goes away.
////////////////////////////////////////////////////////////////////

3054 17 ShaderUtilization 0 532481 17 ShaderUtilization 17 ShaderUtilization 0 0 0 0 0 0 0 0 0 0 4 8 SUT_none 8 SUT_none 0
0 9 SUT_basic 9 SUT_basic 0
1 12 SUT_advanced 12 SUT_advanced 0
2 15 SUT_unspecified 15 SUT_unspecified 0
3 0 0

3055 19 GeomVertexArrayData 0 26625 19 GeomVertexArrayData 19 GeomVertexArrayData 0 0 0 1 1840 1842 0 33 1841 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 0 0 3 3 3056 1834 1835 3 3045 1836 1837 3 3029 1838 1839 0 0 1050
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexArrayData
// Description : This is the data for one array of a GeomVertexData
//               structure.  Many GeomVertexData structures will only
//               define one array, with all data elements interleaved
//               (DirectX 8.0 and before insisted on this format);
//               some will define multiple arrays.
//
//               DirectX calls this concept of one array a "stream".
//               It also closely correlates with the concept of a
//               vertex buffer.
//
//               This object is just a block of data.  In general, you
//               should not be directly messing with this object from
//               application code.  See GeomVertexData for the
//               organizing structure, and see
//               GeomVertexReader/Writer/Rewriter for high-level tools
//               to manipulate the actual vertex data.
////////////////////////////////////////////////////////////////////

3056 17 CopyOnWriteObject 0 2049 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 376
////////////////////////////////////////////////////////////////////
//       Class : CopyOnWriteObject
// Description : This base class provides basic reference counting,
//               but also can be used with a CopyOnWritePointer to
//               provide get_read_pointer() and get_write_pointer().
////////////////////////////////////////////////////////////////////

3057 25 GeomVertexArrayDataHandle 0 26625 25 GeomVertexArrayDataHandle 25 GeomVertexArrayDataHandle 0 0 0 0 1879 0 20 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 0 0 2 3 3053 1875 1876 3 3029 1877 1878 0 0 840
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexArrayDataHandle
// Description : This data object is returned by
//               GeomVertexArrayData::get_handle() or modify_handle().
//               As long as it exists, the data is locked; when the
//               last of these destructs, the data is unlocked.
//
//               Only one thread at a time may lock the data; other
//               threads attempting to lock the data will block.  A
//               given thread may simultaneously lock the data
//               multiple times.
//
//               This class serves in lieu of a pair of
//               GeomVertexArrayDataPipelineReader and
//               GeomVertexArrayDataPipelineWriter classes
////////////////////////////////////////////////////////////////////

3058 16 GeomCacheManager 0 43009 16 GeomCacheManager 16 GeomCacheManager 0 0 0 0 0 0 5 1900 1901 1902 1903 1904 0 0 0 0 0 998
////////////////////////////////////////////////////////////////////
//       Class : GeomCacheManager
// Description : This is used to keep track of, and limit the size of,
//               the cache of munged vertices, which would otherwise
//               be distributed through all of the GeomVertexData
//               objects in the system.
//
//               The actual data in the cache is not stored here, but
//               rather it is distributed among the various
//               GeomVertexData source objects.  This allows the cache
//               data to propagate through the multiprocess pipeline.
//
//               This structure actually caches any of a number of
//               different types of pointers, and mixes them all up in
//               the same LRU cache list.  Some of them (such as
//               GeomMunger) are reference-counted here in the cache;
//               most are not.
////////////////////////////////////////////////////////////////////

3059 15 VertexTransform 0 75777 15 VertexTransform 15 VertexTransform 0 0 0 0 0 0 9 1905 1906 1907 1908 1909 1910 1911 1912 1913 0 0 1 0 3039 0 0 0 0 558
////////////////////////////////////////////////////////////////////
//       Class : VertexTransform
// Description : This is an abstract base class that holds a pointer
//               to some transform, computed in some arbitrary way,
//               that is to be applied to vertices during rendering.
//               This is used to implement soft-skinned and animated
//               vertices.  Derived classes will define how the
//               transform is actually computed.
////////////////////////////////////////////////////////////////////

3060 14 TransformTable 0 75777 14 TransformTable 14 TransformTable 0 0 0 1 1914 0 0 11 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1 3504 0 1 0 3039 0 0 0 0 593
////////////////////////////////////////////////////////////////////
//       Class : TransformTable
// Description : Stores the total set of VertexTransforms that the
//               vertices in a particular GeomVertexData object might
//               depend on.
//
//               This structure is used for a GeomVertexData set up to
//               compute its dynamic vertices on the graphics card.
//               See TransformBlendTable for one set up to compute
//               its dynamic vertices on the CPU.
////////////////////////////////////////////////////////////////////

3061 14 TransformBlend 0 26625 14 TransformBlend 14 TransformBlend 0 0 0 1 1926 1928 0 23 1927 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1 3505 0 0 0 0 374
////////////////////////////////////////////////////////////////////
//       Class : TransformBlend
// Description : This defines a single entry in a
//               TransformBlendTable.  It represents a unique
//               combination of VertexTransform pointers and blend
//               amounts.
////////////////////////////////////////////////////////////////////

3062 19 TransformBlendTable 0 75777 19 TransformBlendTable 19 TransformBlendTable 0 0 0 1 1951 0 0 14 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1 3506 0 1 0 3056 0 0 0 0 867
////////////////////////////////////////////////////////////////////
//       Class : TransformBlendTable
// Description : This structure collects together the different
//               combinations of transforms and blend amounts used by
//               a GeomVertexData, to facilitate computing dynamic
//               vertices on the CPU at runtime.  Each vertex has a
//               pointer to exactly one of the entries in this table,
//               and each entry defines a number of transform/blend
//               combinations.
//
//               This structure is used for a GeomVertexData set up to
//               compute its dynamic vertices on the CPU.  See
//               TransformTable for one set up to compute its
//               dynamic vertices on the graphics card.
////////////////////////////////////////////////////////////////////

3063 12 VertexSlider 0 75777 12 VertexSlider 12 VertexSlider 0 0 0 0 0 0 6 1966 1967 1968 1969 1970 1971 0 0 1 0 3039 0 0 0 0 607
////////////////////////////////////////////////////////////////////
//       Class : VertexSlider
// Description : This is an abstract base class that retains some
//               slider value, which is a linear value that typically
//               ranges from 0.0 to 1.0, and is used to control the
//               animation of morphs (blend shapes).
//
//               It is similar to VertexTransform, which keeps a full
//               4x4 transform matrix, but the VertexSlider only keeps
//               a single float value.
////////////////////////////////////////////////////////////////////

3064 11 SliderTable 0 75777 11 SliderTable 11 SliderTable 0 0 0 1 1972 0 0 16 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1 3507 0 1 0 3039 0 0 0 0 696
////////////////////////////////////////////////////////////////////
//       Class : SliderTable
// Description : Stores the total set of VertexSliders that the
//               vertices in a particular GeomVertexData object might
//               depend on.
//
//               This is similar to a TransformTable, but it stores
//               VertexSliders instead of VertexTransforms, and it
//               stores them by name instead of by index number.
//               Also, it is only used when animating vertices on the
//               CPU, since GPU's don't support morphs at this point
//               in time.
////////////////////////////////////////////////////////////////////

3065 14 GeomVertexData 0 26625 14 GeomVertexData 14 GeomVertexData 0 0 0 1 1993 1995 0 51 1994 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 1 3508 0 2 3 3056 1989 1990 3 3029 1991 1992 0 0 1574
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexData
// Description : This defines the actual numeric vertex data stored in
//               a Geom, in the structure defined by a particular
//               GeomVertexFormat object.
//
//               The data consists of one or more arrays, each of
//               which in turn consists of a series of rows, one per
//               vertex.  All arrays should have the same number of
//               rows; each vertex is defined by the column data from
//               a particular row across all arrays.
//
//               Often, there will be only one array per Geom, and the
//               various columns defined in the GeomVertexFormat will
//               be interleaved within that array.  However, it is
//               also possible to have multiple different arrays, with
//               a certain subset of the total columns defined in each
//               array.
//
//               However the data is distributed, the effect is of a
//               single table of vertices, where each vertex is
//               represented by one row of the table.
//
//               In general, application code should not attempt to
//               directly manipulate the vertex data through this
//               structure; instead, use the GeomVertexReader,
//               GeomVertexWriter, and GeomVertexRewriter objects to
//               read and write vertex data at a high level.
////////////////////////////////////////////////////////////////////

3066 22 AnimateVerticesRequest 0 141313 22 AnimateVerticesRequest 22 AnimateVerticesRequest 0 0 0 1 2046 2049 0 2 2047 2048 0 0 1 0 3067 0 0 0 0 937
////////////////////////////////////////////////////////////////////
//       Class : AnimateVerticesRequest
// Description : This class object manages a single asynchronous
//               request to animate vertices on a GeomVertexData
//               object.  animate_vertices will be called with
//               force=true (i.e. blocking) in a sub-thread (if
//               threading is available).  No result is stored or
//               returned from this object.  It is expected that the
//               result will be cached and available for immediate
//               use later during rendering.  Thus it is important
//               that the main thread block while these requests
//               are being run (presumably on multiple CPUs/cores),
//               to ensure that the data has been computed by the
//               time it's needed.
////////////////////////////////////////////////////////////////////

3067 9 AsyncTask 0 2049 9 AsyncTask 9 AsyncTask 0 0 0 0 0 0 0 0 0 0 0 0 434
////////////////////////////////////////////////////////////////////
//       Class : AsyncTask
// Description : This class represents a concrete task performed by an
//               AsyncManager.  Normally, you would subclass from this
//               class, and override do_task(), to define the
//               functionality you wish to have the task perform.
////////////////////////////////////////////////////////////////////

3068 12 SavedContext 0 141313 12 SavedContext 12 SavedContext 0 0 0 0 2051 0 1 2050 0 0 1 0 3069 0 0 0 0 395
////////////////////////////////////////////////////////////////////
//       Class : SavedContext
// Description : This is the base class for all GSG-specific context
//               objects, such as TextureContext and GeomContext.  It
//               exists mainly to provide some structural
//               organization.
////////////////////////////////////////////////////////////////////

3069 11 TypedObject 0 2049 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 3561
////////////////////////////////////////////////////////////////////
//       Class : TypedObject
// Description : This is an abstract class that all classes which
//               use TypeHandle, and also provide virtual functions to
//               support polymorphism, should inherit from.  Each
//               derived class should define get_type(), which should
//               return the specific type of the derived class.
//               Inheriting from this automatically provides support
//               for is_of_type() and is_exact_type().
//
//               All classes that inherit directly or indirectly from
//               TypedObject should redefine get_type() and
//               force_init_type(), as shown below.  Some classes that
//               do not inherit from TypedObject may still declare
//               TypeHandles for themselves by defining methods called
//               get_class_type() and init_type().  Classes such as
//               these may serve as base classes, but the dynamic type
//               identification system will be limited.  Classes that
//               do not inherit from TypedObject need not define the
//               virtual functions get_type() and force_init_type()
//               (or any other virtual functions).
//
//               There is a specific layout for defining the
//               overrides from this class.  Keeping the definitions
//               formatted just like these examples will allow
//               someone in the future to use a sed (or similar)
//               script to make global changes, if necessary.  Avoid
//               rearranging the braces or the order of the functions
//               unless you're ready to change them in every file all
//               at once.
//
//               What follows are some examples that can be used in
//               new classes that you create.
//
//               @par In the class definition (.h file):
//               @code
//               public:
//                 static TypeHandle get_class_type() {
//                   return _type_handle;
//                 }
//                 static void init_type() {
//                   <<<BaseClassOne>>>::init_type();
//                   <<<BaseClassTwo>>>::init_type();
//                   <<<BaseClassN>>>::init_type();
//                   register_type(_type_handle, "<<<ThisClassStringName>>>",
//                                 <<<BaseClassOne>>>::get_class_type(),
//                                 <<<BaseClassTwo>>>::get_class_type(),
//                                 <<<BaseClassN>>>::get_class_type());
//                 }
//                 virtual TypeHandle get_type() const {
//                   return get_class_type();
//                 }
//                 virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
//
//               private:
//                 static TypeHandle _type_handle;
//               @endcode
//
//               @par In the class .cxx file:
//               @code
//               TypeHandle <<<ThisClassStringName>>>::_type_handle;
//               @endcode
//
//               @par In the class config_<<<PackageName>>>.cxx file:
//               @code
//               ConfigureFn(config_<<<PackageName>>>) {
//                 <<<ClassOne>>>::init_type();
//                 <<<ClassTwo>>>::init_type();
//                 <<<ClassN>>>::init_type();
//               }
//               @endcode
////////////////////////////////////////////////////////////////////

3070 13 BufferContext 0 26625 13 BufferContext 13 BufferContext 0 0 0 0 2054 0 5 2055 2056 2057 2058 2059 0 0 1 3 3068 2052 2053 0 0 752
////////////////////////////////////////////////////////////////////
//       Class : BufferContext
// Description : This is a base class for those kinds of SavedContexts
//               that occupy an easily-measured (and substantial)
//               number of bytes in the video card's frame buffer
//               memory or AGP memory.  At the present, this includes
//               most of the SavedContext types: VertexBufferContext
//               and IndexBufferContext, as well as TextureContext.
//
//               This class provides methods for tracking the video
//               memory utilization, as well as residency of each
//               object, via PStats.
////////////////////////////////////////////////////////////////////

3071 13 GeomPrimitive 0 26625 13 GeomPrimitive 13 GeomPrimitive 0 0 0 0 2065 0 72 2064 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 1 3509 0 2 3 3056 2060 2061 3 3029 2062 2063 0 0 1203
////////////////////////////////////////////////////////////////////
//       Class : GeomPrimitive
// Description : This is an abstract base class for a family of
//               classes that represent the fundamental geometry
//               primitives that may be stored in a Geom.
//
//               They all have in common the fact that they are
//               defined by tables of vertex data stored in a
//               GeomVertexData object.  Each GeomPrimitive object
//               contains an ordered list of integers, which index
//               into the vertex array defined by the GeomVertexData
//               and define the particular vertices of the
//               GeomVertexData that are used for this primitive.
//
//               The meaning of a given arrangement of vertices is
//               defined by each individual primitive type; for
//               instance, a GeomTriangle renders a triangle from each
//               three consecutive vertices, while a GeomTriangleStrip
//               renders a strip of (n - 2) connected triangles from
//               each sequence of n vertices.
////////////////////////////////////////////////////////////////////

3072 12 TextureStage 0 75777 12 TextureStage 12 TextureStage 0 0 0 1 2137 0 0 54 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 0 0 1 0 3039 0 0 0 4 3073 3074 3075 3076 600
////////////////////////////////////////////////////////////////////
//       Class : TextureStage
// Description : Defines the properties of a named stage of the
//               multitexture pipeline.  The TextureAttrib will
//               associated a number of these stages with Texture
//               objects, and the GSG will render geometry by sorting
//               all of the currently active TextureStages in order
//               and then issuing the appropriate rendering calls to
//               activate them.
////////////////////////////////////////////////////////////////////

3073 4 Mode 0 794624 18 TextureStage::Mode 18 TextureStage::Mode 3072 0 0 0 0 0 0 0 0 0 16 10 M_modulate 24 TextureStage::M_modulate 0
0 7 M_decal 21 TextureStage::M_decal 0
1 7 M_blend 21 TextureStage::M_blend 0
2 9 M_replace 23 TextureStage::M_replace 0
3 5 M_add 19 TextureStage::M_add 0
4 9 M_combine 23 TextureStage::M_combine 0
5 19 M_blend_color_scale 33 TextureStage::M_blend_color_scale 0
6 15 M_modulate_glow 29 TextureStage::M_modulate_glow 47
// When fixed-function, equivalent to modulate.
7 16 M_modulate_gloss 30 TextureStage::M_modulate_gloss 47
// When fixed-function, equivalent to modulate.
8 8 M_normal 22 TextureStage::M_normal 0
9 15 M_normal_height 29 TextureStage::M_normal_height 0
10 6 M_glow 20 TextureStage::M_glow 49
// Rarely used: modulate_glow  is more efficient.
11 7 M_gloss 21 TextureStage::M_gloss 49
// Rarely used: modulate_gloss is more efficient.
12 8 M_height 22 TextureStage::M_height 49
// Rarely used: normal_height  is more efficient.
13 10 M_selector 24 TextureStage::M_selector 0
14 14 M_normal_gloss 28 TextureStage::M_normal_gloss 0
15 0 0

3074 11 CombineMode 0 794624 25 TextureStage::CombineMode 25 TextureStage::CombineMode 3072 0 0 0 0 0 0 0 0 0 9 12 CM_undefined 26 TextureStage::CM_undefined 0
0 10 CM_replace 24 TextureStage::CM_replace 0
1 11 CM_modulate 25 TextureStage::CM_modulate 0
2 6 CM_add 20 TextureStage::CM_add 0
3 13 CM_add_signed 27 TextureStage::CM_add_signed 0
4 14 CM_interpolate 28 TextureStage::CM_interpolate 0
5 11 CM_subtract 25 TextureStage::CM_subtract 0
6 11 CM_dot3_rgb 25 TextureStage::CM_dot3_rgb 70
// The following are valid only for combine_rgb, not
// combine_alpha.
7 12 CM_dot3_rgba 26 TextureStage::CM_dot3_rgba 0
8 0 0

3075 13 CombineSource 0 794624 27 TextureStage::CombineSource 27 TextureStage::CombineSource 3072 0 0 0 0 0 0 0 0 0 7 12 CS_undefined 26 TextureStage::CS_undefined 0
0 10 CS_texture 24 TextureStage::CS_texture 0
1 11 CS_constant 25 TextureStage::CS_constant 0
2 16 CS_primary_color 30 TextureStage::CS_primary_color 0
3 11 CS_previous 25 TextureStage::CS_previous 0
4 23 CS_constant_color_scale 37 TextureStage::CS_constant_color_scale 0
5 20 CS_last_saved_result 34 TextureStage::CS_last_saved_result 0
6 0 0

3076 14 CombineOperand 0 794624 28 TextureStage::CombineOperand 28 TextureStage::CombineOperand 3072 0 0 0 0 0 0 0 0 0 5 12 CO_undefined 26 TextureStage::CO_undefined 0
0 12 CO_src_color 26 TextureStage::CO_src_color 0
1 22 CO_one_minus_src_color 36 TextureStage::CO_one_minus_src_color 0
2 12 CO_src_alpha 26 TextureStage::CO_src_alpha 0
3 22 CO_one_minus_src_alpha 36 TextureStage::CO_one_minus_src_alpha 0
4 0 0

3077 4 Geom 0 26625 4 Geom 4 Geom 0 0 0 1 2196 2198 0 62 2197 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 1 3510 0 2 3 3056 2192 2193 3 3029 2194 2195 0 0 687
////////////////////////////////////////////////////////////////////
//       Class : Geom
// Description : A container for geometry primitives.  This class
//               associates one or more GeomPrimitive objects with a
//               table of vertices defined by a GeomVertexData object.
//               All of the primitives stored in a particular Geom are
//               drawn from the same set of vertices (each primitive
//               uses a subset of all of the vertices in the table),
//               and all of them must be rendered at the same time, in
//               the same graphics state.
////////////////////////////////////////////////////////////////////

3078 11 GeomContext 0 141313 11 GeomContext 11 GeomContext 0 0 0 0 2262 0 2 2260 2261 0 0 1 0 3068 0 0 0 0 856
////////////////////////////////////////////////////////////////////
//       Class : GeomContext
// Description : This is a special class object that holds all the
//               information returned by a particular GSG to indicate
//               the geom's internal context identifier.
//
//               Geoms typically have an immediate-mode and a
//               retained-mode operation.  When using geoms in
//               retained-mode (in response to Geom::prepare()),
//               the GSG will create some internal handle for the
//               geom and store it here.  The geom stores all of
//               these handles internally.
//
//               In the case of OpenGL, for example, a GeomContext
//               corresponds to a display list identifier.
////////////////////////////////////////////////////////////////////

3079 9 GeomLines 0 75777 9 GeomLines 9 GeomLines 0 0 0 1 2263 2065 0 4 2264 2265 2266 2267 0 0 1 0 3071 0 0 0 0 229
////////////////////////////////////////////////////////////////////
//       Class : GeomLines
// Description : Defines a series of disconnected line segments.
////////////////////////////////////////////////////////////////////

3080 14 GeomLinestrips 0 75777 14 GeomLinestrips 14 GeomLinestrips 0 0 0 1 2268 2065 0 4 2269 2270 2271 2272 0 0 1 0 3071 0 0 0 0 219
////////////////////////////////////////////////////////////////////
//       Class : GeomLinestrips
// Description : Defines a series of line strips.
////////////////////////////////////////////////////////////////////

3081 11 GeomPatches 0 75777 11 GeomPatches 11 GeomPatches 0 0 0 1 2273 2065 0 4 2274 2275 2276 2277 0 0 1 0 3071 0 0 0 0 330
////////////////////////////////////////////////////////////////////
//       Class : GeomPatches
// Description : Defines a series of "patches", fixed-size groupings
//               of vertices that must be processed by a tessellation
//               shader.
////////////////////////////////////////////////////////////////////

3082 10 GeomPoints 0 75777 10 GeomPoints 10 GeomPoints 0 0 0 1 2278 2065 0 4 2279 2280 2281 2282 0 0 1 0 3071 0 0 0 0 223
////////////////////////////////////////////////////////////////////
//       Class : GeomPoints
// Description : Defines a series of disconnected points.
////////////////////////////////////////////////////////////////////

3083 13 GeomTriangles 0 75777 13 GeomTriangles 13 GeomTriangles 0 0 0 1 2283 2065 0 4 2284 2285 2286 2287 0 0 1 0 3071 0 0 0 0 229
////////////////////////////////////////////////////////////////////
//       Class : GeomTriangles
// Description : Defines a series of disconnected triangles.
////////////////////////////////////////////////////////////////////

3084 11 GeomTrifans 0 75777 11 GeomTrifans 11 GeomTrifans 0 0 0 1 2288 2065 0 4 2289 2290 2291 2292 0 0 1 0 3071 0 0 0 0 218
////////////////////////////////////////////////////////////////////
//       Class : GeomTrifans
// Description : Defines a series of triangle fans.
////////////////////////////////////////////////////////////////////

3085 13 GeomTristrips 0 75777 13 GeomTristrips 13 GeomTristrips 0 0 0 1 2293 2065 0 4 2294 2295 2296 2297 0 0 1 0 3071 0 0 0 0 222
////////////////////////////////////////////////////////////////////
//       Class : GeomTristrips
// Description : Defines a series of triangle strips.
////////////////////////////////////////////////////////////////////

3086 16 GeomVertexReader 0 26625 16 GeomVertexReader 16 GeomVertexReader 0 0 0 1 2298 2300 0 41 2299 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 0 0 1 0 3029 0 0 0 0 1792
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexReader
// Description : This object provides a high-level interface for
//               quickly reading a sequence of numeric values from a
//               vertex table. 
//
//               It is particularly optimized for reading a single
//               column of data values for a series of vertices,
//               without changing columns between each number.
//               Although you can also use one GeomVertexReader to
//               read across the columns if it is convenient, by
//               calling set_column() repeatedly at each vertex, it is
//               faster to read down the columns, and to use a
//               different GeomVertexReader for each column.
//
//               Note that a GeomVertexReader does not keep a
//               reference count to the actual vertex data buffer (it
//               grabs the current data buffer from the GeomVertexData
//               whenever set_column() is called).  This means that it
//               is important not to keep a GeomVertexReader object
//               around over a long period of time in which the data
//               buffer is likely to be deallocated; it is intended
//               for making a quick pass over the data in one session.
//
//               It also means that you should create any
//               GeomVertexWriters *before* creating GeomVertexReaders
//               on the same data, since the writer itself might cause
//               the vertex buffer to be deallocated.  Better yet, use
//               a GeomVertexRewriter if you are going to create both
//               of them anyway.
////////////////////////////////////////////////////////////////////

3087 16 GeomVertexWriter 0 26625 16 GeomVertexWriter 16 GeomVertexWriter 0 0 0 1 2341 2343 0 62 2342 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 0 0 1 0 3029 0 0 0 0 2540
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexWriter
// Description : This object provides a high-level interface for
//               quickly writing a sequence of numeric values from a
//               vertex table.
//
//               This object can be used both to replace existing
//               vertices in the table, or to extend the table with
//               new vertices.  The set_data*() family of methods can
//               only be used to replace existing data; it is an error
//               to allow these to run past the end of the data.  The
//               add_data*() family of methods, on the other hand, can
//               be used to replace existing data or add new data; if
//               you call set_row() into the middle of existing
//               data the add_data*() methods will behave like the
//               corresponding set_data*(), but if they run past the
//               end of existing data they will quietly add new
//               vertices.
//
//               Like GeomVertexReader, the writer is particularly
//               optimized for writing a single column of data values
//               for a series of vertices, without changing columns
//               between each number.  Although you can also use one
//               GeomVertexWriter to write across the columns if it is
//               convenient, by calling set_column() repeatedly at
//               each vertex, it is faster to write down the columns,
//               and to use a different GeomVertexWriter for each
//               column.
//
//               Note that, like a GeomVertexReader, a
//               GeomVertexWriter does not keep a reference count to
//               the actual vertex data buffer.  This means that it is
//               important not to keep a GeomVertexWriter object
//               around over a long period of time in which the data
//               buffer is likely to be deallocated; it is intended
//               for making a quick pass over the data in one session.
//
//               It also means that you should create any
//               GeomVertexWriters *before* creating GeomVertexReaders
//               on the same data, since the writer itself might cause
//               the vertex buffer to be deallocated.  Better yet, use
//               a GeomVertexRewriter if you are going to create both
//               of them anyway.
////////////////////////////////////////////////////////////////////

3088 18 GeomVertexRewriter 0 26625 18 GeomVertexRewriter 18 GeomVertexRewriter 0 0 0 1 2409 2411 0 16 2410 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 0 0 2 3 3087 2405 2406 3 3086 2407 2408 0 0 988
////////////////////////////////////////////////////////////////////
//       Class : GeomVertexRewriter
// Description : This object provides the functionality of both a
//               GeomVertexReader and a GeomVertexWriter, combined
//               together into one convenient package.  It is designed
//               for making a single pass over a GeomVertexData
//               object, modifying rows as it goes.
//
//               Although it doesn't provide any real performance
//               benefit over using a separate reader and writer on
//               the same data, it should probably be used in
//               preference to a separate reader and writer, because
//               it makes an effort to manage the reference counts
//               properly between the reader and the writer to avoid
//               accidentally dereferencing either array while
//               recopying.
////////////////////////////////////////////////////////////////////

3089 12 SamplerState 0 141313 12 SamplerState 12 SamplerState 0 0 0 1 2427 2466 0 38 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 0 0 0 0 2 3090 3091 395
////////////////////////////////////////////////////////////////////
//       Class : SamplerState
// Description : Represents a set of settings that indicate how a
//               texture is sampled.  This can be used to sample the
//               same texture using different settings in different
//               places.
////////////////////////////////////////////////////////////////////

3090 10 FilterType 0 794624 24 SamplerState::FilterType 24 SamplerState::FilterType 3089 0 0 0 0 0 0 0 0 0 9 10 FT_nearest 24 SamplerState::FT_nearest 25
// Point sample the pixel
0 9 FT_linear 23 SamplerState::FT_linear 48
// Bilinear filtering of four neighboring pixels
1 25 FT_nearest_mipmap_nearest 39 SamplerState::FT_nearest_mipmap_nearest 55
// Point sample the pixel from the nearest mipmap level
2 24 FT_linear_mipmap_nearest 38 SamplerState::FT_linear_mipmap_nearest 58
// Bilinear filter the pixel from the nearest mipmap level
3 24 FT_nearest_mipmap_linear 38 SamplerState::FT_nearest_mipmap_linear 68
// Point sample the pixel from two mipmap levels, and linearly blend
4 23 FT_linear_mipmap_linear 37 SamplerState::FT_linear_mipmap_linear 115
// A.k.a. trilinear filtering: Bilinear filter the pixel from
// two mipmap levels, and linearly blend the results.
5 9 FT_shadow 23 SamplerState::FT_shadow 76
// The OpenGL ARB_shadow extension can be thought of as a kind of filtering.
6 10 FT_default 24 SamplerState::FT_default 128
// Default is usually linear, but it depends on format.
// This was added at the end of the list to avoid bumping TXO version #.
7 10 FT_invalid 24 SamplerState::FT_invalid 57
// Returned by string_filter_type() for an invalid match.
8 0 0

3091 8 WrapMode 0 794624 22 SamplerState::WrapMode 22 SamplerState::WrapMode 3089 0 0 0 0 0 0 0 0 0 6 8 WM_clamp 22 SamplerState::WM_clamp 59
// coords that would be outside [0-1] are clamped to 0 or 1
0 9 WM_repeat 23 SamplerState::WM_repeat 0
1 9 WM_mirror 23 SamplerState::WM_mirror 0
2 14 WM_mirror_once 28 SamplerState::WM_mirror_once 26
// mirror once, then clamp
3 15 WM_border_color 29 SamplerState::WM_border_color 105
// coords outside [0-1] use explicit border color
// Returned by string_wrap_mode() for an invalid match.
4 10 WM_invalid 24 SamplerState::WM_invalid 105
// coords outside [0-1] use explicit border color
// Returned by string_wrap_mode() for an invalid match.
5 0 0

3092 7 Texture 0 26625 7 Texture 7 Texture 0 0 0 1 2471 2472 0 201 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 0 0 2 3 3039 2467 2468 3 3025 2469 2470 0 7 3093 3094 3095 3096 3097 3098 3099 1051
////////////////////////////////////////////////////////////////////
//       Class : Texture
// Description : Represents a texture object, which is typically a
//               single 2-d image but may also represent a 1-d or 3-d
//               texture image, or the six 2-d faces of a cube map
//               texture.
//
//               A texture's image data might be stored in system RAM
//               (see get_ram_image()) or its image may be represented
//               in texture memory on one or more
//               GraphicsStateGuardians (see prepare()), or both.  The
//               typical usage pattern is that a texture is loaded
//               from an image file on disk, which copies its image
//               data into system RAM; then the first time the texture
//               is rendered its image data is copied to texture
//               memory (actually, to the graphics API), and the
//               system RAM image is automatically freed.
////////////////////////////////////////////////////////////////////

3093 11 TextureType 0 794624 20 Texture::TextureType 20 Texture::TextureType 3092 0 0 0 0 0 0 0 0 0 6 13 TT_1d_texture 22 Texture::TT_1d_texture 0
0 13 TT_2d_texture 22 Texture::TT_2d_texture 0
1 13 TT_3d_texture 22 Texture::TT_3d_texture 0
2 19 TT_2d_texture_array 28 Texture::TT_2d_texture_array 0
3 11 TT_cube_map 20 Texture::TT_cube_map 0
4 17 TT_buffer_texture 26 Texture::TT_buffer_texture 0
5 0 0

3094 13 ComponentType 0 794624 22 Texture::ComponentType 22 Texture::ComponentType 3092 0 0 0 0 0 0 0 0 0 5 15 T_unsigned_byte 24 Texture::T_unsigned_byte 0
0 16 T_unsigned_short 25 Texture::T_unsigned_short 0
1 7 T_float 16 Texture::T_float 0
2 19 T_unsigned_int_24_8 28 Texture::T_unsigned_int_24_8 9
// Packed
3 5 T_int 14 Texture::T_int 0
4 0 0

3095 6 Format 0 794624 15 Texture::Format 15 Texture::Format 3092 0 0 0 0 0 0 0 0 0 41 15 F_depth_stencil 24 Texture::F_depth_stencil 0
1 13 F_color_index 22 Texture::F_color_index 0
2 5 F_red 14 Texture::F_red 0
3 7 F_green 16 Texture::F_green 0
4 6 F_blue 15 Texture::F_blue 0
5 7 F_alpha 16 Texture::F_alpha 0
6 5 F_rgb 14 Texture::F_rgb 55
// any suitable RGB mode, whatever the hardware prefers
7 6 F_rgb5 15 Texture::F_rgb5 27
// 5 bits per R,G,B channel
8 6 F_rgb8 15 Texture::F_rgb8 27
// 8 bits per R,G,B channel
9 7 F_rgb12 16 Texture::F_rgb12 28
// 12 bits per R,G,B channel
10 8 F_rgb332 17 Texture::F_rgb332 33
// 3 bits per R & G, 2 bits for B
11 6 F_rgba 15 Texture::F_rgba 56
// any suitable RGBA mode, whatever the hardware prefers
12 6 F_rgbm 15 Texture::F_rgbm 58
// as above, but only requires 1 bit for alpha (i.e. mask)
13 7 F_rgba4 16 Texture::F_rgba4 29
// 4 bits per R,G,B,A channel
14 7 F_rgba5 16 Texture::F_rgba5 40
// 5 bits per R,G,B channel, 1 bit alpha
15 7 F_rgba8 16 Texture::F_rgba8 29
// 8 bits per R,G,B,A channel
16 8 F_rgba12 17 Texture::F_rgba12 30
// 12 bits per R,G,B,A channel
17 11 F_luminance 20 Texture::F_luminance 0
18 17 F_luminance_alpha 26 Texture::F_luminance_alpha 33
// 8 bits luminance, 8 bits alpha
19 21 F_luminance_alphamask 30 Texture::F_luminance_alphamask 46
// 8 bits luminance, only needs 1 bit of alpha
20 8 F_rgba16 17 Texture::F_rgba16 30
// 16 bits per R,G,B,A channel
21 8 F_rgba32 17 Texture::F_rgba32 30
// 32 bits per R,G,B,A channel
22 17 F_depth_component 26 Texture::F_depth_component 0
23 19 F_depth_component16 28 Texture::F_depth_component16 0
24 19 F_depth_component24 28 Texture::F_depth_component24 0
25 19 F_depth_component32 28 Texture::F_depth_component32 0
26 5 F_r16 14 Texture::F_r16 0
27 6 F_rg16 15 Texture::F_rg16 0
28 7 F_rgb16 16 Texture::F_rgb16 0
29 6 F_srgb 15 Texture::F_srgb 100
// These formats are in the sRGB color space.
// RGB is 2.2 gamma corrected, alpha is always linear.
30 12 F_srgb_alpha 21 Texture::F_srgb_alpha 0
31 12 F_sluminance 21 Texture::F_sluminance 0
32 18 F_sluminance_alpha 27 Texture::F_sluminance_alpha 0
33 6 F_r32i 15 Texture::F_r32i 41
// 32-bit integer, used for atomic access
34 5 F_r32 14 Texture::F_r32 0
35 6 F_rg32 15 Texture::F_rg32 0
36 7 F_rgb32 16 Texture::F_rgb32 0
37 5 F_r8i 14 Texture::F_r8i 31
// 8 integer bits per R channel
38 6 F_rg8i 15 Texture::F_rg8i 33
// 8 integer bits per R,G channel
39 7 F_rgb8i 16 Texture::F_rgb8i 35
// 8 integer bits per R,G,B channel
40 8 F_rgba8i 17 Texture::F_rgba8i 37
// 8 integer bits per R,G,B,A channel
41 0 0

3096 20 DeprecatedFilterType 0 794624 29 Texture::DeprecatedFilterType 29 Texture::DeprecatedFilterType 3092 0 0 0 0 0 0 0 0 0 9 10 FT_nearest 19 Texture::FT_nearest 0
0 9 FT_linear 18 Texture::FT_linear 0
1 25 FT_nearest_mipmap_nearest 34 Texture::FT_nearest_mipmap_nearest 0
2 24 FT_linear_mipmap_nearest 33 Texture::FT_linear_mipmap_nearest 0
3 24 FT_nearest_mipmap_linear 33 Texture::FT_nearest_mipmap_linear 0
4 23 FT_linear_mipmap_linear 32 Texture::FT_linear_mipmap_linear 0
5 9 FT_shadow 18 Texture::FT_shadow 0
6 10 FT_default 19 Texture::FT_default 0
7 10 FT_invalid 19 Texture::FT_invalid 0
8 0 44
// Deprecated.  See SamplerState.FilterType.

3097 18 DeprecatedWrapMode 0 794624 27 Texture::DeprecatedWrapMode 27 Texture::DeprecatedWrapMode 3092 0 0 0 0 0 0 0 0 0 6 8 WM_clamp 17 Texture::WM_clamp 0
0 9 WM_repeat 18 Texture::WM_repeat 0
1 9 WM_mirror 18 Texture::WM_mirror 0
2 14 WM_mirror_once 23 Texture::WM_mirror_once 0
3 15 WM_border_color 24 Texture::WM_border_color 0
4 10 WM_invalid 19 Texture::WM_invalid 0
5 0 42
// Deprecated.  See SamplerState.WrapMode.

3098 15 CompressionMode 0 794624 24 Texture::CompressionMode 24 Texture::CompressionMode 3092 0 0 0 0 0 0 0 0 0 11 10 CM_default 19 Texture::CM_default 46
// on or off, according to compressed-textures
0 6 CM_off 15 Texture::CM_off 21
// uncompressed image
1 5 CM_on 14 Texture::CM_on 43
// whatever compression the driver supports
2 7 CM_fxt1 16 Texture::CM_fxt1 304
// Specific compression modes.  Use only when you really want to
// use a particular compression algorithm.  Use with caution; not
// all drivers support all compression modes.  You can use
// GSG::get_supports_compressed_texture_format() to query the
// available compression modes for a particular GSG.
3 7 CM_dxt1 16 Texture::CM_dxt1 0
4 7 CM_dxt2 16 Texture::CM_dxt2 0
5 7 CM_dxt3 16 Texture::CM_dxt3 0
6 7 CM_dxt4 16 Texture::CM_dxt4 0
7 7 CM_dxt5 16 Texture::CM_dxt5 0
8 12 CM_pvr1_2bpp 21 Texture::CM_pvr1_2bpp 0
9 12 CM_pvr1_4bpp 21 Texture::CM_pvr1_4bpp 0
10 0 0

3099 12 QualityLevel 0 794624 21 Texture::QualityLevel 21 Texture::QualityLevel 3092 0 0 0 0 0 0 0 0 0 4 10 QL_default 19 Texture::QL_default 37
// according to texture-quality-level
0 10 QL_fastest 19 Texture::QL_fastest 0
1 9 QL_normal 18 Texture::QL_normal 0
2 7 QL_best 16 Texture::QL_best 0
3 0 0

3100 6 Shader 0 75777 6 Shader 6 Shader 0 0 0 0 0 0 17 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 0 0 1 0 3039 0 0 0 4 3101 3102 3103 3104 418
////////////////////////////////////////////////////////////////////
//       Class : Shader
//      Summary: The Shader class is meant to select the Shader Language,
//               select the available profile, compile the shader, and
//               finally compile and store the shader parameters
//               in the appropriate structure.
////////////////////////////////////////////////////////////////////

3101 14 ShaderLanguage 0 794624 22 Shader::ShaderLanguage 22 Shader::ShaderLanguage 3100 0 0 0 0 0 0 0 0 0 3 7 SL_none 15 Shader::SL_none 0
0 5 SL_Cg 13 Shader::SL_Cg 0
1 7 SL_GLSL 15 Shader::SL_GLSL 0
2 0 0

3102 10 ShaderType 0 794624 18 Shader::ShaderType 18 Shader::ShaderType 3100 0 0 0 0 0 0 0 0 0 8 7 ST_none 15 Shader::ST_none 0
0 9 ST_vertex 17 Shader::ST_vertex 0
1 11 ST_fragment 19 Shader::ST_fragment 0
2 11 ST_geometry 19 Shader::ST_geometry 0
3 15 ST_tess_control 23 Shader::ST_tess_control 0
4 18 ST_tess_evaluation 26 Shader::ST_tess_evaluation 0
5 10 ST_compute 18 Shader::ST_compute 0
6 8 ST_COUNT 16 Shader::ST_COUNT 0
7 0 0

3103 16 AutoShaderSwitch 0 794624 24 Shader::AutoShaderSwitch 24 Shader::AutoShaderSwitch 3100 0 0 0 0 0 0 0 0 0 5 9 AS_normal 17 Shader::AS_normal 0
1 7 AS_glow 15 Shader::AS_glow 0
2 8 AS_gloss 16 Shader::AS_gloss 0
4 7 AS_ramp 15 Shader::AS_ramp 0
8 9 AS_shadow 17 Shader::AS_shadow 0
16 0 0

3104 13 AutoShaderBit 0 794624 21 Shader::AutoShaderBit 21 Shader::AutoShaderBit 3100 0 0 0 0 0 0 0 0 0 5 20 bit_AutoShaderNormal 28 Shader::bit_AutoShaderNormal 20
// bit for AS_normal
0 18 bit_AutoShaderGlow 26 Shader::bit_AutoShaderGlow 18
// bit for AS_glow
1 19 bit_AutoShaderGloss 27 Shader::bit_AutoShaderGloss 19
// bit for AS_gloss
2 18 bit_AutoShaderRamp 26 Shader::bit_AutoShaderRamp 18
// bit for AS_ramp
3 20 bit_AutoShaderShadow 28 Shader::bit_AutoShaderShadow 20
// bit for AS_shadow
4 0 0

3105 23 PreparedGraphicsObjects 0 75777 23 PreparedGraphicsObjects 23 PreparedGraphicsObjects 0 0 0 0 0 0 62 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 0 0 1 0 3053 0 0 0 0 1037
////////////////////////////////////////////////////////////////////
//       Class : PreparedGraphicsObjects
// Description : A table of objects that are saved within the graphics
//               context for reference by handle later.  Generally,
//               this represents things like OpenGL texture objects or
//               display lists (or their equivalent on other
//               platforms).
//
//               This object simply records the pointers to the
//               context objects created by the individual GSG's;
//               these context objects will contain enough information
//               to reference or release the actual object stored
//               within the graphics context.
//
//               These tables may potentially be shared between
//               related graphics contexts, hence their storage here
//               in a separate object rather than as a part of the
//               GraphicsStateGuardian.
////////////////////////////////////////////////////////////////////

3106 18 IndexBufferContext 0 141313 18 IndexBufferContext 18 IndexBufferContext 0 0 0 0 2762 0 5 2757 2758 2759 2760 2761 0 0 2 3 3070 2753 2754 3 3026 2755 2756 0 0 634
////////////////////////////////////////////////////////////////////
//       Class : IndexBufferContext
// Description : This is a special class object that holds all the
//               information returned by a particular GSG to indicate
//               the vertex data array's internal context identifier.
//
//               This allows the GSG to cache the vertex data array in
//               whatever way makes sense.  For instance, DirectX can
//               allocate a vertex buffer for the array.  OpenGL can
//               create a buffer object.
////////////////////////////////////////////////////////////////////

3107 4 Lens 0 141313 4 Lens 4 Lens 0 0 0 0 2830 0 67 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 0 0 1 0 3039 0 0 0 2 3108 3109 668
////////////////////////////////////////////////////////////////////
//       Class : Lens
// Description : A base class for any number of different kinds of
//               lenses, linear and otherwise.  Presently, this
//               includes perspective and orthographic lenses.
//
//               A Lens object is the main part of a Camera node,
//               which defines the fundamental interface to
//               point-of-view for rendering.  Lenses are also used in
//               other contexts, however; for instance, a Spotlight is
//               also defined using a lens.
////////////////////////////////////////////////////////////////////

3108 13 StereoChannel 0 794624 19 Lens::StereoChannel 19 Lens::StereoChannel 3107 0 0 0 0 0 0 0 0 0 4 7 SC_mono 13 Lens::SC_mono 0
0 7 SC_left 13 Lens::SC_left 0
1 8 SC_right 14 Lens::SC_right 0
2 9 SC_stereo 15 Lens::SC_stereo 24
// == SC_left | SC_right
3 0 0

3109 11 FromCorners 0 794624 17 Lens::FromCorners 17 Lens::FromCorners 3107 0 0 0 0 0 0 0 0 0 6 7 FC_roll 13 Lens::FC_roll 0
1 15 FC_camera_plane 21 Lens::FC_camera_plane 0
2 11 FC_off_axis 17 Lens::FC_off_axis 0
4 15 FC_aspect_ratio 21 Lens::FC_aspect_ratio 0
8 8 FC_shear 14 Lens::FC_shear 0
16 11 FC_keystone 17 Lens::FC_keystone 0
32 0 183
// These flags are passed in as the last parameter to control the
// behavior of set_frustum_from_corners().  See the documentation
// for that method for an explanation of each flag.

3110 8 Material 0 26625 8 Material 8 Material 0 0 0 1 2835 2837 0 33 2836 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 0 0 2 3 3039 2831 2832 3 3025 2833 2834 0 0 373
////////////////////////////////////////////////////////////////////
//       Class : Material
// Description : Defines the way an object appears in the presence of
//               lighting.  A material is only necessary if lighting
//               is to be enabled; otherwise, the material isn't used.
////////////////////////////////////////////////////////////////////

3111 12 MaterialPool 0 141313 12 MaterialPool 12 MaterialPool 0 0 0 0 2876 0 6 2870 2871 2872 2873 2874 2875 0 0 0 0 0 1029
////////////////////////////////////////////////////////////////////
//       Class : MaterialPool
// Description : The MaterialPool (there is only one in the universe)
//               serves to unify different pointers to the same
//               Material, so we do not (a) waste memory with many
//               different Material objects that are all equivalent,
//               and (b) waste time switching the graphics engine
//               between different Material states that are really the
//               same thing.
//
//               The idea is to create a temporary Material
//               representing the lighting state you want to apply,
//               then call get_material(), passing in your temporary
//               Material.  The return value will either be a new
//               Material object, or it may be the the same object you
//               supplied; in either case, it will have the same
//               value.
////////////////////////////////////////////////////////////////////

3112 10 MatrixLens 0 141313 10 MatrixLens 10 MatrixLens 0 0 0 1 2877 2889 0 11 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 0 0 1 0 3107 0 0 0 0 504
////////////////////////////////////////////////////////////////////
//       Class : MatrixLens
// Description : A completely generic linear lens.  This is provided
//               for the benefit of low-level code that wants to
//               specify a perspective or orthographic frustum via an
//               explicit projection matrix, but not mess around with
//               fov's or focal lengths or any of that nonsense.
////////////////////////////////////////////////////////////////////

3113 16 OrthographicLens 0 141313 16 OrthographicLens 16 OrthographicLens 0 0 0 1 2890 2892 0 1 2891 0 0 1 0 3107 0 0 0 0 682
////////////////////////////////////////////////////////////////////
//       Class : OrthographicLens
// Description : An orthographic lens.  Although this kind of lens is
//               linear, like a PerspectiveLens, it doesn't respect
//               field-of-view or focal length parameters, and
//               adjusting these will have no effect.  Instead, its
//               field of view is controlled by adjusting the
//               film_size; the orthographic lens represents a planar
//               projection onto its imaginary film of the specified
//               size, hanging in space.
////////////////////////////////////////////////////////////////////

3114 19 ParamTextureSampler 0 141313 19 ParamTextureSampler 19 ParamTextureSampler 0 0 0 1 2893 2897 0 3 2894 2895 2896 0 0 1 0 3115 0 0 0 0 353
////////////////////////////////////////////////////////////////////
//       Class : ParamTextureSampler
// Description : A class object for storing a pointer to a Texture
//               along with a sampler state that indicates how to
//               to sample the given texture.
////////////////////////////////////////////////////////////////////

3115 14 ParamValueBase 0 2049 14 ParamValueBase 14 ParamValueBase 0 0 0 0 0 0 0 0 0 0 0 0 348
////////////////////////////////////////////////////////////////////
//       Class : ParamValueBase
// Description : A non-template base class of ParamValue (below),
//               which serves mainly to define the placeholder for the
//               virtual output function.
////////////////////////////////////////////////////////////////////

3116 17 ParamTextureImage 0 141313 17 ParamTextureImage 17 ParamTextureImage 0 0 0 1 2898 2906 0 7 2899 2900 2901 2902 2903 2904 2905 0 0 1 0 3115 0 0 0 0 492
////////////////////////////////////////////////////////////////////
//       Class : ParamTextureImage
// Description : A class object for storing a pointer to a Texture
//               along with a set of properties that indicates which
//               image to bind to a shader input.
//
//               This class is useful for binding texture images
//               to a shader, which is a fairly esoteric feature.
////////////////////////////////////////////////////////////////////

3117 15 PerspectiveLens 0 141313 15 PerspectiveLens 15 PerspectiveLens 0 0 0 1 2907 2909 0 1 2908 0 0 1 0 3107 0 0 0 0 229
////////////////////////////////////////////////////////////////////
//       Class : PerspectiveLens
// Description : A perspective-type lens: a normal camera.
////////////////////////////////////////////////////////////////////

3118 20 TextureReloadRequest 0 141313 20 TextureReloadRequest 20 TextureReloadRequest 0 0 0 1 2910 2916 0 5 2911 2912 2913 2914 2915 0 0 1 0 3067 0 0 0 0 486
////////////////////////////////////////////////////////////////////
//       Class : TextureReloadRequest
// Description : This loader request will call
//               Texture::get_ram_image() in a sub-thread, to force
//               the texture's image to be re-read from disk.  It is
//               used by GraphicsStateGuardian::async_reload_texture(),
//               when get_incomplete_render() is true.
////////////////////////////////////////////////////////////////////

3119 14 TextureContext 0 141313 14 TextureContext 14 TextureContext 0 0 0 0 2931 0 10 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 0 0 2 3 3070 2917 2918 3 3026 2919 2920 0 0 748
////////////////////////////////////////////////////////////////////
//       Class : TextureContext
// Description : This is a special class object that holds all the
//               information returned by a particular GSG to indicate
//               the texture's internal context identifier.
//
//               Textures typically have an immediate-mode and a
//               retained-mode operation.  When using textures in
//               retained-mode (in response to Texture::prepare()),
//               the GSG will create some internal handle for the
//               texture and store it here.  The texture stores all of
//               these handles internally.
////////////////////////////////////////////////////////////////////

3120 13 ShaderContext 0 141313 13 ShaderContext 13 ShaderContext 0 0 0 0 2934 0 2 2932 2933 0 0 1 0 3068 0 0 0 0 0

3121 16 UserVertexSlider 0 141313 16 UserVertexSlider 16 UserVertexSlider 0 0 0 1 2935 2938 0 2 2936 2937 0 0 1 0 3063 0 0 0 0 390
////////////////////////////////////////////////////////////////////
//       Class : UserVertexSlider
// Description : This is a specialization on VertexSlider that
//               allows the user to specify any arbitrary slider
//               valie he likes.  This is rarely used except for
//               testing.
////////////////////////////////////////////////////////////////////

3122 19 UserVertexTransform 0 141313 19 UserVertexTransform 19 UserVertexTransform 0 0 0 1 2939 2943 0 3 2940 2941 2942 0 0 1 0 3059 0 0 0 0 400
////////////////////////////////////////////////////////////////////
//       Class : UserVertexTransform
// Description : This is a specialization on VertexTransform that
//               allows the user to specify any arbitrary transform
//               matrix he likes.  This is rarely used except for
//               testing.
////////////////////////////////////////////////////////////////////

3123 12 VideoTexture 0 141313 12 VideoTexture 12 VideoTexture 0 0 0 0 2952 0 4 2948 2949 2950 2951 0 0 2 3 3092 2944 2945 3 3124 2946 2947 0 0 480
////////////////////////////////////////////////////////////////////
//       Class : VideoTexture
// Description : The base class for a family of animated Textures that
//               take their input from a video source, such as a movie
//               file.  These Textures may be stopped, started,
//               etc. using the AnimInterface controls, similar to an
//               animated character.
////////////////////////////////////////////////////////////////////

3124 13 AnimInterface 0 2049 13 AnimInterface 13 AnimInterface 0 0 0 0 0 0 0 0 0 0 0 0 464
////////////////////////////////////////////////////////////////////
//       Class : AnimInterface
// Description : This is the fundamental interface for things that
//               have a play/loop/stop type interface for frame-based
//               animation, such as animated characters.  This is the
//               base class for AnimControl and other, similar
//               classes.
////////////////////////////////////////////////////////////////////

3125 19 VertexBufferContext 0 141313 19 VertexBufferContext 19 VertexBufferContext 0 0 0 0 2962 0 5 2957 2958 2959 2960 2961 0 0 2 3 3070 2953 2954 3 3026 2955 2956 0 0 635
////////////////////////////////////////////////////////////////////
//       Class : VertexBufferContext
// Description : This is a special class object that holds all the
//               information returned by a particular GSG to indicate
//               the vertex data array's internal context identifier.
//
//               This allows the GSG to cache the vertex data array in
//               whatever way makes sense.  For instance, DirectX can
//               allocate a vertex buffer for the array.  OpenGL can
//               create a buffer object.
////////////////////////////////////////////////////////////////////

3126 17 TextureCollection 0 26625 17 TextureCollection 17 TextureCollection 0 0 0 1 2963 2965 0 21 2964 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 1 3511 0 0 0 0 290
////////////////////////////////////////////////////////////////////
//       Class : TextureCollection
// Description : Manages a list of Texture objects, as returned by
//               TexturePool::find_all_textures().
////////////////////////////////////////////////////////////////////

3127 11 TexturePool 0 141313 11 TexturePool 11 TexturePool 0 0 0 0 3008 0 22 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 0 0 0 0 0 470
////////////////////////////////////////////////////////////////////
//       Class : TexturePool
// Description : This is the preferred interface for loading textures
//               from image files.  It unifies all references to the
//               same filename, so that multiple models that reference
//               the same textures don't waste texture memory
//               unnecessarily.
////////////////////////////////////////////////////////////////////

3128 13 TexturePeeker 0 141313 13 TexturePeeker 13 TexturePeeker 0 0 0 0 3014 0 5 3009 3010 3011 3012 3013 0 0 1 0 3053 0 0 0 0 386
////////////////////////////////////////////////////////////////////
//       Class : TexturePeeker
// Description : An instance of this object is returned by
//               Texture::peek().  This object allows quick and easy
//               inspection of a texture's texels by (u, v)
//               coordinates.
////////////////////////////////////////////////////////////////////

3129 16 TextureStagePool 0 141313 16 TextureStagePool 16 TextureStagePool 0 0 0 0 3023 0 8 3015 3016 3017 3018 3019 3020 3021 3022 0 0 0 0 1 3130 624
////////////////////////////////////////////////////////////////////
//       Class : TextureStagePool
// Description : The TextureStagePool (there is only one in the universe)
//               serves to unify different pointers to the same
//               TextureStage, mainly to help developers use a common
//               pointer to access things that are loaded from
//               different model files.
//
//               It runs in one of three different modes, according to
//               set_mode().  See that method for more information.
////////////////////////////////////////////////////////////////////

3130 4 Mode 0 794624 22 TextureStagePool::Mode 22 TextureStagePool::Mode 3129 0 0 0 0 0 0 0 0 0 3 6 M_none 24 TextureStagePool::M_none 0
0 6 M_name 24 TextureStagePool::M_name 0
1 8 M_unique 26 TextureStagePool::M_unique 0
2 0 0

3131 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3132 6 size_t 0 2105344 6 size_t 6 size_t 0 0 3133 0 0 0 0 0 0 0 0 0 0

3133 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

3134 13 AdaptiveLru * 0 8576 13 AdaptiveLru * 13 AdaptiveLru * 0 0 3024 0 0 0 0 0 0 0 0 0 0

3135 19 AdaptiveLru const * 0 8576 19 AdaptiveLru const * 19 AdaptiveLru const * 0 0 3136 0 0 0 0 0 0 0 0 0 0

3136 17 AdaptiveLru const 0 8832 17 AdaptiveLru const 17 AdaptiveLru const 0 0 3024 0 0 0 0 0 0 0 0 0 0

3137 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3138 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3139 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 3140 0 0 0 0 0 0 0 0 0 0

3140 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3141 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3142 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3143 0 0 0 0 0 0 0 0 0 0

3143 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3144 23 AdaptiveLruPage const * 0 8576 23 AdaptiveLruPage const * 23 AdaptiveLruPage const * 0 0 3145 0 0 0 0 0 0 0 0 0 0

3145 21 AdaptiveLruPage const 0 8832 21 AdaptiveLruPage const 21 AdaptiveLruPage const 0 0 3026 0 0 0 0 0 0 0 0 0 0

3146 17 AdaptiveLruPage * 0 8576 17 AdaptiveLruPage * 17 AdaptiveLruPage * 0 0 3026 0 0 0 0 0 0 0 0 0 0

3147 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

3148 25 GeomVertexAnimationSpec * 0 8576 25 GeomVertexAnimationSpec * 25 GeomVertexAnimationSpec * 0 0 3037 0 0 0 0 0 0 0 0 0 0

3149 31 GeomVertexAnimationSpec const * 0 8576 31 GeomVertexAnimationSpec const * 31 GeomVertexAnimationSpec const * 0 0 3150 0 0 0 0 0 0 0 0 0 0

3150 29 GeomVertexAnimationSpec const 0 8832 29 GeomVertexAnimationSpec const 29 GeomVertexAnimationSpec const 0 0 3037 0 0 0 0 0 0 0 0 0 0

3151 16 PyStringObject * 0 8576 16 PyStringObject * 16 PyStringObject * 0 0 3152 0 0 0 0 0 0 0 0 0 0

3152 14 PyStringObject 0 2105344 14 PyStringObject 14 PyStringObject 0 0 3153 0 0 0 0 0 0 0 0 0 0

3153 0 0 8192 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

3154 14 InternalName * 0 8576 14 InternalName * 14 InternalName * 0 0 3038 0 0 0 0 0 0 0 0 0 0

3155 20 InternalName const * 0 8576 20 InternalName const * 20 InternalName const * 0 0 3156 0 0 0 0 0 0 0 0 0 0

3156 18 InternalName const 0 8832 18 InternalName const 18 InternalName const 0 0 3038 0 0 0 0 0 0 0 0 0 0

3157 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 1098
////////////////////////////////////////////////////////////////////
//       Class : TypeHandle
// Description : TypeHandle is the identifier used to differentiate
//               C++ class types.  Any C++ classes that inherit from
//               some base class, and must be differentiated at run
//               time, should store a static TypeHandle object that
//               can be queried through a static member function
//               named get_class_type().  Most of the time, it is also
//               desirable to inherit from TypedObject, which provides
//               some virtual functions to return the TypeHandle for a
//               particular instance.
//
//               At its essence, a TypeHandle is simply a unique
//               identifier that is assigned by the TypeRegistry.  The
//               TypeRegistry stores a tree of TypeHandles, so that
//               ancestry of a particular type may be queried, and the
//               type name may be retrieved for run-time display.
////////////////////////////////////////////////////////////////////

3158 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3157 0 0 0 0 0 0 0 0 0 0

3159 18 GeomVertexColumn * 0 8576 18 GeomVertexColumn * 18 GeomVertexColumn * 0 0 3040 0 0 0 0 0 0 0 0 0 0

3160 24 GeomVertexColumn const * 0 8576 24 GeomVertexColumn const * 24 GeomVertexColumn const * 0 0 3161 0 0 0 0 0 0 0 0 0 0

3161 22 GeomVertexColumn const 0 8832 22 GeomVertexColumn const 22 GeomVertexColumn const 0 0 3040 0 0 0 0 0 0 0 0 0 0

3162 23 GeomVertexArrayFormat * 0 8576 23 GeomVertexArrayFormat * 23 GeomVertexArrayFormat * 0 0 3041 0 0 0 0 0 0 0 0 0 0

3163 29 GeomVertexArrayFormat const * 0 8576 29 GeomVertexArrayFormat const * 29 GeomVertexArrayFormat const * 0 0 3164 0 0 0 0 0 0 0 0 0 0

3164 27 GeomVertexArrayFormat const 0 8832 27 GeomVertexArrayFormat const 27 GeomVertexArrayFormat const 0 0 3041 0 0 0 0 0 0 0 0 0 0

3165 27 GeomVertexArrayData const * 0 8576 27 GeomVertexArrayData const * 27 GeomVertexArrayData const * 0 0 3166 0 0 0 0 0 0 0 0 0 0

3166 25 GeomVertexArrayData const 0 8832 25 GeomVertexArrayData const 25 GeomVertexArrayData const 0 0 3055 0 0 0 0 0 0 0 0 0 0

3167 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 3039 0 0 0 0 0 0 0 0 0 0

3168 11 GeomEnums * 0 8576 11 GeomEnums * 11 GeomEnums * 0 0 3029 0 0 0 0 0 0 0 0 0 0

3169 18 GeomVertexFormat * 0 8576 18 GeomVertexFormat * 18 GeomVertexFormat * 0 0 3042 0 0 0 0 0 0 0 0 0 0

3170 24 GeomVertexFormat const * 0 8576 24 GeomVertexFormat const * 24 GeomVertexFormat const * 0 0 3171 0 0 0 0 0 0 0 0 0 0

3171 22 GeomVertexFormat const 0 8832 22 GeomVertexFormat const 22 GeomVertexFormat const 0 0 3042 0 0 0 0 0 0 0 0 0 0

3172 22 GeomVertexData const * 0 8576 22 GeomVertexData const * 22 GeomVertexData const * 0 0 3173 0 0 0 0 0 0 0 0 0 0

3173 20 GeomVertexData const 0 8832 20 GeomVertexData const 20 GeomVertexData const 0 0 3065 0 0 0 0 0 0 0 0 0 0

3174 11 SimpleLru * 0 8576 11 SimpleLru * 11 SimpleLru * 0 0 3043 0 0 0 0 0 0 0 0 0 0

3175 17 SimpleLru const * 0 8576 17 SimpleLru const * 17 SimpleLru const * 0 0 3176 0 0 0 0 0 0 0 0 0 0

3176 15 SimpleLru const 0 8832 15 SimpleLru const 15 SimpleLru const 0 0 3043 0 0 0 0 0 0 0 0 0 0

3177 16 LinkedListNode * 0 8576 16 LinkedListNode * 16 LinkedListNode * 0 0 3044 0 0 0 0 0 0 0 0 0 0

3178 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 3025 0 0 0 0 0 0 0 0 0 0

3179 21 SimpleLruPage const * 0 8576 21 SimpleLruPage const * 21 SimpleLruPage const * 0 0 3180 0 0 0 0 0 0 0 0 0 0

3180 19 SimpleLruPage const 0 8832 19 SimpleLruPage const 19 SimpleLruPage const 0 0 3045 0 0 0 0 0 0 0 0 0 0

3181 15 SimpleLruPage * 0 8576 15 SimpleLruPage * 15 SimpleLruPage * 0 0 3045 0 0 0 0 0 0 0 0 0 0

3182 7 Mutex * 0 8576 7 Mutex * 7 Mutex * 0 0 3183 0 0 0 0 0 0 0 0 0 0

3183 5 Mutex 0 2048 5 Mutex 5 Mutex 0 0 0 0 0 0 0 0 0 0 0 0 0

3184 17 SimpleAllocator * 0 8576 17 SimpleAllocator * 17 SimpleAllocator * 0 0 3046 0 0 0 0 0 0 0 0 0 0

3185 22 SimpleAllocatorBlock * 0 8576 22 SimpleAllocatorBlock * 22 SimpleAllocatorBlock * 0 0 3047 0 0 0 0 0 0 0 0 0 0

3186 23 SimpleAllocator const * 0 8576 23 SimpleAllocator const * 23 SimpleAllocator const * 0 0 3187 0 0 0 0 0 0 0 0 0 0

3187 21 SimpleAllocator const 0 8832 21 SimpleAllocator const 21 SimpleAllocator const 0 0 3046 0 0 0 0 0 0 0 0 0 0

3188 28 SimpleAllocatorBlock const * 0 8576 28 SimpleAllocatorBlock const * 28 SimpleAllocatorBlock const * 0 0 3189 0 0 0 0 0 0 0 0 0 0

3189 26 SimpleAllocatorBlock const 0 8832 26 SimpleAllocatorBlock const 26 SimpleAllocatorBlock const 0 0 3047 0 0 0 0 0 0 0 0 0 0

3190 26 VertexDataSaveFile const * 0 8576 26 VertexDataSaveFile const * 26 VertexDataSaveFile const * 0 0 3191 0 0 0 0 0 0 0 0 0 0

3191 24 VertexDataSaveFile const 0 8832 24 VertexDataSaveFile const 24 VertexDataSaveFile const 0 0 3048 0 0 0 0 0 0 0 0 0 0

3192 22 VertexDataPage const * 0 8576 22 VertexDataPage const * 22 VertexDataPage const * 0 0 3193 0 0 0 0 0 0 0 0 0 0

3193 20 VertexDataPage const 0 8832 20 VertexDataPage const 20 VertexDataPage const 0 0 3049 0 0 0 0 0 0 0 0 0 0

3194 16 VertexDataPage * 0 8576 16 VertexDataPage * 16 VertexDataPage * 0 0 3049 0 0 0 0 0 0 0 0 0 0

3195 17 VertexDataBlock * 0 8576 17 VertexDataBlock * 17 VertexDataBlock * 0 0 3052 0 0 0 0 0 0 0 0 0 0

3196 16 VertexDataBook * 0 8576 16 VertexDataBook * 16 VertexDataBook * 0 0 3051 0 0 0 0 0 0 0 0 0 0

3197 20 VertexDataSaveFile * 0 8576 20 VertexDataSaveFile * 20 VertexDataSaveFile * 0 0 3048 0 0 0 0 0 0 0 0 0 0

3198 22 VertexDataBook const * 0 8576 22 VertexDataBook const * 22 VertexDataBook const * 0 0 3199 0 0 0 0 0 0 0 0 0 0

3199 20 VertexDataBook const 0 8832 20 VertexDataBook const 20 VertexDataBook const 0 0 3051 0 0 0 0 0 0 0 0 0 0

3200 23 VertexDataBlock const * 0 8576 23 VertexDataBlock const * 23 VertexDataBlock const * 0 0 3201 0 0 0 0 0 0 0 0 0 0

3201 21 VertexDataBlock const 0 8832 21 VertexDataBlock const 21 VertexDataBlock const 0 0 3052 0 0 0 0 0 0 0 0 0 0

3202 16 ReferenceCount * 0 8576 16 ReferenceCount * 16 ReferenceCount * 0 0 3053 0 0 0 0 0 0 0 0 0 0

3203 21 GeomVertexArrayData * 0 8576 21 GeomVertexArrayData * 21 GeomVertexArrayData * 0 0 3055 0 0 0 0 0 0 0 0 0 0

3204 9 UpdateSeq 0 2048 9 UpdateSeq 9 UpdateSeq 0 0 0 0 0 0 0 0 0 0 0 0 1140
////////////////////////////////////////////////////////////////////
//       Class : UpdateSeq
// Description : This is a sequence number that increments
//               monotonically.  It can be used to track cache
//               updates, or serve as a kind of timestamp for any
//               changing properties.
//
//               A special class is used instead of simply an int, so
//               we can elegantly handle such things as wraparound and
//               special cases.  There are two special cases.
//               Firstly, a sequence number is 'initial' when it is
//               first created.  This sequence is older than any other
//               sequence number.  Secondly, a sequence number may be
//               explicitly set to 'old'.  This is older than any
//               other sequence number except 'initial'.  Finally, we
//               have the explicit number 'fresh', which is newer
//               than any other sequence number.  All other sequences
//               are numeric and are monotonically increasing.
////////////////////////////////////////////////////////////////////

3205 11 UpdateSeq * 0 8576 11 UpdateSeq * 11 UpdateSeq * 0 0 3204 0 0 0 0 0 0 0 0 0 0

3206 31 GeomVertexArrayDataHandle const 0 8832 31 GeomVertexArrayDataHandle const 31 GeomVertexArrayDataHandle const 0 0 3057 0 0 0 0 0 0 0 0 0 0

3207 8 Thread * 0 8576 8 Thread * 8 Thread * 0 0 3208 0 0 0 0 0 0 0 0 0 0

3208 6 Thread 0 2048 6 Thread 6 Thread 0 0 0 0 0 0 0 0 0 0 0 0 668
////////////////////////////////////////////////////////////////////
//       Class : Thread
// Description : A thread; that is, a lightweight process.  This is an
//               abstract base class; to use it, you must subclass
//               from it and redefine thread_main().
//
//               The thread itself will keep a reference count on the
//               Thread object while it is running; when the thread
//               returns from its root function, the Thread object
//               will automatically be destructed if no other pointers
//               are referencing it.
////////////////////////////////////////////////////////////////////

3209 33 GeomVertexArrayDataHandle const * 0 8576 33 GeomVertexArrayDataHandle const * 33 GeomVertexArrayDataHandle const * 0 0 3206 0 0 0 0 0 0 0 0 0 0

3210 27 GeomVertexArrayDataHandle * 0 8576 27 GeomVertexArrayDataHandle * 27 GeomVertexArrayDataHandle * 0 0 3057 0 0 0 0 0 0 0 0 0 0

3211 25 PreparedGraphicsObjects * 0 8576 25 PreparedGraphicsObjects * 25 PreparedGraphicsObjects * 0 0 3105 0 0 0 0 0 0 0 0 0 0

3212 27 GraphicsStateGuardianBase * 0 8576 27 GraphicsStateGuardianBase * 27 GraphicsStateGuardianBase * 0 0 3213 0 0 0 0 0 0 0 0 0 0

3213 25 GraphicsStateGuardianBase 0 2048 25 GraphicsStateGuardianBase 25 GraphicsStateGuardianBase 0 0 0 0 0 0 0 0 0 0 0 0 0

3214 21 VertexBufferContext * 0 8576 21 VertexBufferContext * 21 VertexBufferContext * 0 0 3125 0 0 0 0 0 0 0 0 0 0

3215 11 Py_buffer * 0 8576 11 Py_buffer * 11 Py_buffer * 0 0 3216 0 0 0 0 0 0 0 0 0 0

3216 9 Py_buffer 0 1024 9 Py_buffer 9 Py_buffer 0 0 0 0 0 0 0 0 0 0 0 0 0

3217 19 CopyOnWriteObject * 0 8576 19 CopyOnWriteObject * 19 CopyOnWriteObject * 0 0 3056 0 0 0 0 0 0 0 0 0 0

3218 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3219 0 0 0 0 0 0 0 0 0 0

3219 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3220 0 0 0 0 0 0 0 0 0 0

3220 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3221 24 GeomCacheManager const * 0 8576 24 GeomCacheManager const * 24 GeomCacheManager const * 0 0 3222 0 0 0 0 0 0 0 0 0 0

3222 22 GeomCacheManager const 0 8832 22 GeomCacheManager const 22 GeomCacheManager const 0 0 3058 0 0 0 0 0 0 0 0 0 0

3223 18 GeomCacheManager * 0 8576 18 GeomCacheManager * 18 GeomCacheManager * 0 0 3058 0 0 0 0 0 0 0 0 0 0

3224 23 VertexTransform const * 0 8576 23 VertexTransform const * 23 VertexTransform const * 0 0 3225 0 0 0 0 0 0 0 0 0 0

3225 21 VertexTransform const 0 8832 21 VertexTransform const 21 VertexTransform const 0 0 3059 0 0 0 0 0 0 0 0 0 0

3226 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 3227 0 0 0 0 0 0 0 0 0 0

3227 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 3228 0 0 0 0 0 0 0 0 0 0

3228 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 3 3512 3513 3514 0 0 0 0 215
////////////////////////////////////////////////////////////////////
//       Class : LMatrix4
// Description : This is a 4-by-4 transform matrix.
////////////////////////////////////////////////////////////////////

3229 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 3230 0 0 0 0 0 0 0 0 0 0

3230 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 3227 0 0 0 0 0 0 0 0 0 0

3231 16 TransformTable * 0 8576 16 TransformTable * 16 TransformTable * 0 0 3060 0 0 0 0 0 0 0 0 0 0

3232 22 TransformTable const * 0 8576 22 TransformTable const * 22 TransformTable const * 0 0 3233 0 0 0 0 0 0 0 0 0 0

3233 20 TransformTable const 0 8832 20 TransformTable const 20 TransformTable const 0 0 3060 0 0 0 0 0 0 0 0 0 0

3234 16 TransformBlend * 0 8576 16 TransformBlend * 16 TransformBlend * 0 0 3061 0 0 0 0 0 0 0 0 0 0

3235 22 TransformBlend const * 0 8576 22 TransformBlend const * 22 TransformBlend const * 0 0 3236 0 0 0 0 0 0 0 0 0 0

3236 20 TransformBlend const 0 8832 20 TransformBlend const 20 TransformBlend const 0 0 3061 0 0 0 0 0 0 0 0 0 0

3237 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3238 0 0 0 0 0 0 0 0 0 0

3238 8 LPoint3d 0 2048 8 LPoint3d 8 LPoint3d 0 0 0 0 0 0 0 0 0 0 0 0 596
////////////////////////////////////////////////////////////////////
//       Class : LPoint3
// Description : This is a three-component point in space (as opposed
//               to a three-component vector, which represents a
//               direction and a distance).  Some of the methods are
//               slightly different between LPoint3 and LVector3; in
//               particular, subtraction of two points yields a
//               vector, while addition of a vector and a point yields
//               a point.
////////////////////////////////////////////////////////////////////

3239 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3240 0 0 0 0 0 0 0 0 0 0

3240 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 596
////////////////////////////////////////////////////////////////////
//       Class : LPoint3
// Description : This is a three-component point in space (as opposed
//               to a three-component vector, which represents a
//               direction and a distance).  Some of the methods are
//               slightly different between LPoint3 and LVector3; in
//               particular, subtraction of two points yields a
//               vector, while addition of a vector and a point yields
//               a point.
////////////////////////////////////////////////////////////////////

3241 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3242 0 0 0 0 0 0 0 0 0 0

3242 8 LPoint4d 0 2048 8 LPoint4d 8 LPoint4d 0 0 0 0 0 0 0 0 0 0 0 0 220
////////////////////////////////////////////////////////////////////
//       Class : LPoint4
// Description : This is a four-component point in space.
////////////////////////////////////////////////////////////////////

3243 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3244 0 0 0 0 0 0 0 0 0 0

3244 8 LPoint4f 0 2048 8 LPoint4f 8 LPoint4f 0 0 0 0 0 0 0 0 0 0 0 0 220
////////////////////////////////////////////////////////////////////
//       Class : LPoint4
// Description : This is a four-component point in space.
////////////////////////////////////////////////////////////////////

3245 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3246 0 0 0 0 0 0 0 0 0 0

3246 9 LVector3d 0 2048 9 LVector3d 9 LVector3d 0 0 0 0 0 0 0 0 0 0 0 0 598
////////////////////////////////////////////////////////////////////
//       Class : LVector3
// Description : This is a three-component vector distance (as opposed
//               to a three-component point, which represents a
//               particular point in space).  Some of the methods are
//               slightly different between LPoint3 and LVector3; in
//               particular, subtraction of two points yields a
//               vector, while addition of a vector and a point yields
//               a point.
////////////////////////////////////////////////////////////////////

3247 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3248 0 0 0 0 0 0 0 0 0 0

3248 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 598
////////////////////////////////////////////////////////////////////
//       Class : LVector3
// Description : This is a three-component vector distance (as opposed
//               to a three-component point, which represents a
//               particular point in space).  Some of the methods are
//               slightly different between LPoint3 and LVector3; in
//               particular, subtraction of two points yields a
//               vector, while addition of a vector and a point yields
//               a point.
////////////////////////////////////////////////////////////////////

3249 21 TransformBlendTable * 0 8576 21 TransformBlendTable * 21 TransformBlendTable * 0 0 3062 0 0 0 0 0 0 0 0 0 0

3250 27 TransformBlendTable const * 0 8576 27 TransformBlendTable const * 27 TransformBlendTable const * 0 0 3251 0 0 0 0 0 0 0 0 0 0

3251 25 TransformBlendTable const 0 8832 25 TransformBlendTable const 25 TransformBlendTable const 0 0 3062 0 0 0 0 0 0 0 0 0 0

3252 19 SparseArray const * 0 8576 19 SparseArray const * 19 SparseArray const * 0 0 3253 0 0 0 0 0 0 0 0 0 0

3253 17 SparseArray const 0 8832 17 SparseArray const 17 SparseArray const 0 0 3254 0 0 0 0 0 0 0 0 0 0

3254 11 SparseArray 0 2048 11 SparseArray 11 SparseArray 0 0 0 0 0 0 0 0 0 0 0 0 1136
////////////////////////////////////////////////////////////////////
//       Class : SparseArray
// Description : This class records a set of integers, where each
//               integer is either present or not present in the set.
//
//               It is similar in principle and in interface to a
//               BitArray (which can be thought of as a set of
//               integers, one integer corresponding to each different
//               bit position), but the SparseArray is implemented as
//               a list of min/max subrange lists, rather than as a
//               bitmask.  
//
//               This makes it particularly efficient for storing sets
//               which consist of large sections of consecutively
//               included or consecutively excluded elements, with
//               arbitrarily large integers, but particularly
//               inefficient for doing boolean operations such as & or
//               |.
//
//               Also, unlike BitArray, the SparseArray can store
//               negative integers.
////////////////////////////////////////////////////////////////////

3255 13 SparseArray * 0 8576 13 SparseArray * 13 SparseArray * 0 0 3254 0 0 0 0 0 0 0 0 0 0

3256 20 VertexSlider const * 0 8576 20 VertexSlider const * 20 VertexSlider const * 0 0 3257 0 0 0 0 0 0 0 0 0 0

3257 18 VertexSlider const 0 8832 18 VertexSlider const 18 VertexSlider const 0 0 3063 0 0 0 0 0 0 0 0 0 0

3258 13 SliderTable * 0 8576 13 SliderTable * 13 SliderTable * 0 0 3064 0 0 0 0 0 0 0 0 0 0

3259 19 SliderTable const * 0 8576 19 SliderTable const * 19 SliderTable const * 0 0 3260 0 0 0 0 0 0 0 0 0 0

3260 17 SliderTable const 0 8832 17 SliderTable const 17 SliderTable const 0 0 3064 0 0 0 0 0 0 0 0 0 0

3261 16 GeomVertexData * 0 8576 16 GeomVertexData * 16 GeomVertexData * 0 0 3065 0 0 0 0 0 0 0 0 0 0

3262 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 3263 0 0 0 0 0 0 0 0 0 0

3263 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 3264 0 0 0 0 0 0 0 0 0 0

3264 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 3265 0 0 0 0 0 0 0 0 0 0

3265 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

3266 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3267 0 0 0 0 0 0 0 0 0 0

3267 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3268 0 0 0 0 0 0 0 0 0 0

3268 6 LColor 0 2105344 6 LColor 6 LColor 0 0 3269 0 0 0 0 0 0 0 0 0 0

3269 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 3265 0 0 0 0 0 0 0 0 0 0

3270 24 AnimateVerticesRequest * 0 8576 24 AnimateVerticesRequest * 24 AnimateVerticesRequest * 0 0 3066 0 0 0 0 0 0 0 0 0 0

3271 30 AnimateVerticesRequest const * 0 8576 30 AnimateVerticesRequest const * 30 AnimateVerticesRequest const * 0 0 3272 0 0 0 0 0 0 0 0 0 0

3272 28 AnimateVerticesRequest const 0 8832 28 AnimateVerticesRequest const 28 AnimateVerticesRequest const 0 0 3066 0 0 0 0 0 0 0 0 0 0

3273 21 BufferContext const * 0 8576 21 BufferContext const * 21 BufferContext const * 0 0 3274 0 0 0 0 0 0 0 0 0 0

3274 19 BufferContext const 0 8832 19 BufferContext const 19 BufferContext const 0 0 3070 0 0 0 0 0 0 0 0 0 0

3275 15 BufferContext * 0 8576 15 BufferContext * 15 BufferContext * 0 0 3070 0 0 0 0 0 0 0 0 0 0

3276 14 SavedContext * 0 8576 14 SavedContext * 14 SavedContext * 0 0 3068 0 0 0 0 0 0 0 0 0 0

3277 15 GeomPrimitive * 0 8576 15 GeomPrimitive * 15 GeomPrimitive * 0 0 3071 0 0 0 0 0 0 0 0 0 0

3278 21 GeomPrimitive const * 0 8576 21 GeomPrimitive const * 21 GeomPrimitive const * 0 0 3279 0 0 0 0 0 0 0 0 0 0

3279 19 GeomPrimitive const 0 8832 19 GeomPrimitive const 19 GeomPrimitive const 0 0 3071 0 0 0 0 0 0 0 0 0 0

3280 8 CPTA_int 0 2105344 8 CPTA_int 8 CPTA_int 0 0 3281 0 0 0 0 0 0 0 0 0 0

3281 26 ConstPointerToArray< int > 0 2048 26 ConstPointerToArray< int > 26 ConstPointerToArray< int > 0 0 0 0 0 0 0 0 0 0 0 0 0

3282 10 CPTA_int * 0 8576 10 CPTA_int * 10 CPTA_int * 0 0 3280 0 0 0 0 0 0 0 0 0 0

3283 7 PTA_int 0 2105344 7 PTA_int 7 PTA_int 0 0 3284 0 0 0 0 0 0 0 0 0 0

3284 21 PointerToArray< int > 0 2048 21 PointerToArray< int > 21 PointerToArray< int > 0 0 0 0 0 0 0 0 0 0 0 0 0

3285 9 PTA_int * 0 8576 9 PTA_int * 9 PTA_int * 0 0 3283 0 0 0 0 0 0 0 0 0 0

3286 14 TextureStage * 0 8576 14 TextureStage * 14 TextureStage * 0 0 3072 0 0 0 0 0 0 0 0 0 0

3287 20 TextureStage const * 0 8576 20 TextureStage const * 20 TextureStage const * 0 0 3288 0 0 0 0 0 0 0 0 0 0

3288 18 TextureStage const 0 8832 18 TextureStage const 18 TextureStage const 0 0 3072 0 0 0 0 0 0 0 0 0 0

3289 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3268 0 0 0 0 0 0 0 0 0 0

3290 6 Geom * 0 8576 6 Geom * 6 Geom * 0 0 3077 0 0 0 0 0 0 0 0 0 0

3291 12 Geom const * 0 8576 12 Geom const * 12 Geom const * 0 0 3292 0 0 0 0 0 0 0 0 0 0

3292 10 Geom const 0 8832 10 Geom const 10 Geom const 0 0 3077 0 0 0 0 0 0 0 0 0 0

3293 20 BoundingVolume const 0 8832 20 BoundingVolume const 20 BoundingVolume const 0 0 3294 0 0 0 0 0 0 0 0 0 0

3294 14 BoundingVolume 0 2048 14 BoundingVolume 14 BoundingVolume 0 0 0 0 0 0 0 0 0 0 0 0 596
////////////////////////////////////////////////////////////////////
//       Class : BoundingVolume
// Description : This is an abstract class for any volume in any sense
//               which can be said to define the locality of reference
//               of a node in a graph, along with all of its
//               descendants.  It is not necessarily a geometric
//               volume (although see GeometricBoundingVolume); this
//               is simply an abstract interface for bounds of any
//               sort.
////////////////////////////////////////////////////////////////////

3295 22 BoundingVolume const * 0 8576 22 BoundingVolume const * 22 BoundingVolume const * 0 0 3293 0 0 0 0 0 0 0 0 0 0

3296 10 BoundsType 0 794624 26 BoundingVolume::BoundsType 26 BoundingVolume::BoundsType 3294 0 0 0 0 0 0 0 0 0 5 10 BT_default 26 BoundingVolume::BT_default 0
0 7 BT_best 23 BoundingVolume::BT_best 0
1 9 BT_sphere 25 BoundingVolume::BT_sphere 0
2 6 BT_box 22 BoundingVolume::BT_box 0
3 10 BT_fastest 26 BoundingVolume::BT_fastest 0
4 0 80
// This enum is used to control the automatic generation of bounding
// volumes.

3297 13 GeomContext * 0 8576 13 GeomContext * 13 GeomContext * 0 0 3078 0 0 0 0 0 0 0 0 0 0

3298 19 GeomContext const * 0 8576 19 GeomContext const * 19 GeomContext const * 0 0 3299 0 0 0 0 0 0 0 0 0 0

3299 17 GeomContext const 0 8832 17 GeomContext const 17 GeomContext const 0 0 3078 0 0 0 0 0 0 0 0 0 0

3300 11 GeomLines * 0 8576 11 GeomLines * 11 GeomLines * 0 0 3079 0 0 0 0 0 0 0 0 0 0

3301 17 GeomLines const * 0 8576 17 GeomLines const * 17 GeomLines const * 0 0 3302 0 0 0 0 0 0 0 0 0 0

3302 15 GeomLines const 0 8832 15 GeomLines const 15 GeomLines const 0 0 3079 0 0 0 0 0 0 0 0 0 0

3303 16 GeomLinestrips * 0 8576 16 GeomLinestrips * 16 GeomLinestrips * 0 0 3080 0 0 0 0 0 0 0 0 0 0

3304 22 GeomLinestrips const * 0 8576 22 GeomLinestrips const * 22 GeomLinestrips const * 0 0 3305 0 0 0 0 0 0 0 0 0 0

3305 20 GeomLinestrips const 0 8832 20 GeomLinestrips const 20 GeomLinestrips const 0 0 3080 0 0 0 0 0 0 0 0 0 0

3306 19 GeomPatches const * 0 8576 19 GeomPatches const * 19 GeomPatches const * 0 0 3307 0 0 0 0 0 0 0 0 0 0

3307 17 GeomPatches const 0 8832 17 GeomPatches const 17 GeomPatches const 0 0 3081 0 0 0 0 0 0 0 0 0 0

3308 13 GeomPatches * 0 8576 13 GeomPatches * 13 GeomPatches * 0 0 3081 0 0 0 0 0 0 0 0 0 0

3309 12 GeomPoints * 0 8576 12 GeomPoints * 12 GeomPoints * 0 0 3082 0 0 0 0 0 0 0 0 0 0

3310 18 GeomPoints const * 0 8576 18 GeomPoints const * 18 GeomPoints const * 0 0 3311 0 0 0 0 0 0 0 0 0 0

3311 16 GeomPoints const 0 8832 16 GeomPoints const 16 GeomPoints const 0 0 3082 0 0 0 0 0 0 0 0 0 0

3312 15 GeomTriangles * 0 8576 15 GeomTriangles * 15 GeomTriangles * 0 0 3083 0 0 0 0 0 0 0 0 0 0

3313 21 GeomTriangles const * 0 8576 21 GeomTriangles const * 21 GeomTriangles const * 0 0 3314 0 0 0 0 0 0 0 0 0 0

3314 19 GeomTriangles const 0 8832 19 GeomTriangles const 19 GeomTriangles const 0 0 3083 0 0 0 0 0 0 0 0 0 0

3315 13 GeomTrifans * 0 8576 13 GeomTrifans * 13 GeomTrifans * 0 0 3084 0 0 0 0 0 0 0 0 0 0

3316 19 GeomTrifans const * 0 8576 19 GeomTrifans const * 19 GeomTrifans const * 0 0 3317 0 0 0 0 0 0 0 0 0 0

3317 17 GeomTrifans const 0 8832 17 GeomTrifans const 17 GeomTrifans const 0 0 3084 0 0 0 0 0 0 0 0 0 0

3318 15 GeomTristrips * 0 8576 15 GeomTristrips * 15 GeomTristrips * 0 0 3085 0 0 0 0 0 0 0 0 0 0

3319 21 GeomTristrips const * 0 8576 21 GeomTristrips const * 21 GeomTristrips const * 0 0 3320 0 0 0 0 0 0 0 0 0 0

3320 19 GeomTristrips const 0 8832 19 GeomTristrips const 19 GeomTristrips const 0 0 3085 0 0 0 0 0 0 0 0 0 0

3321 18 GeomVertexReader * 0 8576 18 GeomVertexReader * 18 GeomVertexReader * 0 0 3086 0 0 0 0 0 0 0 0 0 0

3322 24 GeomVertexReader const * 0 8576 24 GeomVertexReader const * 24 GeomVertexReader const * 0 0 3323 0 0 0 0 0 0 0 0 0 0

3323 22 GeomVertexReader const 0 8832 22 GeomVertexReader const 22 GeomVertexReader const 0 0 3086 0 0 0 0 0 0 0 0 0 0

3324 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3325 0 0 0 0 0 0 0 0 0 0

3325 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3326 0 0 0 0 0 0 0 0 0 0

3326 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 263
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

3327 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3328 0 0 0 0 0 0 0 0 0 0

3328 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3329 0 0 0 0 0 0 0 0 0 0

3329 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

3330 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3331 0 0 0 0 0 0 0 0 0 0

3331 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3265 0 0 0 0 0 0 0 0 0 0

3332 9 LMatrix3f 0 2048 9 LMatrix3f 9 LMatrix3f 0 0 0 0 0 0 0 4 3515 3516 3517 3518 0 0 0 0 462
////////////////////////////////////////////////////////////////////
//       Class : LMatrix3
// Description : This is a 3-by-3 transform matrix.  It typically will
//               represent either a rotation-and-scale (no
//               translation) matrix in 3-d, or a full affine matrix
//               (rotation, scale, translation) in 2-d, e.g. for a
//               texture matrix.
////////////////////////////////////////////////////////////////////

3333 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3332 0 0 0 0 0 0 0 0 0 0

3334 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3228 0 0 0 0 0 0 0 0 0 0

3335 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3336 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3337 0 0 0 0 0 0 0 0 0 0

3337 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3338 0 0 0 0 0 0 0 0 0 0

3338 10 LVecBase2d 0 2048 10 LVecBase2d 10 LVecBase2d 0 0 0 0 0 0 0 0 0 0 0 0 263
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

3339 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3340 0 0 0 0 0 0 0 0 0 0

3340 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3341 0 0 0 0 0 0 0 0 0 0

3341 10 LVecBase3d 0 2048 10 LVecBase3d 10 LVecBase3d 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

3342 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3343 0 0 0 0 0 0 0 0 0 0

3343 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3344 0 0 0 0 0 0 0 0 0 0

3344 10 LVecBase4d 0 2048 10 LVecBase4d 10 LVecBase4d 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

3345 9 LMatrix3d 0 2048 9 LMatrix3d 9 LMatrix3d 0 0 0 0 0 0 0 4 3519 3520 3521 3522 0 0 0 0 462
////////////////////////////////////////////////////////////////////
//       Class : LMatrix3
// Description : This is a 3-by-3 transform matrix.  It typically will
//               represent either a rotation-and-scale (no
//               translation) matrix in 3-d, or a full affine matrix
//               (rotation, scale, translation) in 2-d, e.g. for a
//               texture matrix.
////////////////////////////////////////////////////////////////////

3346 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3345 0 0 0 0 0 0 0 0 0 0

3347 9 LMatrix4d 0 2048 9 LMatrix4d 9 LMatrix4d 0 0 0 0 0 0 0 3 3523 3524 3525 0 0 0 0 215
////////////////////////////////////////////////////////////////////
//       Class : LMatrix4
// Description : This is a 4-by-4 transform matrix.
////////////////////////////////////////////////////////////////////

3348 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3347 0 0 0 0 0 0 0 0 0 0

3349 17 LVecBase2 const * 0 8576 17 LVecBase2 const * 17 LVecBase2 const * 0 0 3350 0 0 0 0 0 0 0 0 0 0

3350 15 LVecBase2 const 0 8832 15 LVecBase2 const 15 LVecBase2 const 0 0 3351 0 0 0 0 0 0 0 0 0 0

3351 9 LVecBase2 0 2105344 9 LVecBase2 9 LVecBase2 0 0 3326 0 0 0 0 0 0 0 0 0 0

3352 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 3353 0 0 0 0 0 0 0 0 0 0

3353 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 3354 0 0 0 0 0 0 0 0 0 0

3354 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 3329 0 0 0 0 0 0 0 0 0 0

3355 8 LMatrix3 0 2105344 8 LMatrix3 8 LMatrix3 0 0 3332 0 0 0 0 0 0 0 0 0 0

3356 10 LMatrix3 * 0 8576 10 LMatrix3 * 10 LMatrix3 * 0 0 3355 0 0 0 0 0 0 0 0 0 0

3357 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3358 0 0 0 0 0 0 0 0 0 0

3358 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3359 0 0 0 0 0 0 0 0 0 0

3359 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 263
////////////////////////////////////////////////////////////////////
//       Class : LVecBase2
// Description : This is the base class for all two-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

3360 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3361 0 0 0 0 0 0 0 0 0 0

3361 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3362 0 0 0 0 0 0 0 0 0 0

3362 10 LVecBase3i 0 2048 10 LVecBase3i 10 LVecBase3i 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase3
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

3363 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3364 0 0 0 0 0 0 0 0 0 0

3364 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3365 0 0 0 0 0 0 0 0 0 0

3365 10 LVecBase4i 0 2048 10 LVecBase4i 10 LVecBase4i 0 0 0 0 0 0 0 0 0 0 0 0 265
////////////////////////////////////////////////////////////////////
//       Class : LVecBase4
// Description : This is the base class for all three-component
//               vectors and points.
////////////////////////////////////////////////////////////////////

3366 18 GeomVertexWriter * 0 8576 18 GeomVertexWriter * 18 GeomVertexWriter * 0 0 3087 0 0 0 0 0 0 0 0 0 0

3367 24 GeomVertexWriter const * 0 8576 24 GeomVertexWriter const * 24 GeomVertexWriter const * 0 0 3368 0 0 0 0 0 0 0 0 0 0

3368 22 GeomVertexWriter const 0 8832 22 GeomVertexWriter const 22 GeomVertexWriter const 0 0 3087 0 0 0 0 0 0 0 0 0 0

3369 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3370 0 0 0 0 0 0 0 0 0 0

3370 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3332 0 0 0 0 0 0 0 0 0 0

3371 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3372 0 0 0 0 0 0 0 0 0 0

3372 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3228 0 0 0 0 0 0 0 0 0 0

3373 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3374 0 0 0 0 0 0 0 0 0 0

3374 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3345 0 0 0 0 0 0 0 0 0 0

3375 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3376 0 0 0 0 0 0 0 0 0 0

3376 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3347 0 0 0 0 0 0 0 0 0 0

3377 16 LMatrix3 const * 0 8576 16 LMatrix3 const * 16 LMatrix3 const * 0 0 3378 0 0 0 0 0 0 0 0 0 0

3378 14 LMatrix3 const 0 8832 14 LMatrix3 const 14 LMatrix3 const 0 0 3355 0 0 0 0 0 0 0 0 0 0

3379 20 GeomVertexRewriter * 0 8576 20 GeomVertexRewriter * 20 GeomVertexRewriter * 0 0 3088 0 0 0 0 0 0 0 0 0 0

3380 26 GeomVertexRewriter const * 0 8576 26 GeomVertexRewriter const * 26 GeomVertexRewriter const * 0 0 3381 0 0 0 0 0 0 0 0 0 0

3381 24 GeomVertexRewriter const 0 8832 24 GeomVertexRewriter const 24 GeomVertexRewriter const 0 0 3088 0 0 0 0 0 0 0 0 0 0

3382 14 SamplerState * 0 8576 14 SamplerState * 14 SamplerState * 0 0 3089 0 0 0 0 0 0 0 0 0 0

3383 20 SamplerState const * 0 8576 20 SamplerState const * 20 SamplerState const * 0 0 3384 0 0 0 0 0 0 0 0 0 0

3384 18 SamplerState const 0 8832 18 SamplerState const 18 SamplerState const 0 0 3089 0 0 0 0 0 0 0 0 0 0

3385 16 SamplerContext * 0 8576 16 SamplerContext * 16 SamplerContext * 0 0 3386 0 0 0 0 0 0 0 0 0 0

3386 14 SamplerContext 0 1050624 14 SamplerContext 14 SamplerContext 0 0 0 0 0 0 0 0 0 0 0 0 779
////////////////////////////////////////////////////////////////////
//       Class : SamplerContext
// Description : This is a special class object that holds a handle
//               to the sampler state object given by the graphics
//               back-end for a particular combination of texture
//               sampling settings.
//
//               Some graphics back-ends (like OpenGL) use mutable
//               sampler objects, whereas others (Direct3D 10+) use
//               immutable ones.  In Panda3D, each unique sampler
//               state has its own SamplerContext, which simplifies
//               the implementation and makes redundant sampler
//               objects impossible.
////////////////////////////////////////////////////////////////////

3387 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 3092 0 0 0 0 0 0 0 0 0 0

3388 15 Texture const * 0 8576 15 Texture const * 15 Texture const * 0 0 3389 0 0 0 0 0 0 0 0 0 0

3389 13 Texture const 0 8832 13 Texture const 13 Texture const 0 0 3092 0 0 0 0 0 0 0 0 0 0

3390 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 3391 0 0 0 0 0 0 0 0 0 0

3391 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 3392 0 0 0 0 0 0 0 0 0 0

3392 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 869
////////////////////////////////////////////////////////////////////
//       Class : Filename
// Description : The name of a file, such as a texture file or an Egg
//               file.  Stores the full pathname, and includes
//               functions for extracting out the directory prefix
//               part and the file extension and stuff.
//
//               A Filename is also aware of the mapping between the
//               Unix-like filename convention we use internally, and
//               the local OS's specific filename convention, and it
//               knows how to perform basic OS-specific I/O, like
//               testing for file existence and searching a
//               searchpath, as well as the best way to open an
//               fstream for reading or writing.
////////////////////////////////////////////////////////////////////

3393 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 3394 0 0 0 0 0 0 0 0 0 0

3394 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 3395 0 0 0 0 0 0 0 0 0 0

3395 13 LoaderOptions 0 2048 13 LoaderOptions 13 LoaderOptions 0 0 0 0 0 0 0 0 0 0 0 0 257
////////////////////////////////////////////////////////////////////
//       Class : LoaderOptions
// Description : Specifies parameters that may be passed to the
//               loader.
////////////////////////////////////////////////////////////////////

3396 16 BamCacheRecord * 0 8576 16 BamCacheRecord * 16 BamCacheRecord * 0 0 3397 0 0 0 0 0 0 0 0 0 0

3397 14 BamCacheRecord 0 2048 14 BamCacheRecord 14 BamCacheRecord 0 0 0 0 0 0 0 0 0 0 0 0 469
////////////////////////////////////////////////////////////////////
//       Class : BamCacheRecord
// Description : An instance of this class is written to the front of
//               a Bam or Txo file to make the file a cached instance
//               of some other loadable resource.  This record
//               contains information needed to test the validity of
//               the cache.
////////////////////////////////////////////////////////////////////

3398 9 istream * 0 8576 9 istream * 9 istream * 0 0 3399 0 0 0 0 0 0 0 0 0 0

3399 7 istream 0 2048 7 istream 7 istream 0 0 0 0 0 0 0 0 0 0 0 0 0

3400 16 PNMImage const * 0 8576 16 PNMImage const * 16 PNMImage const * 0 0 3401 0 0 0 0 0 0 0 0 0 0

3401 14 PNMImage const 0 8832 14 PNMImage const 14 PNMImage const 0 0 3402 0 0 0 0 0 0 0 0 0 0

3402 8 PNMImage 0 2048 8 PNMImage 8 PNMImage 0 0 0 0 0 0 0 0 0 0 0 0 2116
////////////////////////////////////////////////////////////////////
//       Class : PNMImage
// Description : The name of this class derives from the fact that we
//               originally implemented it as a layer on top of the
//               "pnm library", based on netpbm, which was built to
//               implement pbm, pgm, and pbm files, and is the
//               underlying support of a number of public-domain image
//               file converters.  Nowadays we are no longer derived
//               directly from the pnm library, mainly to allow
//               support of C++ iostreams instead of the C stdio FILE
//               interface.
//
//               Conceptually, a PNMImage is a two-dimensional array
//               of xels, which are the PNM-defined generic pixel
//               type.  Each xel may have a red, green, and blue
//               component, or (if the image is grayscale) a gray
//               component.  The image may be read in, the individual
//               xels manipulated, and written out again, or a black
//               image may be constructed from scratch.
//
//               A PNMImage has a color space and a maxval, the
//               combination of which defines how a floating-point
//               linear color value is encoded as an integer value in
//               memory.  The functions ending in _val operate on
//               encoded colors, whereas the regular ones work with
//               linear floating-point values.  All operations are
//               color space correct unless otherwise specified.
//
//               The image is of size XSize() by YSize() xels,
//               numbered from top to bottom, left to right, beginning
//               at zero.
//
//               Files can be specified by filename, or by an iostream
//               pointer.  The filename "-" refers to stdin or stdout.
//
//               This class is not inherently thread-safe; use it
//               from a single thread or protect access using a mutex.
////////////////////////////////////////////////////////////////////

3403 15 PfmFile const * 0 8576 15 PfmFile const * 15 PfmFile const * 0 0 3404 0 0 0 0 0 0 0 0 0 0

3404 13 PfmFile const 0 8832 13 PfmFile const 13 PfmFile const 0 0 3405 0 0 0 0 0 0 0 0 0 0

3405 7 PfmFile 0 2048 7 PfmFile 7 PfmFile 0 0 0 0 0 0 0 0 0 0 0 0 355
////////////////////////////////////////////////////////////////////
//       Class : PfmFile
// Description : Defines a pfm file, a 2-d table of floating-point
//               numbers, either 3-component or 1-component, or with a
//               special extension, 2- or 4-component.
////////////////////////////////////////////////////////////////////

3406 10 PNMImage * 0 8576 10 PNMImage * 10 PNMImage * 0 0 3402 0 0 0 0 0 0 0 0 0 0

3407 9 PfmFile * 0 8576 9 PfmFile * 9 PfmFile * 0 0 3405 0 0 0 0 0 0 0 0 0 0

3408 8 WrapMode 0 2367488 17 Texture::WrapMode 17 Texture::WrapMode 3092 0 3091 0 0 0 0 0 0 0 0 0 0

3409 10 FilterType 0 2367488 19 Texture::FilterType 19 Texture::FilterType 3092 0 3090 0 0 0 0 0 0 0 0 0 0

3410 10 CPTA_uchar 0 2105344 10 CPTA_uchar 10 CPTA_uchar 0 0 3411 0 0 0 0 0 0 0 0 0 0

3411 36 ConstPointerToArray< unsigned char > 0 2048 36 ConstPointerToArray< unsigned char > 36 ConstPointerToArray< unsigned char > 0 0 0 0 0 0 0 0 0 0 0 0 0

3412 12 CPTA_uchar * 0 8576 12 CPTA_uchar * 12 CPTA_uchar * 0 0 3410 0 0 0 0 0 0 0 0 0 0

3413 9 PTA_uchar 0 2105344 9 PTA_uchar 9 PTA_uchar 0 0 3414 0 0 0 0 0 0 0 0 0 0

3414 31 PointerToArray< unsigned char > 0 2048 31 PointerToArray< unsigned char > 31 PointerToArray< unsigned char > 0 0 0 0 0 0 0 0 0 0 0 0 0

3415 11 PTA_uchar * 0 8576 11 PTA_uchar * 11 PTA_uchar * 0 0 3413 0 0 0 0 0 0 0 0 0 0

3416 13 long long int 0 8226 13 long long int 13 long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

3417 15 TexturePeeker * 0 8576 15 TexturePeeker * 15 TexturePeeker * 0 0 3128 0 0 0 0 0 0 0 0 0 0

3418 16 AutoTextureScale 0 532480 16 AutoTextureScale 16 AutoTextureScale 0 0 0 0 0 0 0 0 0 0 5 8 ATS_none 8 ATS_none 0
0 8 ATS_down 8 ATS_down 0
1 6 ATS_up 6 ATS_up 0
2 7 ATS_pad 7 ATS_pad 0
3 15 ATS_unspecified 15 ATS_unspecified 0
4 0 0

3419 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 3420 0 0 0 0 0 0 0 0 0 0

3420 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 710
////////////////////////////////////////////////////////////////////
//       Class : TypedReferenceCount
// Description : A base class for things which need to inherit from
//               both TypedObject and from ReferenceCount.  It's
//               convenient to define this intermediate base class
//               instead of multiply inheriting from the two classes
//               each time they are needed, so that we can sensibly
//               pass around pointers to things which are both
//               TypedObjects and ReferenceCounters.
//               
//               See also TypedObject for detailed instructions.
////////////////////////////////////////////////////////////////////

3421 11 LVecBase2 * 0 8576 11 LVecBase2 * 11 LVecBase2 * 0 0 3351 0 0 0 0 0 0 0 0 0 0

3422 16 TextureContext * 0 8576 16 TextureContext * 16 TextureContext * 0 0 3119 0 0 0 0 0 0 0 0 0 0

3423 8 Shader * 0 8576 8 Shader * 8 Shader * 0 0 3100 0 0 0 0 0 0 0 0 0 0

3424 14 Shader const * 0 8576 14 Shader const * 14 Shader const * 0 0 3425 0 0 0 0 0 0 0 0 0 0

3425 12 Shader const 0 8832 12 Shader const 12 Shader const 0 0 3100 0 0 0 0 0 0 0 0 0 0

3426 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 3392 0 0 0 0 0 0 0 0 0 0

3427 15 ShaderContext * 0 8576 15 ShaderContext * 15 ShaderContext * 0 0 3120 0 0 0 0 0 0 0 0 0 0

3428 31 PreparedGraphicsObjects const * 0 8576 31 PreparedGraphicsObjects const * 31 PreparedGraphicsObjects const * 0 0 3429 0 0 0 0 0 0 0 0 0 0

3429 29 PreparedGraphicsObjects const 0 8832 29 PreparedGraphicsObjects const 29 PreparedGraphicsObjects const 0 0 3105 0 0 0 0 0 0 0 0 0 0

3430 20 IndexBufferContext * 0 8576 20 IndexBufferContext * 20 IndexBufferContext * 0 0 3106 0 0 0 0 0 0 0 0 0 0

3431 26 IndexBufferContext const * 0 8576 26 IndexBufferContext const * 26 IndexBufferContext const * 0 0 3432 0 0 0 0 0 0 0 0 0 0

3432 24 IndexBufferContext const 0 8832 24 IndexBufferContext const 24 IndexBufferContext const 0 0 3106 0 0 0 0 0 0 0 0 0 0

3433 35 GeomPrimitivePipelineReader const * 0 8576 35 GeomPrimitivePipelineReader const * 35 GeomPrimitivePipelineReader const * 0 0 3434 0 0 0 0 0 0 0 0 0 0

3434 33 GeomPrimitivePipelineReader const 0 8832 33 GeomPrimitivePipelineReader const 33 GeomPrimitivePipelineReader const 0 0 3435 0 0 0 0 0 0 0 0 0 0

3435 27 GeomPrimitivePipelineReader 0 1050624 27 GeomPrimitivePipelineReader 27 GeomPrimitivePipelineReader 0 0 0 0 0 0 0 0 0 0 0 0 303
////////////////////////////////////////////////////////////////////
//       Class : GeomPrimitivePipelineReader
// Description : Encapsulates the data from a GeomPrimitive,
//               pre-fetched for one stage of the pipeline.
////////////////////////////////////////////////////////////////////

3436 12 Lens const * 0 8576 12 Lens const * 12 Lens const * 0 0 3437 0 0 0 0 0 0 0 0 0 0

3437 10 Lens const 0 8832 10 Lens const 10 Lens const 0 0 3107 0 0 0 0 0 0 0 0 0 0

3438 6 Lens * 0 8576 6 Lens * 6 Lens * 0 0 3107 0 0 0 0 0 0 0 0 0 0

3439 15 LPoint2 const * 0 8576 15 LPoint2 const * 15 LPoint2 const * 0 0 3440 0 0 0 0 0 0 0 0 0 0

3440 13 LPoint2 const 0 8832 13 LPoint2 const 13 LPoint2 const 0 0 3441 0 0 0 0 0 0 0 0 0 0

3441 7 LPoint2 0 2105344 7 LPoint2 7 LPoint2 0 0 3442 0 0 0 0 0 0 0 0 0 0

3442 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 219
////////////////////////////////////////////////////////////////////
//       Class : LPoint2
// Description : This is a two-component point in space.
////////////////////////////////////////////////////////////////////

3443 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 3444 0 0 0 0 0 0 0 0 0 0

3444 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 3240 0 0 0 0 0 0 0 0 0 0

3445 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 3446 0 0 0 0 0 0 0 0 0 0

3446 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 3444 0 0 0 0 0 0 0 0 0 0

3447 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 3448 0 0 0 0 0 0 0 0 0 0

3448 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 3248 0 0 0 0 0 0 0 0 0 0

3449 9 LPoint2 * 0 8576 9 LPoint2 * 9 LPoint2 * 0 0 3441 0 0 0 0 0 0 0 0 0 0

3450 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 213
// The CS_default entry does not refer to a particular coordinate
// system, but rather to the value stored in
// default_coordinate_system, which in turn is loaded from the
// config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 0
1 12 CS_yup_right 12 CS_yup_right 0
2 11 CS_zup_left 11 CS_zup_left 0
3 11 CS_yup_left 11 CS_yup_left 0
4 10 CS_invalid 10 CS_invalid 155
// CS_invalid is not a coordinate system at all.  It can be used in
// user-input processing code to indicate a contradictory coordinate
// system request.
5 0 0

3451 16 LVector2 const * 0 8576 16 LVector2 const * 16 LVector2 const * 0 0 3452 0 0 0 0 0 0 0 0 0 0

3452 14 LVector2 const 0 8832 14 LVector2 const 14 LVector2 const 0 0 3453 0 0 0 0 0 0 0 0 0 0

3453 8 LVector2 0 2105344 8 LVector2 8 LVector2 0 0 3454 0 0 0 0 0 0 0 0 0 0

3454 9 LVector2f 0 2048 9 LVector2f 9 LVector2f 0 0 0 0 0 0 0 0 0 0 0 0 219
////////////////////////////////////////////////////////////////////
//       Class : LVector2
// Description : This is a two-component vector offset.
////////////////////////////////////////////////////////////////////

3455 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 3456 0 0 0 0 0 0 0 0 0 0

3456 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 3448 0 0 0 0 0 0 0 0 0 0

3457 16 BoundingVolume * 0 8576 16 BoundingVolume * 16 BoundingVolume * 0 0 3294 0 0 0 0 0 0 0 0 0 0

3458 16 Material const * 0 8576 16 Material const * 16 Material const * 0 0 3459 0 0 0 0 0 0 0 0 0 0

3459 14 Material const 0 8832 14 Material const 14 Material const 0 0 3110 0 0 0 0 0 0 0 0 0 0

3460 10 Material * 0 8576 10 Material * 10 Material * 0 0 3110 0 0 0 0 0 0 0 0 0 0

3461 12 MatrixLens * 0 8576 12 MatrixLens * 12 MatrixLens * 0 0 3112 0 0 0 0 0 0 0 0 0 0

3462 18 MatrixLens const * 0 8576 18 MatrixLens const * 18 MatrixLens const * 0 0 3463 0 0 0 0 0 0 0 0 0 0

3463 16 MatrixLens const 0 8832 16 MatrixLens const 16 MatrixLens const 0 0 3112 0 0 0 0 0 0 0 0 0 0

3464 18 OrthographicLens * 0 8576 18 OrthographicLens * 18 OrthographicLens * 0 0 3113 0 0 0 0 0 0 0 0 0 0

3465 21 ParamTextureSampler * 0 8576 21 ParamTextureSampler * 21 ParamTextureSampler * 0 0 3114 0 0 0 0 0 0 0 0 0 0

3466 27 ParamTextureSampler const * 0 8576 27 ParamTextureSampler const * 27 ParamTextureSampler const * 0 0 3467 0 0 0 0 0 0 0 0 0 0

3467 25 ParamTextureSampler const 0 8832 25 ParamTextureSampler const 25 ParamTextureSampler const 0 0 3114 0 0 0 0 0 0 0 0 0 0

3468 19 ParamTextureImage * 0 8576 19 ParamTextureImage * 19 ParamTextureImage * 0 0 3116 0 0 0 0 0 0 0 0 0 0

3469 25 ParamTextureImage const * 0 8576 25 ParamTextureImage const * 25 ParamTextureImage const * 0 0 3470 0 0 0 0 0 0 0 0 0 0

3470 23 ParamTextureImage const 0 8832 23 ParamTextureImage const 23 ParamTextureImage const 0 0 3116 0 0 0 0 0 0 0 0 0 0

3471 17 PerspectiveLens * 0 8576 17 PerspectiveLens * 17 PerspectiveLens * 0 0 3117 0 0 0 0 0 0 0 0 0 0

3472 22 TextureReloadRequest * 0 8576 22 TextureReloadRequest * 22 TextureReloadRequest * 0 0 3118 0 0 0 0 0 0 0 0 0 0

3473 28 TextureReloadRequest const * 0 8576 28 TextureReloadRequest const * 28 TextureReloadRequest const * 0 0 3474 0 0 0 0 0 0 0 0 0 0

3474 26 TextureReloadRequest const 0 8832 26 TextureReloadRequest const 26 TextureReloadRequest const 0 0 3118 0 0 0 0 0 0 0 0 0 0

3475 22 TextureContext const * 0 8576 22 TextureContext const * 22 TextureContext const * 0 0 3476 0 0 0 0 0 0 0 0 0 0

3476 20 TextureContext const 0 8832 20 TextureContext const 20 TextureContext const 0 0 3119 0 0 0 0 0 0 0 0 0 0

3477 21 ShaderContext const * 0 8576 21 ShaderContext const * 21 ShaderContext const * 0 0 3478 0 0 0 0 0 0 0 0 0 0

3478 19 ShaderContext const 0 8832 19 ShaderContext const 19 ShaderContext const 0 0 3120 0 0 0 0 0 0 0 0 0 0

3479 18 UserVertexSlider * 0 8576 18 UserVertexSlider * 18 UserVertexSlider * 0 0 3121 0 0 0 0 0 0 0 0 0 0

3480 21 UserVertexTransform * 0 8576 21 UserVertexTransform * 21 UserVertexTransform * 0 0 3122 0 0 0 0 0 0 0 0 0 0

3481 27 UserVertexTransform const * 0 8576 27 UserVertexTransform const * 27 UserVertexTransform const * 0 0 3482 0 0 0 0 0 0 0 0 0 0

3482 25 UserVertexTransform const 0 8832 25 UserVertexTransform const 25 UserVertexTransform const 0 0 3122 0 0 0 0 0 0 0 0 0 0

3483 20 VideoTexture const * 0 8576 20 VideoTexture const * 20 VideoTexture const * 0 0 3484 0 0 0 0 0 0 0 0 0 0

3484 18 VideoTexture const 0 8832 18 VideoTexture const 18 VideoTexture const 0 0 3123 0 0 0 0 0 0 0 0 0 0

3485 14 VideoTexture * 0 8576 14 VideoTexture * 14 VideoTexture * 0 0 3123 0 0 0 0 0 0 0 0 0 0

3486 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 3124 0 0 0 0 0 0 0 0 0 0

3487 27 VertexBufferContext const * 0 8576 27 VertexBufferContext const * 27 VertexBufferContext const * 0 0 3488 0 0 0 0 0 0 0 0 0 0

3488 25 VertexBufferContext const 0 8832 25 VertexBufferContext const 25 VertexBufferContext const 0 0 3125 0 0 0 0 0 0 0 0 0 0

3489 19 TextureCollection * 0 8576 19 TextureCollection * 19 TextureCollection * 0 0 3126 0 0 0 0 0 0 0 0 0 0

3490 25 TextureCollection const * 0 8576 25 TextureCollection const * 25 TextureCollection const * 0 0 3491 0 0 0 0 0 0 0 0 0 0

3491 23 TextureCollection const 0 8832 23 TextureCollection const 23 TextureCollection const 0 0 3126 0 0 0 0 0 0 0 0 0 0

3492 21 TexturePeeker const * 0 8576 21 TexturePeeker const * 21 TexturePeeker const * 0 0 3493 0 0 0 0 0 0 0 0 0 0

3493 19 TexturePeeker const 0 8832 19 TexturePeeker const 19 TexturePeeker const 0 0 3128 0 0 0 0 0 0 0 0 0 0

3494 30 ConstPointerTo< InternalName > 0 2048 30 ConstPointerTo< InternalName > 30 ConstPointerTo< InternalName > 0 0 0 0 0 0 0 0 0 0 0 0 0

0
0
31
3495 0 0 122 11 get_columns 15 get_num_columns 10 get_column 
3496 0 0 155 10 get_arrays 14 get_num_arrays 9 get_array 
3497 0 0 155 11 get_columns 15 get_num_columns 10 get_column 
3498 0 0 155 10 get_points 14 get_num_points 9 get_point 
3499 0 0 155 11 get_vectors 15 get_num_vectors 10 get_vector 
3500 0 0 155 13 get_texcoords 17 get_num_texcoords 12 get_texcoord 
3501 0 0 155 17 get_morph_sliders 14 get_num_morphs 16 get_morph_slider 
3502 0 0 155 15 get_morph_bases 14 get_num_morphs 14 get_morph_base 
3503 0 0 155 16 get_morph_deltas 14 get_num_morphs 15 get_morph_delta 
3504 0 0 402 14 get_transforms 18 get_num_transforms 13 get_transform 
3505 0 0 415 14 get_transforms 18 get_num_transforms 13 get_transform 
3506 0 0 441 10 get_blends 14 get_num_blends 9 get_blend 
3507 0 0 464 11 get_sliders 15 get_num_sliders 10 get_slider 
3508 0 0 482 10 get_arrays 14 get_num_arrays 9 get_array 
3509 0 0 559 15 get_vertex_list 16 get_num_vertices 10 get_vertex 
3510 0 0 697 14 get_primitives 18 get_num_primitives 13 get_primitive 
3511 0 0 1517 12 get_textures 16 get_num_textures 11 get_texture 
3512 0 0 2053 8 get_rows 4 size 7 get_row 
3513 0 0 2053 8 get_cols 4 size 7 get_col 
3514 0 0 2053 9 get_row3s 4 size 8 get_row3 
3515 0 0 2593 8 get_rows 4 size 7 get_row 
3516 0 0 2593 8 get_cols 4 size 7 get_col 
3517 0 0 2593 9 get_col2s 4 size 8 get_col2 
3518 0 0 2593 9 get_row2s 4 size 8 get_row2 
3519 0 0 2612 8 get_rows 4 size 7 get_row 
3520 0 0 2612 8 get_cols 4 size 7 get_col 
3521 0 0 2612 9 get_col2s 4 size 8 get_col2 
3522 0 0 2612 9 get_row2s 4 size 8 get_row2 
3523 0 0 2615 8 get_rows 4 size 7 get_row 
3524 0 0 2615 8 get_cols 4 size 7 get_col 
3525 0 0 2615 9 get_row3s 4 size 8 get_row3 
