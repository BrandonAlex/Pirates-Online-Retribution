;; -*- scheme -*-

(include "cogl-base-types.defs")


;; From cogl-bitmap.h

(define-function bitmap_new_from_file
  (c-name "cogl_bitmap_new_from_file")
  (docstring
  "Loads an image file from disk. This function can be safely called from\n"
  "within a thread. COGL_INVALID_HANDLE if loading the image failed.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("const-gchar*" "filename")
    '("GError**" "error")
  )
)

(define-function bitmap_get_size_from_file
  (c-name "cogl_bitmap_get_size_from_file")
  (docstring
  "Parses an image file enough to extract the width and height of the\n"
  "bitmap.\n"
  )
  (return-type "gboolean")
  (parameters
    '("const-gchar*" "filename")
    '("gint*" "width")
    '("gint*" "height")
  )
)

(define-function is_bitmap
  (c-name "cogl_is_bitmap")
  (docstring
  "Checks whether handle is a CoglHandle for a bitmap and FALSE otherwise\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
  )
)


;; From cogl-color.h

(define-function color_new
  (c-name "cogl_color_new")
  (is-constructor-of "CoglColor")
  (return-type "CoglColor*")
)

(define-method copy
  (of-object "CoglColor")
  (c-name "cogl_color_copy")
  (return-type "CoglColor*")
)

(define-method free
  (of-object "CoglColor")
  (c-name "cogl_color_free")
  (return-type "none")
)

(define-method set_from_4ub
  (of-object "CoglColor")
  (c-name "cogl_color_set_from_4ub")
  (return-type "none")
  (parameters
    '("guint8" "red")
    '("guint8" "green")
    '("guint8" "blue")
    '("guint8" "alpha")
  )
)

(define-method set_from_4f
  (of-object "CoglColor")
  (c-name "cogl_color_set_from_4f")
  (return-type "none")
  (parameters
    '("float" "red")
    '("float" "green")
    '("float" "blue")
    '("float" "alpha")
  )
)

(define-method get_red_float
  (of-object "CoglColor")
  (c-name "cogl_color_get_red_float")
  (return-type "float")
)

(define-method get_green_float
  (of-object "CoglColor")
  (c-name "cogl_color_get_green_float")
  (return-type "float")
)

(define-method get_blue_float
  (of-object "CoglColor")
  (c-name "cogl_color_get_blue_float")
  (return-type "float")
)

(define-method get_alpha_float
  (of-object "CoglColor")
  (c-name "cogl_color_get_alpha_float")
  (return-type "float")
)

(define-method get_red
  (of-object "CoglColor")
  (c-name "cogl_color_get_red")
  (return-type "float")
)

(define-method get_green
  (of-object "CoglColor")
  (c-name "cogl_color_get_green")
  (return-type "float")
)

(define-method get_blue
  (of-object "CoglColor")
  (c-name "cogl_color_get_blue")
  (return-type "float")
)

(define-method get_alpha
  (of-object "CoglColor")
  (c-name "cogl_color_get_alpha")
  (return-type "float")
)

(define-method get_red_byte
  (of-object "CoglColor")
  (c-name "cogl_color_get_red_byte")
  (return-type "int")
)

(define-method get_green_byte
  (of-object "CoglColor")
  (c-name "cogl_color_get_green_byte")
  (return-type "int")
)

(define-method get_blue_byte
  (of-object "CoglColor")
  (c-name "cogl_color_get_blue_byte")
  (return-type "int")
)

(define-method get_alpha_byte
  (of-object "CoglColor")
  (c-name "cogl_color_get_alpha_byte")
  (return-type "int")
)

(define-function color_premultiply
  (c-name "cogl_color_premultiply")
  (return-type "none")
)

(define-function color_equal
  (c-name "cogl_color_equal")
  (docstring
  "Compares two CoglColor<!-- -->s and checks if they are the same. This\n"
  "function can be passed to g_hash_table_new() as the key_equal_func\n"
  "parameter, when using CoglColor<!-- -->s as keys in a GHashTable.\n"
  )
  (return-type "gboolean")
  (parameters
    '("gconstpointer" "v1")
    '("gconstpointer" "v2")
  )
)

(define-function color_to_clutter_color
  (c-name "cogl_color_to_clutter_color")
  (return-type "ClutterColor*")
)


;; From cogl-debug.h



;; From cogl-defines-gl.h



;; From cogl-deprecated.h



;; From cogl-enum-types.h

(define-function material_filter_get_type
  (c-name "cogl_material_filter_get_type")
  (return-type "GType")
)

(define-function material_alpha_func_get_type
  (c-name "cogl_material_alpha_func_get_type")
  (return-type "GType")
)

(define-function material_layer_type_get_type
  (c-name "cogl_material_layer_type_get_type")
  (return-type "GType")
)

(define-function shader_type_get_type
  (c-name "cogl_shader_type_get_type")
  (return-type "GType")
)

(define-function pixel_format_get_type
  (c-name "cogl_pixel_format_get_type")
  (return-type "GType")
)

(define-function feature_flags_get_type
  (c-name "cogl_feature_flags_get_type")
  (return-type "GType")
)

(define-function buffer_target_get_type
  (c-name "cogl_buffer_target_get_type")
  (return-type "GType")
)

(define-function texture_flags_get_type
  (c-name "cogl_texture_flags_get_type")
  (return-type "GType")
)

(define-function fog_mode_get_type
  (c-name "cogl_fog_mode_get_type")
  (return-type "GType")
)

(define-function attribute_type_get_type
  (c-name "cogl_attribute_type_get_type")
  (return-type "GType")
)

(define-function vertices_mode_get_type
  (c-name "cogl_vertices_mode_get_type")
  (return-type "GType")
)

(define-function indices_type_get_type
  (c-name "cogl_indices_type_get_type")
  (return-type "GType")
)

(define-function buffer_bit_get_type
  (c-name "cogl_buffer_bit_get_type")
  (return-type "GType")
)

(define-function read_pixels_flags_get_type
  (c-name "cogl_read_pixels_flags_get_type")
  (docstring
  "(only COGL_READ_PIXELS_COLOR_BUFFER supported currently) (only\n"
  "COGL_PIXEL_FORMAT_RGBA_8888 supported currently) This reads a\n"
  "rectangle of pixels from the current framebuffer where position (0, 0)\n"
  "is the top left. The pixel at (x, y) is the first read, and the data\n"
  "is returned with a rowstride of (width * 4). Currently Cogl assumes\n"
  "that the framebuffer is in a premultiplied format so if format is non-\n"
  "premultiplied it will convert it. To read the pixel values without any\n"
  "conversion you should either specify a format that doesn't use an\n"
  "alpha channel or use one of the formats ending in PRE.\n"
  )
  (return-type "GType")
)



;; From cogl-fixed.h

(define-method sin
  (of-object "CoglFixed")
  (c-name "cogl_fixed_sin")
  (docstring
  "Computes the sine of angle.\n"
  )
  (return-type "CoglFixed")
)

(define-method tan
  (of-object "CoglFixed")
  (c-name "cogl_fixed_tan")
  (docstring
  "Computes the tangent of angle.\n"
  )
  (return-type "CoglFixed")
)

(define-method cos
  (of-object "CoglFixed")
  (c-name "cogl_fixed_cos")
  (docstring
  "Computes the cosine of angle.\n"
  )
  (return-type "CoglFixed")
)

(define-method atani
  (of-object "CoglFixed")
  (c-name "cogl_fixed_atani")
  (docstring
  "Computes the arc tangent of a.\n"
  )
  (return-type "CoglFixed")
)

(define-method atan2
  (of-object "CoglFixed")
  (c-name "cogl_fixed_atan2")
  (docstring
  "Computes the arc tangent of a / b but uses the sign of both arguments\n"
  "to return the angle in right quadrant. notation\n"
  )
  (return-type "CoglFixed")
  (parameters
    '("CoglFixed" "b")
  )
)

(define-method sqrt
  (of-object "CoglFixed")
  (c-name "cogl_fixed_sqrt")
  (docstring
  "Computes the square root of x. notation\n"
  )
  (return-type "CoglFixed")
)

(define-function fixed_log2
  (c-name "cogl_fixed_log2")
  (docstring
  "Calculates base 2 logarithm. This function is some 2.5 times faster on\n"
  "x86, and over 12 times faster on fpu-less arm, than using libc log().\n"
  )
  (return-type "CoglFixed")
  (parameters
    '("guint" "x")
  )
)

(define-method pow2
  (of-object "CoglFixed")
  (c-name "cogl_fixed_pow2")
  (docstring
  "Calculates x to the y power.\n"
  )
  (return-type "guint")
)

(define-function fixed_pow
  (c-name "cogl_fixed_pow")
  (return-type "guint")
  (parameters
    '("guint" "x")
    '("CoglFixed" "y")
  )
)

(define-function sqrti
  (c-name "cogl_sqrti")
  (docstring
  "Very fast fixed point implementation of square root for integers. This\n"
  "function is at least 6x faster than clib sqrt() on x86, and (this is\n"
  "not a typo!) about 500x faster on ARM without FPU. It's error is less\n"
  "than 5 for arguments smaller than COGL_SQRTI_ARG_5_PERCENT and less\n"
  "than 10 for narguments smaller than COGL_SQRTI_ARG_10_PERCENT. The\n"
  "maximum argument that can be passed to this function is\n"
  "COGL_SQRTI_ARG_MAX.\n"
  )
  (return-type "gint")
  (parameters
    '("gint" "x")
  )
)

(define-method sin
  (of-object "CoglAngle")
  (c-name "cogl_angle_sin")
  (docstring
  "Computes the sine of angle\n"
  )
  (return-type "CoglFixed")
)

(define-method tan
  (of-object "CoglAngle")
  (c-name "cogl_angle_tan")
  (docstring
  "Computes the tangent of angle\n"
  )
  (return-type "CoglFixed")
)

(define-method cos
  (of-object "CoglAngle")
  (c-name "cogl_angle_cos")
  (docstring
  "Computes the cosine of angle\n"
  )
  (return-type "CoglFixed")
)



;; From cogl.h

(define-function get_option_group
  (c-name "cogl_get_option_group")
  (docstring
  "Retrieves the GOptionGroup used by COGL to parse the command line\n"
  "options. clutter. uses this to handle the COGL command line options\n"
  "during its initialization process.\n"
  )
  (return-type "GOptionGroup*")
)

(define-function get_features
  (c-name "cogl_get_features")
  (docstring
  "Returns all of the features supported by COGL.\n"
  )
  (return-type "CoglFeatureFlags")
)

(define-function features_available
  (c-name "cogl_features_available")
  (docstring
  "Checks whether the given COGL features are available. Multiple\n"
  "features can be checked for by or-ing them together with the '|'\n"
  "operator. TRUE is only returned if all of the requested features are\n"
  "available.\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglFeatureFlags" "features")
  )
)

(define-function get_proc_address
  (c-name "cogl_get_proc_address")
  (docstring
  "Gets a pointer to a given GL or GL ES extension function. This acts as\n"
  "a wrapper around glXGetProcAddress() or whatever is the appropriate\n"
  "function for the current backend. function is not available.\n"
  )
  (return-type "CoglFuncPtr")
  (parameters
    '("const-gchar*" "name")
  )
)

(define-function get_bitmasks
  (c-name "cogl_get_bitmasks")
  (docstring
  "Gets the number of bitplanes used for each of the color components in\n"
  "the color buffer. Pass NULL for any of the arguments if the value is\n"
  "not required.\n"
  )
  (return-type "none")
  (parameters
    '("gint*" "red")
    '("gint*" "green")
    '("gint*" "blue")
    '("gint*" "alpha")
  )
)

(define-function perspective
  (c-name "cogl_perspective")
  (docstring
  "Replaces the current projection matrix with a perspective matrix based\n"
  "on the provided values.\n"
  )
  (return-type "none")
  (parameters
    '("float" "fovy")
    '("float" "aspect")
    '("float" "z_near")
    '("float" "z_far")
  )
)

(define-function frustum
  (c-name "cogl_frustum")
  (docstring
  "Replaces the current projection matrix with a perspective matrix for\n"
  "the given viewing frustum.\n"
  )
  (return-type "none")
  (parameters
    '("float" "left")
    '("float" "right")
    '("float" "bottom")
    '("float" "top")
    '("float" "z_near")
    '("float" "z_far")
  )
)

(define-function ortho
  (c-name "cogl_ortho")
  (docstring
  "the plane is behind the viewer) the plane is behind the viewer)\n"
  "Replaces the current projection matrix with a parallel projection\n"
  "matrix.\n"
  )
  (return-type "none")
  (parameters
    '("float" "left")
    '("float" "right")
    '("float" "bottom")
    '("float" "top")
    '("float" "near")
    '("float" "far")
  )
)

(define-function push_matrix
  (c-name "cogl_push_matrix")
  (docstring
  "Stores the current model-view matrix on the matrix stack. The matrix\n"
  "can later be restored with cogl_pop_matrix().\n"
  )
  (return-type "none")
)

(define-function pop_matrix
  (c-name "cogl_pop_matrix")
  (docstring
  "Restores the current model-view matrix from the matrix stack.\n"
  )
  (return-type "none")
)

(define-function scale
  (c-name "cogl_scale")
  (docstring
  "Multiplies the current model-view matrix by one that scales the x, y\n"
  "and z axes by the given values.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x")
    '("float" "y")
    '("float" "z")
  )
)

(define-function translate
  (c-name "cogl_translate")
  (docstring
  "Multiplies the current model-view matrix by one that translates the\n"
  "model along all three axes according to the given values.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x")
    '("float" "y")
    '("float" "z")
  )
)

(define-function rotate
  (c-name "cogl_rotate")
  (docstring
  "Multiplies the current model-view matrix by one that rotates the model\n"
  "around the vertex specified by x, y and z. The rotation follows the\n"
  "right-hand thumb rule so for example rotating by 10 degrees about the\n"
  "vertex (0, 0, 1) causes a small counter-clockwise rotation.\n"
  )
  (return-type "none")
  (parameters
    '("float" "angle")
    '("float" "x")
    '("float" "y")
    '("float" "z")
  )
)

(define-function get_modelview_matrix
  (c-name "cogl_get_modelview_matrix")
  (docstring
  "Stores the current model-view matrix in matrix.\n"
  )
  (return-type "none")
  (parameters
    '("CoglMatrix*" "matrix")
  )
)

(define-function set_modelview_matrix
  (c-name "cogl_set_modelview_matrix")
  (docstring
  "Loads matrix as the new model-view matrix.\n"
  )
  (return-type "none")
  (parameters
    '("CoglMatrix*" "matrix")
  )
)

(define-function get_projection_matrix
  (c-name "cogl_get_projection_matrix")
  (docstring
  "Stores the current projection matrix in matrix.\n"
  )
  (return-type "none")
  (parameters
    '("CoglMatrix*" "matrix")
  )
)

(define-function set_projection_matrix
  (c-name "cogl_set_projection_matrix")
  (docstring
  "Loads matrix as the new projection matrix.\n"
  )
  (return-type "none")
  (parameters
    '("CoglMatrix*" "matrix")
  )
)

(define-function get_viewport
  (c-name "cogl_get_viewport")
  (docstring
  "of float<!-- -->s to receive the viewport dimensions. Stores the\n"
  "current viewport in v. v[0] and v[1] get the x and y position of the\n"
  "viewport and v[2] and v[3] get the width and height.\n"
  )
  (return-type "none")
  (parameters
    '("float" "v[4]")
  )
)

(define-function set_depth_test_enabled
  (c-name "cogl_set_depth_test_enabled")
  (docstring
  "Sets whether depth testing is enabled. If it is disabled then the\n"
  "order that actors are layered on the screen depends solely on the\n"
  "order specified using clutter.Actor.raise() and clutter.Actor.lower(),\n"
  "otherwise it will also take into account the actor's depth. Depth\n"
  "testing is disabled by default.\n"
  )
  (return-type "none")
  (parameters
    '("gboolean" "setting")
  )
)

(define-function get_depth_test_enabled
  (c-name "cogl_get_depth_test_enabled")
  (docstring
  "Queries if depth testing has been enabled via\n"
  "cogl_set_depth_test_enable()\n"
  )
  (return-type "gboolean")
)

(define-function set_backface_culling_enabled
  (c-name "cogl_set_backface_culling_enabled")
  (docstring
  "Sets whether textures positioned so that their backface is showing\n"
  "should be hidden. This can be used to efficiently draw two-sided\n"
  "textures or fully closed cubes without enabling depth testing. This\n"
  "only affects calls to the cogl_rectangle* family of functions and\n"
  "cogl_vertex_buffer_draw*. Backface culling is disabled by default.\n"
  )
  (return-type "none")
  (parameters
    '("gboolean" "setting")
  )
)

(define-function get_backface_culling_enabled
  (c-name "cogl_get_backface_culling_enabled")
  (docstring
  "Queries if backface culling has been enabled via\n"
  "cogl_set_backface_culling_enabled()\n"
  )
  (return-type "gboolean")
)

(define-function set_fog
  (c-name "cogl_set_fog")
  (docstring
  "fogging blend factor. COGL_FOG_MODE_EXPONENTIAL_SQUARED equations.\n"
  "Enables fogging. Fogging causes vertices that are further away from\n"
  "the eye to be rendered with a different color. The color is determined\n"
  "according to the chosen fog mode; at it's simplest the color is\n"
  "linearly interpolated so that vertices at z_near are drawn fully with\n"
  "their original color and vertices at z_far are drawn fully with\n"
  "fog_color. Fogging will remain enabled until you call\n"
  "cogl_disable_fog(). <note>The fogging functions only work correctly\n"
  "when primitives use unmultiplied alpha colors. By default Cogl will\n"
  "premultiply textures and cogl_set_source_color() will premultiply\n"
  "colors, so unless you explicitly load your textures requesting an\n"
  "unmultiplied internal format and use cogl_material_set_color() you can\n"
  "only use fogging with fully opaque primitives. This might improve in\n"
  "the future when we can depend on fragment shaders.</note>\n"
  )
  (return-type "none")
  (parameters
    '("const-CoglColor*" "fog_color")
    '("CoglFogMode" "mode")
    '("float" "density")
    '("float" "z_near")
    '("float" "z_far")
  )
)

(define-function disable_fog
  (c-name "cogl_disable_fog")
  (docstring
  "This function disables fogging, so primitives drawn afterwards will\n"
  "not be blended with any previously set fog color.\n"
  )
  (return-type "none")
)

(define-function clear
  (c-name "cogl_clear")
  (docstring
  "buffers to clear Clears all the auxiliary buffers identified in the\n"
  "buffers mask, and if that includes the color buffer then the specified\n"
  "color is used.\n"
  )
  (return-type "none")
  (parameters
    '("const-CoglColor*" "color")
    '("gulong" "buffers")
  )
)

(define-function set_source
  (c-name "cogl_set_source")
  (docstring
  "This function sets the source material that will be used to fill\n"
  "subsequent geometry emitted via the cogl API. <note>In the future we\n"
  "may add the ability to set a front facing material, and a back facing\n"
  "material, in which case this function will set both to the\n"
  "same.</note>\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
  )
)

(define-function set_source_color
  (c-name "cogl_set_source_color")
  (docstring
  "This is a convenience function for creating a solid fill source\n"
  "material from the given color. This color will be used for any\n"
  "subsequent drawing operation. The color will be premultiplied by Cogl,\n"
  "so the color should be semi-transparent red. See also\n"
  "cogl_set_source_color4ub() and cogl_set_source_color4f() if you\n"
  "already have the color components.\n"
  )
  (return-type "none")
  (parameters
    '("const-CoglColor*" "color")
  )
)

(define-function set_source_color4ub
  (c-name "cogl_set_source_color4ub")
  (docstring
  "This is a convenience function for creating a solid fill source\n"
  "material from the given color using unsigned bytes for each component.\n"
  "This color will be used for any subsequent drawing operation. The\n"
  "value for each component is an unsigned byte in the range between 0\n"
  "and 255.\n"
  )
  (return-type "none")
  (parameters
    '("guint8" "red")
    '("guint8" "green")
    '("guint8" "blue")
    '("guint8" "alpha")
  )
)

(define-function set_source_color4f
  (c-name "cogl_set_source_color4f")
  (docstring
  "This is a convenience function for creating a solid fill source\n"
  "material from the given color using normalized values for each\n"
  "component. This color will be used for any subsequent drawing\n"
  "operation. The value for each component is a fixed point number in the\n"
  "range between 0 and 1.0. If the values passed in are outside that\n"
  "range, they will be clamped.\n"
  )
  (return-type "none")
  (parameters
    '("float" "red")
    '("float" "green")
    '("float" "blue")
    '("float" "alpha")
  )
)

(define-function set_source_texture
  (c-name "cogl_set_source_texture")
  (docstring
  "This is a convenience function for creating a material with the first\n"
  "layer set to texture_handle and setting that material as the source\n"
  "with cogl_set_source. and cogl_set_source_texture. If you need to\n"
  "blend a texture with a color then you can create a simple material\n"
  "like this: <programlisting> material = cogl_material_new ();\n"
  "cogl_material_set_color4ub (material, 0xff, 0x00, 0x00, 0x80);\n"
  "cogl_material_set_layer (material, 0, tex_handle); cogl_set_source\n"
  "(material); </programlisting>\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "texture_handle")
  )
)

(define-function clip_push_from_path
  (c-name "cogl_clip_push_from_path")
  (docstring
  "Sets a new clipping area using the current path. The current path is\n"
  "then cleared. The clipping area is intersected with the previous\n"
  "clipping area. To restore the previous clipping area, call\n"
  "cogl_clip_pop().\n"
  )
  (return-type "none")
)

(define-function clip_push_from_path_preserve
  (c-name "cogl_clip_push_from_path_preserve")
  (docstring
  "Sets a new clipping area using the current path. The current path is\n"
  "then cleared. The clipping area is intersected with the previous\n"
  "clipping area. To restore the previous clipping area, call\n"
  "cogl_clip_pop().\n"
  )
  (return-type "none")
)

(define-function clip_pop
  (c-name "cogl_clip_pop")
  (docstring
  "Reverts the clipping region to the state before the last call to\n"
  "cogl_clip_push().\n"
  )
  (return-type "none")
)

(define-function read_pixels
  (c-name "cogl_read_pixels")
  (return-type "none")
  (parameters
    '("int" "x")
    '("int" "y")
    '("int" "width")
    '("int" "height")
    '("CoglReadPixelsFlags" "source")
    '("CoglPixelFormat" "format")
    '("guint8*" "pixels")
  )
)

(define-function flush
  (c-name "cogl_flush")
  (docstring
  "This function should only need to be called in exceptional\n"
  "circumstances. As an optimization Cogl drawing functions may batch up\n"
  "primitives internally, so if you are trying to use raw GL outside of\n"
  "Cogl you stand a better chance of being successful if you ask Cogl to\n"
  "flush any batched geometry before making your state changes. It only\n"
  "ensure that the underlying driver is issued all the commands necessary\n"
  "to draw the batched primitives. It provides no guarantees about when\n"
  "the driver will complete the rendering. This provides no guarantees\n"
  "about the GL state upon returning and to avoid confusing Cogl you\n"
  "should aim to restore any changes you make before resuming use of\n"
  "Cogl. If you are making state changes with the intention of affecting\n"
  "Cogl drawing primitives you are 100 on your own since you stand a good\n"
  "chance of conflicting with Cogl internals. For example clutter-gst\n"
  "which currently uses direct GL calls to bind ARBfp programs will very\n"
  "likely break when Cogl starts to use ARBfb programs itself for the\n"
  "material API.\n"
  )
  (return-type "none")
)

(define-function begin_gl
  (c-name "cogl_begin_gl")
  (docstring
  "We do not advise nor reliably support the interleaving of raw GL\n"
  "drawing and Cogl drawing functions, but if you insist, cogl_begin_gl()\n"
  "and cogl_end_gl() provide a simple mechanism that may at least give\n"
  "you a fighting chance of succeeding. through the modification of GL\n"
  "state; that will never be reliably supported, but if you are trying to\n"
  "do something like: |[ { - setup some OpenGL state. - draw using OpenGL\n"
  "(e.g. glDrawArrays() ) - reset modified OpenGL state. - continue using\n"
  "Cogl to draw } ]| You should surround blocks of drawing using raw GL\n"
  "with cogl_begin_gl() and cogl_end_gl(): |[ { cogl_begin_gl (); - setup\n"
  "some OpenGL state. - draw using OpenGL (e.g. glDrawArrays() ) - reset\n"
  "modified OpenGL state. cogl_end_gl (); - continue using Cogl to draw }\n"
  "]| Don't ever try and do: |[ { - setup some OpenGL state. - use Cogl\n"
  "to draw - reset modified OpenGL state. } ]| When the internals of Cogl\n"
  "evolves, this is very liable to break. This function will flush all\n"
  "batched primitives, and subsequently flush all internal Cogl state to\n"
  "OpenGL as if it were going to draw something itself. The result is\n"
  "that the OpenGL modelview matrix will be setup; the state\n"
  "corresponding to the current source material will be set up and other\n"
  "world state such as backface culling, depth and fogging enabledness\n"
  "will be sent to OpenGL. <note>No special material state is flushed, so\n"
  "if you want Cogl to setup a simplified material state it is your\n"
  "responsibility to set a simple source material before calling\n"
  "cogl_begin_gl(). E.g. by calling cogl_set_source_color4ub().</note>\n"
  "<note>It is your responsibility to restore any OpenGL state that you\n"
  "modify to how it was after calling cogl_begin_gl() if you don't do\n"
  "this then the result of further Cogl calls is undefined.</note>\n"
  "<note>You can not nest begin/end blocks.</note> Again we would like to\n"
  "stress, we do not advise the use of this API and if possible we would\n"
  "prefer to improve Cogl than have developers require raw OpenGL.\n"
  )
  (return-type "none")
)

(define-function end_gl
  (c-name "cogl_end_gl")
  (docstring
  "This is the counterpart to cogl_begin_gl() used to delimit blocks of\n"
  "drawing code using raw OpenGL. Please refer to cogl_begin_gl() for\n"
  "full details.\n"
  )
  (return-type "none")
)

;;(define-function flush_gl_state
;;  (c-name "cogl_flush_gl_state")
;;  (return-type "none")
;;  (parameters
;;    '("int" "flags")
;;  )
;;)

(define-function set_viewport
  (c-name "cogl_set_viewport")
  (docstring
  "Replaces the current viewport with the given values.\n"
  )
  (return-type "none")
  (parameters
    '("int" "x")
    '("int" "y")
    '("int" "width")
    '("int" "height")
  )
)

(define-function clip_push_window_rectangle
  (c-name "cogl_clip_push_window_rectangle")
  (docstring
  "Specifies a rectangular clipping area for all subsequent drawing\n"
  "operations. Any drawing commands that extend outside the rectangle\n"
  "will be clipped so that only the portion inside the rectangle will be\n"
  "displayed. The rectangle dimensions are transformed by the current\n"
  "model-view matrix. The rectangle is intersected with the current clip\n"
  "region. To undo the effect of this function, call cogl_clip_pop().\n"
  "with other API that specify rectangles in model space, and when used\n"
  "with a coordinate space that puts the origin at the center and y+\n"
  "extending up, it's awkward to use. Please use\n"
  "cogl_clip_push_rectangle() instead\n"
  )
  (return-type "none")
  (parameters
    '("int" "x_offset")
    '("int" "y_offset")
    '("int" "width")
    '("int" "height")
  )
)

(define-function clip_push_rectangle
  (c-name "cogl_clip_push_rectangle")
  (docstring
  "Specifies a rectangular clipping area for all subsequent drawing\n"
  "operations. Any drawing commands that extend outside the rectangle\n"
  "will be clipped so that only the portion inside the rectangle will be\n"
  "displayed. The rectangle dimensions are transformed by the current\n"
  "model-view matrix. The rectangle is intersected with the current clip\n"
  "region. To undo the effect of this function, call cogl_clip_pop().\n"
  )
  (return-type "none")
  (parameters
    '("float" "x0")
    '("float" "y0")
    '("float" "x1")
    '("float" "y1")
  )
)

(define-function set_framebuffer
  (c-name "cogl_set_framebuffer")
  (docstring
  "offscreen. This redirects all subsequent drawing to the specified\n"
  "framebuffer. This can either be an offscreen buffer created with\n"
  "cogl_offscreen_new_to_texture () or you can revert to your original\n"
  "onscreen window buffer.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "buffer")
  )
)

(define-function push_framebuffer
  (c-name "cogl_push_framebuffer")
  (docstring
  "offscreen. Redirects all subsequent drawing to the specified\n"
  "framebuffer. This can either be an offscreen buffer created with\n"
  "cogl_offscreen_new_to_texture () or you can revert to your original\n"
  "onscreen window buffer. The previous framebuffer can be restored by\n"
  "calling cogl_pop_framebuffer()\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "buffer")
  )
)

(define-function pop_framebuffer
  (c-name "cogl_pop_framebuffer")
  (docstring
  "Restores the framebuffer that was previously at the top of the stack.\n"
  "All subsequent drawing will be redirected to this framebuffer.\n"
  )
  (return-type "none")
)




;; From cogl-material.h

(define-function material_new
  (c-name "cogl_material_new")
  (docstring
  "Allocates and initializes a blank white material\n"
  )
  (return-type "CoglHandle")
)

(define-function material_ref
  (c-name "cogl_material_ref")
  (docstring
  "Increment the reference count for a cogl material.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function material_unref
  (c-name "cogl_material_unref")
  (docstring
  "Decrement the reference count for a cogl material.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function is_material
  (c-name "cogl_is_material")
  (docstring
  "Gets whether the given handle references an existing material object.\n"
  "FALSE otherwise\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function material_set_color
  (c-name "cogl_material_set_color")
  (docstring
  "Sets the basic color of the material, used when no lighting is\n"
  "enabled. Note that if you don't add any layers to the material then\n"
  "the color will be blended unmodified with the destination; the default\n"
  "blend semi-transparent red. See cogl_color_premultiply(). The default\n"
  "value is (1.0, 1.0, 1.0, 1.0)\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("const-CoglColor*" "color")
  )
)

(define-function material_set_color4ub
  (c-name "cogl_material_set_color4ub")
  (docstring
  "Sets the basic color of the material, used when no lighting is\n"
  "enabled. The default value is (0xff, 0xff, 0xff, 0xff)\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("guint8" "red")
    '("guint8" "green")
    '("guint8" "blue")
    '("guint8" "alpha")
  )
)

(define-function material_set_color4f
  (c-name "cogl_material_set_color4f")
  (docstring
  "Sets the basic color of the material, used when no lighting is\n"
  "enabled. The default value is (1.0, 1.0, 1.0, 1.0)\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("float" "red")
    '("float" "green")
    '("float" "blue")
    '("float" "alpha")
  )
)

(define-function material_get_color
  (c-name "cogl_material_get_color")
  (docstring
  "Retrieves the current material color.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("CoglColor*" "color")
  )
)

(define-function material_set_ambient
  (c-name "cogl_material_set_ambient")
  (docstring
  "Sets the material's ambient color, in the standard OpenGL lighting\n"
  "model. The ambient color affects the overall color of the object.\n"
  "Since the diffuse color will be intense when the light hits the\n"
  "surface directly, the ambient will be most apparent where the light\n"
  "hits at a slant. The default value is (0.2, 0.2, 0.2, 1.0)\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("const-CoglColor*" "ambient")
  )
)

(define-function material_get_ambient
  (c-name "cogl_material_get_ambient")
  (docstring
  "Retrieves the current ambient color for material\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("CoglColor*" "ambient")
  )
)

(define-function material_set_diffuse
  (c-name "cogl_material_set_diffuse")
  (docstring
  "Sets the material's diffuse color, in the standard OpenGL lighting\n"
  "model. The diffuse color is most intense where the light hits the\n"
  "surface directly - perpendicular to the surface. The default value is\n"
  "(0.8, 0.8, 0.8, 1.0)\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("const-CoglColor*" "diffuse")
  )
)

(define-function material_get_diffuse
  (c-name "cogl_material_get_diffuse")
  (docstring
  "Retrieves the current diffuse color for material\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("CoglColor*" "diffuse")
  )
)

(define-function material_set_ambient_and_diffuse
  (c-name "cogl_material_set_ambient_and_diffuse")
  (docstring
  "Conveniently sets the diffuse and ambient color of material at the\n"
  "same time. See cogl_material_set_ambient() and\n"
  "cogl_material_set_diffuse(). The default ambient color is (0.2, 0.2,\n"
  "0.2, 1.0) The default diffuse color is (0.8, 0.8, 0.8, 1.0)\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("const-CoglColor*" "color")
  )
)

(define-function material_set_specular
  (c-name "cogl_material_set_specular")
  (docstring
  "Sets the material's specular color, in the standard OpenGL lighting\n"
  "model. The intensity of the specular color depends on the viewport\n"
  "position, and is brightest along the lines of reflection. The default\n"
  "value is (0.0, 0.0, 0.0, 1.0)\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("const-CoglColor*" "specular")
  )
)

(define-function material_get_specular
  (c-name "cogl_material_get_specular")
  (docstring
  "Retrieves the materials current specular color.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("CoglColor*" "specular")
  )
)

(define-function material_set_shininess
  (c-name "cogl_material_set_shininess")
  (docstring
  "Sets the materials shininess, in the standard OpenGL lighting model,\n"
  "which determines how specular highlights are calculated. A higher The\n"
  "default value is 0.0\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("float" "shininess")
  )
)

(define-function material_get_shininess
  (c-name "cogl_material_get_shininess")
  (docstring
  "Retrieves the materials current emission color.\n"
  )
  (return-type "float")
  (parameters
    '("CoglHandle" "material")
  )
)

(define-function material_set_emission
  (c-name "cogl_material_set_emission")
  (docstring
  "Sets the material's emissive color, in the standard OpenGL lighting\n"
  "model. It will look like the surface is a light source emitting this\n"
  "color. The default value is (0.0, 0.0, 0.0, 1.0)\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("const-CoglColor*" "emission")
  )
)

(define-function material_get_emission
  (c-name "cogl_material_get_emission")
  (docstring
  "Retrieves the materials current emission color.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("CoglColor*" "emission")
  )
)

(define-function material_set_alpha_test_function
  (c-name "cogl_material_set_alpha_test_function")
  (docstring
  "to compare incoming fragments to. Before a primitive is blended with\n"
  "the framebuffer, it goes through an alpha test stage which lets you\n"
  "discard fragments based on the current alpha value. This function lets\n"
  "you change the function used to evaluate the alpha channel, and thus\n"
  "determine which fragments are discarded and which continue on to the\n"
  "blending stage. The default is COGL_MATERIAL_ALPHA_FUNC_ALWAYS\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("CoglMaterialAlphaFunc" "alpha_func")
    '("float" "alpha_reference")
  )
)

(define-function material_set_blend
  (c-name "cogl_material_set_blend")
  (docstring
  "describing the desired blend function. support if you give separate\n"
  "blend string statements for the alpha channel and RGB channels since\n"
  "some drivers, or backends such as GLES 1.1, don't support this\n"
  "feature. May be NULL, in which case a warning will be printed out\n"
  "using GLib's logging facilities if an error is encountered. If not\n"
  "already familiar; please refer <link linkend=cogl-Blend-\n"
  "Strings>here</link> for an overview of what blend strings are, and\n"
  "their syntax. Blending occurs after the alpha test function, and\n"
  "combines fragments with the framebuffer. Currently the only blend\n"
  "function Cogl exposes is ADD(). So any valid blend statements will be\n"
  "of the form: |[ &lt;channel-mask&gt;=ADD(SRC_COLOR*(&lt;factor&gt;),\n"
  "DST_COLOR*(&lt;factor&gt;)) ]| <warning>The brackets around blend\n"
  "factors are currently not optional!</warning> This is the list of\n"
  "source-names usable as blend factors: <itemizedlist> </itemizedlist>\n"
  "The source names can be used according to the <link linkend=cogl-\n"
  "Blend-String-syntax>color-source and factor syntax</link>, so for\n"
  "example (1-SRC_COLOR[A]) would be a valid factor, as would\n"
  "(CONSTANT[RGB]) These can also be used as factors: <itemizedlist>\n"
  "</itemizedlist> <note>Remember; all color components are normalized to\n"
  "the range [0, 1] before computing the result of blending.</note>\n"
  "<example id=cogl-Blend-Strings-blend-unpremul> <title>Blend\n"
  "Strings/1</title> <para>Blend a non-premultiplied source over a\n"
  "destination with premultiplied alpha:</para> <programlisting> RGB =\n"
  "ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A])) A   =\n"
  "ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A])) </programlisting>\n"
  "</example> <example id=cogl-Blend-Strings-blend-premul> <title>Blend\n"
  "Strings/2</title> <para>Blend a premultiplied source over a\n"
  "destination with premultiplied alpha</para> <programlisting> RGBA =\n"
  "ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A])) </programlisting>\n"
  "</example> The default blend string is: |[ RGBA = ADD (SRC_COLOR,\n"
  "DST_COLOR*(1-SRC_COLOR[A])) ]| That gives normal alpha-blending when\n"
  "the calculated color for the material is in premultiplied form.\n"
  "described blending is supported by the underlying driver/hardware. If\n"
  "there was an error, FALSE is returned and error is set accordingly (if\n"
  "present).\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "material")
    '("const-char*" "blend_string")
    '("GError**" "error")
  )
)

(define-function material_set_blend_constant
  (c-name "cogl_material_set_blend_constant")
  (docstring
  "When blending is setup to reference a CONSTANT blend factor then\n"
  "blending will depend on the constant set with this function.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("CoglColor*" "constant_color")
  )
)

(define-function material_set_layer
  (c-name "cogl_material_set_layer")
  (docstring
  "In addition to the standard OpenGL lighting model a Cogl material may\n"
  "have one or more layers comprised of textures that can be blended\n"
  "together in order, with a number of different texture combine modes.\n"
  "This function defines a new texture layer. The index values of\n"
  "multiple layers do not have to be consecutive; it is only their\n"
  "relative order that is important. <note>In the future, we may define\n"
  "other types of material layers, such as purely GLSL based\n"
  "layers.</note>\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("int" "layer_index")
    '("CoglHandle" "texture")
  )
)

(define-function material_remove_layer
  (c-name "cogl_material_remove_layer")
  (docstring
  "This function removes a layer from your material\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("gint" "layer_index")
  )
)

(define-function material_set_layer_combine
  (c-name "cogl_material_set_layer_combine")
  (docstring
  "describing the desired texture combine function. support. May be NULL,\n"
  "in which case a warning will be printed out if an error is\n"
  "encountered. If not already familiar; you can refer <link linkend\n"
  "=cogl-Blend-Strings>here</link> for an overview of what blend strings\n"
  "are and there syntax. These are all the functions available for\n"
  "texture combining: <itemizedlist> <listitem>REPLACE(arg0) =\n"
  "arg0</listitem> <listitem>MODULATE(arg0, arg1) = arg0 x\n"
  "arg1</listitem> <listitem>ADD(arg0, arg1) = arg0 + arg1</listitem>\n"
  "<listitem>ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5</listitem>\n"
  "<listitem>INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 -\n"
  "arg2)</listitem> <listitem>SUBTRACT(arg0, arg1) = arg0 -\n"
  "arg1</listitem> <listitem> <programlisting> DOT3_RGB(arg0, arg1) = 4 x\n"
  "((arg0[R] - 0.5)) * (arg1[R] - 0.5) + (arg0[G] - 0.5)) * (arg1[G] -\n"
  "0.5) + (arg0[B] - 0.5)) * (arg1[B] - 0.5)) </programlisting>\n"
  "</listitem> <listitem> <programlisting> DOT3_RGBA(arg0, arg1) = 4 x\n"
  "((arg0[R] - 0.5)) * (arg1[R] - 0.5) + (arg0[G] - 0.5)) * (arg1[G] -\n"
  "0.5) + (arg0[B] - 0.5)) * (arg1[B] - 0.5)) </programlisting>\n"
  "</listitem> </itemizedlist> Refer to the <link linkend=cogl-Blend-\n"
  "String-syntax>color-source syntax</link> for describing the arguments.\n"
  "The valid source names for texture combining are: <variablelist>\n"
  "<varlistentry> <term>TEXTURE</term> <listitem>Use the color from the\n"
  "current texture layer</listitem> </varlistentry> <varlistentry>\n"
  "<term>TEXTURE_0, TEXTURE_1, etc</term> <listitem>Use the color from\n"
  "the specified texture layer</listitem> </varlistentry> <varlistentry>\n"
  "<term>CONSTANT</term> <listitem>Use the color from the constant given\n"
  "with cogl_material_set_layer_constant()</listitem> </varlistentry>\n"
  "<varlistentry> <term>PRIMARY</term> <listitem>Use the color of the\n"
  "material as set with cogl_material_set_color()</listitem>\n"
  "</varlistentry> <varlistentry> <term>PREVIOUS</term> <listitem>Either\n"
  "use the texture color from the previous layer, or if this is layer 0,\n"
  "use the color of the material as set with\n"
  "cogl_material_set_color()</listitem> </varlistentry> </variablelist>\n"
  "<refsect2 id=cogl-Layer-Combine-Examples> <title>Layer Combine\n"
  "Examples</title> <para>This is effectively what the default blending\n"
  "is:</para> <informalexample><programlisting> RGBA = MODULATE\n"
  "(PREVIOUS, TEXTURE) </programlisting></informalexample> <para>This\n"
  "could be used to cross-fade between two images, using the alpha\n"
  "component of a constant as the interpolator. The constant color is\n"
  "given by calling cogl_material_set_layer_constant.</para>\n"
  "<informalexample><programlisting> RGBA = INTERPOLATE (PREVIOUS,\n"
  "TEXTURE, CONSTANT[A]) </programlisting></informalexample> </refsect2>\n"
  "<note>You can't give a multiplication factor for arguments as you can\n"
  "with blending.</note> described texture combining is supported by the\n"
  "underlying driver and or hardware. On failure, FALSE is returned and\n"
  "error is set\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "material")
    '("gint" "layer_index")
    '("const-char*" "blend_string")
    '("GError**" "error")
  )
)

(define-function material_set_layer_combine_constant
  (c-name "cogl_material_set_layer_combine_constant")
  (docstring
  "for texture combining When you are using the 'CONSTANT' color source\n"
  "in a layer combine description then you can use this function to\n"
  "define its value.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("int" "layer_index")
    '("CoglColor*" "constant")
  )
)

(define-function material_set_layer_matrix
  (c-name "cogl_material_set_layer_matrix")
  (docstring
  "This function lets you set a matrix that can be used to e.g. translate\n"
  "and rotate a single layer of a material used to fill your geometry.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "material")
    '("int" "layer_index")
    '("CoglMatrix*" "matrix")
  )
)

(define-function material_get_layers
  (c-name "cogl_material_get_layers")
  (docstring
  "This function lets you access a materials internal list of layers for\n"
  "iteration. CoglHandle<!-- -->'s that can be passed to the\n"
  "cogl_material_layer_* functions. The list is owned by COGL and it\n"
  "should not be modified or freed\n"
  )
  (return-type "const-GList*")
  (parameters
    '("CoglHandle" "material")
  )
)

(define-function material_get_n_layers
  (c-name "cogl_material_get_n_layers")
  (docstring
  "Retrieves the number of layers defined for the given material\n"
  )
  (return-type "int")
  (parameters
    '("CoglHandle" "material")
  )
)

(define-function material_layer_get_type
  (c-name "cogl_material_layer_get_type")
  (docstring
  "Retrieves the type of the layer Currently there is only one type of\n"
  "layer defined: COGL_MATERIAL_LAYER_TYPE_TEXTURE, but considering we\n"
  "may add purely GLSL based layers in the future, you should write code\n"
  "that checks the type first.\n"
  )
  (return-type "CoglMaterialLayerType")
  (parameters
    '("CoglHandle" "layer_handle")
  )
)

(define-function material_layer_get_texture
  (c-name "cogl_material_layer_get_texture")
  (docstring
  "Extracts a texture handle for a specific layer. <note>In the future\n"
  "Cogl may support purely GLSL based layers; for those layers this\n"
  "function which will likely return COGL_INVALID_HANDLE if you try to\n"
  "get the texture handle from them. Considering this scenario, you\n"
  "should call cogl_material_layer_get_type() first in order check it is\n"
  "of type COGL_MATERIAL_LAYER_TYPE_TEXTURE before calling this\n"
  "function.</note>\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "layer_handle")
  )
)

(define-function material_layer_get_min_filter
  (c-name "cogl_material_layer_get_min_filter")
  (docstring
  "Queries the currently set downscaling filter for a material layer\n"
  )
  (return-type "CoglMaterialFilter")
  (parameters
    '("CoglHandle" "layer_handle")
  )
)

(define-function material_layer_get_mag_filter
  (c-name "cogl_material_layer_get_mag_filter")
  (docstring
  "Queries the currently set downscaling filter for a material later\n"
  )
  (return-type "CoglMaterialFilter")
  (parameters
    '("CoglHandle" "layer_handle")
  )
)

(define-function material_set_layer_filters
  (c-name "cogl_material_set_layer_filters")
  (docstring
  "Changes the decimation and interpolation filters used when a texture\n"
  "is drawn at other scales than 100.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
    '("gint" "layer_index")
    '("CoglMaterialFilter" "min_filter")
    '("CoglMaterialFilter" "mag_filter")
  )
)

(define-function material_copy
  (c-name "cogl_material_copy")
  (docstring
  "Creates a new material handle with the configuration copied from the\n"
  "source material. We would strongly advise developers to always aim to\n"
  "use cogl_material_copy() instead of cogl_material_new() whenever there\n"
  "will be any similarity between two materials. Copying a material helps\n"
  "Cogl keep track of a materials ancestry which we may use to help\n"
  "minimize GPU state changes.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "source")
  )
)



;; From cogl-matrix.h

(define-function matrix_new
  (c-name "cogl_matrix_new")
  (is-constructor-of "CoglMatrix")
  (return-type "CoglMatrix")
)

(define-method init_identity
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_init_identity")
  (return-type "none")
)

(define-method multiply
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_multiply")
  (return-type "none")
  (parameters
    '("const-CoglMatrix*" "a")
    '("const-CoglMatrix*" "b")
  )
)

(define-method rotate
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_rotate")
  (return-type "none")
  (parameters
    '("float" "angle")
    '("float" "x")
    '("float" "y")
    '("float" "z")
  )
)

(define-method translate
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_translate")
  (return-type "none")
  (parameters
    '("float" "x")
    '("float" "y")
    '("float" "z")
  )
)

(define-method scale
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_scale")
  (return-type "none")
  (parameters
    '("float" "sx")
    '("float" "sy")
    '("float" "sz")
  )
)

(define-method frustum
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_frustum")
  (return-type "none")
  (parameters
    '("float" "left")
    '("float" "right")
    '("float" "bottom")
    '("float" "top")
    '("float" "z_near")
    '("float" "z_far")
  )
)

(define-method perspective
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_perspective")
  (return-type "none")
  (parameters
    '("float" "fov_y")
    '("float" "aspect")
    '("float" "z_near")
    '("float" "z_far")
  )
)

(define-method ortho
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_ortho")
  (return-type "none")
  (parameters
    '("float" "left")
    '("float" "right")
    '("float" "bottom")
    '("float" "top")
    '("float" "z_near")
    '("float" "z_far")
  )
)

(define-method init_from_array
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_init_from_array")
  (return-type "none")
  (parameters
    '("const-float*" "array")
  )
)

(define-method get_array
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_get_array")
  (return-type "const-float*")
)

(define-method transform_point
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_transform_point")
  (return-type "none")
  (parameters
    '("float*" "x")
    '("float*" "y")
    '("float*" "z")
    '("float*" "w")
  )
)

(define-method get_inverse
  (of-object "CoglMatrix")
  (c-name "cogl_matrix_get_inverse")
  (return-type "gboolean")
  (parameters
    '("CoglMatrix*" "inverse")
  )
)



;; From cogl-offscreen.h

(define-function offscreen_new_to_texture
  (c-name "cogl_offscreen_new_to_texture")
  (docstring
  "This creates an offscreen buffer object using the given texture as the\n"
  "primary color buffer. It doesn't just initialize the contents of the\n"
  "offscreen buffer with the texture; they are tightly bound so that\n"
  "drawing to the offscreen buffer effectivly updates the contents of the\n"
  "given texture. You don't need to destroy the offscreen buffer before\n"
  "you can use the texture again. if it wasn't possible to create the\n"
  "buffer.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function offscreen_ref
  (c-name "cogl_offscreen_ref")
  (docstring
  "Increments the reference count on the offscreen buffer.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function is_offscreen
  (c-name "cogl_is_offscreen")
  (docstring
  "Determines whether the given CoglHandle references an offscreen buffer\n"
  "object. FALSE otherwise\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function offscreen_unref
  (c-name "cogl_offscreen_unref")
  (docstring
  "Decreases the reference count for the offscreen buffer and frees it\n"
  "when the count reaches 0.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)



;; From cogl-pango.h

(define-function pango_font_map_new
  (c-name "cogl_pango_font_map_new")
  (is-constructor-of "CoglPangoFontMap")
  (return-type "PangoFontMap*")
)

(define-method create_context
  (of-object "CoglPangoFontMap")
  (c-name "cogl_pango_font_map_create_context")
  (return-type "PangoContext*")
)

(define-method set_resolution
  (of-object "CoglPangoFontMap")
  (c-name "cogl_pango_font_map_set_resolution")
  (return-type "none")
  (parameters
    '("double" "dpi")
  )
)

(define-method clear_glyph_cache
  (of-object "CoglPangoFontMap")
  (c-name "cogl_pango_font_map_clear_glyph_cache")
  (return-type "none")
)

(define-function pango_ensure_glyph_cache_for_layout
  (c-name "cogl_pango_ensure_glyph_cache_for_layout")
  (return-type "none")
  (parameters
    '("PangoLayout*" "layout")
  )
)

(define-method set_use_mipmapping
  (of-object "CoglPangoFontMap")
  (c-name "cogl_pango_font_map_set_use_mipmapping")
  (return-type "none")
  (parameters
    '("gboolean" "value")
  )
)

(define-method get_use_mipmapping
  (of-object "CoglPangoFontMap")
  (c-name "cogl_pango_font_map_get_use_mipmapping")
  (return-type "gboolean")
)

(define-method get_renderer
  (of-object "CoglPangoFontMap")
  (c-name "cogl_pango_font_map_get_renderer")
  (return-type "PangoRenderer*")
)

(define-function pango_renderer_get_type
  (c-name "cogl_pango_renderer_get_type")
  (return-type "GType")
)

(define-function pango_render_layout_subpixel
  (c-name "cogl_pango_render_layout_subpixel")
  (return-type "none")
  (parameters
    '("PangoLayout*" "layout")
    '("int" "x")
    '("int" "y")
    '("const-CoglColor*" "color")
    '("int" "flags")
  )
)

(define-function pango_render_layout
  (c-name "cogl_pango_render_layout")
  (return-type "none")
  (parameters
    '("PangoLayout*" "layout")
    '("int" "x")
    '("int" "y")
    '("const-CoglColor*" "color")
    '("int" "flags")
  )
)

(define-function pango_render_layout_line
  (c-name "cogl_pango_render_layout_line")
  (return-type "none")
  (parameters
    '("PangoLayoutLine*" "line")
    '("int" "x")
    '("int" "y")
    '("const-CoglColor*" "color")
  )
)



;; From cogl-path.h

(define-function rectangle
  (c-name "cogl_rectangle")
  (docstring
  "Fills a rectangle at the given coordinates with the current source\n"
  "material\n"
  )
  (return-type "none")
  (parameters
    '("float" "x_1")
    '("float" "y_1")
    '("float" "x_2")
    '("float" "y_2")
  )
)

(define-function path_fill
  (c-name "cogl_path_fill")
  (docstring
  "Fills the constructed shape using the current drawing color. The\n"
  "current path is then cleared. To use the path again, call\n"
  "cogl_path_fill_preserve() instead.\n"
  )
  (return-type "none")
)

(define-function path_fill_preserve
  (c-name "cogl_path_fill_preserve")
  (docstring
  "Fills the constructed shape using the current drawing color and\n"
  "preserves the path to be used again.\n"
  )
  (return-type "none")
)

(define-function path_stroke
  (c-name "cogl_path_stroke")
  (docstring
  "Strokes the constructed shape using the current drawing color and a\n"
  "width of 1 pixel (regardless of the current transformation matrix). To\n"
  "current path is then cleared. To use the path again, call\n"
  "cogl_path_stroke_preserve() instead.\n"
  )
  (return-type "none")
)

(define-function path_stroke_preserve
  (c-name "cogl_path_stroke_preserve")
  (docstring
  "Strokes the constructed shape using the current drawing color and\n"
  "preserves the path to be used again.\n"
  )
  (return-type "none")
)

(define-function path_new
  (c-name "cogl_path_new")
  (docstring
  "Clears the current path and starts a new one.\n"
  )
  (return-type "none")
)

(define-function path_move_to
  (c-name "cogl_path_move_to")
  (docstring
  "Moves the pen to the given location. If there is an existing path this\n"
  "will start a new disjoint subpath.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x")
    '("float" "y")
  )
)

(define-function path_rel_move_to
  (c-name "cogl_path_rel_move_to")
  (docstring
  "Moves the pen to the given offset relative to the current pen\n"
  "location. If there is an existing path this will start a new disjoint\n"
  "subpath.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x")
    '("float" "y")
  )
)

(define-function path_line_to
  (c-name "cogl_path_line_to")
  (docstring
  "Constructs a straight line shape starting and ending at the given\n"
  "coordinates. If there is an existing path this will start a new\n"
  "disjoint sub-path.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x")
    '("float" "y")
  )
)

(define-function path_rel_line_to
  (c-name "cogl_path_rel_line_to")
  (docstring
  "Adds a straight line segment to the current path that ends at the\n"
  "given coordinates relative to the current pen location.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x")
    '("float" "y")
  )
)

(define-function path_arc
  (c-name "cogl_path_arc")
  (docstring
  "Adds an elliptical arc segment to the current path. A straight line\n"
  "segment will link the current pen location with the first vertex of\n"
  "the arc. If you perform a move_to to the arcs start just before\n"
  "drawing it you create a free standing arc.\n"
  )
  (return-type "none")
  (parameters
    '("float" "center_x")
    '("float" "center_y")
    '("float" "radius_x")
    '("float" "radius_y")
    '("float" "angle_1")
    '("float" "angle_2")
  )
)

(define-function path_curve_to
  (c-name "cogl_path_curve_to")
  (docstring
  "Adds a cubic bezier curve segment to the current path with the given\n"
  "second, third and fourth control points and using current pen location\n"
  "as the first control point.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x_1")
    '("float" "y_1")
    '("float" "x_2")
    '("float" "y_2")
    '("float" "x_3")
    '("float" "y_3")
  )
)

(define-function path_rel_curve_to
  (c-name "cogl_path_rel_curve_to")
  (docstring
  "Adds a cubic bezier curve segment to the current path with the given\n"
  "second, third and fourth control points and using current pen location\n"
  "as the first control point. The given coordinates are relative to the\n"
  "current pen location.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x_1")
    '("float" "y_1")
    '("float" "x_2")
    '("float" "y_2")
    '("float" "x_3")
    '("float" "y_3")
  )
)

(define-function path_close
  (c-name "cogl_path_close")
  (docstring
  "Closes the path being constructed by adding a straight line segment to\n"
  "it that ends at the first vertex of the path.\n"
  )
  (return-type "none")
)

(define-function path_line
  (c-name "cogl_path_line")
  (return-type "none")
  (parameters
    '("float" "x_1")
    '("float" "y_1")
    '("float" "x_2")
    '("float" "y_2")
  )
)

(define-function path_polyline
  (c-name "cogl_path_polyline")
  (docstring
  "array of fixed-point values that specify the vertex coordinates.\n"
  "Constructs a series of straight line segments, starting from the first\n"
  "given vertex coordinate. If there is an existing path this will start\n"
  "a new disjoint sub-path. Each subsequent segment starts where the\n"
  "previous one ended and ends at the next given vertex coordinate. The\n"
  "coords array must contain 2 * num_points values. The first value\n"
  "represents the X coordinate of the first vertex, the second value\n"
  "represents the Y coordinate of the first vertex, continuing in the\n"
  "same fashion for the rest of the vertices. (num_points - 1) segments\n"
  "will be constructed.\n"
  )
  (return-type "none")
  (parameters
    '("float*" "coords")
    '("gint" "num_points")
  )
)

(define-function path_polygon
  (c-name "cogl_path_polygon")
  (docstring
  "an array of fixed-point values that specify the vertex coordinates.\n"
  "Constructs a polygonal shape of the given number of vertices. If there\n"
  "is an existing path this will start a new disjoint sub-path. The\n"
  "coords array must contain 2 * num_points values. The first value\n"
  "represents the X coordinate of the first vertex, the second value\n"
  "represents the Y coordinate of the first vertex, continuing in the\n"
  "same fashion for the rest of the vertices.\n"
  )
  (return-type "none")
  (parameters
    '("float*" "coords")
    '("gint" "num_points")
  )
)

(define-function path_rectangle
  (c-name "cogl_path_rectangle")
  (docstring
  "Constructs a rectangular shape at the given coordinates. If there is\n"
  "an existing path this will start a new disjoint sub-path.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x_1")
    '("float" "y_1")
    '("float" "x_2")
    '("float" "y_2")
  )
)

(define-function path_ellipse
  (c-name "cogl_path_ellipse")
  (docstring
  "Constructs an ellipse shape. If there is an existing path this will\n"
  "start a new disjoint sub-path.\n"
  )
  (return-type "none")
  (parameters
    '("float" "center_x")
    '("float" "center_y")
    '("float" "radius_x")
    '("float" "radius_y")
  )
)

(define-function path_round_rectangle
  (c-name "cogl_path_round_rectangle")
  (docstring
  "the corner arcs. Constructs a rectangular shape with rounded corners.\n"
  "If there is an existing path this will start a new disjoint sub-path.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x_1")
    '("float" "y_1")
    '("float" "x_2")
    '("float" "y_2")
    '("float" "radius")
    '("float" "arc_step")
  )
)



;; From cogl-shader.h

(define-function create_shader
  (c-name "cogl_create_shader")
  (docstring
  "Create a new shader handle, use cogl_shader_source to set the source\n"
  "code to be used on it.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglShaderType" "shader_type")
  )
)

(define-function shader_ref
  (c-name "cogl_shader_ref")
  (docstring
  "Add an extra reference to a shader.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function shader_unref
  (c-name "cogl_shader_unref")
  (docstring
  "Removes a reference to a shader. If it was the last reference the\n"
  "shader object will be destroyed.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function is_shader
  (c-name "cogl_is_shader")
  (docstring
  "Gets whether the given handle references an existing shader object.\n"
  "FALSE otherwise\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function shader_source
  (c-name "cogl_shader_source")
  (docstring
  "Replaces the current GLSL source associated with a shader with a new\n"
  "one.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "shader")
    '("const-gchar*" "source")
  )
)

(define-function shader_compile
  (c-name "cogl_shader_compile")
  (docstring
  "Compiles the shader, no return value, but the shader is now ready for\n"
  "linking into a program.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function shader_get_info_log
  (c-name "cogl_shader_get_info_log")
  (docstring
  "Retrieves the information log for a coglobject, can be used in\n"
  "conjunction with cogl_shader_get_parameteriv() to retrieve the\n"
  "compiler warnings/error messages that caused a shader to not compile\n"
  "correctly, mainly useful for debugging purposes. g_free() to free it\n"
  )
  (return-type "gchar*")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function shader_get_type
  (c-name "cogl_shader_get_type")
  (docstring
  "Retrieves the type of a shader CoglHandle or COGL_SHADER_TYPE_FRAGMENT\n"
  "if the shader is a frament processor\n"
  )
  (return-type "CoglShaderType")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function shader_is_compiled
  (c-name "cogl_shader_is_compiled")
  (docstring
  "Retrieves whether a shader CoglHandle has been compiled\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function create_program
  (c-name "cogl_create_program")
  (docstring
  "Create a new cogl program object that can be used to replace parts of\n"
  "the GL rendering pipeline with custom code.\n"
  )
  (return-type "CoglHandle")
)

(define-function program_ref
  (c-name "cogl_program_ref")
  (docstring
  "Add an extra reference to a program.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function program_unref
  (c-name "cogl_program_unref")
  (docstring
  "Removes a reference to a program. If it was the last reference the\n"
  "program object will be destroyed.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function is_program
  (c-name "cogl_is_program")
  (docstring
  "Gets whether the given handle references an existing program object.\n"
  "FALSE otherwise\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function program_attach_shader
  (c-name "cogl_program_attach_shader")
  (docstring
  "Attaches a shader to a program object, a program can have one vertex\n"
  "shader and one fragment shader attached.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "program_handle")
    '("CoglHandle" "shader_handle")
  )
)

(define-function program_link
  (c-name "cogl_program_link")
  (docstring
  "Links a program making it ready for use.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function program_use
  (c-name "cogl_program_use")
  (docstring
  "Activate a specific shader program replacing that part of the GL\n"
  "rendering pipeline, if passed in COGL_INVALID_HANDLE the default\n"
  "behavior of GL is reinstated.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function program_get_uniform_location
  (c-name "cogl_program_get_uniform_location")
  (docstring
  "Retrieve the location (offset) of a uniform variable in a shader\n"
  "program, a uniform is a variable that is constant for all\n"
  "vertices/fragments for a shader object and is possible to modify as an\n"
  "external parameter. This uniform can be set using\n"
  "cogl_program_uniform_1f() when the program is in use.\n"
  )
  (return-type "int")
  (parameters
    '("CoglHandle" "handle")
    '("const-char*" "uniform_name")
  )
)

(define-function program_uniform_1f
  (c-name "cogl_program_uniform_1f")
  (docstring
  "Changes the value of a floating point uniform in the currently used\n"
  "(see cogl_program_use()) shader program.\n"
  )
  (return-type "none")
  (parameters
    '("int" "uniform_no")
    '("float" "value")
  )
)

(define-function program_uniform_1i
  (c-name "cogl_program_uniform_1i")
  (docstring
  "Changes the value of an integer uniform in the currently used (see\n"
  "cogl_program_use()) shader program.\n"
  )
  (return-type "none")
  (parameters
    '("int" "uniform_no")
    '("int" "value")
  )
)

(define-function program_uniform_float
  (c-name "cogl_program_uniform_float")
  (docstring
  "Changes the value of a float vector uniform, or uniform array in the\n"
  "currently used (see cogl_program_use()) shader program.\n"
  )
  (return-type "none")
  (parameters
    '("int" "uniform_no")
    '("int" "size")
    '("int" "count")
    '("const-GLfloat*" "value")
  )
)

(define-function program_uniform_int
  (c-name "cogl_program_uniform_int")
  (docstring
  "Changes the value of a int vector uniform, or uniform array in the\n"
  "currently used (see cogl_program_use()) shader program.\n"
  )
  (return-type "none")
  (parameters
    '("int" "uniform_no")
    '("int" "size")
    '("int" "count")
    '("const-int*" "value")
  )
)

(define-function program_uniform_matrix
  (c-name "cogl_program_uniform_matrix")
  (docstring
  "Changes the value of a matrix uniform, or uniform array in the\n"
  "currently used (see cogl_program_use()) shader program. The size\n"
  "parameter is used to determine the square size of the matrix.\n"
  )
  (return-type "none")
  (parameters
    '("int" "uniform_no")
    '("int" "size")
    '("int" "count")
    '("gboolean" "transpose")
    '("const-float*" "value")
  )
)



;; From cogl-texture.h

(define-function texture_new_with_size
  (c-name "cogl_texture_new_with_size")
  (docstring
  "texture. Creates a new COGL texture with the specified dimensions and\n"
  "pixel format. COGL_INVALID_HANDLE on failure\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("guint" "width")
    '("guint" "height")
    '("CoglTextureFlags" "flags")
    '("CoglPixelFormat" "internal_format")
  )
)

(define-function texture_new_from_file
  (c-name "cogl_texture_new_from_file")
  (docstring
  "texture. If COGL_PIXEL_FORMAT_ANY is given then a premultiplied format\n"
  "similar to the format of the source data will be used. The default\n"
  "blending equations of Cogl expect premultiplied color data; the main\n"
  "use of passing a non-premultiplied format here is if you have non-\n"
  "premultiplied source data and are going to adjust the blend mode (see\n"
  "cogl_material_set_blend()) or use the data for something other than\n"
  "straight blending. Creates a COGL texture from an image file.\n"
  "COGL_INVALID_HANDLE on failure\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("const-gchar*" "filename")
    '("CoglTextureFlags" "flags")
    '("CoglPixelFormat" "internal_format")
    '("GError**" "error")
  )
)

(define-function texture_new_from_data
  (c-name "cogl_texture_new_from_data")
  (docstring
  "the buffer on the GPU. If COGL_PIXEL_FORMAT_ANY is given then a\n"
  "premultiplied format similar to the format of the source data will be\n"
  "used. The default blending equations of Cogl expect premultiplied\n"
  "color data; the main use of passing a non-premultiplied format here is\n"
  "if you have non-premultiplied source data and are going to adjust the\n"
  "blend mode (see cogl_material_set_blend()) or use the data for\n"
  "something other than straight blending. scanlines in data Creates a\n"
  "new COGL texture based on data residing in memory. COGL_INVALID_HANDLE\n"
  "on failure\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("guint" "width")
    '("guint" "height")
    '("CoglTextureFlags" "flags")
    '("CoglPixelFormat" "format")
    '("CoglPixelFormat" "internal_format")
    '("guint" "rowstride")
    '("const-guchar*" "data")
  )
)

(define-function texture_new_from_foreign
  (c-name "cogl_texture_new_from_foreign")
  (docstring
  "Creates a COGL texture based on an existing OpenGL texture; the width,\n"
  "height and format are passed along since it is not always possible to\n"
  "query these from OpenGL. The waste arguments allow you to create a\n"
  "Cogl texture that maps to a region smaller than the real OpenGL\n"
  "texture. For instance if your hardware only supports power-of-two\n"
  "textures you may load a non-power-of-two image into a larger power-of-\n"
  "two texture and use the waste arguments to tell Cogl which region\n"
  "should be mapped to the texture coordinate range [0:1].\n"
  "COGL_INVALID_HANDLE on failure\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("GLuint" "gl_handle")
    '("GLenum" "gl_target")
    '("GLuint" "width")
    '("GLuint" "height")
    '("GLuint" "x_pot_waste")
    '("GLuint" "y_pot_waste")
    '("CoglPixelFormat" "format")
  )
)

(define-function texture_new_from_bitmap
  (c-name "cogl_texture_new_from_bitmap")
  (docstring
  "texture Creates a COGL texture from a CoglBitmap. COGL_INVALID_HANDLE\n"
  "on failure\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "bmp_handle")
    '("CoglTextureFlags" "flags")
    '("CoglPixelFormat" "internal_format")
  )
)

(define-function is_texture
  (c-name "cogl_is_texture")
  (docstring
  "Gets whether the given handle references an existing texture object.\n"
  "FALSE otherwise\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function texture_get_width
  (c-name "cogl_texture_get_width")
  (docstring
  "Queries the width of a cogl texture.\n"
  )
  (return-type "guint")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function texture_get_height
  (c-name "cogl_texture_get_height")
  (docstring
  "Queries the height of a cogl texture.\n"
  )
  (return-type "guint")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function texture_get_format
  (c-name "cogl_texture_get_format")
  (docstring
  "Queries the CoglPixelFormat of a cogl texture.\n"
  )
  (return-type "CoglPixelFormat")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function texture_get_rowstride
  (c-name "cogl_texture_get_rowstride")
  (docstring
  "Queries the rowstride of a cogl texture.\n"
  )
  (return-type "guint")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function texture_get_max_waste
  (c-name "cogl_texture_get_max_waste")
  (docstring
  "Queries the maximum wasted (unused) pixels in one dimension of a GPU\n"
  "side texture.\n"
  )
  (return-type "gint")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function texture_is_sliced
  (c-name "cogl_texture_is_sliced")
  (docstring
  "Queries if a texture is sliced (stored as multiple GPU side tecture\n"
  "objects). is stored as a single GPU texture\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function texture_get_gl_texture
  (c-name "cogl_texture_get_gl_texture")
  (docstring
  "textures GL handle, or NULL. GL target type, or NULL. Queries the GL\n"
  "handles for a GPU side texture through its CoglHandle. If the texture\n"
  "is spliced the data for the first sub texture will be queried. if the\n"
  "handle was invalid\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
    '("GLuint*" "out_gl_handle")
    '("GLenum*" "out_gl_target")
  )
)

(define-function texture_get_data
  (c-name "cogl_texture_get_data")
  (docstring
  "specified. only querying the data size through the return value.\n"
  "Copies the pixel data from a cogl texture to system memory. is not\n"
  "valid\n"
  )
  (return-type "gint")
  (parameters
    '("CoglHandle" "handle")
    '("CoglPixelFormat" "format")
    '("guint" "rowstride")
    '("guchar*" "data")
  )
)

(define-function texture_set_region
  (c-name "cogl_texture_set_region")
  (docstring
  "specified) Sets the pixels in a rectangular subregion of handle from\n"
  "an in-memory buffer containing pixel data. FALSE otherwise\n"
  )
  (return-type "gboolean")
  (parameters
    '("CoglHandle" "handle")
    '("gint" "src_x")
    '("gint" "src_y")
    '("gint" "dst_x")
    '("gint" "dst_y")
    '("guint" "dst_width")
    '("guint" "dst_height")
    '("gint" "width")
    '("gint" "height")
    '("CoglPixelFormat" "format")
    '("guint" "rowstride")
    '("const-guchar*" "data")
  )
)

(define-function texture_ref
  (c-name "cogl_texture_ref")
  (docstring
  "Increment the reference count for a cogl texture.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function texture_unref
  (c-name "cogl_texture_unref")
  (docstring
  "Decrement the reference count for a cogl texture.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function rectangle_with_texture_coords
  (c-name "cogl_rectangle_with_texture_coords")
  (docstring
  "Draw a rectangle using the current material and supply texture\n"
  "coordinates to be used for the first texture layer of the material. To\n"
  "draw the entire texture pass in tx1=0.0 ty1=0.0 tx2=1.0 ty2=1.0.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x1")
    '("float" "y1")
    '("float" "x2")
    '("float" "y2")
    '("float" "tx1")
    '("float" "ty1")
    '("float" "tx2")
    '("float" "ty2")
  )
)

(define-function rectangle_with_multitexture_coords
  (c-name "cogl_rectangle_with_multitexture_coords")
  (docstring
  "coordinates; one for the upper left texel, and one for the lower right\n"
  "texel. Each value should be between 0.0 and 1.0, where the coordinate\n"
  "(0.0, 0.0) represents the top left of the texture, and (1.0, 1.0) the\n"
  "bottom right. and one group of texture coordinates, this would be 4)\n"
  "This function draws a rectangle using the current source material to\n"
  "texture or fill with. As a material may contain multiple texture\n"
  "layers this interface lets you supply texture coordinates for each\n"
  "layer of the material. The first pair of coordinates are for the first\n"
  "layer (with the smallest layer index) and if you supply less texture\n"
  "coordinates than there are layers in the current source material then\n"
  "default texture coordinates (0.0, 0.0, 1.0, 1.0) are generated.\n"
  )
  (return-type "none")
  (parameters
    '("float" "x1")
    '("float" "y1")
    '("float" "x2")
    '("float" "y2")
    '("const-float*" "tex_coords")
    '("gint" "tex_coords_len")
  )
)

(define-function rectangles_with_texture_coords
  (c-name "cogl_rectangles_with_texture_coords")
  (docstring
  "Draws a series of rectangles in the same way that cogl_rectangle()\n"
  "does. In some situations it can give a significant performance boost\n"
  "to use this function rather than calling cogl_rectangle() separately\n"
  "for each rectangle. parameters x1, y1, x2, and y2, and have the same\n"
  "meaning as in cogl_rectangle().\n"
  )
  (return-type "none")
  (parameters
    '("const-float*" "verts")
    '("guint" "n_rects")
  )
)

(define-function rectangles
  (c-name "cogl_rectangles")
  (return-type "none")
  (parameters
    '("const-float*" "verts")
    '("guint" "n_rects")
  )
)

(define-function polygon
  (c-name "cogl_polygon")
  (docstring
  "Draws a convex polygon using the current source material to fill /\n"
  "texture with according to the texture coordinates passed. If use_color\n"
  "is TRUE then the color will be changed for each vertex using the value\n"
  "specified in the color member of CoglTextureVertex. This can be used\n"
  "for example to make the texture fade out by setting the alpha value of\n"
  "the color. All of the texture coordinates must be in the range [0,1]\n"
  "and repeating the texture is not supported. Because of the way this\n"
  "function is implemented it will currently only work if either the\n"
  "texture is not sliced or the backend is not OpenGL ES and the\n"
  "minifying and magnifying functions are both set to\n"
  "COGL_MATERIAL_FILTER_NEAREST.\n"
  )
  (return-type "none")
  (parameters
    '("CoglTextureVertex*" "vertices")
    '("guint" "n_vertices")
    '("gboolean" "use_color")
  )
)

(define-function texture_new_from_sub_texture
  (c-name "cogl_texture_new_from_sub_texture")
  (docstring
  "Creates a new texture which represents a subregion of another texture.\n"
  "The GL resources will be shared so that no new texture data is\n"
  "actually allocated. Sub textures have undefined behaviour texture\n"
  "coordinates outside of the range [0,1] are used. They also do not work\n"
  "with CoglVertexBuffers. The sub texture will keep a reference to the\n"
  "full texture so you do not need to keep one separately if you only\n"
  "want to use the sub texture.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "full_texture")
    '("int" "sub_x")
    '("int" "sub_y")
    '("int" "sub_width")
    '("int" "sub_height")
  )
)


;; From cogl-types.h

(define-function handle_get_type
  (c-name "cogl_handle_get_type")
  (return-type "GType")
)

(define-method ref
  (of-object "CoglHandle")
  (c-name "cogl_handle_ref")
  (return-type "CoglHandle")
)

(define-method unref
  (of-object "CoglHandle")
  (c-name "cogl_handle_unref")
  (return-type "none")
)

(define-function fixed_get_type
  (c-name "cogl_fixed_get_type")
  (return-type "GType")
)



;; From cogl-vertex-buffer.h

(define-function vertex_buffer_new
  (c-name "cogl_vertex_buffer_new")
  (docstring
  "Creates a new vertex buffer that you can use to add attributes.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("guint" "n_vertices")
  )
)

(define-function vertex_buffer_get_n_vertices
  (c-name "cogl_vertex_buffer_get_n_vertices")
  (docstring
  "Retrieves the number of vertices that handle represents\n"
  )
  (return-type "guint")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function vertex_buffer_add
  (c-name "cogl_vertex_buffer_add")
  (docstring
  "variable name and standard attribute types must use one of following\n"
  "<itemizedlist> <listitem>gl_Color</listitem>\n"
  "<listitem>gl_Normal</listitem> <listitem>gl_MultiTexCoord0,\n"
  "gl_MultiTexCoord1, ...</listitem> <listitem>gl_Vertex</listitem>\n"
  "</itemizedlist> To support adding multiple variations of the same\n"
  "attribute the name can have a detail component, E.g. gl_Color::active\n"
  "or gl_Color::inactive 3 or 4 format should be mapped into the range\n"
  "[-1.0, 1.0] or [0.0, 1.0] for unsigned values. If FALSE they are\n"
  "converted to floats directly. value to the start of the next value\n"
  "(for the same attribute). So, for example, with a position interleved\n"
  "with color like this: XYRGBAXYRGBAXYRGBA, then if each letter\n"
  "represents a byte, the stride for both attributes is 6. The special\n"
  "value 0 means the values are stored sequentially in memory. must\n"
  "remain valid until you either call cogl_vertex_buffer_submit() or\n"
  "issue a draw call. Adds an attribute to a buffer. You either can use\n"
  "one of the built-in names such as gl_Vertex, or gl_MultiTexCoord0 to\n"
  "add standard attributes, like positions, colors and normals, or you\n"
  "can add custom attributes for use in shaders. The number of vertices\n"
  "declared when calling cogl_vertex_buffer_new() determines how many\n"
  "attribute values will be read from the supplied The data for your\n"
  "attribute isn't copied anywhere until you call\n"
  "cogl_vertex_buffer_submit(), or issue a draw call which automatically\n"
  "submits pending attribute changes. so the supplied pointer must remain\n"
  "valid until then. If you are updating an existing attribute (done by\n"
  "re-adding it) then you still need to re-call\n"
  "cogl_vertex_buffer_submit() to commit the changes to the GPU. Be\n"
  "carefull to minimize the number of calls to\n"
  "cogl_vertex_buffer_submit(), though. <note>If you are interleving\n"
  "attributes it is assumed that each interleaved attribute starts no\n"
  "farther than +- stride bytes from the other attributes it is\n"
  "interleved with. I.e. this is ok: <programlisting>\n"
  "|-0-0-0-0-0-0-0-0-0-0| </programlisting> This is not ok:\n"
  "<programlisting> |- - - - -0-0-0-0-0-0 0 0 0 0| </programlisting>\n"
  "(Though you can have multiple groups of interleved attributes)</note>\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
    '("const-char*" "attribute_name")
    '("guint8" "n_components")
    '("CoglAttributeType" "type")
    '("gboolean" "normalized")
    '("guint16" "stride")
    '("const-void*" "pointer")
  )
)

(define-function vertex_buffer_delete
  (c-name "cogl_vertex_buffer_delete")
  (docstring
  "Deletes an attribute from a buffer. You will need to call\n"
  "cogl_vertex_buffer_submit() or issue a draw call to commit this change\n"
  "to the GPU.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
    '("const-char*" "attribute_name")
  )
)

(define-function vertex_buffer_submit
  (c-name "cogl_vertex_buffer_submit")
  (docstring
  "Submits all the user added attributes to the GPU; once submitted, the\n"
  "attributes can be used for drawing. You should aim to minimize calls\n"
  "to this function since it implies validating your data; it potentially\n"
  "incurs a transport cost (especially if you are using GLX indirect\n"
  "rendering) and potentially a format conversion cost if the GPU doesn't\n"
  "natively support any of the given attribute formats.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function vertex_buffer_disable
  (c-name "cogl_vertex_buffer_disable")
  (docstring
  "Disables a previosuly added attribute. Since it can be costly to add\n"
  "and remove new attributes to buffers; to make individual buffers more\n"
  "reuseable it is possible to enable and disable attributes before using\n"
  "a buffer for drawing. You don't need to call\n"
  "cogl_vertex_buffer_submit() after using this function.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
    '("const-char*" "attribute_name")
  )
)

(define-function vertex_buffer_enable
  (c-name "cogl_vertex_buffer_enable")
  (docstring
  "Enables a previosuly disabled attribute. Since it can be costly to add\n"
  "and remove new attributes to buffers; to make individual buffers more\n"
  "reuseable it is possible to enable and disable attributes before using\n"
  "a buffer for drawing. You don't need to call\n"
  "cogl_vertex_buffer_submit() after using this function\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
    '("const-char*" "attribute_name")
  )
)

(define-function vertex_buffer_draw
  (c-name "cogl_vertex_buffer_draw")
  (docstring
  "interpreted. Allows you to draw geometry using all or a subset of the\n"
  "vertices in a vertex buffer. Any un-submitted attribute changes are\n"
  "automatically submitted before drawing.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
    '("CoglVerticesMode" "mode")
    '("int" "first")
    '("int" "count")
  )
)

(define-function vertex_buffer_indices_new
  (c-name "cogl_vertex_buffer_indices_new")
  (docstring
  "the indices. your array of indices Depending on how much geometry you\n"
  "are submitting it can be worthwhile optimizing the number of redundant\n"
  "vertices you submit. Using an index array allows you to reference\n"
  "vertices multiple times, for example during triangle strips.\n"
  "cogl_vertex_buffer_draw_elements().\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglIndicesType" "indices_type")
    '("const-void*" "indices_array")
    '("int" "indices_len")
  )
)

(define-function vertex_buffer_indices_get_type
  (c-name "cogl_vertex_buffer_indices_get_type")
  (docstring
  "Queries back the data type used for the given indices\n"
  )
  (return-type "CoglIndicesType")
  (parameters
    '("CoglHandle" "indices")
  )
)

;;(define-function vertex_buffer_delete_indices
;;  (c-name "cogl_vertex_buffer_delete_indices")
;;  (return-type "none")
;;  (parameters
;;    '("CoglHandle" "handle")
;;    '("int" "indices_id")
;;  )
;;)

(define-function vertex_buffer_draw_elements
  (c-name "cogl_vertex_buffer_draw_elements")
  (docstring
  "interpreted. cogl_vertex_buffer_indices_new () index to use for\n"
  "drawing. This function lets you use an array of indices to specify the\n"
  "vertices within your vertex buffer that you want to draw. The indices\n"
  "themselves are created by calling cogl_vertex_buffer_indices_new ()\n"
  "Any un-submitted attribute changes are automatically submitted before\n"
  "drawing.\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
    '("CoglVerticesMode" "mode")
    '("CoglHandle" "indices")
    '("int" "min_index")
    '("int" "max_index")
    '("int" "indices_offset")
    '("int" "count")
  )
)

(define-function vertex_buffer_ref
  (c-name "cogl_vertex_buffer_ref")
  (docstring
  "Increment the reference count for a vertex buffer\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function vertex_buffer_unref
  (c-name "cogl_vertex_buffer_unref")
  (docstring
  "Decrement the reference count for a vertex buffer\n"
  )
  (return-type "none")
  (parameters
    '("CoglHandle" "handle")
  )
)

(define-function vertex_buffer_indices_get_for_quads
  (c-name "cogl_vertex_buffer_indices_get_for_quads")
  (docstring
  "Creates a vertex buffer containing the indices needed to draw pairs of\n"
  "triangles from a list of vertices grouped as quads. There will be at\n"
  "least n_indices entries in the buffer (but there may be more). The\n"
  "indices will follow this pattern: 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7\n"
  "... etc For example, if you submit vertices for a quad like this: |[ 0\n"
  "3                 1        2 ]| Then you can request 6 indices to\n"
  "render two triangles like this: |[ 0           0        3\n"
  "1        2           2 ]| owned by Cogl and should not be modified or\n"
  "unref'd.\n"
  )
  (return-type "CoglHandle")
  (parameters
    '("guint" "n_indices")
  )
)


