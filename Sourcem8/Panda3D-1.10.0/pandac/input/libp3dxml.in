1436948407
2 3
9 libp3dxml 4 uZHm 12 panda3d.core 
149
234 10 ~TiXmlBase 0 6 383 21 TiXmlBase::~TiXmlBase 0 0 0
36
virtual TiXmlBase::~TiXmlBase(void);

235 5 Print 0 6 383 16 TiXmlBase::Print 0 1 1 339
/** All TinyXml classes can print themselves to a filestream
        or the string class (TiXmlString in non-STL mode, std::string
        in STL mode.) Either or both cfile and str can be null.

        This is a formatted print, and will insert
        tabs and newlines.

        (For an unformatted stream, use the << operator.)
    */
64
virtual void TiXmlBase::Print(FILE *cfile, int depth) const = 0;

236 21 SetCondenseWhiteSpace 0 4 383 32 TiXmlBase::SetCondenseWhiteSpace 0 1 2 351
/** The world does not agree on whether white space should be kept or
        not. In order to make everyone happy, these global, static functions
        are provided to set whether or not TinyXml will condense all white space
        into a single space or not. The default is to condense. Note changing this
        value is not thread safe.
    */
60
static void TiXmlBase::SetCondenseWhiteSpace(bool condense);

237 21 IsWhiteSpaceCondensed 0 4 383 32 TiXmlBase::IsWhiteSpaceCondensed 0 1 3 43
/// Return the current white space setting.
51
static bool TiXmlBase::IsWhiteSpaceCondensed(void);

238 3 Row 0 4 383 14 TiXmlBase::Row 0 1 4 944
/** Return the position, in the original source file, of this node or attribute.
        The row and column are 1-based. (That is the first row and first column is
        1,1). If the returns values are 0 or less, then the parser does not have
        a row and column value.

        Generally, the row and column value will be set when the TiXmlDocument::Load(),
        TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
        when the DOM was created from operator>>.

        The values reflect the initial load. Once the DOM is modified programmatically
        (by adding or changing nodes and attributes) the new values will NOT update to
        reflect changes in the document.

        There is a minor performance cost to computing the row and column. Computation
        can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.

        @sa TiXmlDocument::SetTabSize()
    */
31
int TiXmlBase::Row(void) const;

239 6 Column 0 4 383 17 TiXmlBase::Column 0 1 5 14
///< See Row()
34
int TiXmlBase::Column(void) const;

240 11 SetUserData 0 4 383 22 TiXmlBase::SetUserData 0 0 42
///< Set a pointer to arbitrary user data.
40
void TiXmlBase::SetUserData(void *user);

241 11 GetUserData 0 4 383 22 TiXmlBase::GetUserData 0 2 6 7 86
///< Get a pointer to arbitrary user data.

///< Get a pointer to arbitrary user data.
83
void *TiXmlBase::GetUserData(void);
void const *TiXmlBase::GetUserData(void) const;

242 5 Parse 0 6 383 16 TiXmlBase::Parse 0 1 8 0
104
virtual char const *TiXmlBase::Parse(char const *p, TiXmlParsingData *data, TiXmlEncoding encoding) = 0;

243 12 EncodeString 0 4 383 23 TiXmlBase::EncodeString 0 1 9 145
/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc,
        or they will be transformed into entities!
    */
68
static void TiXmlBase::EncodeString(string const &str, string *out);

244 5 Value 0 4 386 16 TiXmlNode::Value 0 1 19 368
/** The meaning of 'value' changes for the specific type of
        TiXmlNode.
        @verbatim
        Document:   filename of the xml file
        Element:    name of the element
        Comment:    the comment text
        Unknown:    the tag contents
        Text:       the text string
        @endverbatim

        The subclasses will wrap this function.
    */
41
char const *TiXmlNode::Value(void) const;

245 8 ValueStr 0 4 386 19 TiXmlNode::ValueStr 0 1 20 153
/** Return Value() as a std::string. If you only use STL,
        this is more efficient than calling Value().
        Only available in STL mode.
    */
46
string const &TiXmlNode::ValueStr(void) const;

246 9 ValueTStr 0 4 386 20 TiXmlNode::ValueTStr 0 1 21 0
47
string const &TiXmlNode::ValueTStr(void) const;

247 8 SetValue 0 4 386 19 TiXmlNode::SetValue 0 2 22 23 314
/** Changes the value of the node. Defined as:
        @verbatim
        Document:   filename of the xml file
        Element:    name of the element
        Comment:    the comment text
        Unknown:    the tag contents
        Text:       the text string
        @endverbatim
    */

/// STL std::string form.
93
void TiXmlNode::SetValue(char const *_value);
void TiXmlNode::SetValue(string const &_value);

248 5 Clear 0 4 386 16 TiXmlNode::Clear 0 1 24 65
/// Delete all the children of this node. Does not affect 'this'.
28
void TiXmlNode::Clear(void);

249 6 Parent 0 4 386 17 TiXmlNode::Parent 0 2 25 26 24
/// One step up the DOM.
83
TiXmlNode *TiXmlNode::Parent(void);
TiXmlNode const *TiXmlNode::Parent(void) const;

250 10 FirstChild 0 4 386 21 TiXmlNode::FirstChild 0 6 27 28 29 30 31 32 382
///< The first child of this node. Will be null if there are no children.

///< The first child of this node. Will be null if there are no children.

///< The first child of this node with the matching 'value'. Will be null if none found.
/// The first child of this node with the matching 'value'. Will be null if none found.

///< STL std::string form.

///< STL std::string form.
334
TiXmlNode const *TiXmlNode::FirstChild(void) const;
TiXmlNode *TiXmlNode::FirstChild(void);
TiXmlNode const *TiXmlNode::FirstChild(char const *value) const;
TiXmlNode *TiXmlNode::FirstChild(char const *_value);
TiXmlNode const *TiXmlNode::FirstChild(string const &_value) const;
TiXmlNode *TiXmlNode::FirstChild(string const &_value);

251 9 LastChild 0 4 386 20 TiXmlNode::LastChild 0 6 33 34 35 36 37 38 380
/// The last child of this node. Will be null if there are no children.

/// The last child of this node. Will be null if there are no children.

/// The last child of this node matching 'value'. Will be null if there are no children.

/// The last child of this node matching 'value'. Will be null if there are no children.

///< STL std::string form.

///< STL std::string form.
328
TiXmlNode const *TiXmlNode::LastChild(void) const;
TiXmlNode *TiXmlNode::LastChild(void);
TiXmlNode const *TiXmlNode::LastChild(char const *value) const;
TiXmlNode *TiXmlNode::LastChild(char const *_value);
TiXmlNode const *TiXmlNode::LastChild(string const &_value) const;
TiXmlNode *TiXmlNode::LastChild(string const &_value);

252 15 IterateChildren 0 4 386 26 TiXmlNode::IterateChildren 0 6 39 40 41 42 43 44 747
/** An alternate way to walk the children of a node.
        One way to iterate over nodes is:
        @verbatim
            for( child = parent->FirstChild(); child; child = child->NextSibling() )
        @endverbatim

        IterateChildren does the same thing with the syntax:
        @verbatim
            child = 0;
            while( child = parent->IterateChildren( child ) )
        @endverbatim

        IterateChildren takes the previous child as input and finds
        the next one. If the previous child is null, it returns the
        first. IterateChildren will return null when done.
    */

/// This flavor of IterateChildren searches for children with a particular 'value'

///< STL std::string form.

///< STL std::string form.
514
TiXmlNode const *TiXmlNode::IterateChildren(TiXmlNode const *previous) const;
TiXmlNode *TiXmlNode::IterateChildren(TiXmlNode const *previous);
TiXmlNode const *TiXmlNode::IterateChildren(char const *value, TiXmlNode const *previous) const;
TiXmlNode *TiXmlNode::IterateChildren(char const *_value, TiXmlNode const *previous);
TiXmlNode const *TiXmlNode::IterateChildren(string const &_value, TiXmlNode const *previous) const;
TiXmlNode *TiXmlNode::IterateChildren(string const &_value, TiXmlNode const *previous);

253 14 InsertEndChild 0 4 386 25 TiXmlNode::InsertEndChild 0 1 45 148
/** Add a new node related to this. Adds a child past the LastChild.
        Returns a pointer to the new object or NULL if an error occured.
    */
63
TiXmlNode *TiXmlNode::InsertEndChild(TiXmlNode const &addThis);

254 17 InsertBeforeChild 0 4 386 28 TiXmlNode::InsertBeforeChild 0 1 46 156
/** Add a new node related to this. Adds a child before the specified child.
        Returns a pointer to the new object or NULL if an error occured.
    */
89
TiXmlNode *TiXmlNode::InsertBeforeChild(TiXmlNode *beforeThis, TiXmlNode const &addThis);

255 16 InsertAfterChild 0 4 386 27 TiXmlNode::InsertAfterChild 0 1 47 155
/** Add a new node related to this. Adds a child after the specified child.
        Returns a pointer to the new object or NULL if an error occured.
    */
87
TiXmlNode *TiXmlNode::InsertAfterChild(TiXmlNode *afterThis, TiXmlNode const &addThis);

256 12 ReplaceChild 0 4 386 23 TiXmlNode::ReplaceChild 0 1 48 113
/** Replace a child of this node.
        Returns a pointer to the new object or NULL if an error occured.
    */
86
TiXmlNode *TiXmlNode::ReplaceChild(TiXmlNode *replaceThis, TiXmlNode const &withThis);

257 11 RemoveChild 0 4 386 22 TiXmlNode::RemoveChild 0 1 49 32
/// Delete a child of this node.
51
bool TiXmlNode::RemoveChild(TiXmlNode *removeThis);

258 15 PreviousSibling 0 4 386 26 TiXmlNode::PreviousSibling 0 6 50 51 52 53 54 55 120
/// Navigate to a sibling node.

/// Navigate to a sibling node.

///< STL std::string form.

///< STL std::string form.
358
TiXmlNode const *TiXmlNode::PreviousSibling(void) const;
TiXmlNode *TiXmlNode::PreviousSibling(void);
TiXmlNode const *TiXmlNode::PreviousSibling(char const *) const;
TiXmlNode *TiXmlNode::PreviousSibling(char const *_prev);
TiXmlNode const *TiXmlNode::PreviousSibling(string const &_value) const;
TiXmlNode *TiXmlNode::PreviousSibling(string const &_value);

259 11 NextSibling 0 4 386 22 TiXmlNode::NextSibling 0 6 56 57 58 59 60 61 143
///< STL std::string form.

///< STL std::string form.

/// Navigate to a sibling node.

/// Navigate to a sibling node with the given 'value'.
334
TiXmlNode const *TiXmlNode::NextSibling(string const &_value) const;
TiXmlNode *TiXmlNode::NextSibling(string const &_value);
TiXmlNode const *TiXmlNode::NextSibling(void) const;
TiXmlNode *TiXmlNode::NextSibling(void);
TiXmlNode const *TiXmlNode::NextSibling(char const *) const;
TiXmlNode *TiXmlNode::NextSibling(char const *_next);

260 18 NextSiblingElement 0 4 386 29 TiXmlNode::NextSiblingElement 0 6 62 63 64 65 66 67 420
/** Convenience function to get through elements.
        Calls NextSibling and ToElement. Will skip all non-Element
        nodes. Returns 0 if there is not another element.
    */

/** Convenience function to get through elements.
        Calls NextSibling and ToElement. Will skip all non-Element
        nodes. Returns 0 if there is not another element.
    */

///< STL std::string form.

///< STL std::string form.
394
TiXmlElement const *TiXmlNode::NextSiblingElement(void) const;
TiXmlElement *TiXmlNode::NextSiblingElement(void);
TiXmlElement const *TiXmlNode::NextSiblingElement(char const *) const;
TiXmlElement *TiXmlNode::NextSiblingElement(char const *_next);
TiXmlElement const *TiXmlNode::NextSiblingElement(string const &_value) const;
TiXmlElement *TiXmlNode::NextSiblingElement(string const &_value);

261 17 FirstChildElement 0 4 386 28 TiXmlNode::FirstChildElement 0 6 68 69 70 71 72 73 156
/// Convenience function to get through elements.

/// Convenience function to get through elements.

///< STL std::string form.

///< STL std::string form.
395
TiXmlElement const *TiXmlNode::FirstChildElement(void) const;
TiXmlElement *TiXmlNode::FirstChildElement(void);
TiXmlElement const *TiXmlNode::FirstChildElement(char const *_value) const;
TiXmlElement *TiXmlNode::FirstChildElement(char const *_value);
TiXmlElement const *TiXmlNode::FirstChildElement(string const &_value) const;
TiXmlElement *TiXmlNode::FirstChildElement(string const &_value);

262 4 Type 0 4 386 15 TiXmlNode::Type 0 1 74 195
/** Query the type (as an enumerated value, above) of this node.
        The possible types are: DOCUMENT, ELEMENT, COMMENT,
                                UNKNOWN, TEXT, and DECLARATION.
    */
32
int TiXmlNode::Type(void) const;

263 11 GetDocument 0 4 386 22 TiXmlNode::GetDocument 0 2 75 76 106
/** Return a pointer to the Document this node lives in.
        Returns null if not in a document.
    */
101
TiXmlDocument const *TiXmlNode::GetDocument(void) const;
TiXmlDocument *TiXmlNode::GetDocument(void);

264 10 NoChildren 0 4 386 21 TiXmlNode::NoChildren 0 1 77 46
/// Returns true if this node has no children.
39
bool TiXmlNode::NoChildren(void) const;

265 10 ToDocument 0 6 386 21 TiXmlNode::ToDocument 0 2 78 79 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
115
virtual TiXmlDocument const *TiXmlNode::ToDocument(void) const;
virtual TiXmlDocument *TiXmlNode::ToDocument(void);

266 9 ToElement 0 6 386 20 TiXmlNode::ToElement 0 2 80 81 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
111
virtual TiXmlElement const *TiXmlNode::ToElement(void) const;
virtual TiXmlElement *TiXmlNode::ToElement(void);

267 9 ToComment 0 6 386 20 TiXmlNode::ToComment 0 2 82 83 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
111
virtual TiXmlComment const *TiXmlNode::ToComment(void) const;
virtual TiXmlComment *TiXmlNode::ToComment(void);

268 9 ToUnknown 0 6 386 20 TiXmlNode::ToUnknown 0 2 84 85 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
111
virtual TiXmlUnknown const *TiXmlNode::ToUnknown(void) const;
virtual TiXmlUnknown *TiXmlNode::ToUnknown(void);

269 6 ToText 0 6 386 17 TiXmlNode::ToText 0 2 86 87 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
99
virtual TiXmlText const *TiXmlNode::ToText(void) const;
virtual TiXmlText *TiXmlNode::ToText(void);

270 13 ToDeclaration 0 6 386 24 TiXmlNode::ToDeclaration 0 2 88 89 162
///< Cast to a more defined type. Will return null if not of the requested type.

///< Cast to a more defined type. Will return null if not of the requested type.
127
virtual TiXmlDeclaration const *TiXmlNode::ToDeclaration(void) const;
virtual TiXmlDeclaration *TiXmlNode::ToDeclaration(void);

271 5 Clone 0 6 386 16 TiXmlNode::Clone 0 1 90 114
/** Create an exact duplicate of this node and return it. The memory must be deleted
        by the caller.
    */
52
virtual TiXmlNode *TiXmlNode::Clone(void) const = 0;

272 6 Accept 0 6 386 17 TiXmlNode::Accept 0 1 91 825
/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the
        XML tree will be conditionally visited and the host will be called back
        via the TiXmlVisitor interface.

        This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
        the XML for the callbacks, so the performance of TinyXML is unchanged by using this
        interface versus any other.)

        The interface has been based on ideas from:

        - http://www.saxproject.org/
        - http://c2.com/cgi/wiki?HierarchicalVisitorPattern

        Which are both good references for "visiting".

        An example of using Accept():
        @verbatim
        TiXmlPrinter printer;
        tinyxmlDoc.Accept( &printer );
        const char* xmlcstr = printer.CStr();
        @endverbatim
    */
64
virtual bool TiXmlNode::Accept(TiXmlVisitor *visitor) const = 0;

273 16 TiXmlDeclaration 0 4 385 34 TiXmlDeclaration::TiXmlDeclaration 0 4 10 11 12 13 69
/// Construct an empty declaration.

/// Constructor.

/// Construct.
325
TiXmlDeclaration::TiXmlDeclaration(void);
TiXmlDeclaration::TiXmlDeclaration(string const &_version, string const &_encoding, string const &_standalone);
TiXmlDeclaration::TiXmlDeclaration(char const *_version, char const *_encoding, char const *_standalone);
TiXmlDeclaration::TiXmlDeclaration(TiXmlDeclaration const &copy);

274 10 operator = 0 4 385 28 TiXmlDeclaration::operator = 0 1 14 0
64
void TiXmlDeclaration::operator =(TiXmlDeclaration const &copy);

275 7 Version 0 4 385 25 TiXmlDeclaration::Version 0 1 15 59
/// Version. Will return an empty string if none was found.
50
char const *TiXmlDeclaration::Version(void) const;

276 8 Encoding 0 4 385 26 TiXmlDeclaration::Encoding 0 1 16 60
/// Encoding. Will return an empty string if none was found.
51
char const *TiXmlDeclaration::Encoding(void) const;

277 10 Standalone 0 4 385 28 TiXmlDeclaration::Standalone 0 1 17 34
/// Is this a standalone document?
53
char const *TiXmlDeclaration::Standalone(void) const;

278 5 Print 0 6 385 23 TiXmlDeclaration::Print 0 1 18 54
// Print this declaration to a FILE stream.

/*depth*/
80
virtual void TiXmlDeclaration::Print(FILE *cfile, int depth, string *str) const;

279 13 TiXmlDocument 0 4 388 28 TiXmlDocument::TiXmlDocument 0 4 92 93 94 95 159
/// Create an empty document, that has no name.

/// Create a document with a name. The name of the document is also the filename of the xml.

/// Constructor.
206
TiXmlDocument::TiXmlDocument(void);
TiXmlDocument::TiXmlDocument(char const *documentName);
TiXmlDocument::TiXmlDocument(string const &documentName);
TiXmlDocument::TiXmlDocument(TiXmlDocument const &copy);

280 10 operator = 0 4 388 25 TiXmlDocument::operator = 0 1 96 0
58
void TiXmlDocument::operator =(TiXmlDocument const &copy);

281 8 LoadFile 0 4 388 23 TiXmlDocument::LoadFile 0 4 97 98 99 100 573
/** Load a file using the current document value.
        Returns true if successful. Will delete any existing
        document data before loading.
    */

/// Load a file using the given filename. Returns true if successful.

/** Load a file using the given FILE*. Returns true if successful. Note that this method
        doesn't stream - the entire object pointed at by the FILE*
        will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
        file location. Streaming may be added in the future.
    */

///< STL std::string version.
377
bool TiXmlDocument::LoadFile(TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING);
bool TiXmlDocument::LoadFile(char const *filename, TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING);
bool TiXmlDocument::LoadFile(FILE *, TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING);
bool TiXmlDocument::LoadFile(string const &filename, TiXmlEncoding encoding = ::TIXML_DEFAULT_ENCODING);

282 8 SaveFile 0 4 388 23 TiXmlDocument::SaveFile 0 4 101 102 103 104 247
/// Save a file using the current document value. Returns true if successful.

/// Save a file using the given filename. Returns true if successful.

/// Save a file using the given FILE*. Returns true if successful.

///< STL std::string version.
203
bool TiXmlDocument::SaveFile(void) const;
bool TiXmlDocument::SaveFile(char const *filename) const;
bool TiXmlDocument::SaveFile(FILE *) const;
bool TiXmlDocument::SaveFile(string const &filename) const;

283 11 RootElement 0 4 388 26 TiXmlDocument::RootElement 0 2 105 106 207
/** Get the root element -- the only top level element -- of the document.
        In well formed XML, there should only be one. TinyXml is tolerant of
        multiple elements at the document level.
    */
107
TiXmlElement const *TiXmlDocument::RootElement(void) const;
TiXmlElement *TiXmlDocument::RootElement(void);

284 5 Error 0 4 388 20 TiXmlDocument::Error 0 1 107 330
/** If an error occurs, Error will be set to true. Also,
        - The ErrorId() will contain the integer identifier of the error (not generally useful)
        - The ErrorDesc() method will return the name of the error. (very useful)
        - The ErrorRow() and ErrorCol() will return the location of the error (if known)
    */
38
bool TiXmlDocument::Error(void) const;

285 9 ErrorDesc 0 4 388 24 TiXmlDocument::ErrorDesc 0 1 108 72
/// Contains a textual (english) description of the error if one occurs.
49
char const *TiXmlDocument::ErrorDesc(void) const;

286 7 ErrorId 0 4 388 22 TiXmlDocument::ErrorId 0 1 109 141
/** Generally, you probably want the error string ( ErrorDesc() ). But if you
        prefer the ErrorId, this function will fetch it.
    */
39
int TiXmlDocument::ErrorId(void) const;

287 8 ErrorRow 0 4 388 23 TiXmlDocument::ErrorRow 0 1 110 359
/** Returns the location (if known) of the error. The first column is column 1,
        and the first row is row 1. A value of 0 means the row and column wasn't applicable
        (memory errors, for example, have no row/column) or the parser lost the error. (An
        error in the error reporting, in that case.)

        @sa SetTabSize, Row, Column
    */
40
int TiXmlDocument::ErrorRow(void) const;

288 8 ErrorCol 0 4 388 23 TiXmlDocument::ErrorCol 0 1 111 55
///< The column where the error occured. See ErrorRow()
40
int TiXmlDocument::ErrorCol(void) const;

289 10 SetTabSize 0 4 388 25 TiXmlDocument::SetTabSize 0 1 112 970
/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
        to report the correct values for row and column. It does not change the output
        or input in any way.

        By calling this method, with a tab size
        greater than 0, the row and column of each node and attribute is stored
        when the file is loaded. Very useful for tracking the DOM back in to
        the source file.

        The tab size is required for calculating the location of nodes. If not
        set, the default of 4 is used. The tabsize is set per document. Setting
        the tabsize to 0 disables row/column tracking.

        Note that row and column tracking is not supported when using operator>>.

        The tab size needs to be enabled before the parse or load. Correct usage:
        @verbatim
        TiXmlDocument doc;
        doc.SetTabSize( 8 );
        doc.Load( "myfile.xml" );
        @endverbatim

        @sa Row, Column
    */
45
void TiXmlDocument::SetTabSize(int _tabsize);

290 7 TabSize 0 4 388 22 TiXmlDocument::TabSize 0 1 113 0
39
int TiXmlDocument::TabSize(void) const;

291 10 ClearError 0 4 388 25 TiXmlDocument::ClearError 0 1 114 152
/** If you have handled the error, it can be reset with this call. The error
        state is automatically cleared if you Parse a new XML block.
    */
37
void TiXmlDocument::ClearError(void);

292 5 Print 0 4 388 20 TiXmlDocument::Print 0 1 115 84
/** Write the document to standard out using formatted printing ("pretty print"). */
38
void TiXmlDocument::Print(void) const;

293 8 SetError 0 4 388 23 TiXmlDocument::SetError 0 1 116 17
// [internal use]
117
void TiXmlDocument::SetError(int err, char const *errorLocation, TiXmlParsingData *prevData, TiXmlEncoding encoding);

294 12 TiXmlElement 0 4 389 26 TiXmlElement::TiXmlElement 0 3 117 118 119 55
/// Construct an element.

/// std::string constructor.
149
TiXmlElement::TiXmlElement(char const *in_value);
TiXmlElement::TiXmlElement(string const &_value);
TiXmlElement::TiXmlElement(TiXmlElement const &);

295 10 operator = 0 4 389 24 TiXmlElement::operator = 0 1 120 0
56
void TiXmlElement::operator =(TiXmlElement const &base);

296 9 Attribute 0 4 389 23 TiXmlElement::Attribute 0 2 121 122 695
/** Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none exists.
    */

/** Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none exists.
        If the attribute exists and can be converted to an integer,
        the integer value will be put in the return 'i', if 'i'
        is non-null.
    */

/** Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none exists.
        If the attribute exists and can be converted to an double,
        the double value will be put in the return 'd', if 'd'
        is non-null.
    */
415
char const *TiXmlElement::Attribute(char const *name) const;
char const *TiXmlElement::Attribute(char const *name, int *i) const;
char const *TiXmlElement::Attribute(char const *name, double *d) const;
string const *TiXmlElement::Attribute(string const &name) const;
string const *TiXmlElement::Attribute(string const &name, int *i) const;
string const *TiXmlElement::Attribute(string const &name, double *d) const;

297 17 QueryIntAttribute 0 4 389 31 TiXmlElement::QueryIntAttribute 0 0 384
/** QueryIntAttribute examines the attribute - it is an alternative to the
        Attribute() method with richer error checking.
        If the attribute is an integer, it is stored in 'value' and
        the call returns TIXML_SUCCESS. If it is not
        an integer, it returns TIXML_WRONG_TYPE. If the attribute
        does not exist, then TIXML_NO_ATTRIBUTE is returned.
    */
149
int TiXmlElement::QueryIntAttribute(char const *name, int *_value) const;
int TiXmlElement::QueryIntAttribute(string const &name, int *_value) const;

298 20 QueryDoubleAttribute 0 4 389 34 TiXmlElement::QueryDoubleAttribute 0 0 74
/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
161
int TiXmlElement::QueryDoubleAttribute(char const *name, double *_value) const;
int TiXmlElement::QueryDoubleAttribute(string const &name, double *_value) const;

299 19 QueryFloatAttribute 0 4 389 33 TiXmlElement::QueryFloatAttribute 0 0 73
/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().
77
int TiXmlElement::QueryFloatAttribute(char const *name, float *_value) const;

300 20 QueryStringAttribute 0 4 389 34 TiXmlElement::QueryStringAttribute 0 1 123 74
/// QueryStringAttribute examines the attribute - see QueryIntAttribute().
79
int TiXmlElement::QueryStringAttribute(char const *name, string *_value) const;

301 19 QueryValueAttribute 0 4 389 33 TiXmlElement::QueryValueAttribute 0 1 124 0
82
int TiXmlElement::QueryValueAttribute(string const &name, string *outValue) const;

302 12 SetAttribute 0 4 389 26 TiXmlElement::SetAttribute 0 4 125 126 127 128 331
/** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */

/// STL std::string form.

///< STL std::string form.

/** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */
272
void TiXmlElement::SetAttribute(char const *name, char const *_value);
void TiXmlElement::SetAttribute(string const &name, string const &_value);
void TiXmlElement::SetAttribute(string const &name, int _value);
void TiXmlElement::SetAttribute(char const *name, int value);

303 18 SetDoubleAttribute 0 4 389 32 TiXmlElement::SetDoubleAttribute 0 2 129 130 165
///< STL std::string form.

/** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */
143
void TiXmlElement::SetDoubleAttribute(string const &name, double value);
void TiXmlElement::SetDoubleAttribute(char const *name, double value);

304 15 RemoveAttribute 0 4 389 29 TiXmlElement::RemoveAttribute 0 2 131 132 80
/** Deletes an attribute with the given name.
    */

///< STL std::string form.
109
void TiXmlElement::RemoveAttribute(char const *name);
void TiXmlElement::RemoveAttribute(string const &name);

305 14 FirstAttribute 0 4 389 28 TiXmlElement::FirstAttribute 0 2 133 134 98
///< Access the first attribute in this element.

///< Access the first attribute in this element.
115
TiXmlAttribute const *TiXmlElement::FirstAttribute(void) const;
TiXmlAttribute *TiXmlElement::FirstAttribute(void);

306 13 LastAttribute 0 4 389 27 TiXmlElement::LastAttribute 0 2 135 136 96
///< Access the last attribute in this element.

///< Access the last attribute in this element.
113
TiXmlAttribute const *TiXmlElement::LastAttribute(void) const;
TiXmlAttribute *TiXmlElement::LastAttribute(void);

307 7 GetText 0 4 389 21 TiXmlElement::GetText 0 1 137 1274
/** Convenience function for easy access to the text inside an element. Although easy
        and concise, GetText() is limited compared to getting the TiXmlText child
        and accessing it directly.

        If the first child of 'this' is a TiXmlText, the GetText()
        returns the character string of the Text node, else null is returned.

        This is a convenient method for getting the text of simple contained text:
        @verbatim
        <foo>This is text</foo>
        const char* str = fooElement->GetText();
        @endverbatim

        'str' will be a pointer to "This is text".

        Note that this function can be misleading. If the element foo was created from
        this XML:
        @verbatim
        <foo><b>This is text</b></foo>
        @endverbatim

        then the value of str would be null. The first child node isn't a text node, it is
        another element. From this XML:
        @verbatim
        <foo>This is <b>text</b></foo>
        @endverbatim
        GetText() will return "This is ".

        WARNING: GetText() accesses a child node - don't become confused with the
                 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are
                 safe type casts on the referenced node.
    */
46
char const *TiXmlElement::GetText(void) const;

308 15 read_xml_stream 0 1 0 15 read_xml_stream 0 1 226 293
////////////////////////////////////////////////////////////////////
//     Function: read_xml_stream
//  Description: Reads an XML document from the indicated stream.
//               Returns the document, or NULL on error.
////////////////////////////////////////////////////////////////////
44
TiXmlDocument *read_xml_stream(istream &in);

309 16 write_xml_stream 0 1 0 16 write_xml_stream 0 1 227 0
56
void write_xml_stream(ostream &out, TiXmlDocument *doc);

310 9 print_xml 0 1 0 9 print_xml 0 1 228 0
33
void print_xml(TiXmlNode *xnode);

311 17 print_xml_to_file 0 1 0 17 print_xml_to_file 0 1 229 0
67
void print_xml_to_file(Filename const &filename, TiXmlNode *xnode);

312 23 get_TIXML_MAJOR_VERSION 0 16 0 23 get_TIXML_MAJOR_VERSION 0 1 230 41
getter for int const TIXML_MAJOR_VERSION;
34
int get_TIXML_MAJOR_VERSION(void);

313 23 get_TIXML_MINOR_VERSION 0 16 0 23 get_TIXML_MINOR_VERSION 0 1 231 41
getter for int const TIXML_MINOR_VERSION;
34
int get_TIXML_MINOR_VERSION(void);

314 23 get_TIXML_PATCH_VERSION 0 16 0 23 get_TIXML_PATCH_VERSION 0 1 232 41
getter for int const TIXML_PATCH_VERSION;
34
int get_TIXML_PATCH_VERSION(void);

315 12 ~TiXmlCursor 0 4 391 25 TiXmlCursor::~TiXmlCursor 0 0 0
32
TiXmlCursor::~TiXmlCursor(void);

316 13 ~TiXmlVisitor 0 6 392 27 TiXmlVisitor::~TiXmlVisitor 0 0 0
42
virtual TiXmlVisitor::~TiXmlVisitor(void);

317 10 VisitEnter 0 6 392 24 TiXmlVisitor::VisitEnter 0 2 138 139 27
/*doc*/

/*firstAttribute*/
146
virtual bool TiXmlVisitor::VisitEnter(TiXmlDocument const &);
virtual bool TiXmlVisitor::VisitEnter(TiXmlElement const &, TiXmlAttribute const *);

318 9 VisitExit 0 6 392 23 TiXmlVisitor::VisitExit 0 2 140 141 20
/*doc*/

/*element*/
120
virtual bool TiXmlVisitor::VisitExit(TiXmlDocument const &);
virtual bool TiXmlVisitor::VisitExit(TiXmlElement const &);

319 5 Visit 0 6 392 19 TiXmlVisitor::Visit 0 4 142 143 144 145 51
/*declaration*/

/*text*/

/*comment*/

/*unknown*/
224
virtual bool TiXmlVisitor::Visit(TiXmlDeclaration const &);
virtual bool TiXmlVisitor::Visit(TiXmlText const &);
virtual bool TiXmlVisitor::Visit(TiXmlComment const &);
virtual bool TiXmlVisitor::Visit(TiXmlUnknown const &);

320 26 get_TIXML_DEFAULT_ENCODING 0 16 0 26 get_TIXML_DEFAULT_ENCODING 0 1 233 54
getter for TiXmlEncoding const TIXML_DEFAULT_ENCODING;
47
TiXmlEncoding get_TIXML_DEFAULT_ENCODING(void);

321 14 TiXmlAttribute 0 4 395 30 TiXmlAttribute::TiXmlAttribute 0 3 146 147 148 114
/// Construct an empty attribute.

/// std::string constructor.

/// Construct an attribute with a name and value.
183
TiXmlAttribute::TiXmlAttribute(void);
TiXmlAttribute::TiXmlAttribute(string const &_name, string const &_value);
TiXmlAttribute::TiXmlAttribute(char const *_name, char const *_value);

322 4 Name 0 4 395 20 TiXmlAttribute::Name 0 1 149 39
///< Return the name of this attribute.
45
char const *TiXmlAttribute::Name(void) const;

323 5 Value 0 4 395 21 TiXmlAttribute::Value 0 1 150 40
///< Return the value of this attribute.
46
char const *TiXmlAttribute::Value(void) const;

324 8 ValueStr 0 4 395 24 TiXmlAttribute::ValueStr 0 1 151 40
///< Return the value of this attribute.
51
string const &TiXmlAttribute::ValueStr(void) const;

325 8 IntValue 0 4 395 24 TiXmlAttribute::IntValue 0 1 152 65
///< Return the value of this attribute, converted to an integer.
41
int TiXmlAttribute::IntValue(void) const;

326 11 DoubleValue 0 4 395 27 TiXmlAttribute::DoubleValue 0 1 153 63
///< Return the value of this attribute, converted to a double.
47
double TiXmlAttribute::DoubleValue(void) const;

327 8 NameTStr 0 4 395 24 TiXmlAttribute::NameTStr 0 1 154 40
// Get the tinyxml string representation
51
string const &TiXmlAttribute::NameTStr(void) const;

328 13 QueryIntValue 0 4 395 29 TiXmlAttribute::QueryIntValue 0 0 440
/** QueryIntValue examines the value string. It is an alternative to the
        IntValue() method with richer error checking.
        If the value is an integer, it is stored in 'value' and
        the call returns TIXML_SUCCESS. If it is not
        an integer, it returns TIXML_WRONG_TYPE.

        A specialized but useful call. Note that for success it returns 0,
        which is the opposite of almost all other TinyXml calls.
    */
53
int TiXmlAttribute::QueryIntValue(int *_value) const;

329 16 QueryDoubleValue 0 4 395 32 TiXmlAttribute::QueryDoubleValue 0 0 68
/// QueryDoubleValue examines the value string. See QueryIntValue().
59
int TiXmlAttribute::QueryDoubleValue(double *_value) const;

330 7 SetName 0 4 395 23 TiXmlAttribute::SetName 0 2 155 156 63
///< Set the name of this attribute.

/// STL std::string form.
99
void TiXmlAttribute::SetName(char const *_name);
void TiXmlAttribute::SetName(string const &_name);

331 8 SetValue 0 4 395 24 TiXmlAttribute::SetValue 0 2 157 158 46
///< Set the value.

/// STL std::string form.
103
void TiXmlAttribute::SetValue(char const *_value);
void TiXmlAttribute::SetValue(string const &_value);

332 11 SetIntValue 0 4 395 27 TiXmlAttribute::SetIntValue 0 1 159 35
///< Set the value from an integer.
45
void TiXmlAttribute::SetIntValue(int _value);

333 14 SetDoubleValue 0 4 395 30 TiXmlAttribute::SetDoubleValue 0 1 160 33
///< Set the value from a double.
51
void TiXmlAttribute::SetDoubleValue(double _value);

334 4 Next 0 4 395 20 TiXmlAttribute::Next 0 2 161 162 67
/// Get the next sibling attribute in the DOM. Returns null at end.
99
TiXmlAttribute const *TiXmlAttribute::Next(void) const;
TiXmlAttribute *TiXmlAttribute::Next(void);

335 8 Previous 0 4 395 24 TiXmlAttribute::Previous 0 2 163 164 77
/// Get the previous sibling attribute in the DOM. Returns null at beginning.
107
TiXmlAttribute const *TiXmlAttribute::Previous(void) const;
TiXmlAttribute *TiXmlAttribute::Previous(void);

336 11 operator == 0 4 395 27 TiXmlAttribute::operator == 0 1 165 0
66
bool TiXmlAttribute::operator ==(TiXmlAttribute const &rhs) const;

337 10 operator < 0 4 395 26 TiXmlAttribute::operator < 0 1 166 0
65
bool TiXmlAttribute::operator <(TiXmlAttribute const &rhs) const;

338 10 operator > 0 4 395 26 TiXmlAttribute::operator > 0 1 167 0
65
bool TiXmlAttribute::operator >(TiXmlAttribute const &rhs) const;

339 5 Print 0 4 395 21 TiXmlAttribute::Print 0 1 168 9
/*depth*/
70
void TiXmlAttribute::Print(FILE *cfile, int depth, string *str) const;

340 11 SetDocument 0 4 395 27 TiXmlAttribute::SetDocument 0 1 169 81
// [internal use]
// Set the document pointer so the attribute can report errors.
53
void TiXmlAttribute::SetDocument(TiXmlDocument *doc);

341 15 ~TiXmlAttribute 0 4 395 31 TiXmlAttribute::~TiXmlAttribute 0 0 0
38
TiXmlAttribute::~TiXmlAttribute(void);

342 17 TiXmlAttributeSet 0 4 396 36 TiXmlAttributeSet::TiXmlAttributeSet 0 1 170 0
43
TiXmlAttributeSet::TiXmlAttributeSet(void);

343 18 ~TiXmlAttributeSet 0 4 396 37 TiXmlAttributeSet::~TiXmlAttributeSet 0 0 0
44
TiXmlAttributeSet::~TiXmlAttributeSet(void);

344 3 Add 0 4 396 22 TiXmlAttributeSet::Add 0 1 171 0
55
void TiXmlAttributeSet::Add(TiXmlAttribute *attribute);

345 6 Remove 0 4 396 25 TiXmlAttributeSet::Remove 0 1 172 0
58
void TiXmlAttributeSet::Remove(TiXmlAttribute *attribute);

346 5 First 0 4 396 24 TiXmlAttributeSet::First 0 2 173 174 0
107
TiXmlAttribute const *TiXmlAttributeSet::First(void) const;
TiXmlAttribute *TiXmlAttributeSet::First(void);

347 4 Last 0 4 396 23 TiXmlAttributeSet::Last 0 2 175 176 0
105
TiXmlAttribute const *TiXmlAttributeSet::Last(void) const;
TiXmlAttribute *TiXmlAttributeSet::Last(void);

348 4 Find 0 4 396 23 TiXmlAttributeSet::Find 0 2 177 178 0
133
TiXmlAttribute *TiXmlAttributeSet::Find(char const *_name) const;
TiXmlAttribute *TiXmlAttributeSet::Find(string const &_name) const;

349 12 FindOrCreate 0 4 396 31 TiXmlAttributeSet::FindOrCreate 0 2 179 180 0
137
TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(char const *_name);
TiXmlAttribute *TiXmlAttributeSet::FindOrCreate(string const &_name);

350 12 TiXmlComment 0 4 397 26 TiXmlComment::TiXmlComment 0 3 181 182 183 68
/// Constructs an empty comment.

/// Construct a comment from text.
131
TiXmlComment::TiXmlComment(void);
TiXmlComment::TiXmlComment(char const *_value);
TiXmlComment::TiXmlComment(TiXmlComment const &);

351 10 operator = 0 4 397 24 TiXmlComment::operator = 0 1 184 0
56
void TiXmlComment::operator =(TiXmlComment const &base);

352 9 TiXmlText 0 4 398 20 TiXmlText::TiXmlText 0 3 185 186 187 210
/** Constructor for text element. By default, it is treated as
        normal, encoded text. If you want it be output as a CDATA text
        element, set the parameter _cdata to 'true'
    */

/// Constructor.
136
TiXmlText::TiXmlText(char const *initValue);
TiXmlText::TiXmlText(string const &initValue);
TiXmlText::TiXmlText(TiXmlText const &copy);

353 10 operator = 0 4 398 21 TiXmlText::operator = 0 1 188 0
50
void TiXmlText::operator =(TiXmlText const &base);

354 5 CDATA 0 4 398 16 TiXmlText::CDATA 0 1 189 63
/// Queries whether this represents text using a CDATA section.
34
bool TiXmlText::CDATA(void) const;

355 8 SetCDATA 0 4 398 19 TiXmlText::SetCDATA 0 1 190 51
/// Turns on or off a CDATA representation of text.
38
void TiXmlText::SetCDATA(bool _cdata);

356 12 TiXmlUnknown 0 4 399 26 TiXmlUnknown::TiXmlUnknown 0 2 191 192 0
87
TiXmlUnknown::TiXmlUnknown(void);
TiXmlUnknown::TiXmlUnknown(TiXmlUnknown const &copy);

357 10 operator = 0 4 399 24 TiXmlUnknown::operator = 0 1 193 0
56
void TiXmlUnknown::operator =(TiXmlUnknown const &copy);

358 11 TiXmlHandle 0 4 400 24 TiXmlHandle::TiXmlHandle 0 2 194 195 111
/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.

/// Copy constructor
93
TiXmlHandle::TiXmlHandle(TiXmlNode *_node);
TiXmlHandle::TiXmlHandle(TiXmlHandle const &ref);

359 10 operator = 0 4 400 23 TiXmlHandle::operator = 0 1 196 0
60
TiXmlHandle TiXmlHandle::operator =(TiXmlHandle const &ref);

360 10 FirstChild 0 4 400 23 TiXmlHandle::FirstChild 0 3 197 198 199 110
/// Return a handle to the first child node.

/// Return a handle to the first child node with the given name.
175
TiXmlHandle TiXmlHandle::FirstChild(void) const;
TiXmlHandle TiXmlHandle::FirstChild(char const *value) const;
TiXmlHandle TiXmlHandle::FirstChild(string const &_value) const;

361 17 FirstChildElement 0 4 400 30 TiXmlHandle::FirstChildElement 0 3 200 201 202 116
/// Return a handle to the first child element.

/// Return a handle to the first child element with the given name.
196
TiXmlHandle TiXmlHandle::FirstChildElement(void) const;
TiXmlHandle TiXmlHandle::FirstChildElement(char const *value) const;
TiXmlHandle TiXmlHandle::FirstChildElement(string const &_value) const;

362 5 Child 0 4 400 18 TiXmlHandle::Child 0 3 203 204 205 216
/** Return a handle to the "index" child with the given name.
        The first child is 0, the second 1, etc.
    */

/** Return a handle to the "index" child.
        The first child is 0, the second 1, etc.
    */
187
TiXmlHandle TiXmlHandle::Child(char const *value, int index) const;
TiXmlHandle TiXmlHandle::Child(int index) const;
TiXmlHandle TiXmlHandle::Child(string const &_value, int index) const;

363 12 ChildElement 0 4 400 25 TiXmlHandle::ChildElement 0 3 206 207 208 406
/** Return a handle to the "index" child element with the given name.
        The first child element is 0, the second 1, etc. Note that only TiXmlElements
        are indexed: other types are not counted.
    */

/** Return a handle to the "index" child element.
        The first child element is 0, the second 1, etc. Note that only TiXmlElements
        are indexed: other types are not counted.
    */
208
TiXmlHandle TiXmlHandle::ChildElement(char const *value, int index) const;
TiXmlHandle TiXmlHandle::ChildElement(int index) const;
TiXmlHandle TiXmlHandle::ChildElement(string const &_value, int index) const;

364 6 ToNode 0 4 400 19 TiXmlHandle::ToNode 0 1 209 66
/** Return the handle as a TiXmlNode. This may return null.
    */
43
TiXmlNode *TiXmlHandle::ToNode(void) const;

365 9 ToElement 0 4 400 22 TiXmlHandle::ToElement 0 1 210 69
/** Return the handle as a TiXmlElement. This may return null.
    */
49
TiXmlElement *TiXmlHandle::ToElement(void) const;

366 6 ToText 0 4 400 19 TiXmlHandle::ToText 0 1 211 66
/** Return the handle as a TiXmlText. This may return null.
    */
43
TiXmlText *TiXmlHandle::ToText(void) const;

367 9 ToUnknown 0 4 400 22 TiXmlHandle::ToUnknown 0 1 212 69
/** Return the handle as a TiXmlUnknown. This may return null.
    */
49
TiXmlUnknown *TiXmlHandle::ToUnknown(void) const;

368 4 Node 0 4 400 17 TiXmlHandle::Node 0 1 213 98
/** @deprecated use ToNode.
        Return the handle as a TiXmlNode. This may return null.
    */
41
TiXmlNode *TiXmlHandle::Node(void) const;

369 7 Element 0 4 400 20 TiXmlHandle::Element 0 1 214 104
/** @deprecated use ToElement.
        Return the handle as a TiXmlElement. This may return null.
    */
47
TiXmlElement *TiXmlHandle::Element(void) const;

370 4 Text 0 4 400 17 TiXmlHandle::Text 0 1 215 99
/** @deprecated use ToText()
        Return the handle as a TiXmlText. This may return null.
    */
41
TiXmlText *TiXmlHandle::Text(void) const;

371 7 Unknown 0 4 400 20 TiXmlHandle::Unknown 0 1 216 105
/** @deprecated use ToUnknown()
        Return the handle as a TiXmlUnknown. This may return null.
    */
47
TiXmlUnknown *TiXmlHandle::Unknown(void) const;

372 12 ~TiXmlHandle 0 4 400 25 TiXmlHandle::~TiXmlHandle 0 0 0
32
TiXmlHandle::~TiXmlHandle(void);

373 12 TiXmlPrinter 0 4 401 26 TiXmlPrinter::TiXmlPrinter 0 1 217 0
33
TiXmlPrinter::TiXmlPrinter(void);

374 9 SetIndent 0 4 401 23 TiXmlPrinter::SetIndent 0 1 218 148
/** Set the indent characters for printing. By default 4 spaces
        but tab (\t) is also useful, or null/empty string for no indentation.
    */
50
void TiXmlPrinter::SetIndent(char const *_indent);

375 6 Indent 0 4 401 20 TiXmlPrinter::Indent 0 1 219 31
/// Query the indention string.
39
char const *TiXmlPrinter::Indent(void);

376 12 SetLineBreak 0 4 401 26 TiXmlPrinter::SetLineBreak 0 1 220 194
/** Set the line breaking string. By default set to newline (\n).
        Some operating systems prefer other characters, or can be
        set to the null/empty string for no indenation.
    */
56
void TiXmlPrinter::SetLineBreak(char const *_lineBreak);

377 9 LineBreak 0 4 401 23 TiXmlPrinter::LineBreak 0 1 221 43
/// Query the current line breaking string.
42
char const *TiXmlPrinter::LineBreak(void);

378 17 SetStreamPrinting 0 4 401 31 TiXmlPrinter::SetStreamPrinting 0 1 222 162
/** Switch over to "stream printing" which is the most dense formatting without
        linebreaks. Common when the XML is needed for network transmission.
    */
43
void TiXmlPrinter::SetStreamPrinting(void);

379 4 CStr 0 4 401 18 TiXmlPrinter::CStr 0 1 223 22
/// Return the result.
37
char const *TiXmlPrinter::CStr(void);

380 4 Size 0 4 401 18 TiXmlPrinter::Size 0 1 224 43
/// Return the length of the result string.
32
size_t TiXmlPrinter::Size(void);

381 3 Str 0 4 401 17 TiXmlPrinter::Str 0 1 225 22
/// Return the result.
38
string const &TiXmlPrinter::Str(void);

382 13 ~TiXmlPrinter 0 4 401 27 TiXmlPrinter::~TiXmlPrinter 0 0 0
34
TiXmlPrinter::~TiXmlPrinter(void);

233
1 0 0 4 3 406 0 0 339 /** All TinyXml classes can print themselves to a filestream
        or the string class (TiXmlString in non-STL mode, std::string
        in STL mode.) Either or both cfile and str can be null.

        This is a formatted print, and will insert
        tabs and newlines.

        (For an unformatted stream, use the << operator.)
    */ 3 4 this 3 402  5 cfile 1 404  5 depth 1 390  
2 0 0 4 4 406 0 0 351 /** The world does not agree on whether white space should be kept or
        not. In order to make everyone happy, these global, static functions
        are provided to set whether or not TinyXml will condense all white space
        into a single space or not. The default is to condense. Note changing this
        value is not thread safe.
    */ 1 8 condense 1 407  
3 0 0 6 5 407 0 0 43 /// Return the current white space setting. 0 
4 0 0 6 6 390 0 0 944 /** Return the position, in the original source file, of this node or attribute.
        The row and column are 1-based. (That is the first row and first column is
        1,1). If the returns values are 0 or less, then the parser does not have
        a row and column value.

        Generally, the row and column value will be set when the TiXmlDocument::Load(),
        TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
        when the DOM was created from operator>>.

        The values reflect the initial load. Once the DOM is modified programmatically
        (by adding or changing nodes and attributes) the new values will NOT update to
        reflect changes in the document.

        There is a minor performance cost to computing the row and column. Computation
        can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.

        @sa TiXmlDocument::SetTabSize()
    */ 1 4 this 3 402  
5 0 0 6 7 390 0 0 14 ///< See Row() 1 4 this 3 402  
6 0 0 4 9 406 0 0 42 ///< Get a pointer to arbitrary user data. 1 4 this 3 408  
7 0 0 4 9 406 0 0 42 ///< Get a pointer to arbitrary user data. 1 4 this 3 402  
8 0 0 6 10 409 0 0 0 4 4 this 3 408  1 p 1 409  4 data 1 410  8 encoding 1 394  
9 0 0 4 11 406 0 0 145 /** Expands entities in a string. Note this should not contian the tag's '<', '>', etc,
        or they will be transformed into entities!
    */ 2 3 str 1 409  3 out 1 412  
10 0 0 7 45 415 234 0 35 /// Construct an empty declaration. 0 
11 0 0 7 45 415 234 0 0 1 4 copy 1 416  
12 0 0 7 45 415 234 0 14 /// Construct. 3 8 _version 1 409  9 _encoding 1 409  11 _standalone 1 409  
13 0 0 7 45 415 234 0 16 /// Constructor. 3 8 _version 1 409  9 _encoding 1 409  11 _standalone 1 409  
14 0 0 6 46 415 0 0 0 2 4 this 3 415  4 copy 1 416  
15 0 0 6 47 409 0 0 59 /// Version. Will return an empty string if none was found. 1 4 this 3 416  
16 0 0 6 48 409 0 0 60 /// Encoding. Will return an empty string if none was found. 1 4 this 3 416  
17 0 0 6 49 409 0 0 34 /// Is this a standalone document? 1 4 this 3 416  
18 0 0 4 50 406 0 0 43 // Print this declaration to a FILE stream. 4 4 this 3 416  5 cfile 1 404  5 depth 1 390  3 str 1 412  
19 0 0 6 16 409 0 0 368 /** The meaning of 'value' changes for the specific type of
        TiXmlNode.
        @verbatim
        Document:   filename of the xml file
        Element:    name of the element
        Comment:    the comment text
        Unknown:    the tag contents
        Text:       the text string
        @endverbatim

        The subclasses will wrap this function.
    */ 1 4 this 3 418  
20 0 0 6 17 409 0 0 153 /** Return Value() as a std::string. If you only use STL,
        this is more efficient than calling Value().
        Only available in STL mode.
    */ 1 4 this 3 418  
21 0 0 6 18 409 0 0 0 1 4 this 3 418  
22 0 0 4 19 406 0 0 287 /** Changes the value of the node. Defined as:
        @verbatim
        Document:   filename of the xml file
        Element:    name of the element
        Comment:    the comment text
        Unknown:    the tag contents
        Text:       the text string
        @endverbatim
    */ 2 4 this 3 420  6 _value 1 409  
23 0 0 4 19 406 0 0 25 /// STL std::string form. 2 4 this 3 420  6 _value 1 409  
24 0 0 4 20 406 0 0 65 /// Delete all the children of this node. Does not affect 'this'. 1 4 this 3 420  
25 0 0 6 21 420 0 0 24 /// One step up the DOM. 1 4 this 3 420  
26 0 0 6 21 418 0 0 0 1 4 this 3 418  
27 0 0 6 22 420 0 0 73 ///< The first child of this node. Will be null if there are no children. 1 4 this 3 420  
28 0 0 6 22 418 0 0 73 ///< The first child of this node. Will be null if there are no children. 1 4 this 3 418  
29 0 0 6 22 420 0 0 176 ///< The first child of this node with the matching 'value'. Will be null if none found.
/// The first child of this node with the matching 'value'. Will be null if none found. 2 4 this 3 420  6 _value 1 409  
30 0 0 6 22 418 0 0 0 2 4 this 3 418  5 value 1 409  
31 0 0 6 22 420 0 0 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 409  
32 0 0 6 22 418 0 0 26 ///< STL std::string form. 2 4 this 3 418  6 _value 1 409  
33 0 0 6 23 420 0 0 71 /// The last child of this node. Will be null if there are no children. 1 4 this 3 420  
34 0 0 6 23 418 0 0 71 /// The last child of this node. Will be null if there are no children. 1 4 this 3 418  
35 0 0 6 23 420 0 0 88 /// The last child of this node matching 'value'. Will be null if there are no children. 2 4 this 3 420  6 _value 1 409  
36 0 0 6 23 418 0 0 88 /// The last child of this node matching 'value'. Will be null if there are no children. 2 4 this 3 418  5 value 1 409  
37 0 0 6 23 420 0 0 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 409  
38 0 0 6 23 418 0 0 26 ///< STL std::string form. 2 4 this 3 418  6 _value 1 409  
39 0 0 6 24 420 0 0 0 2 4 this 3 420  8 previous 1 418  
40 0 0 6 24 418 0 0 607 /** An alternate way to walk the children of a node.
        One way to iterate over nodes is:
        @verbatim
            for( child = parent->FirstChild(); child; child = child->NextSibling() )
        @endverbatim

        IterateChildren does the same thing with the syntax:
        @verbatim
            child = 0;
            while( child = parent->IterateChildren( child ) )
        @endverbatim

        IterateChildren takes the previous child as input and finds
        the next one. If the previous child is null, it returns the
        first. IterateChildren will return null when done.
    */ 2 4 this 3 418  8 previous 1 418  
41 0 0 6 24 420 0 0 0 3 4 this 3 420  6 _value 1 409  8 previous 1 418  
42 0 0 6 24 418 0 0 82 /// This flavor of IterateChildren searches for children with a particular 'value' 3 4 this 3 418  5 value 1 409  8 previous 1 418  
43 0 0 6 24 420 0 0 26 ///< STL std::string form. 3 4 this 3 420  6 _value 1 409  8 previous 1 418  
44 0 0 6 24 418 0 0 26 ///< STL std::string form. 3 4 this 3 418  6 _value 1 409  8 previous 1 418  
45 0 0 6 25 420 0 0 148 /** Add a new node related to this. Adds a child past the LastChild.
        Returns a pointer to the new object or NULL if an error occured.
    */ 2 4 this 3 420  7 addThis 1 418  
46 0 0 6 26 420 0 0 156 /** Add a new node related to this. Adds a child before the specified child.
        Returns a pointer to the new object or NULL if an error occured.
    */ 3 4 this 3 420  10 beforeThis 1 420  7 addThis 1 418  
47 0 0 6 27 420 0 0 155 /** Add a new node related to this. Adds a child after the specified child.
        Returns a pointer to the new object or NULL if an error occured.
    */ 3 4 this 3 420  9 afterThis 1 420  7 addThis 1 418  
48 0 0 6 28 420 0 0 113 /** Replace a child of this node.
        Returns a pointer to the new object or NULL if an error occured.
    */ 3 4 this 3 420  11 replaceThis 1 420  8 withThis 1 418  
49 0 0 6 29 407 0 0 32 /// Delete a child of this node. 2 4 this 3 420  10 removeThis 1 420  
50 0 0 6 30 420 0 0 0 1 4 this 3 420  
51 0 0 6 30 418 0 0 31 /// Navigate to a sibling node. 1 4 this 3 418  
52 0 0 6 30 420 0 0 0 2 4 this 3 420  5 _prev 1 409  
53 0 0 6 30 418 0 0 31 /// Navigate to a sibling node. 2 4 this 3 418  6 param0 0 409  
54 0 0 6 30 420 0 0 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 409  
55 0 0 6 30 418 0 0 26 ///< STL std::string form. 2 4 this 3 418  6 _value 1 409  
56 0 0 6 31 420 0 0 0 1 4 this 3 420  
57 0 0 6 31 418 0 0 31 /// Navigate to a sibling node. 1 4 this 3 418  
58 0 0 6 31 420 0 0 0 2 4 this 3 420  5 _next 1 409  
59 0 0 6 31 418 0 0 54 /// Navigate to a sibling node with the given 'value'. 2 4 this 3 418  6 param0 0 409  
60 0 0 6 31 420 0 0 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 409  
61 0 0 6 31 418 0 0 26 ///< STL std::string form. 2 4 this 3 418  6 _value 1 409  
62 0 0 6 32 421 0 0 0 1 4 this 3 420  
63 0 0 6 32 422 0 0 181 /** Convenience function to get through elements.
        Calls NextSibling and ToElement. Will skip all non-Element
        nodes. Returns 0 if there is not another element.
    */ 1 4 this 3 418  
64 0 0 6 32 421 0 0 0 2 4 this 3 420  5 _next 1 409  
65 0 0 6 32 422 0 0 181 /** Convenience function to get through elements.
        Calls NextSibling and ToElement. Will skip all non-Element
        nodes. Returns 0 if there is not another element.
    */ 2 4 this 3 418  6 param0 0 409  
66 0 0 6 32 421 0 0 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 409  
67 0 0 6 32 422 0 0 26 ///< STL std::string form. 2 4 this 3 418  6 _value 1 409  
68 0 0 6 33 421 0 0 0 1 4 this 3 420  
69 0 0 6 33 422 0 0 49 /// Convenience function to get through elements. 1 4 this 3 418  
70 0 0 6 33 421 0 0 0 2 4 this 3 420  6 _value 1 409  
71 0 0 6 33 422 0 0 49 /// Convenience function to get through elements. 2 4 this 3 418  6 _value 1 409  
72 0 0 6 33 421 0 0 26 ///< STL std::string form. 2 4 this 3 420  6 _value 1 409  
73 0 0 6 33 422 0 0 26 ///< STL std::string form. 2 4 this 3 418  6 _value 1 409  
74 0 0 6 34 390 0 0 195 /** Query the type (as an enumerated value, above) of this node.
        The possible types are: DOCUMENT, ELEMENT, COMMENT,
                                UNKNOWN, TEXT, and DECLARATION.
    */ 1 4 this 3 418  
75 0 0 6 35 424 0 0 0 1 4 this 3 420  
76 0 0 6 35 425 0 0 106 /** Return a pointer to the Document this node lives in.
        Returns null if not in a document.
    */ 1 4 this 3 418  
77 0 0 6 36 407 0 0 46 /// Returns true if this node has no children. 1 4 this 3 418  
78 0 0 6 37 424 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
79 0 0 6 37 425 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 418  
80 0 0 6 38 421 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
81 0 0 6 38 422 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 418  
82 0 0 6 39 427 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
83 0 0 6 39 428 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 418  
84 0 0 6 40 430 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
85 0 0 6 40 431 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 418  
86 0 0 6 41 433 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
87 0 0 6 41 434 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 418  
88 0 0 6 42 415 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 420  
89 0 0 6 42 416 0 0 80 ///< Cast to a more defined type. Will return null if not of the requested type. 1 4 this 3 418  
90 0 0 6 43 420 0 0 114 /** Create an exact duplicate of this node and return it. The memory must be deleted
        by the caller.
    */ 1 4 this 3 418  
91 0 0 6 44 407 0 0 825 /** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the
        XML tree will be conditionally visited and the host will be called back
        via the TiXmlVisitor interface.

        This is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse
        the XML for the callbacks, so the performance of TinyXML is unchanged by using this
        interface versus any other.)

        The interface has been based on ideas from:

        - http://www.saxproject.org/
        - http://c2.com/cgi/wiki?HierarchicalVisitorPattern

        Which are both good references for "visiting".

        An example of using Accept():
        @verbatim
        TiXmlPrinter printer;
        tinyxmlDoc.Accept( &printer );
        const char* xmlcstr = printer.CStr();
        @endverbatim
    */ 2 4 this 3 418  7 visitor 1 436  
92 0 0 7 52 424 234 0 47 /// Create an empty document, that has no name. 0 
93 0 0 7 52 424 234 0 0 1 4 copy 1 425  
94 0 0 7 52 424 234 0 92 /// Create a document with a name. The name of the document is also the filename of the xml. 1 12 documentName 1 409  
95 0 0 7 52 424 234 0 16 /// Constructor. 1 12 documentName 1 409  
96 0 0 6 53 424 0 0 0 2 4 this 3 424  4 copy 1 425  
97 0 0 6 54 407 0 0 314 /** Load a file using the given FILE*. Returns true if successful. Note that this method
        doesn't stream - the entire object pointed at by the FILE*
        will be interpreted as an XML file. TinyXML doesn't stream in XML from the current
        file location. Streaming may be added in the future.
    */ 3 4 this 3 424  6 param0 0 404  8 encoding 1 394  
98 0 0 6 54 407 0 0 155 /** Load a file using the current document value.
        Returns true if successful. Will delete any existing
        document data before loading.
    */ 2 4 this 3 424  8 encoding 1 394  
99 0 0 6 54 407 0 0 69 /// Load a file using the given filename. Returns true if successful. 3 4 this 3 424  8 filename 1 409  8 encoding 1 394  
100 0 0 6 54 407 0 0 29 ///< STL std::string version. 3 4 this 3 424  8 filename 1 409  8 encoding 1 394  
101 0 0 6 55 407 0 0 77 /// Save a file using the current document value. Returns true if successful. 1 4 this 3 425  
102 0 0 6 55 407 0 0 66 /// Save a file using the given FILE*. Returns true if successful. 2 4 this 3 425  6 param0 0 404  
103 0 0 6 55 407 0 0 69 /// Save a file using the given filename. Returns true if successful. 2 4 this 3 425  8 filename 1 409  
104 0 0 6 55 407 0 0 29 ///< STL std::string version. 2 4 this 3 425  8 filename 1 409  
105 0 0 6 56 421 0 0 0 1 4 this 3 424  
106 0 0 6 56 422 0 0 207 /** Get the root element -- the only top level element -- of the document.
        In well formed XML, there should only be one. TinyXml is tolerant of
        multiple elements at the document level.
    */ 1 4 this 3 425  
107 0 0 6 57 407 0 0 330 /** If an error occurs, Error will be set to true. Also,
        - The ErrorId() will contain the integer identifier of the error (not generally useful)
        - The ErrorDesc() method will return the name of the error. (very useful)
        - The ErrorRow() and ErrorCol() will return the location of the error (if known)
    */ 1 4 this 3 425  
108 0 0 6 58 409 0 0 72 /// Contains a textual (english) description of the error if one occurs. 1 4 this 3 425  
109 0 0 6 59 390 0 0 141 /** Generally, you probably want the error string ( ErrorDesc() ). But if you
        prefer the ErrorId, this function will fetch it.
    */ 1 4 this 3 425  
110 0 0 6 60 390 0 0 359 /** Returns the location (if known) of the error. The first column is column 1,
        and the first row is row 1. A value of 0 means the row and column wasn't applicable
        (memory errors, for example, have no row/column) or the parser lost the error. (An
        error in the error reporting, in that case.)

        @sa SetTabSize, Row, Column
    */ 1 4 this 3 425  
111 0 0 6 61 390 0 0 55 ///< The column where the error occured. See ErrorRow() 1 4 this 3 425  
112 0 0 4 62 406 0 0 970 /** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())
        to report the correct values for row and column. It does not change the output
        or input in any way.

        By calling this method, with a tab size
        greater than 0, the row and column of each node and attribute is stored
        when the file is loaded. Very useful for tracking the DOM back in to
        the source file.

        The tab size is required for calculating the location of nodes. If not
        set, the default of 4 is used. The tabsize is set per document. Setting
        the tabsize to 0 disables row/column tracking.

        Note that row and column tracking is not supported when using operator>>.

        The tab size needs to be enabled before the parse or load. Correct usage:
        @verbatim
        TiXmlDocument doc;
        doc.SetTabSize( 8 );
        doc.Load( "myfile.xml" );
        @endverbatim

        @sa Row, Column
    */ 2 4 this 3 424  8 _tabsize 1 390  
113 0 0 6 63 390 0 0 0 1 4 this 3 425  
114 0 0 4 64 406 0 0 152 /** If you have handled the error, it can be reset with this call. The error
        state is automatically cleared if you Parse a new XML block.
    */ 1 4 this 3 424  
115 0 0 4 65 406 0 0 84 /** Write the document to standard out using formatted printing ("pretty print"). */ 1 4 this 3 425  
116 0 0 4 66 406 0 0 17 // [internal use] 5 4 this 3 424  3 err 1 390  13 errorLocation 1 409  8 prevData 1 410  8 encoding 1 394  
117 0 0 7 68 421 234 0 0 1 6 param0 0 422  
118 0 0 7 68 421 234 0 25 /// Construct an element. 1 8 in_value 1 409  
119 0 0 7 68 421 234 0 28 /// std::string constructor. 1 6 _value 1 409  
120 0 0 6 69 421 0 0 0 2 4 this 3 421  4 base 1 422  
121 0 0 6 70 409 0 0 129 /** Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none exists.
    */ 2 4 this 3 422  4 name 1 409  
122 0 0 6 70 409 0 0 0 2 4 this 3 422  4 name 1 409  
123 0 0 6 74 390 0 0 74 /// QueryStringAttribute examines the attribute - see QueryIntAttribute(). 3 4 this 3 422  4 name 1 409  6 _value 1 412  
124 0 0 6 75 390 0 0 0 3 4 this 3 422  4 name 1 409  8 outValue 1 412  
125 0 0 4 76 406 0 0 137 /** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */ 3 4 this 3 421  4 name 1 409  6 _value 1 409  
126 0 0 4 76 406 0 0 137 /** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */ 3 4 this 3 421  4 name 1 409  5 value 1 390  
127 0 0 4 76 406 0 0 26 ///< STL std::string form. 3 4 this 3 421  4 name 1 409  6 _value 1 390  
128 0 0 4 76 406 0 0 25 /// STL std::string form. 3 4 this 3 421  4 name 1 409  6 _value 1 409  
129 0 0 4 77 406 0 0 137 /** Sets an attribute of name to a given value. The attribute
        will be created if it does not exist, or changed if it does.
    */ 3 4 this 3 421  4 name 1 409  5 value 1 437  
130 0 0 4 77 406 0 0 26 ///< STL std::string form. 3 4 this 3 421  4 name 1 409  5 value 1 437  
131 0 0 4 78 406 0 0 52 /** Deletes an attribute with the given name.
    */ 2 4 this 3 421  4 name 1 409  
132 0 0 4 78 406 0 0 26 ///< STL std::string form. 2 4 this 3 421  4 name 1 409  
133 0 0 6 79 438 0 0 48 ///< Access the first attribute in this element. 1 4 this 3 421  
134 0 0 6 79 439 0 0 48 ///< Access the first attribute in this element. 1 4 this 3 422  
135 0 0 6 80 438 0 0 47 ///< Access the last attribute in this element. 1 4 this 3 421  
136 0 0 6 80 439 0 0 47 ///< Access the last attribute in this element. 1 4 this 3 422  
137 0 0 6 81 409 0 0 1274 /** Convenience function for easy access to the text inside an element. Although easy
        and concise, GetText() is limited compared to getting the TiXmlText child
        and accessing it directly.

        If the first child of 'this' is a TiXmlText, the GetText()
        returns the character string of the Text node, else null is returned.

        This is a convenient method for getting the text of simple contained text:
        @verbatim
        <foo>This is text</foo>
        const char* str = fooElement->GetText();
        @endverbatim

        'str' will be a pointer to "This is text".

        Note that this function can be misleading. If the element foo was created from
        this XML:
        @verbatim
        <foo><b>This is text</b></foo>
        @endverbatim

        then the value of str would be null. The first child node isn't a text node, it is
        another element. From this XML:
        @verbatim
        <foo>This is <b>text</b></foo>
        @endverbatim
        GetText() will return "This is ".

        WARNING: GetText() accesses a child node - don't become confused with the
                 similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are
                 safe type casts on the referenced node.
    */ 1 4 this 3 422  
138 0 0 6 97 407 0 0 7 /*doc*/ 2 4 this 3 436  6 param0 0 425  
139 0 0 6 97 407 0 0 18 /*firstAttribute*/ 3 4 this 3 436  6 param0 0 422  6 param1 0 439  
140 0 0 6 98 407 0 0 7 /*doc*/ 2 4 this 3 436  6 param0 0 425  
141 0 0 6 98 407 0 0 11 /*element*/ 2 4 this 3 436  6 param0 0 422  
142 0 0 6 99 407 0 0 11 /*comment*/ 2 4 this 3 436  6 param0 0 428  
143 0 0 6 99 407 0 0 15 /*declaration*/ 2 4 this 3 436  6 param0 0 416  
144 0 0 6 99 407 0 0 8 /*text*/ 2 4 this 3 436  6 param0 0 434  
145 0 0 6 99 407 0 0 11 /*unknown*/ 2 4 this 3 436  6 param0 0 431  
146 0 0 7 105 438 341 0 33 /// Construct an empty attribute. 0 
147 0 0 7 105 438 341 0 49 /// Construct an attribute with a name and value. 2 5 _name 1 409  6 _value 1 409  
148 0 0 7 105 438 341 0 28 /// std::string constructor. 2 5 _name 1 409  6 _value 1 409  
149 0 0 6 106 409 0 0 39 ///< Return the name of this attribute. 1 4 this 3 439  
150 0 0 6 107 409 0 0 40 ///< Return the value of this attribute. 1 4 this 3 439  
151 0 0 6 108 409 0 0 40 ///< Return the value of this attribute. 1 4 this 3 439  
152 0 0 6 109 390 0 0 65 ///< Return the value of this attribute, converted to an integer. 1 4 this 3 439  
153 0 0 6 110 437 0 0 63 ///< Return the value of this attribute, converted to a double. 1 4 this 3 439  
154 0 0 6 111 409 0 0 40 // Get the tinyxml string representation 1 4 this 3 439  
155 0 0 4 114 406 0 0 36 ///< Set the name of this attribute. 2 4 this 3 438  5 _name 1 409  
156 0 0 4 114 406 0 0 25 /// STL std::string form. 2 4 this 3 438  5 _name 1 409  
157 0 0 4 115 406 0 0 19 ///< Set the value. 2 4 this 3 438  6 _value 1 409  
158 0 0 4 115 406 0 0 25 /// STL std::string form. 2 4 this 3 438  6 _value 1 409  
159 0 0 4 116 406 0 0 35 ///< Set the value from an integer. 2 4 this 3 438  6 _value 1 390  
160 0 0 4 117 406 0 0 33 ///< Set the value from a double. 2 4 this 3 438  6 _value 1 437  
161 0 0 6 118 438 0 0 0 1 4 this 3 438  
162 0 0 6 118 439 0 0 67 /// Get the next sibling attribute in the DOM. Returns null at end. 1 4 this 3 439  
163 0 0 6 119 438 0 0 0 1 4 this 3 438  
164 0 0 6 119 439 0 0 77 /// Get the previous sibling attribute in the DOM. Returns null at beginning. 1 4 this 3 439  
165 0 0 6 120 407 0 0 0 2 4 this 3 439  3 rhs 1 439  
166 0 0 6 121 407 0 0 0 2 4 this 3 439  3 rhs 1 439  
167 0 0 6 122 407 0 0 0 2 4 this 3 439  3 rhs 1 439  
168 0 0 4 123 406 0 0 9 /*depth*/ 4 4 this 3 439  5 cfile 1 404  5 depth 1 390  3 str 1 412  
169 0 0 4 124 406 0 0 81 // [internal use]
// Set the document pointer so the attribute can report errors. 2 4 this 3 438  3 doc 1 424  
170 0 0 7 127 441 343 0 0 0 
171 0 0 4 129 406 0 0 0 2 4 this 3 441  9 attribute 1 438  
172 0 0 4 130 406 0 0 0 2 4 this 3 441  9 attribute 1 438  
173 0 0 6 131 438 0 0 0 1 4 this 3 441  
174 0 0 6 131 439 0 0 0 1 4 this 3 442  
175 0 0 6 132 438 0 0 0 1 4 this 3 441  
176 0 0 6 132 439 0 0 0 1 4 this 3 442  
177 0 0 6 133 438 0 0 0 2 4 this 3 442  5 _name 1 409  
178 0 0 6 133 438 0 0 0 2 4 this 3 442  5 _name 1 409  
179 0 0 6 134 438 0 0 0 2 4 this 3 441  5 _name 1 409  
180 0 0 6 134 438 0 0 0 2 4 this 3 441  5 _name 1 409  
181 0 0 7 136 427 234 0 32 /// Constructs an empty comment. 0 
182 0 0 7 136 427 234 0 0 1 6 param0 0 428  
183 0 0 7 136 427 234 0 34 /// Construct a comment from text. 1 6 _value 1 409  
184 0 0 6 137 427 0 0 0 2 4 this 3 427  4 base 1 428  
185 0 0 7 139 433 234 0 0 1 4 copy 1 434  
186 0 0 7 139 433 234 0 192 /** Constructor for text element. By default, it is treated as
        normal, encoded text. If you want it be output as a CDATA text
        element, set the parameter _cdata to 'true'
    */ 1 9 initValue 1 409  
187 0 0 7 139 433 234 0 16 /// Constructor. 1 9 initValue 1 409  
188 0 0 6 140 433 0 0 0 2 4 this 3 433  4 base 1 434  
189 0 0 6 141 407 0 0 63 /// Queries whether this represents text using a CDATA section. 1 4 this 3 434  
190 0 0 4 142 406 0 0 51 /// Turns on or off a CDATA representation of text. 2 4 this 3 433  6 _cdata 1 407  
191 0 0 7 144 430 234 0 0 0 
192 0 0 7 144 430 234 0 0 1 4 copy 1 431  
193 0 0 6 145 430 0 0 0 2 4 this 3 430  4 copy 1 431  
194 0 0 7 147 446 372 0 20 /// Copy constructor 1 3 ref 1 444  
195 0 0 7 147 446 372 0 89 /// Create a handle from any node (at any depth of the tree.) This can be a null pointer. 1 5 _node 1 420  
196 0 0 6 148 446 0 0 0 2 4 this 3 446  3 ref 1 444  
197 0 0 7 149 446 372 0 44 /// Return a handle to the first child node. 1 4 this 3 444  
198 0 0 7 149 446 372 0 64 /// Return a handle to the first child node with the given name. 2 4 this 3 444  5 value 1 409  
199 0 0 7 149 446 372 0 0 2 4 this 3 444  6 _value 1 409  
200 0 0 7 150 446 372 0 47 /// Return a handle to the first child element. 1 4 this 3 444  
201 0 0 7 150 446 372 0 67 /// Return a handle to the first child element with the given name. 2 4 this 3 444  5 value 1 409  
202 0 0 7 150 446 372 0 0 2 4 this 3 444  6 _value 1 409  
203 0 0 7 151 446 372 0 117 /** Return a handle to the "index" child with the given name.
        The first child is 0, the second 1, etc.
    */ 3 4 this 3 444  5 value 1 409  5 index 1 390  
204 0 0 7 151 446 372 0 97 /** Return a handle to the "index" child.
        The first child is 0, the second 1, etc.
    */ 2 4 this 3 444  5 index 1 390  
205 0 0 7 151 446 372 0 0 3 4 this 3 444  6 _value 1 409  5 index 1 390  
206 0 0 7 152 446 372 0 212 /** Return a handle to the "index" child element with the given name.
        The first child element is 0, the second 1, etc. Note that only TiXmlElements
        are indexed: other types are not counted.
    */ 3 4 this 3 444  5 value 1 409  5 index 1 390  
207 0 0 7 152 446 372 0 192 /** Return a handle to the "index" child element.
        The first child element is 0, the second 1, etc. Note that only TiXmlElements
        are indexed: other types are not counted.
    */ 2 4 this 3 444  5 index 1 390  
208 0 0 7 152 446 372 0 0 3 4 this 3 444  6 _value 1 409  5 index 1 390  
209 0 0 6 153 420 0 0 66 /** Return the handle as a TiXmlNode. This may return null.
    */ 1 4 this 3 444  
210 0 0 6 154 421 0 0 69 /** Return the handle as a TiXmlElement. This may return null.
    */ 1 4 this 3 444  
211 0 0 6 155 433 0 0 66 /** Return the handle as a TiXmlText. This may return null.
    */ 1 4 this 3 444  
212 0 0 6 156 430 0 0 69 /** Return the handle as a TiXmlUnknown. This may return null.
    */ 1 4 this 3 444  
213 0 0 6 157 420 0 0 98 /** @deprecated use ToNode.
        Return the handle as a TiXmlNode. This may return null.
    */ 1 4 this 3 444  
214 0 0 6 158 421 0 0 104 /** @deprecated use ToElement.
        Return the handle as a TiXmlElement. This may return null.
    */ 1 4 this 3 444  
215 0 0 6 159 433 0 0 99 /** @deprecated use ToText()
        Return the handle as a TiXmlText. This may return null.
    */ 1 4 this 3 444  
216 0 0 6 160 430 0 0 105 /** @deprecated use ToUnknown()
        Return the handle as a TiXmlUnknown. This may return null.
    */ 1 4 this 3 444  
217 0 0 7 163 447 382 0 0 0 
218 0 0 4 164 406 0 0 148 /** Set the indent characters for printing. By default 4 spaces
        but tab (\t) is also useful, or null/empty string for no indentation.
    */ 2 4 this 3 447  7 _indent 1 409  
219 0 0 6 165 409 0 0 31 /// Query the indention string. 1 4 this 3 447  
220 0 0 4 166 406 0 0 194 /** Set the line breaking string. By default set to newline (\n).
        Some operating systems prefer other characters, or can be
        set to the null/empty string for no indenation.
    */ 2 4 this 3 447  10 _lineBreak 1 409  
221 0 0 6 167 409 0 0 43 /// Query the current line breaking string. 1 4 this 3 447  
222 0 0 4 168 406 0 0 162 /** Switch over to "stream printing" which is the most dense formatting without
        linebreaks. Common when the XML is needed for network transmission.
    */ 1 4 this 3 447  
223 0 0 6 169 409 0 0 22 /// Return the result. 1 4 this 3 447  
224 0 0 6 170 448 0 0 43 /// Return the length of the result string. 1 4 this 3 447  
225 0 0 6 171 409 0 0 22 /// Return the result. 1 4 this 3 447  
226 0 0 6 82 424 0 0 293 ////////////////////////////////////////////////////////////////////
//     Function: read_xml_stream
//  Description: Reads an XML document from the indicated stream.
//               Returns the document, or NULL on error.
//////////////////////////////////////////////////////////////////// 1 2 in 1 450  
227 0 0 4 83 406 0 0 0 2 3 out 1 452  3 doc 1 424  
228 0 0 4 84 406 0 0 0 1 5 xnode 1 420  
229 0 0 4 85 406 0 0 0 2 8 filename 1 454  5 xnode 1 420  
230 0 0 6 87 390 0 0 0 0 
231 0 0 6 89 390 0 0 0 0 
232 0 0 6 91 390 0 0 0 0 
233 0 0 6 102 394 0 0 0 0 
74
383 9 TiXmlBase 0 26625 9 TiXmlBase 9 TiXmlBase 0 0 0 0 234 0 9 235 236 237 238 239 240 241 242 243 0 0 0 0 1 384 786
/** TiXmlBase is a base class for every class in TinyXml.
    It does little except to establish that TinyXml classes
    can be printed and provide some utility functions.

    In XML, the document and elements can contain
    other elements and other types of nodes.

    @verbatim
    A Document can contain: Element (container or leaf)
                            Comment (leaf)
                            Unknown (leaf)
                            Declaration( leaf )

    An Element can contain: Element (container or leaf)
                            Text    (leaf)
                            Attributes (not on tree)
                            Comment (leaf)
                            Unknown (leaf)

    A Decleration contains: Attributes (not on tree)
    @endverbatim
*/

384 0 0 794624 11 TiXmlBase:: 0 383 0 0 0 0 0 0 0 0 0 17 14 TIXML_NO_ERROR 25 TiXmlBase::TIXML_NO_ERROR 0
0 11 TIXML_ERROR 22 TiXmlBase::TIXML_ERROR 0
1 24 TIXML_ERROR_OPENING_FILE 35 TiXmlBase::TIXML_ERROR_OPENING_FILE 0
2 27 TIXML_ERROR_PARSING_ELEMENT 38 TiXmlBase::TIXML_ERROR_PARSING_ELEMENT 0
3 39 TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME 50 TiXmlBase::TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME 0
4 33 TIXML_ERROR_READING_ELEMENT_VALUE 44 TiXmlBase::TIXML_ERROR_READING_ELEMENT_VALUE 0
5 30 TIXML_ERROR_READING_ATTRIBUTES 41 TiXmlBase::TIXML_ERROR_READING_ATTRIBUTES 0
6 25 TIXML_ERROR_PARSING_EMPTY 36 TiXmlBase::TIXML_ERROR_PARSING_EMPTY 0
7 27 TIXML_ERROR_READING_END_TAG 38 TiXmlBase::TIXML_ERROR_READING_END_TAG 0
8 27 TIXML_ERROR_PARSING_UNKNOWN 38 TiXmlBase::TIXML_ERROR_PARSING_UNKNOWN 0
9 27 TIXML_ERROR_PARSING_COMMENT 38 TiXmlBase::TIXML_ERROR_PARSING_COMMENT 0
10 31 TIXML_ERROR_PARSING_DECLARATION 42 TiXmlBase::TIXML_ERROR_PARSING_DECLARATION 0
11 26 TIXML_ERROR_DOCUMENT_EMPTY 37 TiXmlBase::TIXML_ERROR_DOCUMENT_EMPTY 0
12 25 TIXML_ERROR_EMBEDDED_NULL 36 TiXmlBase::TIXML_ERROR_EMBEDDED_NULL 0
13 25 TIXML_ERROR_PARSING_CDATA 36 TiXmlBase::TIXML_ERROR_PARSING_CDATA 0
14 29 TIXML_ERROR_DOCUMENT_TOP_ONLY 40 TiXmlBase::TIXML_ERROR_DOCUMENT_TOP_ONLY 0
15 24 TIXML_ERROR_STRING_COUNT 35 TiXmlBase::TIXML_ERROR_STRING_COUNT 0
16 0 0

385 16 TiXmlDeclaration 0 75777 16 TiXmlDeclaration 16 TiXmlDeclaration 0 0 0 1 273 234 0 5 274 275 276 277 278 0 0 1 0 386 0 0 0 0 510
/** In correct XML the declaration is the first entry in the file.
    @verbatim
        <?xml version="1.0" standalone="yes"?>
    @endverbatim

    TinyXml will happily read or write files without a declaration,
    however. There are 3 possible attributes to the declaration:
    version, encoding, and standalone.

    Note: In this version of the code, the attributes are
    handled as special cases, not generic attributes, simply
    because there can only be at most 3 and they are always the same.
*/

386 9 TiXmlNode 0 75777 9 TiXmlNode 9 TiXmlNode 0 0 0 0 234 0 29 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 0 0 1 0 383 0 0 0 1 387 289
/** The parent class for everything in the Document Object Model.
    (Except for attributes).
    Nodes have siblings, a parent, and children. A node can be
    in a document, or stand on its own. The type of a TiXmlNode
    can be queried, and it can be cast to its more defined type.
*/

387 8 NodeType 0 794624 19 TiXmlNode::NodeType 19 TiXmlNode::NodeType 386 0 0 0 0 0 0 0 0 0 7 16 TINYXML_DOCUMENT 27 TiXmlNode::TINYXML_DOCUMENT 0
0 15 TINYXML_ELEMENT 26 TiXmlNode::TINYXML_ELEMENT 0
1 15 TINYXML_COMMENT 26 TiXmlNode::TINYXML_COMMENT 0
2 15 TINYXML_UNKNOWN 26 TiXmlNode::TINYXML_UNKNOWN 0
3 12 TINYXML_TEXT 23 TiXmlNode::TINYXML_TEXT 0
4 19 TINYXML_DECLARATION 30 TiXmlNode::TINYXML_DECLARATION 0
5 17 TINYXML_TYPECOUNT 28 TiXmlNode::TINYXML_TYPECOUNT 0
6 0 121
/** The types of XML nodes supported by TinyXml. (All the
            unsupported types are picked up by UNKNOWN.)
    */

388 13 TiXmlDocument 0 75777 13 TiXmlDocument 13 TiXmlDocument 0 0 0 1 279 234 0 14 280 281 282 283 284 285 286 287 288 289 290 291 292 293 0 0 1 0 386 0 0 0 0 192
/** Always the top level node. A document binds together all the
    XML pieces. It can be saved, loaded, and printed to the screen.
    The 'value' of a document node is the xml file name.
*/

389 12 TiXmlElement 0 75777 12 TiXmlElement 12 TiXmlElement 0 0 0 1 294 234 0 13 295 296 297 298 299 300 301 302 303 304 305 306 307 0 0 1 0 386 0 0 0 0 201
/** The element is a container class. It has a value, the element name,
    and can contain other elements, text, comments, and unknowns.
    Elements also contain an arbitrary number of attributes.
*/

390 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

391 11 TiXmlCursor 0 140289 11 TiXmlCursor 11 TiXmlCursor 0 0 0 0 315 0 0 0 0 0 0 0 77
/*  Internal structure for tracking location of items
    in the XML file.
*/

392 12 TiXmlVisitor 0 26625 12 TiXmlVisitor 12 TiXmlVisitor 0 0 0 0 316 0 3 317 318 319 0 0 0 0 0 897
/**
    Implements the interface to the "Visitor pattern" (see the Accept() method.)
    If you call the Accept() method, it requires being passed a TiXmlVisitor
    class to handle callbacks. For nodes that contain other nodes (Document, Element)
    you will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves
    are simply called with Visit().

    If you return 'true' from a Visit method, recursive parsing will continue. If you return
    false, <b>no children of this node or its sibilings</b> will be Visited.

    All flavors of Visit methods have a default implementation that returns 'true' (continue
    visiting). You need to only override methods that are interesting to you.

    Generally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.

    You should never change the document from a callback.

    @sa TiXmlNode::Accept()
*/

393 0 0 532481 0 0 0 0 0 0 0 0 0 0 0 0 3 13 TIXML_SUCCESS 13 TIXML_SUCCESS 0
0 18 TIXML_NO_ATTRIBUTE 18 TIXML_NO_ATTRIBUTE 0
1 16 TIXML_WRONG_TYPE 16 TIXML_WRONG_TYPE 0
2 0 42
// Only used by Attribute::Query functions

394 13 TiXmlEncoding 0 532481 13 TiXmlEncoding 13 TiXmlEncoding 0 0 0 0 0 0 0 0 0 0 3 22 TIXML_ENCODING_UNKNOWN 22 TIXML_ENCODING_UNKNOWN 0
0 19 TIXML_ENCODING_UTF8 19 TIXML_ENCODING_UTF8 0
1 21 TIXML_ENCODING_LEGACY 21 TIXML_ENCODING_LEGACY 0
2 0 32
// Used by the parsing routines.

395 14 TiXmlAttribute 0 141313 14 TiXmlAttribute 14 TiXmlAttribute 0 0 0 1 321 341 0 19 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 0 0 1 0 383 0 0 0 0 303
/** An attribute is a name-value pair. Elements have an arbitrary
    number of attributes, each with a unique name.

    @note The attributes are not TiXmlNodes, since they are not
          part of the tinyXML document object model. There are other
          suggested ways to look at this problem.
*/

396 17 TiXmlAttributeSet 0 26625 17 TiXmlAttributeSet 17 TiXmlAttributeSet 0 0 0 1 342 343 0 6 344 345 346 347 348 349 0 0 0 0 0 560
/*  A class used to manage a group of attributes.
    It is only used internally, both by the ELEMENT and the DECLARATION.

    The set can be changed transparent to the Element and Declaration
    classes that use it, but NOT transparent to the Attribute
    which has to implement a next() and previous() method. Which makes
    it a bit problematic and prevents the use of STL.

    This version is implemented with circular lists because:
        - I like circular lists
        - it demonstrates some independence from the (typical) doubly linked list.
*/

397 12 TiXmlComment 0 75777 12 TiXmlComment 12 TiXmlComment 0 0 0 1 350 234 0 1 351 0 0 1 0 386 0 0 0 0 22
/** An XML comment.
*/

398 9 TiXmlText 0 75777 9 TiXmlText 9 TiXmlText 0 0 0 1 352 234 0 3 353 354 355 0 0 1 0 386 0 0 0 0 283
/** XML text. A text node can have 2 ways to output the next. "normal" output
    and CDATA. It will default to the mode it was parsed from the XML file and
    you generally want to leave it alone, but you can change the output mode with
    SetCDATA() and query it with CDATA().
*/

399 12 TiXmlUnknown 0 75777 12 TiXmlUnknown 12 TiXmlUnknown 0 0 0 1 356 234 0 1 357 0 0 1 0 386 0 0 0 0 246
/** Any tag that tinyXml doesn't recognize is saved as an
    unknown. It is a tag of text, but should not be modified.
    It will be written back to the XML, unchanged, when the file
    is saved.

    DTD tags get thrown into TiXmlUnknowns.
*/

400 11 TiXmlHandle 0 141313 11 TiXmlHandle 11 TiXmlHandle 0 0 0 1 358 372 0 13 359 360 361 362 363 364 365 366 367 368 369 370 371 0 0 0 0 0 2519
/**
    A TiXmlHandle is a class that wraps a node pointer with null checks; this is
    an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
    DOM structure. It is a separate utility class.

    Take an example:
    @verbatim
    <Document>
        <Element attributeA = "valueA">
            <Child attributeB = "value1" />
            <Child attributeB = "value2" />
        </Element>
    <Document>
    @endverbatim

    Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
    easy to write a *lot* of code that looks like:

    @verbatim
    TiXmlElement* root = document.FirstChildElement( "Document" );
    if ( root )
    {
        TiXmlElement* element = root->FirstChildElement( "Element" );
        if ( element )
        {
            TiXmlElement* child = element->FirstChildElement( "Child" );
            if ( child )
            {
                TiXmlElement* child2 = child->NextSiblingElement( "Child" );
                if ( child2 )
                {
                    // Finally do something useful.
    @endverbatim

    And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
    of such code. A TiXmlHandle checks for null pointers so it is perfectly safe
    and correct to use:

    @verbatim
    TiXmlHandle docHandle( &document );
    TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).ToElement();
    if ( child2 )
    {
        // do something useful
    @endverbatim

    Which is MUCH more concise and useful.

    It is also safe to copy handles - internally they are nothing more than node pointers.
    @verbatim
    TiXmlHandle handleCopy = handle;
    @endverbatim

    What they should not be used for is iteration:

    @verbatim
    int i=0;
    while ( true )
    {
        TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).ToElement();
        if ( !child )
            break;
        // do something
        ++i;
    }
    @endverbatim

    It seems reasonable, but it is in fact two embedded while loops. The Child method is
    a linear walk to find the element, so this code would iterate much more than it needs
    to. Instead, prefer:

    @verbatim
    TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).ToElement();

    for( child; child; child=child->NextSiblingElement() )
    {
        // do something
    }
    @endverbatim
*/

401 12 TiXmlPrinter 0 141313 12 TiXmlPrinter 12 TiXmlPrinter 0 0 0 1 373 382 0 8 374 375 376 377 378 379 380 381 0 0 1 0 392 0 0 0 0 685
/** Print to memory functionality. The TiXmlPrinter is useful when you need to:

    -# Print to memory (especially in non-STL mode)
    -# Control formatting (line endings, etc.)

    When constructed, the TiXmlPrinter is in its default "pretty printing" mode.
    Before calling Accept() you can call methods to control the printing
    of the XML document. After TiXmlNode::Accept() is called, the printed document can
    be accessed via the CStr(), Str(), and Size() methods.

    TiXmlPrinter uses the Visitor API.
    @verbatim
    TiXmlPrinter printer;
    printer.SetIndent( "\t" );

    doc.Accept( &printer );
    fprintf( stdout, "%s", printer.CStr() );
    @endverbatim
*/

402 17 TiXmlBase const * 0 8576 17 TiXmlBase const * 17 TiXmlBase const * 0 0 403 0 0 0 0 0 0 0 0 0 0

403 15 TiXmlBase const 0 8832 15 TiXmlBase const 15 TiXmlBase const 0 0 383 0 0 0 0 0 0 0 0 0 0

404 6 FILE * 0 8576 6 FILE * 6 FILE * 0 0 405 0 0 0 0 0 0 0 0 0 0

405 4 FILE 0 1024 4 FILE 4 FILE 0 0 0 0 0 0 0 0 0 0 0 0 0

406 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

407 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

408 11 TiXmlBase * 0 8576 11 TiXmlBase * 11 TiXmlBase * 0 0 383 0 0 0 0 0 0 0 0 0 0

409 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

410 18 TiXmlParsingData * 0 8576 18 TiXmlParsingData * 18 TiXmlParsingData * 0 0 411 0 0 0 0 0 0 0 0 0 0

411 16 TiXmlParsingData 0 2048 16 TiXmlParsingData 16 TiXmlParsingData 0 0 0 0 0 0 0 0 0 0 0 0 0

412 8 string * 0 8576 8 string * 8 string * 0 0 413 0 0 0 0 0 0 0 0 0 0

413 6 string 0 2105344 6 string 6 string 0 0 414 0 0 0 0 0 0 0 0 0 0

414 20 basic_string< char > 0 2048 20 basic_string< char > 20 basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

415 18 TiXmlDeclaration * 0 8576 18 TiXmlDeclaration * 18 TiXmlDeclaration * 0 0 385 0 0 0 0 0 0 0 0 0 0

416 24 TiXmlDeclaration const * 0 8576 24 TiXmlDeclaration const * 24 TiXmlDeclaration const * 0 0 417 0 0 0 0 0 0 0 0 0 0

417 22 TiXmlDeclaration const 0 8832 22 TiXmlDeclaration const 22 TiXmlDeclaration const 0 0 385 0 0 0 0 0 0 0 0 0 0

418 17 TiXmlNode const * 0 8576 17 TiXmlNode const * 17 TiXmlNode const * 0 0 419 0 0 0 0 0 0 0 0 0 0

419 15 TiXmlNode const 0 8832 15 TiXmlNode const 15 TiXmlNode const 0 0 386 0 0 0 0 0 0 0 0 0 0

420 11 TiXmlNode * 0 8576 11 TiXmlNode * 11 TiXmlNode * 0 0 386 0 0 0 0 0 0 0 0 0 0

421 14 TiXmlElement * 0 8576 14 TiXmlElement * 14 TiXmlElement * 0 0 389 0 0 0 0 0 0 0 0 0 0

422 20 TiXmlElement const * 0 8576 20 TiXmlElement const * 20 TiXmlElement const * 0 0 423 0 0 0 0 0 0 0 0 0 0

423 18 TiXmlElement const 0 8832 18 TiXmlElement const 18 TiXmlElement const 0 0 389 0 0 0 0 0 0 0 0 0 0

424 15 TiXmlDocument * 0 8576 15 TiXmlDocument * 15 TiXmlDocument * 0 0 388 0 0 0 0 0 0 0 0 0 0

425 21 TiXmlDocument const * 0 8576 21 TiXmlDocument const * 21 TiXmlDocument const * 0 0 426 0 0 0 0 0 0 0 0 0 0

426 19 TiXmlDocument const 0 8832 19 TiXmlDocument const 19 TiXmlDocument const 0 0 388 0 0 0 0 0 0 0 0 0 0

427 14 TiXmlComment * 0 8576 14 TiXmlComment * 14 TiXmlComment * 0 0 397 0 0 0 0 0 0 0 0 0 0

428 20 TiXmlComment const * 0 8576 20 TiXmlComment const * 20 TiXmlComment const * 0 0 429 0 0 0 0 0 0 0 0 0 0

429 18 TiXmlComment const 0 8832 18 TiXmlComment const 18 TiXmlComment const 0 0 397 0 0 0 0 0 0 0 0 0 0

430 14 TiXmlUnknown * 0 8576 14 TiXmlUnknown * 14 TiXmlUnknown * 0 0 399 0 0 0 0 0 0 0 0 0 0

431 20 TiXmlUnknown const * 0 8576 20 TiXmlUnknown const * 20 TiXmlUnknown const * 0 0 432 0 0 0 0 0 0 0 0 0 0

432 18 TiXmlUnknown const 0 8832 18 TiXmlUnknown const 18 TiXmlUnknown const 0 0 399 0 0 0 0 0 0 0 0 0 0

433 11 TiXmlText * 0 8576 11 TiXmlText * 11 TiXmlText * 0 0 398 0 0 0 0 0 0 0 0 0 0

434 17 TiXmlText const * 0 8576 17 TiXmlText const * 17 TiXmlText const * 0 0 435 0 0 0 0 0 0 0 0 0 0

435 15 TiXmlText const 0 8832 15 TiXmlText const 15 TiXmlText const 0 0 398 0 0 0 0 0 0 0 0 0 0

436 14 TiXmlVisitor * 0 8576 14 TiXmlVisitor * 14 TiXmlVisitor * 0 0 392 0 0 0 0 0 0 0 0 0 0

437 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

438 16 TiXmlAttribute * 0 8576 16 TiXmlAttribute * 16 TiXmlAttribute * 0 0 395 0 0 0 0 0 0 0 0 0 0

439 22 TiXmlAttribute const * 0 8576 22 TiXmlAttribute const * 22 TiXmlAttribute const * 0 0 440 0 0 0 0 0 0 0 0 0 0

440 20 TiXmlAttribute const 0 8832 20 TiXmlAttribute const 20 TiXmlAttribute const 0 0 395 0 0 0 0 0 0 0 0 0 0

441 19 TiXmlAttributeSet * 0 8576 19 TiXmlAttributeSet * 19 TiXmlAttributeSet * 0 0 396 0 0 0 0 0 0 0 0 0 0

442 25 TiXmlAttributeSet const * 0 8576 25 TiXmlAttributeSet const * 25 TiXmlAttributeSet const * 0 0 443 0 0 0 0 0 0 0 0 0 0

443 23 TiXmlAttributeSet const 0 8832 23 TiXmlAttributeSet const 23 TiXmlAttributeSet const 0 0 396 0 0 0 0 0 0 0 0 0 0

444 19 TiXmlHandle const * 0 8576 19 TiXmlHandle const * 19 TiXmlHandle const * 0 0 445 0 0 0 0 0 0 0 0 0 0

445 17 TiXmlHandle const 0 8832 17 TiXmlHandle const 17 TiXmlHandle const 0 0 400 0 0 0 0 0 0 0 0 0 0

446 13 TiXmlHandle * 0 8576 13 TiXmlHandle * 13 TiXmlHandle * 0 0 400 0 0 0 0 0 0 0 0 0 0

447 14 TiXmlPrinter * 0 8576 14 TiXmlPrinter * 14 TiXmlPrinter * 0 0 401 0 0 0 0 0 0 0 0 0 0

448 6 size_t 0 2105344 6 size_t 6 size_t 0 0 449 0 0 0 0 0 0 0 0 0 0

449 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

450 9 istream * 0 8576 9 istream * 9 istream * 0 0 451 0 0 0 0 0 0 0 0 0 0

451 7 istream 0 2048 7 istream 7 istream 0 0 0 0 0 0 0 0 0 0 0 0 0

452 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 453 0 0 0 0 0 0 0 0 0 0

453 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

454 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 455 0 0 0 0 0 0 0 0 0 0

455 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 456 0 0 0 0 0 0 0 0 0 0

456 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 869
////////////////////////////////////////////////////////////////////
//       Class : Filename
// Description : The name of a file, such as a texture file or an Egg
//               file.  Stores the full pathname, and includes
//               functions for extracting out the directory prefix
//               part and the file extension and stuff.
//
//               A Filename is also aware of the mapping between the
//               Unix-like filename convention we use internally, and
//               the local OS's specific filename convention, and it
//               knows how to perform basic OS-specific I/O, like
//               testing for file existence and searching a
//               searchpath, as well as the best way to open an
//               fstream for reading or writing.
////////////////////////////////////////////////////////////////////

5
457 16 TINYXML_INCLUDED 0 0 0 0 0 0 
458 10 TIXML_SAFE 0 0 0 0 0 0 
459 14 TIXML_SNPRINTF 0 5 0 390 0 11 _snprintf_s 
460 12 TIXML_SSCANF 0 5 0 390 0 8 sscanf_s 
461 12 TIXML_STRING 0 0 0 0 0 11 std::string 
4
462 19 TIXML_MAJOR_VERSION 0 3 390 312 0 19 TIXML_MAJOR_VERSION 0

463 19 TIXML_MINOR_VERSION 0 3 390 313 0 19 TIXML_MINOR_VERSION 0

464 19 TIXML_PATCH_VERSION 0 3 390 314 0 19 TIXML_PATCH_VERSION 0

465 22 TIXML_DEFAULT_ENCODING 0 3 394 320 0 22 TIXML_DEFAULT_ENCODING 0

0
